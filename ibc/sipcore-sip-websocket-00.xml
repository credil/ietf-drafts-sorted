<?xml version="1.0" encoding="UTF-8"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629xslt/rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced.
     An alternate method (rfc include) is described in the references. -->

 <!-- Normative References -->
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2617 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml">
<!ENTITY RFC5234 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml">
<!ENTITY RFC3261 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml">
<!ENTITY RFC3263 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3263.xml">
<!ENTITY RFC5626 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5626.xml">
<!ENTITY RFC5627 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5627.xml">
<!ENTITY I-D.ietf-hybi-thewebsocketprotocol SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-hybi-thewebsocketprotocol-17.xml">
<!-- Informative References -->
<!ENTITY RFC2616 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml">
<!ENTITY RFC3327 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3327.xml">
<!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC3581 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3581.xml">
<!ENTITY RFC4168 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4168.xml">
<!ENTITY RFC5658 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5658.xml">
<!ENTITY RFC6265 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6265.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="no" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->

<rfc category="std" docName="draft-ibc-sipcore-sip-websocket-00" ipr="trust200902">
<!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN"
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>

    <!-- The abbreviated title is used in the page header - it is only necessary if the
         full title is longer than 39 characters -->
    <title abbrev="WebSocket as a Transport for SIP">The WebSocket Protocol as a Transport for the Session Initiation Protocol (SIP)</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Inaki Baz Castillo" initials="I.B.C." surname="Baz Castillo">
      <organization>XtraTelecom S.A.</organization>
      <address>
        <postal>
          <street></street>
          <city>Barakaldo</city>
          <region>Basque Country</region>
          <code></code>
          <country>Spain</country>
        </postal>
        <email>ibc@aliax.net</email>
      </address>
    </author>

    <author fullname="Jose Luis Millan" initials="J.L.M." surname="Luis Millan">
      <organization>XtraTelecom S.A.</organization>
      <address>
        <postal>
        <street>
        </street>
        <city>Bilbao</city>
        <region>Basque Country</region>
        <code>
        </code>
        <country>Spain</country>
        </postal>
        <email>jmillan@aliax.net</email>
      </address>
    </author>

    <author fullname="Victor Pascual" initials="V.P." surname="Pascual">
      <organization>Acme Packet</organization>
      <address>
        <postal>
          <street>Anabel Segura 10</street>
          <city>Madrid</city>
          <region>Madrid</region>
          <code>28108</code>
          <country>Spain</country>
        </postal>
        <email>vpascual@acmepacket.com</email>
      </address>
    </author>


    <date month="November" year="2011" />
    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
         in the current day for you. If only the current year is specified, xml2rfc will fill
         in the current day and month for you. If the year is not the current one, it is
         necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
         purpose of calculating the expiry date).  With drafts it is normally sufficient to
         specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>IETF</area>
    <workgroup>SIPCORE Working Group</workgroup>
    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.
         If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>SIP</keyword>
    <keyword>WebSocket</keyword>
    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>This document specifies a WebSocket Sub-Protocol for a new transport in SIP (Session Initiation Protocol). The WebSocket protocol enables two-way realtime communication between clients and servers.</t>
    </abstract>

  </front>



  <middle>

    <section title="Introduction" anchor="introduction">

      <t>This specification defines a new WebSocket Sub-Protocol for transporting SIP messages between a WebSocket client and server, a new transport for the SIP protocol and procedures for SIP servers when bridging WebSocket and other SIP transports.</t>

      <t>This specification is focused on integrating the SIP protocol within client applications running a WebSocket stack. Other aspects such as the usage of WebSocket as a transport between SIP servers are not fully covered by this specification.</t>

     </section>

    <section title="Terminology" anchor="terminology">

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>

    </section>


    <section title="The WebSocket Protocol" anchor="the_websocket_protocol">

      <t>WebSocket protocol <xref target="I-D.ietf-hybi-thewebsocketprotocol"/> is a transport layer on top of TCP in which both client and server exchange message units in both directions. The protocol defines a connection handshake, WebSocket Sub-Protocol and extensions negotiation, a frame format for sending application and control data, a masking mechanism, and status codes for indicating disconnection causes.</t>

      <t>The WebSocket connection handshake is based on HTTP <xref target="RFC2616"/> protocol by means of a specific HTTP GET request sent by the client, typically a web browser, which is answered by the server (if the negotiation succeeded) with HTTP 101 status code. This handshake procedure is designed to reuse the existing HTTP infrastructure. During the connection handshake, client and server agree in the application protocol to use on top of the WebSocket transport. Such application protocol (also known as the "WebSocket Sub-Protocol") defines the format and semantics of the messages exchanged between both endpoints. The WebSocket Sub-Protocol to be used is up to the application developer. It may be a custom protocol or a standarized one (as the WebSocket SIP Sub-Protocol proposed in this document). Once the HTTP 101 response is processed both client and server reuse the existing TCP connection for sending application messages and control frames to each other in a persistent way.</t>

      <t>WebSocket defines message units as application data exchange for communication endpoints, becoming a message boundary transport layer. These messages can contain UTF-8 text or binary data, and can be splitted into various WebSocket text/binary frames. However, the <xref target="WS-API">WebSocket API</xref> for web browsers just includes JavaScript callbacks that are invoked upon receipt of an entire message, regardless it has been received in a single or multiple WebSocket frames.</t>

    </section>


    <section title="The WebSocket SIP Sub-Protocol" anchor="the_websocket_sip_subprotocol">

      <t>The term WebSocket Sub-Protocol refers to the application-level protocol layered over a WebSocket connection. This document specifies the WebSocket SIP Sub-Protocol for carrying SIP requests and responses through a WebSocket connection.</t>

      <t>The WebSocket client and server need to agree on this protocol during the WebSocket handshake procedure as defined in section 1.3 of <xref target="I-D.ietf-hybi-thewebsocketprotocol"/>. The client MUST include the value "sip" in the Sec-WebSocket-Protocol header in its handshake request. The 101 reply from the WebSocket server MUST contain "sip" in its own Sec-WebSocket-Protocol header.</t>

      <t>Below is an example of the WebSocket handshake in which the client requests SIP Sub-Protocol support from the server:<figure><artwork><![CDATA[
  GET / HTTP/1.1
  Host: sip-ws.example.com
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
  Origin: http://www.example.com
  Sec-WebSocket-Protocol: sip
  Sec-WebSocket-Version: 13
]]></artwork></figure>
      </t>

      <t>The handshake response from the server supporting the WebSocket SIP Sub-Protocol would look like:<figure><artwork><![CDATA[
  HTTP/1.1 101 Switching Protocols
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
  Sec-WebSocket-Protocol: sip
]]></artwork></figure>
      </t>

      <t>Once the negotiation is done, the WebSocket connection is established with SIP as the WebSocket Sub-Protocol. The WebSocket messages to be transmitted over this connection MUST conform to the established signaling protocol.</t>

      <t>WebSocket messages are carried on top of WebSocket UTF-8 text frames or binary frames. SIP protocol <xref target="RFC3261"/> allows both text and binary bodies in SIP messages. Therefore a client and server implementing the WebSocket SIP Sub-Protocol MUST accept both WebSocket text and binary frames.</t>
 
      <t>Each SIP message MUST be carried within a single WebSocket message and MUST be a complete SIP message, so a Content-Length header field is not mandatory. Sending more than one SIP message within a single WebSocket message is not allowed, neither sending an incomplete SIP message.
        <list style="empty">
          <t>This makes parsing of SIP messages easier on client side (typically web-based applications with an strict and simple API for receiving WebSocket messages). There is no need to establish boundaries (using Content-Length headers) between different messages. Same advantage is present in other message-based SIP transports as UDP or <xref target="RFC4168">SCTP</xref>.</t>
        </list>
      </t>

    </section>
 

    
    <section title="SIP WebSocket Transport" anchor="sip_websocket_transport">

      <t>WebSocket <xref target="I-D.ietf-hybi-thewebsocketprotocol"/> is a reliable protocol and therefore the WebSocket sub-protocol for a SIP transport defined by this document is also a reliable transport. Thus, client and server transactions using WebSocket transport MUST follow the procedures and timer values for reliable transports as defined in <xref target="RFC3261"/>.</t>

      <section title="Via Transport Parameter" anchor="via_transport_parameter">

        <t>Via header fields carry the transport protocol identifier. This document defines the value "WS" to be used for requests over plain WebSocket protocol and "WSS" for requests over secure WebSocket protocol (in which the WebSocket connection is established on top of TLS <xref target="RFC5246"/> over TCP transport).</t>

        <t>The updated augmented BNF (Backus-Naur Form) <xref target="RFC5234"/> for this parameter is the following:<figure><artwork><![CDATA[
  transport  =  "UDP" / "TCP" / "TLS" / "SCTP" / "WS" / "WSS"
                / other-transport
]]></artwork></figure>
        </t>

      </section>

      <section title="SIP URI Transport Parameter" anchor="sip_uri_transport_parameter">
   
        <t>This document defines the value "ws" as the transport parameter value for a SIP URI <xref target="RFC3986"/> to be contacted using WebSocket protocol as transport.</t>
   
        <t>The updated augmented BNF (Backus-Naur Form) <xref target="RFC5234"/> for this parameter is the following:<figure><artwork><![CDATA[
  transport-param  =  "transport="
                      ( "udp" / "tcp" / "sctp" / "tls" / "sctp"
                      / "ws"
                      / other-transport )
]]></artwork></figure>
        </t>
       
      </section>

      <section title="Sending Responses" anchor="sending_responses">

        <t>The SIP server transport uses the value of the top Via header field in order to determine where to send a response. If the "sent-protocol" is "WS" or "WSS" the response MUST be sent using the existing WebSocket connection to the source of the original request, if that connection is still open. This requires the server transport to maintain an association between server transactions and transport connections. If that connection is no longer open, the server MUST NOT attempt to open a WebSocket connection to the Via "sent-by"/"received"/"rport".
          <list style="empty">
            <t>This is due to the nature of the WebSocket protocol in which just the WebSocket client can establish a connection with the WebSocket server. A WebSocket client does not listen for incoming connections.</t>
          </list>
        </t>

      </section>
     
    </section>


    <section title="Outbound and GRUU Usage" anchor="outbound_and_gruu_usage">

      <t>WebSocket requires the client to open a TCP connection with the server and perform the WebSocket handshake. A WebSocket client does not listen for incoming connections so it can only receive SIP requests from the WebSocket server it is connected to. WebSocket clients may use either public or private addressing but it is expected that many of them will run the latter. Unfortunately, some implementations may not have the ability to discover the local transport address which the WebSocket connection is originated from (e.g. a JavaScript stack within a web browser).</t>

      <t>Therefore clients and servers implementing SIP over the WebSocket transport MUST implement the Outbound mechanism <xref target="RFC5626"/>, being this the most suitable solution for SIP clients behind Network Address Translation (NAT) using reliable transports for contacting SIP servers.</t>

      <t>A client implementing SIP over the WebSocket transport SHOULD also implement GRUU <xref target="RFC5627"/>. The registrar responsible for the registration of SIP clients using the WebSocket transport SHOULD implement GRUU as well.
        <list style="empty">
          <t>If a REFER request is sent to a SIP User Agent indicating the Contact URI of a WebSocket client as the target in the Refer-To header field, such a URI will be reachable by the SIP UA just in the case it is a globally routable URI obtained from a SIP registrar implementing GRUU.</t>
        </list>
      </t>

      <t>Both Outbound and GRUU require the client to indicate a Uniform Resource Name (URN) in the "+sip.instance" parameter of the Contact header during the registration. The client device is responsible for getting such a constant and unique value.
        <list style="empty">
          <t>In the case of web browsers it is hard to get a URN value from the browser itself. This specification suggests that value is generated according to <xref target="RFC5626"/> section 4.1 by the web application running in the browser the first time it loads the web page, and then it is stored as a Cookie <xref target="RFC6265"/> within the browser data and loaded every time the same web page is visited. The application developer could choose any other mechanism which accomplishes the requirements of a URN.</t>
        </list>
      </t>

    </section>


    <section title="Locating a SIP Server" anchor="locating_a_sip_server">

      <t>SIP entities follow normal SIP procedures in <xref target="RFC3263"/> to discover a SIP server. This specification defines the NAPTR service value "SIP+D2W" for servers that support plain WebSocket transport and "SIPS+D2W" for servers that support secure WebSocket transport.</t>

      <t>A SIP entity using the WebSocket transport SHOULD perform procedures in <xref target="RFC3263"/> for the given WebSocket URI it will connect to. If the WebSocket URI has "wss" schema the SIP entity MUST only consider "SIPS+D2W" resource records. If the WebSocket URI does not contain a domain in the host part or does include a port, the SIP entity MUST follow procedures in <xref target="I-D.ietf-hybi-thewebsocketprotocol"/> section 3 instead.
        <list style="empty">
          <t>Unfortunately the JavaScript stack running in web browsers cannot perform DNS NAPTR/SRV queries, neither the WebSocket stack running in web browsers can do it. Thus, a WebSocket URI given within a web application needs to have a numeric network address or a hostname with associated DNS A/AAAA resource record(s) in its host part.</t>
        </list>
      </t>

    </section>
    

    <section title="WebSocket Client Usage" anchor="websocket_client_usage">

      <t>The WebSocket connection MUST be established in order to allow the client application to send and receive SIP requests.
        <list style="empty">
          <t>Based on local policy, this might occur once the JavaScript SIP application has been downloaded from the web server, or when the SIP user using the web browser application registers itself to a SIP registrar (assuming that SIP requests cannot be sent or received before then).</t>
        </list>
      </t>

      <t>In case the client application decides to close the WebSocket connection (for example when performing "logout" in a web application) it is recommended to remove the existing SIP registration binding (if present) by means of a REGISTER with expiration value of 0 and the associated "+sip.instance" Contact header parameter as per <xref target="RFC5626"/>.</t>


      <section title="WebSocket Disconnection" anchor="websocket_disconnection">

        <t>In some circumstances the WebSocket connection could be terminated by the WebSocket server (for example when the server is restarted). If the client application wants to become reachable again it SHOULD reconnect to the WebSocket server and perform a new SIP registration with same "+sip.instance" and "reg-id" Contact header parameters (as stated in <xref target="RFC5626"/>).</t>

      </section>

    </section>


    <section title="WebSocket Server Usage" anchor="websocket_server_usage">
      
      <t>How a SIP server authorizes WebSocket connection attemps from clients is out of the scope of this specification. However some informational guidelines are provided in <xref target="authentication"/>. Once the WebSocket SIP Sub-Protocol is agreed, both client and server can send SIP messages to each other.</t>

      <section title="SIP Proxy Considerations" anchor="sip_proxy_considerations">
        
        <t>When a SIP proxy bridges WebSocket and any other SIP transport (including WebSocket transport) it MUST perform Loose Routing as specified in <xref target="RFC3261"/>. Otherwise in-dialog requests would fail since WebSocket clients cannot contact destinations other than their WebSocket server, and non-WebSocket SIP entities cannot establish a connection to WebSocket clients. It is also recommended that SIP proxy implementations use double Record-Route techniques (as specified in <xref target="RFC5658"/>).</t>

        <t>In the same way, if the SIP proxy implementing the WebSocket server behaves as an outbound proxy for REGISTER requests, it MUST add a Path header field as described in <xref target="RFC3327"/>. Otherwise the WebSocket client would never receive incoming requests from the SIP registrar server after the lookup procedures in the SIP location service.</t>
        
      </section>

    </section>


    <section title="Connection Keep Alive" anchor="connection_keep_alive">
      
      <t>It is recommended that the WebSocket client or server keeps the WebSocket connection open by sending periodic WebSocket Ping frames as described in <xref target="I-D.ietf-hybi-thewebsocketprotocol"/> section 5.5.2. The decision for a WebSocket endpoint to maintain, or not, the connection over time is out of scope of this document.</t>

      <t>The client application MAY also use Network Address Translation (NAT) keep-alive mechanisms defined for the SIP protocol, such as the CRLF Keep-Alive Technique mechanism described in <xref target="RFC5626"/> section 3.5.1. Therefore, a SIP server implementing the WebSocket transport MUST support the CRLF Keep-Alive Technique.</t>
 
    </section>


    <section title="Authentication" anchor="authentication">

      <t>Prior to sending SIP requests, the WebSocket client implementing the SIP protocol connects to the WebSocket server and performs the connection handshake. As described in <xref target="the_websocket_protocol"/> the handshake procedure involves an HTTP GET request replied with HTTP 101 status code by the server.</t>

      <t>In order to authorize the WebSocket connection the server MAY inspect the Cookie <xref target="RFC6265"/> header in the HTTP GET request (if present). In case of web applications the value of such a Cookie is typically provided by the web server once the user has authenticated itself against the web application by following any of the multiple existing mechanisms. As an alternative method, the WebSocket server could request Digest <xref target="RFC2617"/> authentication by replying a HTTP 401 status code. The WebSocket protocol <xref target="I-D.ietf-hybi-thewebsocketprotocol"/> covers this usage in section 4.1:
        <list style="empty">
          <t>If the status code received from the server is not 101, the client handles the response per HTTP <xref target="RFC2616"/> procedures, in particular the client might perform authentication if it receives 401 status code.</t>
        </list>
      </t>

      <t>Regardless the WebSocket server requires authentication during the WebSocket handshake or not, authentication MAY be requested at SIP protocol level. Therefore a SIP client using the WebSocket transport MUST implement Digest <xref target="RFC2617"/> authentication as stated in <xref target="RFC3261"/>.</t>
      
    </section>

    
    <section title="Examples" anchor="examples">

      <section title="Registration" anchor="registration">
        <t><figure><artwork><![CDATA[
Alice    (SIP WSS)    proxy.atlanta.com
|                             |
|REGISTER F1                  |
|---------------------------->|
|200 OK F2                    |
|<----------------------------|
|                             |
]]></artwork></figure>
        </t>

        <t>Alice loads a web page using her web browser and retrieves a JavaScript code implementing the WebSocket SIP Sub-Protocol defined in this document. The JavaScript code obtained from the web server establishes a secure WebSocket connection with a SIP proxy/registrar at proxy.atlanta.com. Upon WebSocket connection, Alice constructs and sends a SIP REGISTER by requesting Outbound and GRUU support. Since the JavaScript stack in a browser has no way to determine the local address from which the WebSocket connection is made, this implementation uses anonymous.invalid in Via sent-by for every SIP requests and anonymous.invalid as URI hostpart in the Contact header of the initial REGISTER request.</t>

        <t>Message details (authentication and SDP bodies are omitted for simplicity):</t>

<t><figure><artwork><![CDATA[
F1 REGISTER  Alice -> proxy.atlanta.com (transport WSS)

REGISTER sip:proxy.atlanta.com SIP/2.0
Via: SIP/2.0/WSS anonymous.invalid;branch=z9hG4bKasudf
From: sip:alice@atlanta.com;tag=65bnmj.34asd
To: sip:alice@atlanta.com
Call-ID: aiuy7k9njasd
CSeq: 1 REGISTER
Max-Forwards: 70
Supported: path, outbound, gruu
Route: <sip:proxy.atlanta.com:443;transport=ws;lr>
Contact: <sip:alice@anonymous.invalid;transport=ws>
  ;reg-id=1
  ;+sip.instance="<urn:uuid:f81-7dec-14a06cf1>"


F2 200 OK  proxy.atlanta.com -> Alice (transport WSS)

SIP/2.0 200 OK
Via: SIP/2.0/WSS anonymous.invalid;branch=z9hG4bKasudf
From: sip:alice@atlanta.com;tag=65bnmj.34asd
To: sip:alice@atlanta.com;tag=12isjljn8
Call-ID: aiuy7k9njasd
CSeq: 1 REGISTER
Supported: outbound, gruu
Contact: <sip:alice@anonymous.invalid;transport=ws>
  ;reg-id=1
  ;+sip.instance="<urn:uuid:f81-7dec-14a06cf1>"
  ;pub-gruu="sip:alice@atlanta.com;gr=urn:uuid:f81-7dec-14a06cf1"
  ;temp-gruu="sip:87ash54=3dd.98a@atlanta.com;gr"
  ;expires=3600
]]></artwork></figure>
        </t>
      </section>

      <section title="INVITE dialog through a proxy" anchor="invite_dialog_through_a_proxy">
        <t><figure><artwork><![CDATA[
Alice    (SIP WSS)    proxy.atlanta.com    (SIP UDP)       Bob
|                             |                             |
|INVITE F1                    |                             |
|---------------------------->|                             |
|100 Trying F2                |                             |
|<----------------------------|                             |
|                             |INVITE F3                    |
|                             |---------------------------->|
|                             |200 OK F4                    |
|                             |<----------------------------|
|200 OK F5                    |                             |
|<----------------------------|                             |
|                             |                             |
|ACK F6                       |                             |
|---------------------------->|                             |
|                             |ACK F7                       |
|                             |---------------------------->|
|                             |                             |
|                    Both Way RTP Media                     |
|<=========================================================>|
|                             |                             |
|                             |BYE F8                       |
|                             |<----------------------------|
|BYE F9                       |                             |
|<----------------------------|                             |
|200 OK F10                   |                             |
|---------------------------->|                             |
|                             |200 OK F11                   |
|                             |---------------------------->|
|                             |                             |
]]></artwork></figure>
        </t>
        
        <t>In the same scenario Alice places a call to Bob's AoR by using the public GRUU retrieved from the registrar as Contact URI of the INVITE. The WebSocket SIP server at proxy.atlanta.com acts as a SIP proxy routing the INVITE to the UDP location of Bob, who answers the call and terminates it later.</t>

        <t>Message details (authentication and SDP bodies are omitted for simplicity):</t>
 
        <t><figure><artwork><![CDATA[
F1 INVITE  Alice -> proxy.atlanta.com (transport WSS)

INVITE sip:bob@atlanta.com SIP/2.0
Via: SIP/2.0/WSS anonymous.invalid;branch=z9hG4bK56sdasks
From: sip:alice@atlanta.com;tag=asdyka899
To: sip:bob@atlanta.com
Call-ID: asidkj3ss
CSeq: 1 INVITE
Max-Forwards: 70
Supported: path, outbound, gruu
Route: <sip:proxy.atlanta.com:443;transport=ws;lr>
Contact: <sip:alice@atlanta.com
 ;gr=urn:uuid:f81-7dec-14a06cf1;ob>"
Content-Type: application/sdp


F2 100 Trying  proxy.atlanta.com -> Alice (transport WSS)

SIP/2.0 100 Trying
Via: SIP/2.0/WSS anonymous.invalid;branch=z9hG4bK56sdasks
From: sip:alice@atlanta.com;tag=asdyka899
To: sip:bob@atlanta.com
Call-ID: asidkj3ss
CSeq: 1 INVITE


F3 INVITE  proxy.atlanta.com -> Bob (transport UDP)

INVITE sip:bob@203.0.113.22:5060 SIP/2.0
Via: SIP/2.0/UDP proxy.atlanta.com;branch=z9hG4bKhjhjqw32c
Via: SIP/2.0/WSS anonymous.invalid;branch=z9hG4bK56sdasks
Record-Route: <sip:proxy.atlanta.com;transport=udp;lr>,
  <sip:h7kjh12s@proxy.atlanta.com:443;transport=ws;lr>
From: sip:alice@atlanta.com;tag=asdyka899
To: sip:bob@atlanta.com
Call-ID: asidkj3ss
CSeq: 1 INVITE
Max-Forwards: 69
Supported: path, outbound, gruu
Contact: <sip:alice@atlanta.com
  ;gr=urn:uuid:f81-7dec-14a06cf1;ob>"
Content-Type: application/sdp


F4 200 OK  Bob -> proxy.atlanta.com (transport UDP)

SIP/2.0 200 OK
Via: SIP/2.0/UDP proxy.atlanta.com;branch=z9hG4bKhjhjqw32c
Via: SIP/2.0/WSS anonymous.invalid;branch=z9hG4bK56sdasks
Record-Route: <sip:proxy.atlanta.com;transport=udp;lr>,
  <sip:h7kjh12s@proxy.atlanta.com:443;transport=ws;lr>
From: sip:alice@atlanta.com;tag=asdyka899
To: sip:bob@atlanta.com;tag=bmqkjhsd
Call-ID: asidkj3ss
CSeq: 1 INVITE
Max-Forwards: 69
Contact: <sip:bob@203.0.113.22:5060;transport=udp>
Content-Type: application/sdp


F5 200 OK  proxy.atlanta.com -> Alice (transport WSS)

SIP/2.0 200 OK
Via: SIP/2.0/WSS anonymous.invalid;branch=z9hG4bK56sdasks
Record-Route: <sip:proxy.atlanta.com;transport=udp;lr>,
  <sip:h7kjh12s@proxy.atlanta.com:443;transport=ws;lr>
From: sip:alice@atlanta.com;tag=asdyka899
To: sip:bob@atlanta.com;tag=bmqkjhsd
Call-ID: asidkj3ss
CSeq: 1 INVITE
Max-Forwards: 69
Contact: <sip:bob@203.0.113.22:5060;transport=udp>
Content-Type: application/sdp
           

F6 ACK  Alice -> proxy.atlanta.com (transport WSS)

ACK sip:bob@203.0.113.22:5060;transport=udp SIP/2.0
Via: SIP/2.0/WSS anonymous.invalid;branch=z9hG4bKhgqqp090
Route: <sip:h7kjh12s@proxy.atlanta.com:443;transport=ws;lr>,
  <sip:proxy.atlanta.com;transport=udp;lr>,
From: sip:alice@atlanta.com;tag=asdyka899
To: sip:bob@atlanta.com;tag=bmqkjhsd
Call-ID: asidkj3ss
CSeq: 1 ACK
Max-Forwards: 70


F7 ACK  proxy.atlanta.com -> Bob (transport UDP)

ACK sip:bob@203.0.113.22:5060;transport=udp SIP/2.0
Via: SIP/2.0/UDP proxy.atlanta.com;branch=z9hG4bKhwpoc80zzx
Via: SIP/2.0/WSS anonymous.invalid;branch=z9hG4bKhgqqp090
From: sip:alice@atlanta.com;tag=asdyka899
To: sip:bob@atlanta.com;tag=bmqkjhsd
Call-ID: asidkj3ss
CSeq: 1 ACK
Max-Forwards: 69


F8 BYE  Bob -> proxy.atlanta.com (transport UDP)

BYE sip:alice@atlanta.com;gr=urn:uuid:f81-7dec-14a06cf1;ob SIP/2.0
Via: SIP/2.0/UDP 203.0.113.22;branch=z9hG4bKbiuiansd001
Route: <sip:proxy.atlanta.com;transport=udp;lr>,
  <sip:h7kjh12s@proxy.atlanta.com:443;transport=ws;lr>
From: sip:bob@atlanta.com;tag=bmqkjhsd
To: sip:alice@atlanta.com;tag=asdyka899
Call-ID: asidkj3ss
CSeq: 1201 BYE
Max-Forwards: 70


F9 BYE  proxy.atlanta.com -> Alice (transport WSS)

BYE sip:alice@atlanta.com;gr=urn:uuid:f81-7dec-14a06cf1;ob SIP/2.0
Via: SIP/2.0/WSS proxy.atlanta.com:443;branch=z9hG4bKmma01m3r5
Via: SIP/2.0/UDP 203.0.113.22;branch=z9hG4bKbiuiansd001
From: sip:bob@atlanta.com;tag=bmqkjhsd
To: sip:alice@atlanta.com;tag=asdyka899
Call-ID: asidkj3ss
CSeq: 1201 BYE
Max-Forwards: 69


F10 200 OK  Alice -> proxy.atlanta.com (transport WSS)

SIP/2.0 200 OK
Via: SIP/2.0/WSS proxy.atlanta.com:443;branch=z9hG4bKmma01m3r5
Via: SIP/2.0/UDP 203.0.113.22;branch=z9hG4bKbiuiansd001
From: sip:bob@atlanta.com;tag=bmqkjhsd
To: sip:alice@atlanta.com;tag=asdyka899
Call-ID: asidkj3ss
CSeq: 1201 BYE


F11 200 OK  proxy.atlanta.com -> Bob (transport UDP)

SIP/2.0 200 OK
Via: SIP/2.0/UDP 203.0.113.22;branch=z9hG4bKbiuiansd001
From: sip:bob@atlanta.com;tag=bmqkjhsd
To: sip:alice@atlanta.com;tag=asdyka899
Call-ID: asidkj3ss
CSeq: 1201 BYE
]]></artwork></figure>
        </t>
      </section>

    </section>

   
    <section title="Security Considerations" anchor="security_considerations">

      <section title="Secure WebSocket Connection">
        <t>It is recommended to protect the privacy of the SIP traffic through the WebSocket communication by using a secure WebSocket connection (tunneled over TLS <xref target="RFC5246"/>). For this, the client application MUST be provided with a secure "wss" WebSocket URI.</t>
      </section>

      <section title="WebSocket Topology Hiding" anchor="websocket_topology_hiding">

        <t><xref target="RFC3261">RFC 3261</xref> section 18.2.1 "Receiving Requests" states the following:
          <list style="empty">
            <t>When the server transport receives a request over any transport, it MUST examine the value of the "sent-by" parameter in the top Via header field value.  If the host portion of the "sent-by" parameter contains a domain name, or if it contains an IP address that differs from the packet source address, the server MUST add a "received" parameter to that Via header field value.  This parameter MUST contain the source address from which the packet was received.</t>
          </list>
        </t>

        <t>The requirement of adding the "received" parameter does not fit well into WebSocket protocol nature. The WebSocket handshake connection reuses existing HTTP infrastructure in which there could be certain number of HTTP proxies and/or TCP load balancers between the client and the WebSocket server, so the source IP the server would write into the Via "received" parameter would be the IP of the HTTP/TCP intermediary in front of it. This would reveal sensitive information about the internal topology of the provider network to the WebSocket client.</t>

        <t>Thus, given the fact that SIP responses can only be sent over the existing WebSocket connection, the meaning of the Via "received" parameter added by the server is of little use. Therefore, in order to allow hiding possible sensitive information about the provider infrastructure, this specification relaxes the requirement in <xref target="RFC3261">RFC 3261</xref> section 18.2.1 "Receiving Requests" by stating that a WebSocket server receiving a SIP request from a WebSocket client MAY choose not to add the Via "received" parameter nor honor the Via "rport" <xref target="RFC3581"/> parameter. A SIP client implementing the WebSocket transport MUST be ready to receive SIP responses in which the topmost Via header field does not contain the "received" and "rport" parameters.</t>

      </section>
      
    </section>


    <section title="IANA Considerations" anchor="iana_considerations">

      <section title="Registration of the WebSocket SIP Sub-Protocol">
        <t>This specification requests IANA to create the WebSocket SIP Sub-Protocol in the registry of WebSocket sub-protocols with the following data:
          <list style="hanging">
            <t hangText="Subprotocol Identifier:">sip</t>
            <t hangText="Subprotocol Common Name:">SIP over WebSocket</t>
            <t hangText="Subprotocol Definition:">TBD, it should point to this document</t>
          </list>
        </t>
      </section>
      
      <section title="Registration of new Via transports">
        <t>This specification registers two new transport identifiers for Via headers:
          <list style="hanging" hangIndent="6">
            <t hangText="WS:">MUST be used when constructing a SIP request to be sent over a plain WebSocket connection.</t>
            <t hangText="WSS:">MUST be used when constructing a SIP request to be sent over a secure WebSocket connection (tunneled over TLS <xref target="RFC5246"/>).</t>
          </list>
        </t>
      </section>

      <section title="Registration of new SIP URI transport">
        <t>This specification registers a new value for the "transport" parameter in a SIP URI:
          <list style="hanging" hangIndent="6">
            <t hangText="ws:">Identifies a SIP URI to be contacted using a WebSocket connection.</t>
          </list>
        </t>
      </section>

      <section title="Registration of new NAPTR service field values">

        <t>This document defines two new NAPTR service field values (SIP+D2W and SIPS+D2W) and requests IANA to register these values under the "Registry for the SIP SRV Resource Record Services Field".  The resulting entries are as follows:<figure><artwork><![CDATA[
 Services Field        Protocol  Reference
 --------------------  --------  ---------
 SIP+D2W               WS        TBD: this document
 SIPS+D2W              WSS       TBD: this document
]]></artwork></figure>
        </t>

      </section>

    </section>


    <section title="Acknowledgements" anchor="acknowledgements">

      <t>Special thanks to the following people who participated in discussions on the SIPCORE and RTCWEB WG mailing lists and contributed ideas and/or provided detailed reviews (the list is likely to be incomplete): Hadriel Kaplan, Paul Kyzivat, Ranjit Avasarala.</t>

      <t>Special thanks also to Saul Ibarra Corretg√© for his detailed review and provided suggestions.</t>
    </section>
    

  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      &RFC2119;
      &RFC2617;
      &RFC5234;
      &RFC3261;
      &RFC3263;
      &RFC5626;
      &RFC5627;
      &I-D.ietf-hybi-thewebsocketprotocol;
    </references>

    <references title="Informative References">
      &RFC2616;
      &RFC3986;
      &RFC4168;
      &RFC5246;
      &RFC3327;
      &RFC3581;
      &RFC5658;
      &RFC6265;

      <reference anchor="WS-API">
        <front>
          <title>The Web Sockets API</title>
          <author initials="I." surname="Hickson" fullname="Ian Hickson">
            <organization>Google, Inc.</organization>
          </author>
          <date month="September" year="2010" />
        </front>
      </reference>
      
    </references>


  </back>

</rfc>
