<?xml version="1.0" encoding="us-ascii"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes" ?>
<?rfc linkmailto="yes"?>
<?rfc strict="yes"?>
<?rfc subcompact="no"?>
<rfc category="info" docName="draft-loreto-http-bidirectional-07" ipr="trust200902">

  <front>
    <title abbrev="Bidirectional HTTP">Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP</title>

    <author initials="S." surname="Loreto" fullname="Salvatore Loreto">
      <organization>Ericsson</organization>
      <address>
        <postal>
          <street>Hirsalantie 11</street>
          <code>02420</code> 
          <city>Jorvas</city> 
          <country>Finland</country>
        </postal>
        <email>salvatore.loreto@ericsson.com</email>
      </address>
    </author>

    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization>Cisco</organization>
       <address>
         <postal>
           <street>1899 Wyknoop Street, Suite 600</street>
           <city>Denver</city>
           <region>CO</region>
           <code>80202</code>
           <country>USA</country>
         </postal>
         <phone>+1-303-308-3282</phone>
         <email>psaintan@cisco.com</email>
       </address>
    </author>

    <author initials="S." surname="Salsano" fullname="Stefano Salsano">
      <organization>Univ.  of Rome "Tor Vergata"</organization>
      <address>
        <postal>
          <street>Via del Politecnico, 1</street>
          <code>00133</code> 
          <city>Rome</city> 
          <country>Italy</country>
        </postal>
        <email>stefano.salsano@uniroma2.it</email>
      </address>
    </author>

    <author initials="G." surname="Wilkins" fullname="Greg Wilkins">
      <organization>Webtide</organization>
      <address>
        <email>gregw@webtide.com</email>
      </address>
    </author> 

    <date day="4" month="January" year="2011"/>

    <area>Applications</area>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>HTTP</keyword>
    <keyword>HTTP Streaming</keyword>
    <keyword>Long Polling</keyword>

    <abstract>
      <t>On today's Internet, the Hypertext Transfer Protocol (HTTP) is often used (some would say abused) to enable asynchronous, "server-initiated" communication from a server to a client as well as from a client to a server.  This document describes known issues and best practices related to such "bidirectional HTTP" applications, focusing on the two most common mechanisms: "HTTP long polling" and "HTTP streaming".</t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction" toc="default">
      <t>The Hypertext Transfer Protocol <xref target="RFC2616"/> is a request/response protocol.  HTTP defines the following entities: clients, proxies, and servers.  A client establishes connections to a server for the purpose of sending HTTP requests.  A server accepts connections from clients in order to service HTTP requests by sending back responses.  Proxies are intermediate entities that can be involved in the delivery of requests and responses from the client to the server and vice versa.</t>
      <t>In the standard HTTP model, a server cannot initiate a connection with a client nor send an unrequested HTTP response to the client; thus the server cannot push asynchronous events to clients.  Therefore, in order to receive asynchronous events as soon as possible, the client needs to poll the server periodically for new content.  However, continual polling can consume significant bandwidth by forcing a request/response round trip when no data is available.  It can also be inefficient because it reduces the responsiveness of the application since data is queued until the server receives the next poll request from the client.</t>
      <t>In order to improve this situation, several server push programming mechanisms have been implemented in recent years.  These mechanisms, which are often grouped under the common label "Comet" <xref target="COMET"/>, enable a web server to send updates to clients without waiting for a poll request from the client.  Such mechanisms can deliver updates to clients in a more timely manner while avoiding the latency experienced by client applications due to the frequent opening and closing of connections necessary to periodically poll for data.</t>
      <t>The two most common server push mechanisms are "HTTP long polling" and "HTTP streaming":</t>
      <t>
        <list style="hanging">
          <t hangText="HTTP Long Polling:"> The server attempts to "hold open" (not immediately reply to) each HTTP request, responding only when there are events to deliver.  In this way, there is always a pending request to which the server can reply for the purpose of delivering events as they occur, thereby minimizing the latency in message delivery.</t>
          <t hangText="HTTP Streaming:"> The server keeps a request open indefinitely; that is, it never terminates the request or closes the connection, even after it pushes data to the client.</t>
        </list>
      </t>
      <t>It is possible to define other technologies for bidirectional HTTP, however such technologies typically require changes to HTTP itself (e.g., by defining new HTTP methods).  This document focuses only on bidirectional HTTP technologies that work within the current scope of HTTP as defined in <xref target="RFC2616"/> (HTTP 1.1) and <xref target="RFC1945"/> (HTTP 1.0).</t>
      <t>The authors acknowledge that both the "HTTP long polling" and "HTTP streaming" mechanisms stretch the original semantic of HTTP and that the HTTP protocol was not designed for bidirectional communication.  This document neither encourages nor discourages the use of these mechanisms, and takes no position on whether they provide appropriate solutions to the problem of providing bidirectional communication between clients and servers.  Instead, this document merely identifies technical issues with these mechanisms and suggests best practices for their deployment.</t>
      <t>The remainder of this document is organized as follows.  <xref target="polling"/> analyzes the "HTTP long polling" technique.  <xref target="streaming"/> analyzes the "HTTP streaming" technique.  <xref target="tech"/> provides an overview of the specific technologies that use server-push technique.  <xref target="practices"/> lists best practices for bidirectional HTTP using existing technologies.</t>
    </section>

    <section anchor="polling" title="HTTP Long Polling">
      <section anchor="polling-definition" title="Definition">
        <t>With the traditional or "short" polling technique, a client sends regular requests to the server and each request attempts to "pull" any available events or data.  If there are no events or data available, the server returns an empty response and the client waits for some time before sending another poll request.  The polling frequency depends on the latency that the client can tolerate in retrieving updated information from the server.  This mechanism has the drawback that the consumed resources (server processing and network) strongly depend on the acceptable latency in the delivery of updates from server to client.  If the acceptable latency is low (e.g., on the order of seconds) then the polling frequency can cause an unacceptable burden on the server, the network, or both.</t>
        <t>By contrast with such "short polling", "long polling" attempts to minimize both latency in server-client message delivery and the use of processing/network resources.  The server achieves these efficiencies by responding to a request only when a particular event, status, or timeout has occurred.  Once the server sends a long poll response, typically the client immediately sends a new long poll request.  Effectively this means that at any given time the server will be holding open a long poll request, to which it replies when new information is available for the client.  As a result, the server is able to asynchronously "initiate" communication.</t>
        <t>The basic life cycle of an application using "HTTP long polling" is as follows:</t>
        <t>
          <list style="numbers">
            <t>The client makes an initial request and then waits for a response.</t>
            <t>The server defers its response until an update is available, or until a particular status or timeout has occurred.</t>
            <t>When an update is available, the server sends a complete response to the client.</t>
            <t>The client typically sends a new long poll request, either immediately upon receiving a response or after a pause to allow an acceptable latency period.</t>
           </list>
         </t>
         <t>The HTTP long polling mechanism can be applied to either persistent or non-persistent HTTP connections.  The use of persistent HTTP connections will avoid the additional overhead of establishing a new TCP/IP connection <xref target='TCP'/> for every long poll request.</t>
       </section>

       <section anchor="polling-issues" title="HTTP Long Polling Issues">
         <t>The HTTP long polling mechanism introduces the following issues.</t>
         <t>
           <list style="hanging">
             <t hangText="Header Overhead:">With the HTTP long polling technique, every long poll request and long poll response is a complete HTTP message and thus contains a full set of HTTP headers in the message framing.  For small, infrequent messages, the headers can represent a large percentage of the data transmitted.  If the network MTU (Maximum Transmission Unit) allows all the information (including the HTTP header) to fit within a single IP packet, this typically does not represent a significant increase in the burden for networking entities.  On the other hand, the amount of transferred data can be significantly larger than the real payload carried by HTTP and this can have a significant impact (e.g., when volume-based charging is in place).</t>
             <t hangText="Maximal Latency:">After a long polling response is sent to a client, the server needs to wait for the next long polling request before another message can be sent to the client.  This means that while the average latency of long polling is close to one network transit, the maximal latency is over three network transits (long poll response, next long poll request, long poll response).  However, because HTTP is carried over TCP/IP, packet loss and retransmission can occur; therefore maximal latency for any TCP/IP protocol will be more than three network transits (lost packet, next packet, negative ack, retransmit).  When HTTP pipelining (see <xref target="pipelining"/>) is available, the latency due to the server waiting for a new request can be avoided.</t>
             <t hangText="Connection Establishment:">A common criticism of both short polling and long polling is that these mechanisms frequently open TCP/IP connections and then close them.  However, both polling mechanisms work well with persistent HTTP connections that can be reused for many poll requests.  Specifically, the short duration of the pause between a long poll response and the next long poll request avoids the closing of idle connections.</t>
             <t hangText="Allocated Resources:">Operating systems will allocate resources to TCP/IP connections and to HTTP requests outstanding on those connections.  The HTTP long polling mechanism requires that for each client, both a TCP/IP connection and an HTTP request are held open.  Thus it is important to consider the resources related to both of these when sizing an HTTP long polling application.  Typically the resources used per TCP/IP connection are minimal and can scale reasonably.  Frequently the resources allocated to HTTP requests can be significant, and scaling the total number of requests outstanding can be limited on some gateways, proxies, and servers.</t>
             <t hangText="Graceful Degradation:">A long polling client or server that is under load has a natural tendency to gracefully degrade in performance at a cost of message latency.  If load causes either a client or server to run slowly, then events to be pushed to the client will queue (waiting either for the client to send a long poll request or for the server to free up CPU that can be used to process a long poll request that is being held at the server).  If multiple messages are queued for a client, they might be delivered in a batch within a single long poll response.  This can significantly reduce the per-message overhead and thus ease the work load of the client or server for the given message load.</t>
             <t hangText="Timeouts:">Long polling requests need to remain pending or "hanging" until the server has something to send to the client.  The timeout issues related to these pending requests are discussed under <xref target="timeouts"/>.</t>
             <t hangText="Caching:">Caching mechanisms implemented by intermediate entities can interfere with long polling requests.  This issue is discussed under <xref target="network"/>.</t>
           </list>
         </t>
       </section>
     </section>

     <section anchor="streaming" title="HTTP Streaming">
       <section anchor="streaming-definition" title="Definition">
         <t>The "HTTP streaming" mechanism keeps a request open indefinitely.  It never terminates the request or closes the connection, even after the server pushes data to the client.  This mechanism significantly reduces the network latency because the client and the server do not need to open and close the connection.</t>
         <t>The basic life cycle of an application using "HTTP streaming" is as follows:</t>
         <t>
           <list style="numbers">
             <t>The client makes an initial request and then waits for a response.</t>
             <t>The server defers the response to a poll request until an update is available, or until a particular status or timeout has occurred.</t>
             <t>Whenever an update is available, the server sends it back to the client as a part of the response.</t>
             <t>The data sent by the server does not terminate the request or the connection.  The server returns to step 3.</t>
           </list>
         </t>
         <t>The HTTP streaming mechanism is based on the capability of the server to send several pieces of information on the same response, without terminating the request or the connection.  This result can be achieved by both HTTP/1.1 and HTTP/1.0 servers.</t>
         <t>An HTTP response content length can be defined using 3 options:</t>
         <t>
           <list style="hanging">
             <t hangText="Content-Length header:">This indicates the size of the entity body in the message, in bytes.</t>
             <t hangText="Transfer-Encoding header:">The 'chunked' valued in this header indicates the message will break into chunks of known size if needed.</t>
             <t hangText="End of File (EOF):">This is actually the default approach for HTTP/1.0 where the connections are not persistent.  Clients do not need to know the size of the body they are reading; instead they expect to read the body until the server closes the connection.  Although with HTTP/1.1 the default is for persistent connections, it is still possible to use EOF by setting the 'Connection:close' header in either the request or the response, to indicate that the connection is not to be considered 'persistent' after the current request/response is complete.  The client's inclusion of the 'Connection: close' header field in the request will also prevent pipelining.</t><t>The main issue with EOF is that it is difficult to tell the difference between a connection terminated by a fault and one that is correctly terminated.</t>
           </list>
         </t>
	<t>An HTTP/1.0 server can use only EOF as a streaming mechanism.  By contrast, both EOF and "chunked transfer" are available to an HTTP/1.1 server.</t>
         <t>The "chunked transfer" mechanism is the one typically used by HTTP/1.1 servers for streaming.  This is accomplished by including the header "Transfer-Encoding: chunked" at the beginning of the response, which enables it to send the following parts of the response in different "chunks" over the same connection.  Each chunk starts with the hexadecimal expression of the length of its data, followed by CR/LF (the end of the response is indicated with a chunk of size 0).</t>
         <figure anchor="notifier" title="Transfer-Encoding response">
           <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height=""><![CDATA[
        HTTP/1.1 200 OK
        Content-Type: text/plain
        Transfer-Encoding: chunked

        25
        This is the data in the first chunk

        1C
        and this is the second one

        0
           ]]></artwork>
         </figure>
         <t>An HTTP/1.0 server will omit the Content-Length header in the response to achieve the same result, so it will be able to send the subsequent parts of the response on the same connection (in this case the different parts of the response are not explicitly separated by HTTP protocol, and the end of the response is achieved by closing the connection).</t>
       </section>
        
       <section anchor="streaming-issues" title="HTTP Streaming Issues">
         <t>The HTTP streaming mechanism introduces the following issues.</t>
         <t>
           <list style="hanging">
             <t hangText="Network Intermediaries:">The HTTP protocol allows for intermediaries (proxies, transparent proxies, gateways, etc.) to be involved in the transmission of a response from the server to the client.  There is no requirement for an intermediary to immediately forward a partial response and it is legal for it to buffer the entire response before sending any data to the client (e.g., caching transparent proxies).  HTTP streaming will not work with such intermediaries.</t>
             <t hangText="Maximal Latency:">Theoretically, on a perfect network, an HTTP streaming protocol's average and maximal latency is one network transit.  However, in practice the maximal latency is higher due to network and browser limitations.  The browser techniques used to terminate HTTP streaming connections are often associated with JavaScript and/or DOM (Document Object Model) elements that will grow in size for every message received.  Thus in order to avoid unlimited memory growth in the client, an HTTP streaming implementation occasionally needs to terminate the streaming response and send a request to initiate a new streaming response (which is essentially equivalent to a long poll).  Thus the maximal latency is at least three network transits.  Also, because HTTP is carried over TCP/IP, packet loss and retransmission can occur; therefore maximal latency for any TCP/IP protocol will be more than three network transits (lost packet, next packet, negative ack, retransmit).</t>
             <t hangText="Client Buffering:">There is no requirement in existing HTTP specifications for a client library to make the data from a partial HTTP response available to the client application.  For example, if each response chunk contains a statement of JavaScript, there is no requirement in the browser to execute that JavaScript before the entire response is received.   However, in practice most browsers do execute JavaScript received in partial responses, although some require a buffer overflow to trigger execution; in most implementations, blocks of white space can be sent to achieve buffer overflow.</t>
             <t hangText="Framing Techniques:">Using HTTP streaming, several application messages can be sent within a single HTTP response.  The separation of the response stream into application messages needs to be perfomed at the application level and not at the HTTP level.  In particular it is not possible to use the HTTP chunks as application message delimiters, since intermediate proxies might "re-chunk" the message stream (for example by combining different chunks into a longer one).  This issue does not affect the HTTP long polling technique, which provides a canonical framing technique: each application message can be sent in a different HTTP response.</t>
           </list>
         </t>
       </section>
     </section>

    <section anchor="tech" title="Overview of Technologies">
      <t>This section provides an overview of existing technologies that implement HTTP-based server-push mechanisms to asynchronously deliver messages from the server to the client.</t>

      <section anchor="bayeux" title="Bayeux">
        <t>The Bayeux protocol <xref target="BAYEUX"/> was developed in 2006-2007 by the Dojo Foundation.  Bayeux can use both the HTTP long polling and HTTP streaming mechanisms.</t> 
        <t>In order to achieve bidirectional communications, a Bayeux client will use two HTTP connections to a Bayeux server so that both server-to-client and client-to-server messaging can occur asynchronously.</t>
        <t>The Bayeux specification requires that implementations control pipeling of HTTP requests, so that requests are not pipelined inappropriately (e.g., a client-to-server message pipelined behind a long poll request).</t>
        <t>In practice, for JavaScript clients, such control over pipelining is not possible in current browsers.  Therefore JavaScript implementations of Bayeux attempt to meet this requirement by limiting themselves to a maximum of two outstanding HTTP requests at any one time, so that browser connection limits will not be applied and the requests will not be queued or pipelined.  While broadly effective, this mechanism can be disrupted by non-Bayeux JavaScript simultaneously issuing requests to the same host.</t>
        <t>Bayeux connections are negotiated between client and server with handshake messages that allow the connection type, authentication method, and other parameters to be agreed upon between the client and the server.  Furthermore, during the handshake phase, the client and the server reveal to each other their acceptable bidirectional techniques and the client selects one from the intersection of those sets.</t>
        <t>For non-browser or same-domain Bayeux, clients use HTTP POST requests to the server for both the long poll request and the request to send messages to the server.  The Bayeux protocol packets are sent as the body of the HTTP messages using the "application/json" Internet media type <xref target="RFC4627"/>.</t>
        <t>For browsers that are operating in cross-domain mode, Bayeux attempts to use Cross-Origin Resource Sharing <xref target="CORS"/> checking if the browser and server support it, so that normal HTTP POST requests can be used.  If this mechanism fails, Bayeux clients use the "JSONP" mechanism as described in <xref target="JSONP"/>.  In this last case, client-to-server messages are sent as encoded JSON on the URL query parameters and server-to-client messages are sent as a JavaScript program that wraps the message JSON with a JavaScript function call to the already loaded Bayeux implementation.</t>
      </section>

      <section anchor="bosh" title="BOSH" toc="bosh">
         <t>BOSH, which stands for Bidirectional-streams Over Synchronous HTTP <xref target="BOSH"/>, was developed by the XMPP Standards Foundation in 2003-2004.  The purpose of BOSH is to emulate normal TCP connections over HTTP (TCP is the standard connection mechanism used in the Extensible Messaging and Presence Protocol as described in <xref target="XMPP"/>).  BOSH employs the HTTP long polling mechanism by allowing the server (called a "BOSH connection manager") to defer its response to a request until it actually has data to send to the client from the application server itself (typically an XMPP server).  As soon as the client receives a response from the connection manager, it sends another request to the connection manager, thereby ensuring that the connection manager is (almost) always holding a request that it can use to "push" data to the client.</t>
         <t>In some situations, the client needs to send data to the server while it is waiting for data to be pushed from the connection manager.  To prevent data from being pipelined behind the long poll request that is on hold, the client can send its outbound data in a second HTTP request over a second TCP connection.  BOSH forces the server to respond to the request it has been holding on the first connection as soon as it receives a new request from the client, even if it has no data to send to the client.  It does so to make sure that the client can send more data immediately if necessary even in the case where the client is not able to pipeline the requests, respecting at the same time the two-connection limit discussed under <xref target="connectionlimit"/>.</t>
         <t>The number of long polling request-response pairs is negotiated during the first request sent from the client to the connection manager.  Typically BOSH clients and connection managers will negotiate the use of two pairs, although it is possible to use only one pair or to use more than two pairs.</t>
         <t>The roles of the two request-response pairs typically switch whenever the client sends data to the connection manager.  This means that when the client issues a new request, the connection manager immediately answers the blocked request on the other TCP connection, thus freeing it; in this way, in a scenario where only the client sends data, all the even requests are sent over one connection and the odd ones are sent over the other connection.</t>
         <t>BOSH is able to work reliably both when network conditions force every HTTP request to be made over a different TCP connection and when it is possible to use HTTP/1.1 and then relay on two persistent TCP connections.</t>
         <t>If the connection manager has no data to send to the client for an agreed amount of time (also negotiated during the first request), then the connection manager will respond to the request it has been holding with no data, and that response immediately triggers a fresh client request.  The connection manager does so to ensure that if a network connection is broken then both parties will realise that fact within a reasonable amount of time.</t>
        <t>Moreover BOSH defines the negotiation of an "inactivity period" value that specifies the longest allowable inactivity period (in seconds).  This enables the client to ensure that the periods with no requests pending are never too long.</t>
        <t>BOSH allows data to be pushed immediately when HTTP Pipelining is available.  However if HTTP Pipelining is not available and one of the endpoints has just pushed some data, BOSH will usually need to wait for a network round trip time until the server is able to again push data to the client.</t>
        <t>BOSH uses standard HTTP POST request and response bodies to encode all information.</t>
        <t>BOSH normally uses HTTP Pipelining over a persistent HTTP/1.1 connection.  However, a client can deliver its POST requests in any way permitted by HTTP 1.0 or HTTP 1.1.  (Although the use of HTTP POST with pipelining is discouraged in RFC 2616, BOSH employs various methods (such as request identifiers) to ensure that this usage does not lead to indeterminate results if the transport connection is terminated prematurely.)</t>
        <t>BOSH clients and connection managers are not allowed to use Chunked Transfer Coding, since intermediaries might buffer each partial HTTP request or response and only forward the full request or response once it is available.</t>
        <t>BOSH allows the usage of the Accept-Encoding and Content-Encoding headers in the request and in the response respectively, and then compresses the response body accordingly.</t>
        <t>Each BOSH session can share the HTTP connection(s) it uses with other HTTP traffic, including other BOSH sessions and HTTP requests and responses completely unrelated to the BOSH protocol (e.g., web page downloads).</t>
      </section>

      <section anchor="server-sent-events" title="Server-Sent Events">
        <t>W3C Server-Sent Events specification <xref target="WD-eventsource"></xref> defines an API that enables servers to push data to Web pages over HTTP in the form of DOM events.</t> 
        <t>The data is encoded as text/event-stream content and pushed using an HTTP streaming mechanism, but the specification suggests to disable HTTP chunking for serving event streams unless the rate of messages is high enough to avoid the possible negative effects of this technique as described under <xref target="streaming-issues"/>.</t>
        <t>However it is not clear if there are significant benefits of using EOF rather than chunking with regards to intermediaries, unless they support only HTTP/1.0.</t>
      </section>

    </section>

    <section anchor="practices" title="HTTP Best Practices">
      <section anchor="connectionlimit" title="Limits to the Maximum Number of Connections">
        <t>HTTP <xref target="RFC2616"/> section 8.1.4 recommended that a single user client not maintain more than two connections to any server or proxy, in order to prevent the server from being overloaded and to avoid unexpected side effects in congested networks.  This limit was until recently implemented by most commonly deployed browsers, thus making connections a scarce resource that needed to be shared within the browser.  Note that the available JavaScript APIs in the browsers hide the connections and the security model inhibits the sharing of any resource between frames.  The new HTTP specification <xref target="HTTPBIS"/> removes the two connection limitation, only encouraging clients to be conservative when opening multiple connections.  In fact, recent browsers have increased this limit to 6 or 8 connections; however, it is still not possible to discover the local limit, and usage of multiple frames and tabs still places 8 connections within easy reach.</t> 
        <t>Web applications need to limit the number of long poll requests initiated, ideally to a single long poll that is shared between frames, tabs, or windows of the same browser.  However the security constraints of the browsers make such sharing difficult.</t>
        <t>A best practice for a server is to use cookies <xref target="COOKIE"/> to detect multiple long poll requests from the same browser and to avoid deferring both requests since this might cause connection starvation and/or pipeline issues.</t>
      </section>

      <section anchor="pipelining" title="Pipelined Connections">
        <t>HTTP <xref target="RFC2616"/> permits optional request pipelining over persistent connections.  Multiple requests can be enqueued before the responses arrive.</t>
        <t>In the case of HTTP long polling, the use of HTTP pipelining can reduce latency when multiple messages need to be sent by a server to a client in a short period of time.  With HTTP pipelining the server can receive and "enqueue" a set of HTTP requests.  Therefore the server does not need to to receive a new HTTP request from the client after it has sent a message to the client within an HTTP response.  In principle the HTTP pipelining can be applied to HTTP GET and HTTP POST requests, but using HTTP POST request is more critical.  In fact, the use of HTTP POST with pipelining is discouraged in RFC 2616 and needs to be handled with special care.</t>
        <t>There is an issue regarding the inability to control "pipelining".  Normal requests can be pipelined behind a long poll, and are thus delayed until the long poll completes.</t>
        <t>Mechanisms for bidirectional HTTP that want exploit HTTP pipelining need to verify that HTTP pipelining is available (e.g., supported by the client, the intermediaries, and the server); if not they need to fall back to solutions without HTTP pipelining.</t>
      </section>

      <section anchor="proxies" title="Proxies">
        <t>Most proxies work well with HTTP long polling, because a complete HTTP response will be sent either on an event or a timeout.  Proxies are advised to return that response immediately to the user-agent, which immediately acts on it.</t>
        <t>The HTTP streaming mechanism uses partial responses and sends some JavaScript in an HTTP/1.1 chunk as described under <xref target="streaming"/>.  This mechanism can face problems caused by two factors: (1) it relies on proxies to forward each chunk (even though there is no requirement for them to do so, and some caching proxies do not), and (2) it relies on user-agents to execute the chunk of JavaScript as it arrives (even though there is also no requirement for them to do so).</t>
        <t>A "reverse proxy" basically is a proxy that pretends to be the actual server (as far as any client or client proxy is concerned), but it passes on the request to the actual server that is usually sitting behind another layer of firewalls.  Any HTTP short polling or HTTP long polling solution will work fine with this, as will most HTTP streaming solutions.  The main downside is performance, since most proxies are not designed to hold many open connections.</t>
        <t>Reverse proxies can come to grief when they try to share connections to the servers between multiple clients.  As an example, Apache with mod_jk shares a small set of connections (often 8 or 16) between all clients.  If long polls are sent on those shared connections, then the proxy can be starved of connections, which means that other requests (either long poll or normal) can be held up.  Thus Comet mechanisms currently need to avoid any connection sharing -- either in the browser or in any intermediary -- because the HTTP assumption is that each request will complete as fast as possible.</t>
        <t>One of the main reasons why both HTTP long polling and HTTP streaming are perceived as having a negative impact on servers and proxies is that they use a synchronous programming model for handling requests, since the resources allocated to each request are held for the duration of the request.  Asynchronous proxies and servers can handle long polls with few resources above that of normal HTTP traffic.  Unfortunately some synchronous proxies do exist (e.g., Apache mod_jk) and many HTTP application servers also have a blocking model for their request handling (e.g., the Java servlet 2.5 specification).</t>
      </section>

      <section anchor="responses" title="HTTP Responses">
        <t>In accordance with <xref target='RFC2616'/>, the server responds to a request it has successfully received by sending a 200 OK answer, but only when a particular event, status, or timeout has occurred.  The 200 OK body section contains the actual event, status, or timeout that occurred.  This "best practice" is simply standard HTTP.</t>
      </section>

      <section anchor="timeouts" title="Timeouts">
        <t>The HTTP long polling mechanism allows the server to respond to a request only when a particular event, status, or timeout has occurred.  In order to minimize as much as possible both latency in server-client message delivery and the processing/network resources needed, the long polling request timeout ought to be set to a high value.</t>
        <t>However, the timeout value has to be chosen carefully; indeed, problems can occur if this value is set too high (e.g., the client might receive a 408 Request Timeout answer from the server or a 504 Gateway Timeout answer from a proxy).  The default timeout value in a browser is 300 seconds, but most network infrastructures include proxies and servers whose timeout is not that long.</t>
        <t>Several experiments have shown success with timeouts as high as 120 seconds, but generally 30 seconds is a safer value.  Therefore vendors of network equipment wishing to be compatible with the HTTP long polling mechanism are advised to implement a timeout substantially greater than 30 seconds (where "substantially" means several times more than the medium network transit time).</t>
      </section>
      <section anchor="network" title="Impact on Intermediary Entities">
        <t>There is no way for an end client or host to signal to HTTP intermediaries that long polling is in use; therefore long poll requests are completely transparent for intermediary entities and are handled as normal requests.  This can have an impact on intermediary entities that perform operations that are not useful in case of long-polling.  However any capabilities that might interfere with bidirectional flow (e.g., caching) can be controlled with standard headers or cookies.</t>
        <t>As a best practice, caching is always intentionally suppressed in a long poll request or response: i.e., the "Cache-Control" header is set to "no-cache".</t>
      </section>
    </section>

    <section title="Acknowledgments">
      <t>Thanks to Joe Hildebrand, Julien Laganier, Jack Moffitt, Subramanian Moonesamy, Mark Nottingham, Julian Reschke, Martin Thomson, and Martin Tyler for their feedback.</t>
    </section>

    <section title="IANA Considerations" anchor="iana">
      <t>This document does not require any actions by the IANA.</t>
    </section>

    <section title="Security Considerations" anchor="security">
      <t>This document is meant to describe current usage of HTTP to enable asynchronous or server-initiated communication.  It does not propose any change to the HTTP protocol or to the expected behavior of HTTP entities.  Therefore this document does not introduce new security concerns into existing HTTP infrastructure.  The considerations reported hereafter refer to the solutions that are already implemented and deployed.</t>
      <t>One security concern with cross-domain HTTP long polling is related to the fact that often the mechanism is implemented by executing the JavaScript returned from the long poll request.  If the server is prone to an injection attacks, then it could be far easier to trick a browser into executing the code <xref target="CORS"/>.</t>
      <t>Another security concern is that the number of open connections that needs to be maintained by a server in HTTP long polling and HTTP streaming could more easily lead to Denial of Service (DOS) attacks.<xref target="RFC4732"/>.</t>
    </section>

  </middle>

  <back>

    <references title="Normative References">

<reference anchor='RFC1945'>
<front>
<title abbrev='HTTP/1.0'>Hypertext Transfer Protocol -- HTTP/1.0</title>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization>MIT, Laboratory for Computer Science</organization>
<address>
<postal>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>US</country></postal>
<facsimile>+1 617 258 8682</facsimile>
<email>timbl@w3.org</email></address></author>
<author initials='R.T.' surname='Fielding' fullname='Roy T.  Fielding'>
<organization>University of California, Irvine, Department of Information and Computer Science</organization>
<address>
<postal>
<street />
<city>Irvine</city>
<region>CA</region>
<code>92717-3425</code>
<country>US</country></postal>
<facsimile>+1 714 824 4056</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials='H.F.' surname='Nielsen' fullname='Henrik Frystyk Nielsen'>
<organization>W3 Consortium, MIT Laboratory for Computer Science</organization>
<address>
<postal>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>US</country></postal>
<facsimile>+1 617 258 8682</facsimile>
<email>frystyk@w3.org</email></address></author>
<date year='1996' month='May' />
<abstract>
<t>The Hypertext Transfer Protocol (HTTP) is an application-level protocol with the lightness and speed necessary for distributed, collaborative, hypermedia information systems.  It is a generic, stateless, object-oriented protocol which can be used for many tasks, such as name servers and distributed object management systems, through extension of its request methods (commands).  A feature of HTTP is the typing of data representation, allowing systems to be built independently of the data being transferred.</t>
<t>HTTP has been in use by the World-Wide Web global information initiative since 1990.  This specification reflects common usage of the protocol referred to as "HTTP/1.0".</t></abstract></front>
<seriesInfo name='RFC' value='1945' />
<format type='TXT' octets='137582' target='http://www.rfc-editor.org/rfc/rfc1945.txt' />
</reference>

<reference anchor='RFC2616'>
<front>
<title abbrev='HTTP/1.1'>Hypertext Transfer Protocol -- HTTP/1.1</title>
<author initials='R.' surname='Fielding' fullname='Roy T.  Fielding'>
<organization abbrev='UC Irvine'>Department of Information and Computer Science</organization>
<address>
<postal>
<street>University of California, Irvine</street>
<city>Irvine</city>
<region>CA</region>
<code>92697-3425</code></postal>
<facsimile>+1(949)824-1715</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials='J.' surname='Gettys' fullname='James Gettys'>
<organization abbrev='Compaq/W3C'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>jg@w3.org</email></address></author>
<author initials='J.' surname='Mogul' fullname='Jeffrey C.  Mogul'>
<organization abbrev='Compaq'>Compaq Computer Corporation</organization>
<address>
<postal>
<street>Western Research Laboratory</street>
<street>250 University Avenue</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94305</code></postal>
<email>mogul@wrl.dec.com</email></address></author>
<author initials='H.' surname='Frystyk' fullname='Henrik Frystyk Nielsen'>
<organization abbrev='W3C/MIT'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>frystyk@w3.org</email></address></author>
<author initials='L.' surname='Masinter' fullname='Larry Masinter'>
<organization abbrev='Xerox'>Xerox Corporation</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94034</code></postal>
<email>masinter@parc.xerox.com</email></address></author>
<author initials='P.' surname='Leach' fullname='Paul J.  Leach'>
<organization abbrev='Microsoft'>Microsoft Corporation</organization>
<address>
<postal>
<street>1 Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code></postal>
<email>paulle@microsoft.com</email></address></author>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization abbrev='W3C/MIT'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>timbl@w3.org</email></address></author>
<date year='1999' month='June' />
<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems.  It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers .  A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.
</t>
<t>
   HTTP has been in use by the World-Wide Web global information
   initiative since 1990.  This specification defines the protocol
   referred to as "HTTP/1.1", and is an update to RFC 2068 .
</t></abstract></front>
<seriesInfo name='RFC' value='2616' />
<format type='TXT' octets='422317' target='http://www.rfc-editor.org/rfc/rfc2616.txt' />
<format type='PS' octets='5529857' target='http://www.rfc-editor.org/rfc/rfc2616.ps' />
<format type='PDF' octets='550558' target='http://www.rfc-editor.org/rfc/rfc2616.pdf' />
<format type='HTML' octets='636125' target='http://xml.resource.org/public/rfc/html/rfc2616.html' />
<format type='XML' octets='493420' target='http://xml.resource.org/public/rfc/xml/rfc2616.xml' />
</reference>

<reference anchor='RFC4732'>
<front>
<title>Internet Denial-of-Service Considerations</title>
<author initials='M.' surname='Handley' fullname='M.  Handley'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E.  Rescorla'>
<organization /></author>
<author>
<organization>IAB</organization></author>
<date year='2006' month='December' />
<abstract>
<t>This document provides an overview of possible avenues for denial-of-service (DoS) attack on Internet systems.  The aim is to encourage protocol designers and network engineers towards designs that are more robust.  We discuss partial solutions that reduce the effectiveness of attacks, and how some solutions might inadvertently open up alternative vulnerabilities.  This memo provides information for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='4732' />
<format type='TXT' octets='91844' target='http://www.rfc-editor.org/rfc/rfc4732.txt' />
</reference>

    </references>

    <references title="Informative References">

<reference anchor="BAYEUX"
            target="http://svn.cometd.com/trunk/bayeux/bayeux.html">
  <front>
    <title>Bayeux Protocol -- Bayeux 1.0.0</title>
    <author initials="A." surname="Russell" fullname="Alex Russel">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="G." surname="Wilkins" fullname="Greg Wilins">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="D." surname="Davis" fullname="David Davis">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
   <author initials="M." surname="Nesbitt" fullname="Mark Nesbitt">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="" month="" year="2007"/>
  </front>
  <format type="HTML" target="http://svn.cometd.com/trunk/bayeux/bayeux.html"/>
</reference>

<reference anchor="BOSH">
  <front>
    <title>Bidirectional-streams Over Synchronous HTTP (BOSH)</title>

    <author initials="I." surname="Paterson" fullname="Ian Paterson">
      <organization/>
      <address>
        <email>ian.paterson@clientside.co.uk</email>
      </address>
    </author>
    <author initials="D." surname="Smith" fullname="Dave Smith">
      <organization/>
      <address>
        <email>dizzyd@jabber.org</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="21" month="February" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0124"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0124.html"/>
</reference>

<reference anchor="COMET" target="http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/ ">
  <front>
    <title>Comet: Low Latency Data for the Browser</title>
    <author initials="A." surname="Russell" fullname="Alex Russell">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="3" month="March" year="2006"/>
  </front>
  <format type="HTML" target="http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/"/>
</reference>

<reference anchor='COOKIE'>
<front>
<title>HTTP State Management Mechanism</title>
<author initials='A' surname='Barth' fullname='Adam Barth'>
    <organization />
</author>
<date month='December' day='19' year='2010' />
<abstract><t>This document defines the HTTP Cookie and Set-Cookie header fields.  These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.
</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-httpstate-cookie-20' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpstate-cookie-20.txt' />
</reference>

<reference anchor='CORS' target='http://www.w3.org/TR/2010/WD-cors-20100727/'>
  <front>
    <title>Cross-Origin Resource Sharing</title>
    <author fullname='Anne van Kesteren' surname='van Kesteren' initials='A.'/>
    <date year='2010' month='July' day='27'/>
  </front>
  <seriesInfo name='W3C Working Draft' value='WD-cors-20100727'/>
  <annotation>
    Latest version available at
    <eref target='http://www.w3.org/TR/cors/'/>.
  </annotation>
</reference>

<reference anchor='HTTPBIS'>
<front>
<title>HTTP/1.1, part 1: URIs, Connections, and Message Parsing</title>
<author initials='R' surname='Fielding' fullname='Roy Fielding'>
    <organization />
</author>
<author initials='J' surname='Gettys' fullname='Jim Gettys'>
    <organization />
</author>
<author initials='J' surname='Mogul' fullname='Jeffrey Mogul'>
    <organization />
</author>
<author initials='H' surname='Nielsen' fullname='Henrik Nielsen'>
    <organization />
</author>
<author initials='L' surname='Masinter' fullname='Larry Masinter'>
    <organization />
</author>
<author initials='P' surname='Leach' fullname='Paul Leach'>
    <organization />
</author>
<author initials='T' surname='Berners-Lee' fullname='Tim Berners-Lee'>
    <organization />
</author>
<author initials='Y' surname='Lafon' fullname='Yves Lafon'>
    <organization />
</author>
<author initials='J' surname='Reschke' fullname='Julian Reschke'>
    <organization />
</author>
<date month='October' day='25' year='2010' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypertext information systems.  HTTP has been in use by the World Wide Web global information initiative since 1990.  This document is Part 1 of the seven-part specification that defines the protocol referred to as "HTTP/1.1" and, taken together, obsoletes RFC 2616.  Part 1 provides an overview of HTTP and its associated terminology, defines the "http" and "https" Uniform Resource Identifier (URI) schemes, defines the generic message syntax and parsing requirements for HTTP message frames, and describes general security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-p1-messaging-12' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-p1-messaging-12.txt' />
</reference>

<reference anchor='JSONP'
           target='http://en.wikipedia.org/wiki/JSONP#JSONP'>
  <front>
    <title>JSON with padding</title>
    <author>
    </author>
  </front>
  <format type='HTML' target='http://en.wikipedia.org/wiki/JSONP#JSONP'/>
</reference>

<reference anchor='RFC4627'>
<front>
<title>The application/json Media Type for JavaScript Object Notation (JSON)</title>
<author initials='D.' surname='Crockford' fullname='D.  Crockford'>
<organization /></author>
<date year='2006' month='July' />
<abstract>
<t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.  This memo provides information for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='4627' />
<format type='TXT' octets='16319' target='http://www.rfc-editor.org/rfc/rfc4627.txt' />
</reference>

<reference anchor='TCP'>
<front>
<title abbrev='Transmission Control Protocol'>Transmission Control Protocol</title>
<author initials='J.' surname='Postel' fullname='Jon Postel'>
<organization>University of Southern California (USC)/Information Sciences Institute</organization>
<address>
<postal>
<street>4676 Admiralty Way</street>
<city>Marina del Rey</city>
<region>CA</region>
<code>90291</code>
<country>US</country></postal></address></author>
<date year='1981' day='1' month='September' /></front>
<seriesInfo name='STD' value='7' />
<seriesInfo name='RFC' value='793' />
<format type='TXT' octets='172710' target='http://www.rfc-editor.org/rfc/rfc793.txt' />
</reference>

<reference anchor="XMPP">
<front>
<title>Extensible Messaging and Presence Protocol (XMPP): Core</title>
<author initials='P' surname='Saint-Andre' fullname='Peter Saint-Andre'>
    <organization />
</author>
<date month='December' day='20' year='2010' />
<abstract><t>This document defines the core features of the Extensible Messaging and Presence Protocol (XMPP), a technology for streaming Extensible Markup Language (XML) elements in order to exchange structured information in close to real time between any two or more network- aware entities. XMPP provides a generalized, extensible framework for incrementally exchanging XML data, upon which a variety of applications can be built. The framework includes methods for stream setup and teardown, channel encryption, authentication of a client to a server and of one server to another server, and primitives for push-style messages, publication of network availability information ("presence"), and request-response interactions between any two XMPP entities. This document obsoletes RFC 3920.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-xmpp-3920bis-22' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-xmpp-3920bis-22.txt' />
</reference>

<reference anchor='WD-eventsource'
           target='http://www.w3.org/TR/2009/WD-eventsource-20091222/'>
  <front>
    <title>Server-Sent Events</title>
    <author fullname='Ian Hickson' surname='Hickson' initials='I.'/>
    <date year='2009' month='December' day='22'/>
  </front>
  <seriesInfo name='W3C Working Draft' value='WD-eventsource-20091222'/>
  <annotation>
    Latest version available at
    <eref target='http://www.w3.org/TR/eventsource/'/>.
  </annotation>
</reference> 

    </references>
  </back>
</rfc>
