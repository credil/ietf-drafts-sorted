<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<!-- $Id: draft-hohendorf-secure-sctp-10.xml 2433 2010-12-02 21:18:39Z dreibh $ -->

<?rfc toc="yes"?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc strict="no" ?>
<?rfc symrefs="yes" ?>

<rfc category="exp" ipr="pre5378Trust200902" docName="draft-hohendorf-secure-sctp-14.txt">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<front>
<title abbrev="Secure SCTP">Secure SCTP</title>

<!--  ************** CARSTEN HOHENDORF *************** -->
<author initials="C." surname="Hohendorf" fullname="Carsten Hohendorf">
<organization abbrev="University of Duisburg-Essen">University of Duisburg-Essen, Institute for Experimental Mathematics</organization>
<address>
<postal>
<street>Ellernstraße 29</street>
<city>45326 Essen</city>
<region>Nordrhein-Westfalen</region>
<country>Germany</country>
</postal>
<email>hohend@iem.uni-due.de</email>
</address>
</author>

<!--  ************** Esbold Unurkhaan *************** -->
<author initials="E." surname="Unurkhaan" fullname="Esbold Unurkhaan">
<organization abbrev="Mongolian University">Mongolian University of Science and Technology</organization>
<address>
<postal>
<street>Bayanzurkh duureg, 2-nd khoroo</street>
<city>313/49 Ulaanbaatar</city>
<country>Mongolia</country>
</postal>
<email>esbold@csms.edu.mn</email>
</address>
</author>

<!-- ************** THOMAS DREIBHOLZ *************** -->
<author initials="T." surname="Dreibholz" fullname="Thomas Dreibholz">
<organization abbrev="Simula Research Laboratory">Simula Research Laboratory, Network Systems Group</organization>
<address>
<postal>
   <street>Martin Linges vei 17</street>
   <city>1364 Fornebu</city>
   <region>Østlandet</region>
   <country>Norway</country>
</postal>
<phone>+47-6782-8200</phone>
<facsimile>+47-6782-8201</facsimile>
<email>dreibh@simula.no</email>
<uri>http://www.iem.uni-due.de/~dreibh/</uri>
</address>
</author>

<date day="2" month="July" year="2012" />
<keyword>Internet-Draft</keyword>

<abstract>
<t>
This document explains the reason for the integration of security functionality into SCTP, and gives a short description of S-SCTP and its services. S-SCTP is fully compatible with SCTP defined in RFC4960, it is designed to integrate cryptographic functions into SCTP.
</t>
</abstract>
</front>


<middle>
<section title="Introduction" toc="default">
  <t>
  SCTP is a message oriented reliable transmission protocol which works on top of the IP-based network. It provides several advantages over other transmission protocols, such as TCP and UDP over IP. One of the advantages is multistreaming -- user data transported by individual streams. When multistreaming is used, network blocking can be avoided in certain cases (e.g. network loss). Also, SCTP supports multihoming -- the endpoints support multiple IP addresses. SCTP provides unordered delivery, so that a receiver immediately delivers user data to the upper layers upon receipt. For more details, see <xref target="RFC4960" pageno="false" format="default">RFC4960</xref>.
  </t>
</section>

<section title="Conventions">
 <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>
</section>

<section title="A brief description of S-SCTP" toc="default">
  <t>
  S-SCTP provides security functionalities in the transport layer without the need for any other security protocols (e.g. TLS or IP-sec). Normally, a data transport over SCTP can either be secured with TLS or can be protected by IPsec. As both TLS over SCTP and SCTP over IPsec have disadvantages in certain scenarios, it is preferable to integrate cryptographic functions into SCTP.
  </t>
  <t>
  The main issues for the security solutions TLS over SCTP <xref target="RFC3436" pageno="false" format="default">RFC3436</xref> and SCTP over IPSec <xref target="RFC3554" pageno="false" format="default">RFC3554</xref> is scalability with the number of streams. For N secure streams, N TLS connections have to be created, and N handshakes have to be performed. If N is small, this is not a big issue, but as N grows larger, it becomes a problem because a handshake is a slow and expensive process. So, when an application performs N handshakes, the load in terms of memory use, CPU use etc. increases linearly over time. This problem could be overcome by using IPsec. However, IPsec is not so flexible and on the other hand SCTP over IPsec has to establish new security associations (SA) for newly added IP addresses in dynamic address reconfiguration scenario. In this case, the application has to configure a new SA and to negotiate a new key exchange.
  </t>
</section>

<section title="Key terms" toc="default">
  <t>
  This part gives the definitions of the key terms, which are used in this draft:
  </t>
  <t>
  <list style="symbols">
    <t>Secure session: This is the session, which provides the security functionalities for an established SCTP association.</t>

    <t>Master secret key: S-SCTP uses two kinds of secret keys. One is the secret key for the S-SCTP packet authentication, and the other is the secret key for the data encryption and decryption.</t>

    <t>Cipher suite: This is the suite of cryptographic algorithms, which are used for key exchange, data encryption/decryption and the packet authentication.</t>

    <t>Pre-enc-data: This is the collection of the data chunks, which requires encryption. The data chunks are concatenated together and create pre-enc-data. Pre-enc-data may include the padding chunk.</t>

    <t>Cipher suite sequence: This is the bundle of cipher suites chosen by an endpoint from the supported cipher suites.</t>
  </list>
  </t>
</section>

<section title="Additional chunks and parameters" toc="default">
  <t>
  Several new chunks and parameters are defined in S-SCTP. This section explains those chunks and parameters. All new chunks can be bundled with other chunks. The new parameters follow the Type-Length-Value format as defined in section 3.2.1 of RFC4960.
  </t>

  <section title="New type chunks and definitions" toc="default">
    <t>
    The following table shows the new chunks. All new chunks, except for the Encrypted Data (EncData) chunk, Authentication (AUTH) chunk and Padding (PADDING) chunk, are used for building the secure session and to update the master secret key. The new chunks are to be interpreted as described in Section 3.2 of RFC 4960, by the receiver.</t>
    <figure><artwork>
 Chunktype     Chunk name
 ---------     ---------------------
   0xD0        Secure Session Open Request Chunk
   0xD1        Secure Session Certificate Chunk
   0xD2        Secure Session Acknowledge Chunk
   0xD3        Secure Session Server Key Chunk
   0xD4        Secure Session Client Key Chunk
   0xD5        Secure Session Open Complete Chunk
   0xD6        Secure Session Close Chunk
   0xD7        Secure Session Close Acknowledge Chunk
   0xD8        Security Level Change Chunk
   0xD9        Security Level Change Acknowledge Chunk
   0x10        Encrypted Data Chunk
   0x11        Authentication Chunk
   0x12        Padding Chunk
    </artwork></figure>
    <t>
    The new parameters are defined in this section.
    </t>

    <section title="Secure Session Open request chunk (SSOpReq)">
      <t>An endpoint creates the Secure Session Open Request chunk (see next table)when it wishes to establish a secure session. The chunk can be bundled with other chunks. The SSOpReq chunk can also be used to update the master secret key or cipher suite after a secure session establishment. During the association lifetime, both associated endpoints can request an update of the master secret key or cipher suite; in this case, the requesting endpoint sends the SSSOpReq chunk immediately to the other endpoint.</t>
      <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Type=0xD0   | Reserved=0  |CF|           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |            Version             |     Key material length       |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                                \
 /                     Optional parameters                        /
 \                                                                \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      </artwork></figure>
   <t>CF: Certificate flag: 1 bit</t>
   <t>
   This flag indicates whether or not the client will send a certificate. It is set to 1 when the client sends a certificate. If a receiver receives SSOpReq chunk with CF=1 and does not receive a certificate it raises an error and terminates the secure session initialisation.
   </t>
   <t>Length: 16 bits unsigned integer</t>
   <t>
   The length field contains the size of the chunk in bytes, including the chunk header, version, random number length and optional parameter(s).
   </t>
   <t>Version: 16 bits unsigned integer</t>
   <t>
   This field indicates the S-SCTP version 1.0. The high eight bits indicate the major version, the low eight bits indicate minor version.
   </t>
   <t>Key material length: 16 bits unsigned integer</t>
   <t>
   This number has two meanings:</t>
   <t><list style="symbols">
   <t> when the handshake is made using the RSA key exchange protocol, the key material length defines the random number length, which is generated by the server and client to calculate a master secret key (see RSA parameters of the SSSerKey and SSCliKey chunks)</t>
   <t> when the handshake is made using the DH key exchange protocol, the key material length defines the DH prime number length (see DH parameters of the SSSerKey and SSCliKey chunks).
   For security reasons, the key material length MUST be 512 bits (default) or longer when the key exchange mechanism uses RSA, and 1024 bits (default) or longer when the key exchange mechanism uses DH. The key material length is increased in steps of 64 bits. If a user defines the key material length to be shorter than the default value, S-SCTP automatically sets it to the default.</t>
   </list></t>

   <t>Parameter(S):</t>
   <t>SSOpReq chunk includes the cipher suite and compression method parameters, which are described below:</t>
   <t>Cipher suite parameter:</t>
   <t>This parameter contains the cipher suites, which are chosen from all supported cipher suites by the client. One of them is used for the secure session. The user can choose certain cipher suites from the cipher suites supported by the client.</t>
   <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |         Type=30               |           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |      Cipher suite 1           |      Cipher suite 2           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |      ..............           |      ..............           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |      Cipher suite N-1         |      Cipher suite N           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   </artwork></figure>
   <t>Cipher suite: 16 bits unsigned integer:</t>
   <t>This field indicates a cipher suite, which is supported by the client. The next table includes cipher suites supported in S-SCTP. Additional cipher suites can be specified.
   </t>
   <figure><artwork>
Value  Cipher suite               Key exchange  Encryption  Hash
-----  -------------------------  ------------  ----------  ---------
  1    RSA_with_DES_CBC_MD5       RSA           DES_CBC     MD5
  2    RSA_with_DES_CBC_SHA-1     RSA           DES_CBC     SHA-1
  3    RSA_with_3DES_CBC_MD5      RSA           3DES_CBC    MD5
  4    RSA_with_3DES_CBC_SHA-1    RSA           3DES_CBC    SHA-1
  5    RSA_with_AES-128_CBC_MD5   RSA           AES-128     MD5
  6    RSA_with_AES-128_CBC_SHA-1 RSA           AES-128     SHA-1
  7    DH_with_DES_CBC_MD5        DH            DES_CBC     MD5
  8    DH_with_DES_CBC_SHA-1      DH            DES_CBC     SHA-1
  9    DH_with_3DES_CBC_MD5       DH            3DES_CBC    MD5
 10    DH_with_3DES_CBC_SHA-1     DH            3DES_CBC    SHA-1
 11    DH_with_AES-128_CBC_MD5    DH            AES-128     MD5
 12    DH_with_AES-128_CBC_SHA-1  DH            AES-128     SHA-1
 13    RSA_with_NULL_MD5          RSA           NULL        MD5
 14    RSA_with_NULL_SHA-1        RSA           NULL        SHA-1
 15    DH_with_NULL_MD5           DH            NULL        MD5
 16    DH_with_NULL_SHA-1         DH            NULL        SHA-1
 17    RSA_with_AES-192_CBC_MD5   RSA           AES-192     MD5
 18    RSA_with_AES-192_CBC_SHA-1 RSA           AES-192     SHA-1
 19    RSA_with_AES-256_CBC_MD5   RSA           AES-256     MD5
 20    RSA_with_AES-256_CBC_SHA-1 RSA           AES-256     SHA-1
 21    DH_with_AES-192_CBC_MD5    DH            AES-192     MD5
 22    DH_with_AES-192_CBC_SHA-1  DH            AES-192     SHA-1
 23    DH_with_AES-256_CBC_MD5    DH            AES-256     MD5
 24    DH_with_AES-256_CBC_SHA-1  DH            AES-256     SHA-1
      </artwork></figure>
      <t>
      The hash algorithms, defined in cipher suites, are used only for the S-SCTP packet authentication, and not for the signature of the handshake messages. An S-SCTP implementation MUST at least support the default cipher suite, DH_with_3DES_CBC_SHA-1 (value=0). If the SSOpReq chunk does not contain a cipher suite parameter, then:
      </t>
      <t>
      a.) S-SCTP will use the default, or:
      </t>
      <t>
      b.) S-SCTP will use the old cipher suite.
      </t>
      <t>
      The case "a" will be used at the beginning of the secure session. The case "b" will be used when the SSOpReq chunk is created after a secure session establishment. The signature schemes are derived from both the client and server certificates, and may be different.
      </t>

      <t>
      Compression method parameter
      </t>
      <t>
      This parameter contains compression methods, which are used for data compression. The data compression uses lossless compression methods. The user chooses several compression methods and sends it to the receiver. The receiver chooses one compression method.
      </t>
      <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | Compression   | Compression   | Compression   | Compression   |
 |  method 1     |  method 2     |  method 3     |  method 4     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |    ....       |    ....       | Compression   | Compression   |
 |               |               | method N-1    |  method N     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      </artwork></figure>
      <t>
      Compression method: 8 bits unsigned char</t>
      <t>
      This field indicates a compression method, which is supported by the client. The next table includes compression methods supported in S-SCTP. Additional compression methods can be specified.
      </t>
      <figure><artwork>
 Value  Compression method
 -----  ---------------------
    1   Huffman Code
    2   Lempel-Ziv Code
      </artwork></figure>
      <t>
      The secure session uses null compression when the SSOpReq chunk contains no compression parameters.
      </t>
    </section>

    <section title="Secure Session Certificate chunk: (SSCert)">
    <t>
    This chunk can be sent by both endpoints. The certificate helps to authenticate the endpoint, that establishes a S-SCTP session. This chunk contains only one parameter, the certificate parameter. The SSCert chunk is optional. For security reasons, both endpoints SHOULD use a certificate to authenticate each other.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Type=0xD1   | Reserved=0    |           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                           Certificate                         /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                        Optional parameter                     /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>
      <t>Length: 16 bits unsigned integer</t>
      <t>
      The length field contains the size of the chunk in bytes, including the chunk header and parameter.
      </t>
      <t>Certificate: Variable length</t>
      <t>
      The certificate field contains the certificate of the endpoint. S-SCTP uses the X.509v3 certificate which is defined in <xref target="RFC5280" pageno="false" format="default">RFC5280</xref>.
      </t>
      <t>Optional parameter</t>
      <t>
      SSCert chunk has only one optional parameter.
      </t>

    <t> Certificate parameter
    </t>
    <t>
    The SSCert chunk uses the certificate parameter for additional certificates, when the endpoint has two or more certificates.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |         Type=33               |           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                          Certificate                          /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>
      <t> Certificate: Variable length</t>
      <t>
      The endpoint can send two or more certificates. In this case the certificate field contains the endpoint's additional certificate. S-SCTP uses the X.509v3 certificate, which is defined in <xref target="RFC5280" pageno="false" format="default">RFC5280</xref>.
      </t>
    </section>

    <section title="Secure Session Open Acknowledge chunk (SSOpReq_Ack)">
    <t>
    The Secure Session Open Acknowledge chunk is sent by the server to tell the client that the secure session open request is accepted.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Type=0xD2   | Reserved=0  |CF|           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |             Version            |        Cipher suite           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |    Compression method          |        Reserved = 0           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>
    <t>CF: Certificate flag: 1 bit</t>
    <t>
    This flag indicates whether or not the server has a certificate. This flag is set to 1 when the server has a certificate, else it is zero.
    </t>
    <t>Length: 16 bits unsigned integer</t>
    <t>
    The chunk length is 8 bytes, including the chunk header, version and cipher suite field.
    </t>
    <t>Version: 16 bits unsigned integer</t>
    <t>
    This field indicates the S-SCTP version 1.0. The high eight bits indicate the major version, the low eight bits indicate the minor version.
    </t>
    <t>Cipher suite: 16 bits unsigned integer</t>
    <t>
    This field indicates the cipher suite, which is used for a secure session. The cipher suite includes necessary information for the key derivation, message encoding and MAC computation. The server uses the following rules to choose the cipher suite:
    </t>
    <t><list style="symbols">
      <t>Client and Server do not have a certificate:  Use DH key exchange.
      </t>
      <t>Client or Server has a certificate:  Use DH key exchange.
      </t>
      <t>Client and Server have a RSA certificate:  Use RSA key exchange.
      </t>
      <t>Client and Server have a DSS certificate:  Use DH key exchange.
      </t>
     </list></t>
    <t>Compression method: 16 bits unsigned char</t>
    <t>
    This field indicates the compression method, which is used for data compression in the secure session.
    </t>
    </section>
    <section title="Secure Session Server Key chunk (SSSerKey)">
    <t>
    This chunk includes the parameter which is used for the key exchange algorithm. The Server Key Exchange chunk consists of the chunk header and one parameter. The parameter type depends on the key exchange algorithm.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Type=0xD3   | Reserved=0  |SL|           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                                \
 /                           Parameter                            /
 \                                                                \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>
      <t>Security level (SL): 2 bits</t>
      <t>
      This 2-bit value indicates a server's security level of the reserved flags.
      </t>
      <t>Length: 16 bit unsigned integer</t>
      <t>
      The length field contains the size of the chunk in bytes, including the chunk header and parameter.
      </t>
      <t>Parameters:</t>
      <t>
      The following two parameters define the key exchange protocols. Their parameter formats are shown in the next two tables. When a user specifies a new cipher suite with a new key exchange algorithm, then they must define a new parameter.
      </t>
    <t>Diffie-Hellman parameter
    </t>
    <t>
    The SSSerKey chunk uses this parameter when the handshake is done via the DH key exchange algorithm.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |       Type=0xD001             |           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |  Length of DH prime number, P | Length of DH prmitive root, R |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Length of DH public key, Y  |         Reserved=0            |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                      DH prime number, P                       /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                     DH primitive root, R                      /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                         DH value, Y                           /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                          Signature                            /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>
    <t>Length: 16 bit unsigned integer</t>
    <t>
    The length field contains the size of the parameter in bytes, including the parameter header, length of DH prime number, length of DH primitive root, length of DH public key, reserved, DH prime number, DH primitive root, DH public key and signature.
    </t>
    <t>Length of DH prime number, P: 16 bits unsigned integer</t>
    <t>
    This field contains the size of the DH prime number.
    </t>
    <t>Length of DH primitive root, Q: 16 bits unsigned integer</t>
    <t>
    This field contains the size of the DH primitive root. The size of the prime number is equal R, where R is a random number defined in the SSOpReq chunk.
    </t>
    <t>Length of DH value, Y: 16 bits unsigned integer</t>
    <t>
    This field contains the size of the DH public key.
    </t>
    <t>DH value, P: Variable length</t>
    <t>
    This is the prime number of the DH key exchange protocol.
    </t>
    <t>DH value, Q: Variable length</t>
    <t>
    This is the primitive root of the prime number P.
    </t>
    <t>DH value, Y: Variable length</t>
    <t>
    This is the public key of the DH key exchange protocol.
    </t>
    <t>Signature: Variable length</t>
    <t>
    The field contains the signature which is derived from the chunk header and the whole parameter except the signature field. The signature computation uses the signature algorithm which is defined in the server certificate. If the server does not have a certificate, this field does not exist in the parameter.
    </t>
    <t>RSA parameter
    </t>
    <t>
    The SSSerKey chunk uses this parameter when the handshake uses the RSA key exchange algorithm.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |       Type=0xD002             |           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                 Encrypted (random number, R)                  /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                          Signature                            /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>
    <t>Length: 16 bits unsigned integer</t>
    <t>
    The length field contains the size of the parameter in bytes, including the parameter header, the encrypted random number and the signature.
    </t>
    <t>Encrypted (Random number, R): Variable length</t>
    <t>
    The random number is used to generate the secret keys for user data encryption and authentication. The random number encryption uses the client public key.
    </t>
    <t>Signature: Variable length</t>
    <t>
    The field contains the signature, which is derived from the chunk header and the whole parameter except the signature field. The signature computation uses the signature algorithm which is defined in the server certificate.
    </t>
    </section>
    <section title="Secure Session Client Key chunk (SSCliKey)">
    <t>
    This chunk includes the parameters which are used for the key exchange algorithm. The Secure Session Client Key Exchange chunk consists of the chunk header and one parameter. The parameter format depends on the key exchange algorithm.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Type=0xD4   | Reserved=0  |SL|           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                                \
 /                           Parameter                            /
 \                                                                \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>

      <t>Security level (SL): 2 bits</t>
      <t>
      This 2-bit value indicates a client's security level.
      </t>
      <t>Length: 16 bit unsigned integer</t>
      <t>
      The length field contains the size of the chunk in bytes, including the chunk header and parameter.
      </t>
      <t>Parameters:</t>
      <t>
      Two new parameters are defined here that can appear in the SSCliKey chunk. Their parameter formats are shown in the next two tables.
      </t>
    <t>Diffie-Hellman parameter
    </t>
    <t>
    The SSCliKey chunk uses this parameter when the handshake uses the DH key exchange algorithm.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |       Type=0xD003             |           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                         DH value, Y                           /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                          Signature                            /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>
    <t>Length: 16 bit unsigned integer</t>
    <t>
    The length field contains the size of the parameter in bytes, including the parameter header, the DH public key and the signature.
    </t>
    <t>DH value, Y: Variable length</t>
    <t>
    This field contains the public key of the DH key exchange protocol.
    </t>
    <t>Signature: Variable length</t>
    <t>
    The field contains a signature which is derived from the chunk header and the whole parameter except the signature field. The signature computation uses the signature algorithm defined in the client certificate. If the client does not have a certificate, then this field does not exist in the parameter.
    </t>
    <t> RSA parameter
    </t>
    <t>
    The SSCliKey chunk uses this parameter when the handshake uses RSA key exchange algorithm.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |       Type=0xD003             |           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                 Encrypted (random number, R)                  /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                          Signature                            /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>
    <t>Length: 16 bits unsigned integer</t>
    <t>
    The length field contains the size of the parameter in bytes, including the parameter header, the encrypted random number and a signature.
    </t>
    <t>Encrypted (Random number): Variable length</t>
    <t>
    This field contains the random number, encrypted by the server's public key, which is used to generate the master secret key for encryption and authentication.
    </t>
    <t>Signature: Variable length</t>
    <t>
    The field contains the signature which is derived from the chunk header and the whole parameter except the signature field. The signature computation uses the signature algorithm defined in the server certificate.
    </t>
    </section>
    <section title="Secure Session Open Complete chunk (SSOpCom)">
    <t>
    This chunk is the last chunk of the handshake and it indicates the completion of the secure session establishment. After receiving this chunk the endpoint verifies the verification data which is contained in the chunk. The secure session procedure is complete when the verification is successful. Otherwise the secure session will be closed.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Type=0xD5   | Reserved=0    |           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                       Verification data                       /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>
    <t>Length: 16 bits unsigned integer</t>
    <t>
    The length field contains the size of the chunk in bytes, including the chunk header and verification data.
    </t>
    <t>Verification data: Variable length</t>
    <t>
    The verification data contains a hashed value which is an output of the HMAC function. The HMAC uses the authentication secret key, which is individually generated by the endpoints. The HMAC input contains  all received secure session handshake chunks of the current endpoint. Both endpoints compute the hash value individually and exchange it using the SSOpCom chunk. The receiver computes the hash value using the same algorithm as the sender, and compares it with the verification data. If the receiver's computed value is the same as the sender's verification data, then the receiver assures that the secure session open is successfully completed. If it is not the same, then the receiver sends an ERROR message to the sender, and immediately closes the secure session.
    </t>
    </section>

    <section title="Secure Session Close chunk (SSClose)">
    <t>
    This chunk indicates a request to close the current secure session. The sender MUST NOT send any encrypted or authenticated chunks after it has sent this chunk.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Type=0xD6   | Reserved=0  |OF|           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                               TSN                              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>
    <t>Outstanding flag (OF): 1 bit</t>
    <t>
    This flag indicates that the endpoint has sent the SSClose chunk and has no outstanding secured data.
    </t>
    <t>Length: 16 bits unsigned integer</t>
    <t>
    The length field contains the size of the chunk in bytes, including the chunk header and TSN.
    </t>
    <t>Transmission sequence number (TSN): 16 bits unsigned integer</t>
    <t>
    This is the transmission sequence number of the data chunk that was last encrypted and sent. The TSN helps the server to detect outstanding EncData chunks.
    </t>
    </section>

    <section title="Secure Session Close Acknowledge chunk (SSClose_Ack)">
    <t>
    This chunk is used to acknowledge the receipt of the secure session close chunk. When the endpoint receives the secure session close chunk, it immediately stops sending encrypted or authenticated chunks. The Secure Session Close Acknowledge chunk only consists of the chunk header.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Type=0xD7   |   Reserved=0  |          Length=4             |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>
    </section>

    <section title="Security Level Changed chunk (SecLevCHD)">
    <t>
    This chunk is used to convey the other associated endpoint of the endpoint's new security level. The endpoint sends SecLevCHD chunk every time it selects a new security level. The endpoint uses the new selected security level when it receives the Security Level Changed Acknowledged chunk. The sender MUST NOT send a new SecLevCHD chunk when an unacknowledged SecLevCHD chunk exists.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Type=0xD8   | Reserved=0  |SL|          Length=4             |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>
    <t>Security level (SL): 2 bits</t>
    <t>
    This 2-bit value indicates the sender's new security level.
    </t>
    </section>
    <section title="Security Level Changed Acknowledged chunk (SecLevCHD_Ack)">
    <t>
    This chunk is used to acknowledge the receipt of the SecLevCHD chunk. When the endpoint receives the SecLevCHD chunk, it immediately sends the SecLevCHD_Ack chunk.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Type=0xD9   |   Reserved=0  |          Length=4             |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>

    </section>
    <section title="Encrypted Data Chunk (EncData)">
    <t>
    Each S-SCTP packet includes at most one encrypted data chunk, and the packet could also include several (normal, unencrypted) data chunks. The encrypted data chunk may contain one or several data chunks. The EncData chunk includes a padding chunk when it is needed.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Type=0x10   | Reserved=0    |           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | Master secret key reference # |     Random number length      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                         Random number                         /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                         Encrypted data                        /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>
    <t>Length: 16 bits unsigned integer</t>
    <t>
    The length field contains the size of the chunk in bytes,including the chunk header and encrypted data.
    </t>
    <t>Master secret key reference number: 16 bits unsigned integer</t>
    <t>
    The association can be updated by changing the master secret key several times during the association lifetime. The association keeps old secret keys. The number of the kept old secret keys depends on the implementation. This field helps to identify  which key (old or new) has been used for encryption. That means the endpoint is able to receive messages, which were encrypted with an old key, after the update of a master secret key.
    </t>
    <t>Random number length: 16 bits unsigned integer</t>
    <t>
    This field contains the size of the random number which is defined below.
    </t>
    <t>Random number: Variable length</t>
    <t>
    This field indicates the random number which is used as initialisation vector of the cipher block chaining (CBC) mode for encryption.
    </t>
    <t>Encrypted data: Variable length</t>
    <t>
    Contains a byte vector that consists of the encrypted data chunks. Before encryption, the chunk(s) MUST fulfil the following conditions. If encryption is performed using the DES or 3DES algorithm, the total size of the chunk(s) MUST be a multiple of 8 bytes. If encryption is performed using the AES algorithm, the total size of the chunk(s) MUST be a multiple of 16 bytes. If the total size of the chunk(s) is not a multiple of 8 bytes or 16 bytes, the sender MUST add appropriate padding at the chunk's end.
    </t>
    </section>

    <section title="Padding chunk (PADDING)">
    <t>
    This padding chunk is used with an EncData chunk. The symmetric encryption algorithms use a block oriented encryption of the user data. For example DES uses 64 bit blocks, and AES uses 128 bit blocks. Before encryption, the user data which has to be encrypted has to be formatted according to the required block size. If the last block is not completely full, padding has to be added. If less than 4 bytes padding are required, the block is filled up will all zeros. The receiver can calculate the number of padding bytes based on the length field of the original data chunks. If 4 bytes or more are required, a padding chunk of appropriate length is added.
    </t>
    <t>
    The algorithms split user data into blocks when the data length is greater  than the block size. The blocks MUST be full. If 104 bits are to be encrypted using DES algorithm with 64 bit block size, user data is split into two blocks of 64 and 40 bits. The second block must be padded with 24 bits up to the full block size of 64 bits.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Type=0x12   | Reserved=0    |           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                            Padding                            |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>
    <t>Length: Variable length</t>
    <t>
    This field indicates the padding size. The padding follows the padding chunk. The length includes the padding chunk and padding.
    </t>
    <t>Padding: Variable length</t>
    <t>
    The padding is a random number. The random number generation is implementation specific.
    </t>
    </section>

    <section title="Authentication chunk (AUTH)">
    <t>
    This chunk is dedicated to the authentication of an S-SCTP packet. S-SCTP inserts this chunk into the packet when the security level requires authentication.
    </t>
    <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Type=0x11   | Reserved=0    |           Length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | Master secret key reference # |          Reserved=0           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 \                                                               \
 /                              HMAC                             /
 \                                                               \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork></figure>
    <t>Length: 16 bits unsigned integer</t>
    <t>
    The length field contains the size of the chunk in bytes, including the chunk header, master secret key reference, reserved field and MAC.
    </t>
    <t>Master secret key reference number: 16 bits unsigned integer</t>
    <t>
    The association can update the secret keys several times during the association lifetime. The association keeps old secret keys. The number of the kept old secret keys depends on the implementation. This field identifies the key which is used for authentication. If the endpoint receives a message which was authenticated by an old key, this message can still be authenticated after an update of the master secret key.
    </t>
    <t>HMAC: Variable length</t>
    <t>
    This field contains the authentication code for the SCTP packet. The message authentication uses the HMAC algorithm defined in RFC 2104. The hash function used in the HMAC algorithm is derived from the negotiated cipher suite, which was chosen by the server.
    </t>
    </section>
  </section>
</section>

<section title="New Error Cause">
  <t>
  This part explains the new error causes defined for S-SCTP. When a secure session or certificate failure is detected in the secure session open process, the S-SCTP association immediately stops the process. However, the association continues (without any security functionality). When the secure session failure happens during an update of the master secret key the association stops the update operation and closes the secure session. The following table shows four general failure groups.
  </t>
  <figure><artwork>
 Cause Code Value  Cause Code
 ----------------  ---------------------------------------
       0x20        Secure Session failure
       0x21        Secure Session Certificate failure
       0x22        Secure Session Decryption failure
       0x23        Secure Session Authentication failure
       0x24        Secure Session Decompression failure
  </artwork></figure>

  <section title="Secure Session failure">
  <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |       Cause Code=0x20         |     Cause length = 8          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |          Error Code           |          Reserved=0           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork></figure>
  <t>
  If any error happens in the secure session open and update process, endpoints alert their peers with these error codes. The next table shows error codes for what can happen.
  </t>
  <figure><artwork>
 Error Code Value  Error Code
 ----------------  -------------------------------------
      0            Timer expired
      1            Signature failure
      2            Secure Session Open Complete failure
  </artwork></figure>
  <t><list style="symbols">
  <t>Timer expired:

  The sender starts a timer when it sends the secure session message. When the sender receives no response from the receiver before the timer expires, it sends this error code.
  </t>
  <t>Signature failure:

  Some secure session chunks include a signature, which identifies and protects the secure session message. If the receiver checks the signature and cannot identify the chunk, this error code is used in the error chunk.
  </t>
  <t>Secure Session Open Complete failure:

  This chunk is a very important part of the secure session. Both server and client individually compute the master secret and HMAC secret keys. Both sides check these secret keys and parameters (i.e. secure session chunks exchanged before, source and destination ports). If these keys are not identical,  an error chunk is sent containing this error code.
  </t>
 </list></t>
  </section>

  <section title="Secure Session Certificate failure">
  <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |       Cause Code=0x21         |     Cause length = 8          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |          Error Code           |          Reserved=0           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork></figure>
  <t>
  The certificate failure signals that an error has occurred in processing the certificates. The next table shows error codes for what can happen.
  </t>
  <figure><artwork>
 Error Code Value  Error Code
 ----------------  -------------------------------------
        0          No certificate
        1          Bad certificate
        2          Certificate expired
        3          Unknown certificate
  </artwork></figure>
  <t><list style="symbols">
  <t>No certificate:

  This error happens when the sender sets the CF flag and the receiver does not receive the certificate.
  </t>
  <t>Bad certificate:

  The signature of the certificate is bad and the certificate could not be verified.
  </t>
  <t>Certificate expired:

  The certificate is no longer valid.
  </t>
  <t>Unknown certificate:

  The received certificate a X.509v3 certificate.
  </t>
 </list></t>
  </section>

  <section title="Decryption failure">
  <t>
  This error happens when the EncData chunk cannot be decrypted or the data chunk(s) cannot be identified after decryption. The receiver discards the EncData and increases a counter by 1. This counter counts errors. If the number of errors reaches a limit, the secure session is terminated. The limit of the errors depends on the implementation.
  </t>
  <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |       Cause Code=0x22         |     Cause length = 4          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork></figure>
  </section>

  <section title="Authentication failure">
  <t>
  In the event of a HMAC error, the packet is discarded by the receiver.  To check for an error, the receiver computes the HMAC and compares it to the HMAC field of the packet. If they do not match, an error is reported back.
  </t>
  <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |       Cause Code=0x23         |     Cause length = 4          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork></figure>
  </section>

  <section title="Decompression failure">
  <t>
  This error happens when the compressed chunk(s) cannot be decompressed or the data chunk(s) cannot be identified after decompression. The receiver discards the decompressed chunk(s).
  </t>
  <figure><artwork>
 0                   1                    2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |       Cause Code=0x24         |     Cause length = 4          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork></figure>
  </section>
</section>

<section title="S-SCTP packet format and security levels">
  <t>
  S-SCTP has four different security levels, which cover privacy settings of an S-SCTP association. The S-SCTP application can change the security levels at any time during the security session lifetime.
  </t>
  <t><list style="symbols">
  <t>Security level 0:

  This is the null security level. S-SCTP  does use neither data chunk encryption  nor authentication. The S-SCTP packet is the same as the SCTP packet (this level is fully  compatible to SCTP).
  </t>
  <t>Security level 1:

  This security level requires packet authentication but does not use encryption. Every outgoing packet (including the SCTP common header) is authenticated.
  </t>
  <t>Security level 2:

  In this security level, data chunks may be encrypted. When an S-SCTP packet contains an encrypted data chunk, it MUST include an AUTH chunk as well. That means every chunk and the packet header are authenticated. When a packet includes only unencrypted data chunks or control chunks or both unencrypted data chunks and control chunks, the packet will not be authenticated.
  </t>
  <t>Security level 3:

  This is the highest security level.  S-SCTP requires both encryption and authentication. Every outgoing chunk is encrypted and the packet is authenticated.
  </t>
 </list></t>
  <t>
  Both  endpoints  can use different security levels, e.g. the association can use security functions only for one direction, e.g. from server to client. In this case the server uses security level 3 and the client uses security level 0. The transmission control block (TCB) of the association includes the security level as a new parameter.
  </t>
</section>

<section title="S-SCTP data format">
  <t>
  S-SCTP sorts data chunks before bundling them into the outgoing SCTP packet. The data chunks are sorted according to whether they have to be encrypted or not. The chunks belonging to the encryption group are concatenated and encrypted into an EncData chunk. May be a PADDING chunk is inserted into the encryption group. Insertion of a PADDING chunk is done depending on data length and encryption block size.
  </t>
  <t>
  An assortment of encrypted and non-encrypted chunks are bundled in the packet. The control chunk(s) are placed first in the packet when bundled with other chunks.  Finally, an AUTH chunk may be added to the packet.
  </t>
  <t>
  HMAC computation is performed over all chunks and the SCTP common header with a 0 checksum. The checksum is then computed over the complete packet (including AUTH chunk). The HMAC length depends on the hash function in the cipher suite. In every security level, the SCTP packet construction is slightly different. In security level 0 the packet format is same as the SCTP packet format.
  </t>
</section>

<section title="Procedures">
  <t>
  In this section an explanation of the procedures of secure session: initialisation, termination, update and etc., is given.
  </t>
  <section title="Establishment of a secure session">
  <t>
  The following process is used to establish the S-SCTP secure session. The handshake process runs in parallel with the data transmission. The secure session start and close is controlled by the user. The user can establish and close a secure session at any time during the association lifetime. Each time a secure session is established, a new set of keys is generated. It is not possible to create a new secure session when a secure session already exists. The following describes secure session establishment, which makes use of a handshake timer and retransmissions in case packets are lost during transmission. S-SCTP uses a four-way handshake. After all messages of one of the connection "legs" have been sent, client or server starts a RTO.hand (handshake retransmission time out) timer. For example, the secure session certificate is the last handshake message of the first leg. The sender waits for a response from the receiver until the RTO.hand timer expires. The sender stops the RTO.hand timer when it receives the expected message(s). If the RTO.hand timer expires before all expected messages have been received, the sender retransmits the handshake message(s).
  </t>
  <t>
  The retransmission uses the following algorithm. The RTO.hand timer gets a value from RTO of the path where the message is sent to, which is defined in RFC4960. Before a retransmission, the sender checks RTN.hand.max (handshake maximum retransmission number). This initial value is dependent upon specific implementations. The suggested value for RTN.hand.max is Path.Max.Retrans (see RFC 4960).
  </t>
  <t>
  RTN.hand.max should be a constant parameter. We introduce a counter for the number of retransmissions, and if that counter exceeds the parameter RTN.hand.max, the timer expired error message is sent to the peer. If a retransmission is required then S-SCTP uses the same retransmission rules as defined in RFC4960. If the receiver receives a retransmission of a handshake message that was already received, the message last received MUST be dropped. The endpoint discards the message(s) when they are unexpected. A secure session initialisation begins when one of the associated endpoints sets the security level to a value higher than 0. The endpoint starting a secure session initialisation is called client and the other associated endpoint is called server.
  </t>
  <t><list style="symbols">
  <t>
  The client sends the SSOpReq chunk to the server. If the client has a certificate, it  sets the CF flag of the SSOPReq chunk to 1. The client sends the SSCert chunk immediately after the SSOpReq chunk. The SSCert chunk can be bundled with the SSOpReq chunk or with other chunk(s). When the CF flag is set to 0, the client sends only the SSOpReq chunk.
  </t>
  <t>
  The server receives a SSOpReq chunk and checks the CF flag. If the CF flag is set to 1, the server waits for the SSCert chunk. Upon receipt, the server checks the certificate and if there is a problem with it, the server stops the handshake and goes to an error state, aborts secure session setup and reports the cause to its peer. It there is no error, the server chooses the cipher suite and sends the SSOpReq_Ack chunk with CF=1 flag to the client when the server has a certificate. The server immediately sends the certificate and the SSSerKey chunks after the SSOpReq_Ack chunk. All three chunks may be bundled together or with other chunks. The server sends only the SSOpReq_Ack chunk with the SSSerKey chunk if CF=0. Before sending the server key exchange chunk, the server generates key material. The server starts the update master secret key operation when it receives the SSOpReq chunk after secure session establishment. If the server receives the SSCert chunk before the SSOpReq chunk, it stores the SSCert chunk and waits until it receives the SSOpReq chunk. But the server drops a second SSCert chunk.
  </t>
  <t>
  The client receives the handshake messages and checks the certificate in the SSSerKey chunk. If the client detects any errors, it stops the handshake and goes to an error state, aborts secure session setup and reports the cause to its peer. The client generates key material and sends the SSCliKey chunk to the server. The client sends the SSOpCom chunk immediately after the client key exchange chunk.  Before sending the handshake-finished chunk, the client computes the encryption secret and MAC secret keys.
  </t>
  <t>
  The server receives the SSCliKey chunk and computes the master secret and the MAC secret keys. It then computes the SSOpCom chunk and sends it to the client. Finally, the server checks the  SSOpCom chunk of the client. If the server detects any error, it reports a secure session open complete error and closes the handshake. The secure session is established only when both sides detect no errors. The server is ready for secure transmission when it detects no errors, but the client must wait for the  SSOpCom chunk of the server. When this is received, the client checks it and reports to the peer a secure session open complete error if any error is detected before aborting secure session setup. The handshake may run simultaneously with normal SCTP data transmission. If the client receives  encrypted or authenticated data chunks before it receives the server's SSOpCom chunk, then those chunks MUST be discarded.
  </t>
 </list></t>
  <t>
  When both associated endpoints request the initialisation of a secure session  simultaneously (both endpoints send an SSOpReq message), both ignore the received SSOpReq message and wait a random time before resending the SSOpReq message. Each endpoint generates the random time independently. The random number must be small, e.g. 120 seconds maximum.
  </t>
  </section>

  <section title="Choice of cipher suite and compression method">
  <t>
  This section explains how to choose the cipher suite and compression method which are used for the secure session. Each endpoint maintains an ordered list of supported cipher suites (cipher suite list). The ordering in the list indicates the preference with which a cipher suite should be used (first in the list have higher preference). The order in the list is defined by the retrospective S-SCTP user.
  </t>
  <t>
  S-SCTP users on both sides can allow all cipher suited in the list when establishing a secure session or limit the allowed cipher suites to a subset. The complete list or the selected subset can be indicated to the server in the SSOpReq. If the complete list is sent, the default cipher suite list must be located first in the list. The server uses the following rules to choose the cipher suite to be used for the secure session:
  </t>
  <t>
  The server chooses the default cipher suite, if the SSOpReq chunk does not contain any cipher suite.
  </t>
  <t>
  The server gets the first cipher suites from SSOpReq chunk and server's cipher suite sequence. When both cipher suites are identical the server chooses this cipher suite for the secure session. Otherwise, the server takes its first cipher suite and looks for a match in the cipher suite sequence of the client. When there is no matche, the server takes the client's first cipher suite and searches for match in its cipher suite sequence. S-SCTP checks the first  cipher suite in the SSOpReq chunk against all cipher suites in the cipher suite list of the server. If no match is found, all subsequent cipher suites in the SSOpReq are checked sequentially in the order they appear in the SSOPReq until a match is found. The first cipher suite supported by both endpoints is chosen. When two cipher suites match each other then this cipher suite is selected for the secure session. If not, the server looks, its second cipher suite, for a match in the cipher suite sequence of the client. Furthermore, the server uses the same mechanism to look a cipher suite for the secure session.
  </t>
  <t>
  The server chooses the default cipher suite, when the cipher suites in the SSOpReq chunk are not supported by the server.
  </t>
  <t>
  Both client and server also maintain a list of compression methods. The choice of the compression mechanism works similarly to the cipher suite selection mechanism described above. S-SCTP uses a NULL compression method as default compression method.
  </t>
  </section>

  <section title="Data transfer">
  <t>
  Before transporting the packet over the network, S-SCTP takes the following steps. First, it checks the security level. If the security level is:
  </t>
  <t><list style="symbols">
  <t>
  0, jump to step "d"
  </t>
  <t>
  1, jump to step "c"
  </t>
  <t>
  2, check the user data. If the user data requires encryption, jump to step "a" . If the user data does not require encryption, jump to step "c"
  </t>
  <t>
  3, jump to step "a"
  </t>
  </list></t>
  <t><list>
  <t>
   a) S-SCTP sorts data chunks in two groups, which are encrypted and unencrypted. The encrypted group consists of those data chunks requiring encryption. The unencrypted group consists of those data chunks not requiring encryption. If the secure session's security level is set to 3, all chunks are sorted into the encrypted group.
  </t>
  <t>
  b) The data chunks in the encrypted group are concatenated. After this, S-SCTP calculates the padding chunk and inserts the padding chunk on the last position into pre-enc-data if necessary. The Pre-enc-data size MUST be smaller than the current MTU. If the pre-enc-data is bigger than the current MTU, S-SCTP must create two pre-enc-datas. Every pre-enc-data is encrypted and stored in the encryption data field of the EncData chunk.
  </t>
  <t>
  c) SCTP builds the packet according to the security level and inserts the AUTH chunk in the last position in the packet.
  </t>
  <t>
  d) S-SCTP sends the packet.
  </t>
  </list></t>
  </section>

  <section title="Closing of a secure session">
  <t>
  The termination of a secure session begins when one of the endpoints sends the secure session close chunk. This chunk includes the last encrypted data TSN and OF. The endpoint (sender) stops the encryption or authentication of all chunks or packets after it has sent the secure session close chunk. But normal (unsecured) data transfer will continue. The endpoint then waits until it receives the SSClose_Ack chunk. After receiving the SSClose_Ack chunk, the association clears the TCB parameters belonging to the secure session. The receiver (other endpoint) immediately stops encryption and authentication of all chunks or packets after it receives the secure session close chunk. Before sending the SSClose_Ack, the receiver waits for outstanding data (encrypted or authenticated data), which are the receiver's unacknowledged data chunks and sender's data chunks that have a TSN less than the last encrypted data TSN in the SSClose chunk. If the receiver does not receive the outstanding data chunks before RTO.hand timer expires, the S-SCTP association closes the secure session and outstanding data chunks will be dropped. The receiver ignores the last TSN of SSClose chunk and waits only for the receiver's unacknowledged data chunks when SSClose chunk's OF=1. The SSClose and SSClose_Ack chunks may be bundled with other chunks. If the sender does not receive the acknowledge chunk, the client follows the standard retransmission rule for messages. After the termination of the secure session, the TCB parameters belonging to the secure session MUST be set to zero. If the SCTP association begins to close the current association, the SSClose chunk is sent. If the SCTP association creates an ABORT chunk, the secure session closes immediately and the TCB parameters belonging to the secure session MUST be set to zero.
  </t>
  </section>

  <section title="Generation of the Master secret key">
  <t>
  Secret key generation uses the 3DES_CBC algorithm. Both server and client compute the master secret key separately. The key material is split into 64 bit blocks. Every block will be input to the 3DES_CBC encryption. The key material is as follows:
  </t>
  <t><list style="symbols">
  <t>
  If the secure session key exchange algorithm uses DH, the key material consists of the DH's secret key.
  </t>
  <t>
  If the secure session key exchange algorithm uses RSA, the key material consists of random numbers of both client and server.
  </t>
 </list></t>
  </section>

  <section title="Update of the master secret key">
  <t>
  A secure update mechanism of the secret keys is a very important requirement for a secure session. The secret keys consist of the master secret key, which is used for data chunk encryption, and the HMAC secret key, which is used for packet authentication. If an association exists for a long time, the S-SCTP association needs to update the secret keys. Both the client and the server can request an update of the secret keys. A three way handshake, called an abbreviated handshake, is used to update the master secret keys. All actions of the handshake are encrypted by the current master secret key.  The current security level does not affect the packets, which contain the handshake messages. The key update handshake works similar to the first establishment handshake (e.g. the endpoints start an RTO.hand timer when sending  handshake chunks). Format and function of the chunks used to update keys are the same as for the handshake. When an endpoint receives a SSOpReq chunk (after a secure session establishment) it begins to update secret keys. Both the server and client key exchange chunks always use the RSA key exchange algorithm. The random numbers in SSSerKey and SSCliKey chunks are encrypted by the current master secret key. The following describes the method used to update the master secret key:
  </t>
  <t>
  The client generates a random number and sends the SSopReq chunk with the SSCliKey chunk. The key material length in the handshake request chunk may be equal to 0. If  not, the number indicates the size of the new key material. If 0, both sides will use the key material length which was used in the last handshake. The server  sends the SSop_Ack, the SSSerKey and the SSOpCom chunks immediately after receiving the SSOpReq and the SSCliKey chunks. After receiving the handshake messages from the server, the client computes a new master secret key and checks the  SSOpCom chunk of the server. If it detects any error, the client closes the secure session and reports an error to the peer. The client computes the SSOpCom chunk and sends it to the server. After sending the SSOpCom chunk the client is ready to use the new master secret key. The server receives the SSOpCom chunk of the client and checks the new keys. If it detects any error, the server closes the secure session and reports an error to the peer. Before receiving the client's SSOpCom chunk, the server discards any encrypted or authenticated chunk that make use of the new master secret key.
  </t>
  <t>
  The encrypted and unencrypted user data transmission works in parallel with the update operation.  After the update operation, the new master secret key is used for data encryption and authentication.  When both client and server receive an SSOpReq chunk simultaneously,  the client ignores the server's SSopReq chunk and the server accepts the client's SSOpReq chunk. The next steps are the same as for the secure session initialisation.
  </t>
  <t>
  The new master secret key generation uses the same algorithm as described above. The secure session includes one parameter which is called secure session lifetime. This parameter is used to initialise a timer which indicates the secure session secret key's lifetime in seconds. When the timer expires, the association automatically updates the secret keys. The user can define this parameter. If the user does not define it, the parameter assumes a default value. This default value depends on the implementation. The implementation MUST define secure session's lifetime initial value. We suggest a value of 600 seconds for the lifetime as a compromise between security and overhead.
  </t>
  </section>

  <section title="Random number generation">
  <t>
  As the security of S-SCTP depends on the quality of the random number generator, we suggest to use one according to <xref target="RFC4086" pageno="false" format="default">RFC4086</xref>.
  </t>
  </section>

  <section title="HMAC algorithm">
  <t>
  S-SCTP uses the HMAC algorithm which is defined in <xref target="RFC2104" pageno="false" format="default">RFC2104</xref> for the packet authentication.
  </t>
  </section>
</section>

<section title="HMAC algorithm">
  <t>
  ULP-to-SCTP primitives deliver upper layer requests to S-SCTP. The following part describes new ULP-to-SCTP primitives and thus enhances the section 10 of RFC4960. All new ULP-to-SCTP primitives described below are defined in the ssctp.h header file.
  </t>
  <t>
  INITSECSESS: This primitive initialises a new secure session.
  </t>
  <t>
  Format: {initSecSess(secure session ID, key material length, cipher suites list, compression methods list, certiticate(s)  ) --> result}
  </t>
  <t><list style="symbols">
  <t>secure session ID:

  This parameter identifies a secure session.
  </t>
  <t>key material length:

  This defines the key material length which is used in the SSOPReq chunk.
  </t>
  <t>cipher suite list:

  Eligible cipher suites for a new secure session.
  </t>
  <t>compression method list:

  Eligible compression methods for a new secure session.
  </t>
  <t>certificate(s):

  Local endpoint certificate(s).
  </t>
  </list></t>

  <t>
  SETSECLEVEL: This primitive sets a new security level for an existing secure session.
  </t>
  <t>
  Format: {setSecLevel(secure session ID, security level) --> result}
  </t>
  <t><list style="symbols">
  <t>secure session ID:

  local handle to the secure session
  </t>
  <t>security level:

  This parameter indicates the new security level
  </t>
  </list></t>

  <t>
  GETSECLEVEL: This primitive gets the current security level of a secure session.
  </t>
  <t>
  Format: {getSecLevel(secure session ID) --> security level}
  </t>
  <t><list style="symbols">
  <t>secure session ID:

  local handle to the secure session
  </t>
  </list></t>

  <t>
  SENDSEC: This primitive sends secure data via S-SCTP.
  </t>
  <t>
  Format: {sctp_send_enc(association id, buffer address, byte count, context, stream id, life time, destination transport address, unorder flag, no-bundle flag, payload protocol-id, encryption flag, compression flag) --> result}
  </t>
  <t>
  Every parameter, except the encryption and compression flags, defined in this function is the same as the corresponding parameter defined in the SEND function of RFC4960 section 10.
  </t>
  <t><list style="symbols">
  <t>encryption flag:

  This flag defines if a current user data message needs encryption or not.
  </t>
  <t>compression flag:

  This flag defines if a current user data message needs compression or not.
  </t>
  </list></t>

  <t>
  GETSECSTATUS: This primitive gets the security status of an association. The security status indicates if the SCTP association is using a secure session or not.
  </t>
  <t>
  Format: {setSecStatus(association ID) -->  status}
  </t>
  <t><list style="symbols">
  <t>association ID:

  local handle to the SCTP association.
  </t>
  </list></t>

  <t>
  SETSECSESSTTL: This primitive sets a new lifetime for a secure session.
  </t>
  <t>
  Format: {setSecSessTTL(secure session ID, Time) --> result}
  </t>
  <t><list style="symbols">
  <t>secure session ID:

  local handle to the secure session.
  </t>
  <t>time:

  The new lifetime in seconds.
  </t>
  </list></t>

  <t>
  SHUTSECSESS: This primitive deletes a secure session.
  </t>
  <t>
  Format: {shutSecSess(secure session ID) --> result}
  </t>
  <t><list style="symbols">
  <t>secure session ID:

  local handle to the secure session.
  </t>
  <t>security level:

  This parameter indicates the new security level.
  </t>
 </list></t>
</section>

<section title="S-SCTP to ULP">
  <t>
  S-SCTP defines new notifications to deliver information to the upper layer. The notifications extend the section 10.2 of <xref target="RFC4960" pageno="false" format="default">RFC4960</xref>. All new notifications are defined in the ssctp.h header file.
  </t>
  <t>
  SECSESSUP:
  </t>
  <t>
   This notification indicates that S-SCTP is ready to send or receive secure data ({secsessUpNotif()}).
  </t>
  <t>
  SECSESSDOWN:
  </t>
  <t>
  This notification indicates that an association has lost a secure session ({secsessdownNotif()}).
  </t>
  <t>
  SECSESSREKEY:
  </t>
  <t>
  This notification indicates that a secure session updated the secret keys ({secsessrekeyNotif()}).
  </t>
  <t>
  Additional changes had to be made in the socket API implementation to access the new sctplib functions described above. A user calls the same socket API functions as in standard SCTP to send and receive user data, but has to set an additional encryption flag (MSG_ENC) to request encryption of user data. Also, a compression flag (MSG_COMP) has to be set in ext_send, ext_sendto, ext_sendmsg to request compression of user data. S-SCTP compression performs per user message not per chunk or per packet. In the SCTP DATA chunk, a new flag is defined, which indicates if the data is compressed or not. On the receiver side there are no changes.
  </t>
</section>

<section title="Transmission Control Block (TCB) extension">
  <t>
  A SCTP TCB contains parameters which are related to an association (e.g. an association id, port number, IP address list...). S-SCTP defines several parameters which are related to a secure session and it extends the TCB defined in section 12 of RFC4960.
  </t>
  <t>
  Security level:
  </t>
  <t>
  This parameter contains the association's current security level.
  </t>
  <t>
  Second security level:
  </t>
  <t>
  This is the security level of the associated second endpoint.
  </t>
  <t>
  Key material length:
  </t>
  <t>
  The size of the key material, which was last used for key generation.
  </t>
  <t>
  Secure session status:
  </t>
  <t>
  This parameter indicates whether the association is using a secure session or not.
  </t>
  <t>
  Secure session lifetime:
  </t>
  <t>
  This parameter indicates the lifetime of the secret keys of a secure session.
  </t>
  <t>
  Server indication:
  </t>
  <t>
  This parameter indicates if an endpoint is server or client. If the parameter is equal to 1 then it is a server, otherwise it is a client.
  </t>
  <t>
  Secure session ID:
  </t>
  <t>
  This parameter indicates the local secure session ID.
  </t>
  <t>
  Master secret key reference:
  </t>
  <t>
  This is an "array of secret data" collection and every array element includes the following parameters.
  </t>
  <t><list style="symbols">
  <t>Selected cipher suite:

  This parameter indicates the encryption and authentication algorithms that are used in a secure session.
  </t>
  <t>Selected compression:

  This parameter indicates the compression method that is used in a secure session.
  </t>
  <t>Encryption key:

  This is a secret key which is used for encryption.
  </t>
  <t>Authentication key:

  This is a secret key which is used for authentication.
  </t>
  </list></t>
  <t>
  This information is used in EncData and AUTH chunks.
  </t>
</section>

<section title="Socket API extensions for Secure SCTP">
  <t>
  S-SCTP defines new socket options for the ext_setsockopt() and ext_getsockopt() socket functions to initialise, delete and rekey a secure session. A user calls the ext_setsockopt or ext_getsockopt functions with a new option. It is not necessary to define new socket API functions, as this is a more standard socket API fashion. The following paragraphs describe the new socket options.
  </t>
  <t>
  SSCTP-INIT:
  </t>
  <t>
  This socket option is used to initialise or update a secure session. The following structure is used to access these parameters.
  </t>
  <figure><artwork>
struct ssctp_init {
       uint16_t  secsessID;
       uint16_t  key_length;
       uint8_t   num_cipher;
       uint8_t   *cipher_suites;
       uint8_t   num_comp;
       uint8_t   *comp_methods;
       uint8_t   *certificate;
};
  </artwork></figure>
  <t><list style="symbols">
  <t>secsessID:

  This parameter indicates a current secure session ID.
  </t>
  <t>key_length:

  This parameter defines the length of a key material.
  </t>
  <t>num_cipher:

  This parameter defines the number of cipher suites.
  </t>
  <t>cipher_suites:

  This parameter includes a list of cipher suites.
  </t>
  <t>num_comp:

  This parameter defines the number of compression methods.
  </t>
  <t>comp_methods:

  This parameter includes a list of compression methods.
  </t>
  <t>certificate:

  This parameter includes a certificate of the endpoint.
  </t>
 </list></t>

  <t>
  SSCTP-SECLEVEL:
  </t>
  <t>
  This socket option is used to set and get a secure session security level. The following structure is used to access and modify these parameters.
  </t>
  <figure><artwork>
struct ssctp_seclevel {
       uint16_t  secsessID;
       uint8_t  seclevel;
};
  </artwork></figure>
  <t><list style="symbols">
  <t>secsessID:

  This parameter indicates a current secure session ID.
  This parameter MUST be zero when  beginning a secure session initialisation.
  </t>
  <t>seclevel:

  This parameter contains a new security level before socket write access or contains the current security level after socket read access.
  </t>
 </list></t>

  <t>
  SSCTP-SECSTATUS:
  </t>
  <t>
  This socket option is used to get the secure session status and secure session ID when a secure session exists. The following structure is used to access these parameters.
  </t>
  <figure><artwork>
struct ssctp_secstatus {
       uint16_t secsessID;
       uint8_t sec_status;
};
  </artwork></figure>
  <t><list style="symbols">
  <t>secsessID:

  This parameter contains the current secure session ID. This parameter MUST be zero when a secure session does not exist.
  </t>
  <t>sec_status:

  This parameter contains a security status. This parameter MUST be zero when a secure session does not exist. This parameter is equal to 1 when a secure session exists.
  </t>
  </list></t>

  <t>
  SSCTP-SECSESSTTL:
  </t>
  <t>
  This socket option is used to set and get the secure session lifetime. The following structure is used to access and modify these parameters.
  </t>
  <figure><artwork>
struct ssctp_secsessTTL {
       uint16_t secsessID;
       uint16_t secsessTTL;
};
  </artwork></figure>
  <t><list style="symbols">
  <t>secsessID:

  This parameter indicates the current secure session ID.

  </t>
  <t>secsessTTL (seconds):

  This parameter contains a new secure session lifetime before socket write access or contains a current secure session lifetime  after socket read access.
  </t>
  </list></t>

  <t>
  SSCTP-CLOSE:
  </t>
  <t>
  This socket option is used to close an existing secure session. The following structure is used to access these parameters.
  </t>
  <figure><artwork>
struct ssctp_secclose {
       uint16_t  secsessID;
};
  </artwork></figure>
  <t><list style="symbols">
  <t>secsessID:

  This parameter contains the current secure session ID.
  </t>
  </list></t>

</section>


<section title="Security Considerations">
<t>Security has been described in the previous sections.</t>
</section>


<section title="IANA Considerations">
<t>This document introduces no additional considerations for IANA.</t>
</section>


</middle>


<back>

<references title='Normative References'>
<?rfc include="reference.RFC.2104" ?>
<?rfc include="reference.RFC.2119" ?>
<?rfc include="reference.RFC.3436" ?>
<?rfc include="reference.RFC.3554" ?>
<?rfc include="reference.RFC.4086" ?>
<?rfc include="reference.RFC.4960" ?>
<?rfc include="reference.RFC.5280" ?>
</references>

</back>

</rfc>
