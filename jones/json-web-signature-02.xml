<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC1421 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1421.xml">
<!ENTITY RFC1738 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1738.xml">
<!ENTITY RFC2045 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY RFC2104 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY RFC3275 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3275.xml">
<!ENTITY RFC3339 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml">
<!ENTITY RFC3447 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml">
<!ENTITY RFC3629 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml">
<!ENTITY RFC3986 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC4627 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
<!ENTITY RFC4648 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY RFC5226 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY RFC5280 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
<!ENTITY RFC5785 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5785.xml">
]>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-jones-json-web-signature-02"
     ipr="trust200902">
  <front>
    <title>JSON Web Signature (JWS)</title>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization>Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>

    <author fullname="Dirk Balfanz" initials="D." surname="Balfanz">
      <organization>Google</organization>
      <address>
	<email>balfanz@google.com</email>
      </address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>independent</organization>
      <address>
	<email>ve7jtb@ve7jtb.com</email>
      </address>
    </author>

    <author fullname="Yaron Y. Goland" initials="Y.Y." surname="Goland">
      <organization>Microsoft</organization>
      <address>
	<email>yarong@microsoft.com</email>
      </address>
    </author>

    <author fullname="John Panzer" initials="J." surname="Panzer">
      <organization>Google</organization>
      <address>
	<email>jpanzer@google.com</email>
      </address>
    </author>

    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization>Nomura Research Institute</organization>
      <address>
	<email>n-sakimura@nri.co.jp</email>
      </address>
    </author>

    <author fullname="Paul Tarjan" initials="P." surname="Tarjan">
      <organization>Facebook</organization>
      <address>
	<email>pt@fb.com</email>
      </address>
    </author>

    <date day="29" month="April" year="2011" />

    <area>Applications</area>

    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>Assertion</keyword>
    <keyword>Simple Web Token</keyword>
    <keyword>Security Token</keyword>
    <keyword>SWT</keyword>
    <keyword>JavaScript Object Notation</keyword>
    <keyword>JSON</keyword>
    <keyword>JSON Web Token</keyword>
    <keyword>JWT</keyword>
    <keyword>JSON Web Signature</keyword>
    <keyword>JWS</keyword>
    <keyword>JSON Web Encryption</keyword>
    <keyword>JWE</keyword>
    <keyword>JSON Web Key</keyword>
    <keyword>JWK</keyword>

    <abstract>
      <t>
	JSON Web Signature (JWS) is a means of representing signed
	content using JSON data structures.  Related encryption
	capabilities are described in the separate JSON Web Encryption
	(JWE) specification.
      </t>
    </abstract>

    <note title="Requirements Language">
      <t>
	The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
	NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
	"OPTIONAL" in this document are to be interpreted as described
	in <xref target="RFC2119">RFC 2119</xref>.
      </t>
    </note>
  </front>

  <middle>
    <section title="Introduction">
      <t>
	JSON Web Signature (JWS) is a compact signature format
	intended for space constrained environments such as HTTP
	Authorization headers and URI query parameters.  It represents
	signed content using JSON <xref target="RFC4627" /> data
	structures.  The JWS signature mechanisms are independent of
	the type of content being signed, allowing arbitrary content
	to be signed.  A related encryption capability is described in
	a separate JSON Web Encryption (JWE) <xref target="JWE" />
	specification.
      </t>
    </section>

    <section title="Terminology">
      <t>
	<list style="hanging">

          <t hangText="JSON Web Signature (JWS)">
	    A data structure cryptographically securing a JWS Header
	    Input and a JWS Payload Input with a JWS Crypto Output.
	  </t>

          <t hangText="JWS Header Input">
	    A string containing a base64url encoded JSON object that
	    describes the cryptographic operations applied to the JWS
	    Header Input and the JWS Payload Input.
	  </t>
          <t hangText="JWS Payload Input">
	    A string containing base64url encoded content.
	  </t>
          <t hangText="JWS Crypto Output">
	    A string containing base64url encoded cryptographic
	    material that secures the contents of the JWS Header Input
	    and the JWS Payload Input.
	  </t>

          <t hangText="Decoded JWS Header Input">
	    JWS Header Input that has been base64url decoded back into
	    a JSON object.
	  </t>
          <t hangText="Decoded JWS Payload Input">
	    JWS Payload Input that has been base64url decoded.
	  </t>
          <t hangText="Decoded JWS Crypto Output">
	    JWS Crypto Output that has been base64url decoded back
	    into cryptographic material.
	  </t>

	  <t hangText="JWS Signing Input">
	    The concatenation of the JWS Header Input, a period ('.')
	    character, and the JWS Payload Input.
	  </t>

	  <t hangText="Header Parameter Names">
	    The names of the members within the JSON object
	    represented in a JWS Header Input.
	  </t>
	  <t hangText="Header Parameter Values">
	    The values of the members within the JSON object
	    represented in a JWS Header Input.
	  </t>

	  <t hangText="Digital Signature">
	    For the purposes of this specification, we use this term
	    to encompass both Hash-based Message Authentication Codes
	    (HMACs), which can provide authenticity but not
	    non-repudiation, and digital signatures using public key
	    algorithms, which can provide both.  Readers should be
	    aware of this distinction, despite the decision to use a
	    single term for both concepts to improve readability of
	    the specification.
	  </t>
          <t hangText="Base64url Encoding">
	    For the purposes of this specification, this term always
	    refers to the he URL- and filename-safe Base64 encoding
	    described in <xref target="RFC4648">RFC 4648</xref>,
	    Section 5, with the '=' padding characters omitted, as
	    permitted by Section 3.2.
	  </t>
        </list>
      </t>
    </section>

    <section title="JSON Web Signature (JWS) Overview">

      <t>
	JWSs represent content that is base64url encoded and digitally
	signed, and optionally encrypted, using JSON data structures.
	A portion of the base64url encoded content that is signed is
	the JWS Payload Input.
        An accompanying base64url encoded JSON object - the JWS Header
        Input - describes the signature method used.
      </t>
      <t>
	The member names within the Decoded JWS Header Input are
	referred to as Header Parameter Names.  These names MUST be
	unique.  The corresponding values are referred to as Header
	Parameter Values.
      </t>
      <t>
	JWSs contain a signature that ensures the integrity of the
	contents of the JWS Header Input and the JWS Payload Input.
	This signature value is the JWS Crypto Output.  The JSON
	Header object MUST contain an <spanx style="verb">alg</spanx> parameter, the value of
	which is a string that unambiguously identifies the algorithm
	used to sign the JWS Header Input and the JWS Payload Input to
	produce the JWS Crypto Output.
      </t>

      <section title="Example JWS" anchor="ExampleJWS">

	<t>
	  The following example JSON header object declares that the
	  encoded object is a JSON Web Token (JWT) <xref target="JWT" />
	  and the JWS Header Input and the JWS Payload Input are
	  signed using the HMAC SHA-256 algorithm:
	</t>

	<artwork><![CDATA[{"typ":"JWT",
 "alg":"HS256"}]]></artwork>

	<t>
	  Base64url encoding the UTF-8 representation of the JSON
	  header object yields this JWS Header Input value:
	</t>

	<artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9]]></artwork>

	<t>
	  The following is an example of a JSON object that can be
	  encoded to produce a JWS Payload Input.  (Note that
	  the payload can be any base64url encoded content, and need
	  not be a base64url encoded JSON object.)
	</t>

	<artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork>

	<t>
	  Base64url encoding the UTF-8 representation of the JSON
	  object yields the following JWS Payload Input.
	</t>

	<artwork><![CDATA[eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork>

	<t>
	  Signing the UTF-8 representation of the JWS Signing Input
	  (the concatenation of the JWS Header Input, a period ('.')
	  character, and the JWS Payload Input) with the HMAC
	  SHA-256 algorithm and base64url encoding the result, as per
	  <xref target="DefiningHMAC"></xref>, yields this
	  JWS Crypto Output value:
	</t>

	<artwork><![CDATA[dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk]]></artwork>

	<t>
	  This computation is illustrated in more detail in <xref
	  target="HMACSHA256Example"></xref>.
	</t>

      </section>
    </section>

    <section title="JWS Header">

      <t>
	The members of the JSON object represented by the Decoded JWS
	Header Input describe the signature applied to the JWS
	Header Input and the JWS Payload Input and optionally
	additional properties of the JWS.  Implementations MUST
	understand the entire contents of the header; otherwise, the
	JWS MUST be rejected for processing.
      </t>

      <section title="Reserved Header Parameter Names" anchor="ReservedHeaderParameterName">
	<t>
	  The following header parameter names are reserved.  All
	  the names are short because a core goal of JWSs is for the
	  representations to be compact.
	</t>

	<texttable title="Reserved Header Parameter Definitions" anchor="HeaderParameterTable">

	  <ttcol align="left">Header Parameter Name</ttcol>
	  <ttcol align="left">JSON Value Type</ttcol>
	  <ttcol align="left">Header Parameter Syntax</ttcol>
	  <ttcol align="left">Header Parameter Semantics</ttcol>

	  <c>alg</c>
	  <c>string</c>
	  <c>StringAndURI</c>
	  <c>
	    The <spanx style="verb">alg</spanx> (algorithm) header
	    parameter identifies the cryptographic algorithm used to
	    secure the JWS.  A list of reserved alg values is in <xref
	    target="AlgTable"></xref>.  The processing of the <spanx
	    style="verb">alg</spanx> (algorithm) header parameter, if
	    present, requires that the value of the <spanx
	    style="verb">alg</spanx> header parameter MUST be one that
	    is both supported and for which there exists a key for use
	    with that algorithm associated with the signer of the
	    content.
	    The <spanx style="verb">alg</spanx> parameter value is case sensitive.
	    This header parameter is REQUIRED.
	  </c>

	  <c>typ</c>
	  <c>string</c>
	  <c>String</c>
	  <c>
	    The <spanx style="verb">typ</spanx> (type) header
	    parameter is used to declare the type of the signed
	    content.
	    The <spanx style="verb">typ</spanx> value is case sensitive.
	    This header parameter is OPTIONAL.
	  </c>

	  <c>jku</c>
	  <c>string</c>
	  <c>URL</c>
	  <c>
	    The <spanx style="verb">jku</spanx> (JSON Key URL) header
	    parameter is a URL that points to JSON-encoded public keys
	    that can be used to validate the signature.  The keys MUST
	    be encoded as per the JSON Web Key (JWK) <xref
	    target="JWK" /> specification.  This header parameter is
	    OPTIONAL.
	  </c>

	  <c>kid</c>
	  <c>string</c>
	  <c>String</c>
	  <c>
	    The <spanx style="verb">kid</spanx> (key ID) header
	    parameter is a hint indicating which specific key owned by
	    the signer should be used to validate the signature.  This
	    allows signers to explicitly signal a change of key to
	    recipients. Omitting this parameter is equivalent to
	    setting it to an empty string.  The interpretation of the
	    contents of the <spanx style="verb">kid</spanx> parameter
	    is unspecified.
	    This header parameter is OPTIONAL.
	  </c>

	  <c>x5u</c>
	  <c>string</c>
	  <c>URL</c>
	  <c>
	    The <spanx style="verb">x5u</spanx> (X.509 URL) header
	    parameter is a URL utilizing TLS <xref
	    target="RFC5785">RFC 5785</xref> that points to an X.509
	    public key certificate or certificate chain that can be
	    used to validate the signature.  This certificate or
	    certificate chain MUST use the PEM encoding <xref
	    target="RFC1421">RFC 1421</xref> and MUST conform to <xref
	    target="RFC5280">RFC 5280</xref>.
	    This header parameter is OPTIONAL.
	  </c>

	  <c>x5t</c>
	  <c>string</c>
	  <c>String</c>
	  <c>
	    The <spanx style="verb">x5t</spanx> (x.509 certificate
	    thumbprint) header parameter provides a base64url encoded
	    SHA-1 thumbprint (a.k.a. digest) of the DER encoding of an
	    X.509 certificate that can be used to match the certificate.
	    This header parameter is OPTIONAL.
	  </c>

	</texttable>

	<t>
	  Additional reserved header parameter names MAY be defined
	  via the IANA JSON Web Signature Header Parameters registry,
	  as per <xref target="IANA" />.  The syntax values used above
	  are defined as follows:
	</t>

	<texttable title="Header Parameter Syntax Definitions" anchor="SyntaxDefinitions">
	  <ttcol align="left">Syntax Name</ttcol>
	  <ttcol align="left">Syntax Definition</ttcol>

	  <c>IntDate</c>
	  <c>
	    The number of seconds from 1970-01-01T0:0:0Z as measured
	    in UTC until the desired date/time. See <xref
	    target="RFC3339">RFC 3339</xref> for details regarding
	    date/times in general and UTC in particular.
	  </c>

	  <c>String</c>
	  <c>
	    Any string value MAY be used.
	  </c>

	  <c>StringAndURI</c>
	  <c>
	    Any string value MAY be used but a value containing a ":"
	    character MUST be a URI as defined in <xref
	    target="RFC3986">RFC 3986</xref>.
	  </c>

	  <c>URL</c>
	  <c>
	    A URL as defined in <xref target="RFC1738">RFC 1738</xref>.
	  </c>
	</texttable>

      </section>

      <section title="Public Header Parameter Names" anchor="PublicHeaderParameterName">

        <t>
	  Additional header parameter names can be defined by those
	  using JWSs. However, in order to prevent collisions, any new
	  header parameter name or algorithm value SHOULD either be
	  defined in the IANA JSON Web Signature Header Parameters
	  registry or be defined as a URI that contains a collision
	  resistant namespace.  In each case, the definer of the name
	  or value MUST take reasonable precautions to make sure they
	  are in control of the part of the namespace they use to
	  define the header parameter name.
	</t>
	<t>
	  New header parameters should be introduced sparingly, as
	  they can result in non-interoperable JWSs.
	</t>
      </section>

      <section title="Private Header Parameter Names" anchor="PrivateHeaderParameterName">

	<t>
	  A producer and consumer of a JWS may agree to any header
	  parameter name that is not a Reserved Name <xref
	  target="ReservedHeaderParameterName"></xref> or a Public
	  Name <xref
	  target="PublicHeaderParameterName"></xref>. Unlike Public
	  Names, these private names are subject to collision and
	  should be used with caution.
	</t>
	<t>
	  New header parameters should be introduced sparingly, as
	  they can result in non-interoperable JWSs.
	</t>

      </section>
    </section>

    <section title="Rules for Creating and Validating a JWS">
      <t>
	To create a JWS, one MUST follow these steps:

        <list style="numbers">

	  <t>
	    Create the payload content to be encoded as the Decoded
	    JWS Payload Input.
	  </t>
          <t>
	    Base64url encode the Decoded JWS Payload Input.  This
	    encoding becomes the JWS Payload Input.
	  </t>
	  <t>
	    Create a JSON object containing a set of desired header
	    parameters.  Note that white space is explicitly allowed
	    in the representation and no canonicalization is performed
	    before encoding.
	  </t>
          <t>
	    Translate this JSON object's Unicode code points into
	    UTF-8, as defined in <xref target="RFC3629">RFC
	    3629</xref>.
	  </t>
          <t>
	    Base64url encode the UTF-8 representation of this JSON
	    object as defined in this specification (without
	    padding). This encoding becomes the JWS Header Input.
	  </t>
          <t>
	    Compute the JWS Crypto Output in the manner defined for
	    the particular algorithm being used.  The JWS Signing
	    Input is always the concatenation of the JWS Header Input,
	    a period ('.') character, and the JWS Payload Input.  The
	    <spanx style="verb">alg</spanx> header parameter MUST be
	    present in the JSON Header Input, with the algorithm value
	    accurately representing the algorithm used to construct
	    the JWS Crypto Input.
	  </t>
        </list>
      </t>
      <t>
	When validating a JWS, the following steps MUST be taken. If
	any of the listed steps fails, then the signed content MUST be
	rejected.
      </t>
      <t>
	<list style="numbers">
          <t>
	    The JWS Payload Input MUST be successfully base64url
	    decoded following the restriction given in this specification that
	    no padding characters have been used.
	  </t>
          <t>
	    The JWS Header Input MUST be successfully base64url
	    decoded following the restriction given in this specification that
	    no padding characters have been used.
	  </t>
          <t>
	    The Decoded JWS Header Input MUST be completely valid
	    JSON syntax conforming to <xref target="RFC4627">RFC
	    4627</xref>.
	  </t>
          <t>
	    The JWS Crypto Output MUST be successfully base64url
	    decoded following the restriction given in this specification that
	    no padding characters have been used.
	  </t>
          <t>
	    The JWS Header Input MUST be validated to only include
	    parameters and values whose syntax and semantics are both
	    understood and supported.
	  </t>
          <t>
	    The JWS Crypto Output MUST be successfully validated
	    against the JWS Header Input and JWS Payload Input
	    in the manner defined for the algorithm being used, which
	    MUST be accurately represented by the value of the <spanx style="verb">alg</spanx>
	    header parameter, which MUST be present.
	  </t>
        </list>
      </t>

      <t>
	Processing a JWS inevitably requires comparing known strings
	to values in the header. For example, in checking what the
	algorithm is, the Unicode string encoding <spanx style="verb">alg</spanx> will be
	checked against the member names in the Decoded JWS Header
	Input to see if there is a matching header parameter
	name. A similar process occurs when determining if the value
	of the <spanx style="verb">alg</spanx> header parameter represents a supported
	algorithm. Comparing Unicode strings, however, has significant
	security implications, as per <xref target="Security"></xref>.
      </t>
      <t>
	Comparisons between JSON strings and other Unicode strings
	MUST be performed as specified below:
      </t>

      <t>
	<list style="numbers">

          <t>
	    Remove any JSON applied escaping to produce an array of
	    Unicode code points.
	  </t>
          <t>
	    <xref target="USA15">Unicode Normalization</xref> MUST NOT
	    be applied at any point to either the JSON string or to
	    the string it is to be compared against.
	  </t>
          <t>
	    Comparisons between the two strings MUST be performed as a
	    Unicode code point to code point equality comparison.
	  </t>

        </list>
      </t>

    </section>

    <section title="Base64url encoding as used by JWSs" anchor="base64urllogic">

      <t>
	JWSs make use of the base64url encoding as defined in <xref
	target="RFC4648">RFC 4648</xref>. As allowed by Section 3.2 of
	the RFC, this specification mandates that base64url encoding
	when used with JWSs MUST NOT use padding. The reason for this
	restriction is that the padding character ('=') is not URL
	safe.
      </t>
      <t>
	For notes on implementing base64url encoding without padding,
	see <xref target="base64urlnotes"></xref>.
      </t>
    </section>

    <section title="Signing JWSs with Cryptographic Algorithms" anchor="Signing">

      <t>
	JWSs use specific cryptographic algorithms to sign the contents
	of the JWS Header Input and the JWS Payload Input.  The
	use of the following algorithms for producing JWSs is defined in
	this section.  The table below is the list of <spanx style="verb">alg</spanx> header
	parameter values reserved by this specification, each of which
	is explained in more detail in the following sections:
      </t>

      <texttable title="JSON Web Signature Reserved Algorithm Values" anchor="AlgTable">

	<ttcol align="left">Alg Parameter Value</ttcol>
	<ttcol align="left">Algorithm</ttcol>

	<c>HS256</c>
	<c>HMAC using SHA-256 hash algorithm</c>

	<c>HS384</c>
	<c>HMAC using SHA-384 hash algorithm</c>

	<c>HS512</c>
	<c>HMAC using SHA-512 hash algorithm</c>

	<c>RS256</c>
	<c>RSA using SHA-256 hash algorithm</c>

	<c>RS384</c>
	<c>RSA using SHA-384 hash algorithm</c>

	<c>RS512</c>
	<c>RSA using SHA-512 hash algorithm</c>

	<c>ES256</c>
	<c>ECDSA using P-256 curve and SHA-256 hash algorithm</c>

	<c>ES384</c>
	<c>ECDSA using P-384 curve and SHA-384 hash algorithm</c>

	<c>ES512</c>
	<c>ECDSA using P-521 curve and SHA-512 hash algorithm</c>

      </texttable>

      <t>
	See <xref target="algxref" /> for a table cross-referencing the <spanx
	style="verb">alg</spanx> values used in this specification
	with the equivalent identifiers used by other
	standards and software packages.
      </t>

      <t>
	Of these algorithms, only HMAC SHA-256 MUST be implemented by
	conforming implementations.  It is RECOMMENDED that
	implementations also support the RSA SHA-256 and ECDSA P-256
	SHA-256 algorithms.  Support for other algorithms is OPTIONAL.
      </t>

      <t>
	The signed content for a JWS is the same for all algorithms:
	the concatenation of the JWS Header Input, a period ('.')
	character, and the JWS Payload Input.  This character sequence
	is referred to as the JWS Signing Input.  Note that if the JWS
	represents a JWT, this corresponds to the portion of the JWT
	representation preceding the second period character.  The
	UTF-8 representation of the JWS Signing Input is passed to the
	respective signing algorithms.
      </t>

      <section title="Creating a JWS with HMAC SHA-256, HMAC SHA-384, or HMAC SHA-512" anchor="DefiningHMAC">

	<t>
	  Hash based Message Authentication Codes (HMACs) enable one to
	  use a secret plus a cryptographic hash function to generate a
	  Message Authentication Code (MAC). This can be used to
	  demonstrate that the MAC matches the hashed content, in this
	  case the JWS Signing Input, which therefore demonstrates that
	  whoever generated the MAC was in possession of the secret.
	  The means of exchanging the shared key is outside the scope
	  of this specification.
	</t>
	<t>
	  The algorithm for implementing and validating HMACs is
	  provided in <xref target="RFC2104">RFC 2104</xref>.  This
	  section defines the use of the HMAC SHA-256, HMAC SHA-384,
	  and HMAC SHA-512 cryptographic hash functions as defined in
	  <xref target="FIPS.180-3">FIPS 180-3</xref>. The reserved
	  <spanx style="verb">alg</spanx> header parameter values
	  <spanx style="verb">HS256</spanx>, <spanx
	  style="verb">HS384</spanx>, and <spanx
	  style="verb">HS512</spanx> are used in the JWS Header Input
	  to indicate that the JWS Crypto Output contains a base64url
	  encoded HMAC value using the respective hash function.
	</t>
	<t>
	  The HMAC SHA-256 MAC is generated as follows:

	  <list style="numbers">
	    <t>
	      Apply the HMAC SHA-256 algorithm to the UTF-8
	      representation of the JWS Signing Input using the shared
	      key to produce an HMAC.
	    </t>
	    <t>
	      Base64url encode the HMAC, as defined in this specification.
	    </t>
	  </list>

	  The output is the JWS Crypto Output for that JWS.
	</t>

	<t>
	  The HMAC SHA-256 MAC for a JWS is validated as follows:

	  <list style="numbers">

	    <t>
	      Apply the HMAC SHA-256 algorithm to the UTF-8
	      representation of the JWS Signing Input of the JWS using
	      the shared key.
	    </t>
	    <t>
	      Base64url encode the previously generated HMAC, as
	      defined in this specification.
	    </t>
	    <t>
	      If the JWS Crypto Output and the previously calculated
	      value exactly match, then one has confirmation that the
	      key was used to generate the HMAC on the JWS and that the
	      contents of the JWS have not be tampered with.
	    </t>
	    <t>
	      If the validation fails, the signed content MUST be rejected.
	    </t>

	  </list>
	</t>

	<t>
	  Signing with the HMAC SHA-384 and HMAC SHA-512 algorithms is
	  performed identically to the procedure for HMAC SHA-256 - just
	  with correspondingly longer key and result values.
	</t>

      </section>

      <section title="Creating a JWS with RSA SHA-256, RSA SHA-384, or RSA SHA-512" anchor="DefiningRSA">

	<t>
	  This section defines the use of the RSASSA-PKCS1-v1_5
	  signature algorithm as defined in <xref target="RFC3447">RFC
	  3447</xref>, Section 8.2 (commonly known as PKCS#1), using
	  SHA-256, SHA-384, or SHA-512 as the hash function.  The
	  RSASSA-PKCS1-v1_5 algorithm is described in <xref
	  target="FIPS.186-3">FIPS 186-3</xref>, Section 5.5, and the
	  SHA-256, SHA-384, and SHA-512 cryptographic hash functions
	  are defined in <xref target="FIPS.180-3">FIPS 180-3</xref>.
	  The reserved <spanx style="verb">alg</spanx> header
	  parameter values <spanx style="verb">RS256</spanx>, <spanx
	  style="verb">RS384</spanx>, and <spanx
	  style="verb">RS512</spanx> are used in the JWS Header Input
	  to indicate that the JWS Crypto Output contains a base64url
	  encoded RSA signature using the respective hash function.
	</t>
	<t>
	  The public keys employed may be retrieved using Header
	  Parameter methods described in <xref
	  target="ReservedHeaderParameterName" /> or may be
	  distributed using methods that are outside the scope of this
	  specification.
	</t>
	<t>
	  A 2048-bit or longer key length MUST be used with this
	  algorithm.
	</t>
	<t>
	  The RSA SHA-256 signature is generated as follows:

	  <list style="numbers">

	    <t>
	      Generate a digital signature of the UTF-8 representation
	      of the JWS Signing Input using RSASSA-PKCS1-V1_5-SIGN
	      and the SHA-256 hash function with the desired private
	      key. The output will be a byte array.
	    </t>
	    <t>
	      Base64url encode the byte array, as defined in this
	      specification.
	    </t>

	  </list>

	  The output is the JWS Crypto Output for that JWS.
	</t>

	<t>
	  The RSA SHA-256 signature for a JWS is validated as follows:

	  <list style="numbers">

	    <t>
	      Take the JWS Crypto Output and base64url decode it into
	      a byte array. If decoding fails, the signed content MUST
	      be rejected.
	    </t>
	    <t>
	      Submit the UTF-8 representation of the JWS Signing Input
	      and the public key corresponding to the private key used
	      by the signer to the RSASSA-PKCS1-V1_5-VERIFY algorithm
	      using SHA-256 as the hash function.
	    </t>
	    <t>
	      If the validation fails, the signed content MUST be rejected.
	    </t>

	  </list>
	</t>

	<t>
	  Signing with the RSA SHA-384 and RSA SHA-512 algorithms is
	  performed identically to the procedure for RSA SHA-256 - just
	  with correspondingly longer key and result values.
	</t>

      </section>

      <section title="Creating a JWS with ECDSA P-256 SHA-256, ECDSA P-384 SHA-384, or ECDSA P-521 SHA-512" anchor="DefiningECDSA">
	<t>
	  The Elliptic Curve Digital Signature Algorithm (ECDSA) is
	  defined by <xref target="FIPS.186-3">FIPS 186-3</xref>. ECDSA
	  provides for the use of Elliptic Curve cryptography, which is
	  able to provide equivalent security to RSA cryptography but
	  using shorter key lengths and with greater processing
	  speed. This means that ECDSA signatures will be substantially
	  smaller in terms of length than equivalently strong RSA
	  Digital Signatures.
	</t>
	<t>
	  This specification defines the use of ECDSA with the P-256
	  curve and the SHA-256 cryptographic hash function, ECDSA
	  with the P-384 curve and the SHA-384 hash function, and
	  ECDSA with the P-521 curve and the SHA-512 hash
	  function. The P-256, P-384, and P-521 curves are also
	  defined in FIPS 186-3. The reserved <spanx
	  style="verb">alg</spanx> header parameter values <spanx
	  style="verb">ES256</spanx>, <spanx
	  style="verb">ES384</spanx>, and <spanx
	  style="verb">ES512</spanx> are used in the JWS Header Input
	  to indicate that the JWS Crypto Output contains a based64url
	  encoded ECDSA P-256 SHA-256, ECDSA P-384 SHA-384, or ECDSA
	  P-521 SHA-512 signature, respectively.
	</t>
	<t>
	  The public keys employed may be retrieved using Header
	  Parameter methods described in <xref
	  target="ReservedHeaderParameterName" /> or may be
	  distributed using methods that are outside the scope of this
	  specification.
	</t>
	<t>
	  A JWS is signed with an ECDSA P-256 SHA-256 signature as
	  follows:

	  <list style="numbers">
	    <t>
	      Generate a digital signature of the UTF-8 representation
	      of the JWS Signing Input using ECDSA P-256 SHA-256 with
	      the desired private key. The output will be the EC point
	      (R, S), where R and S are unsigned integers.
	    </t>
	    <t>
	      Turn R and S into byte arrays in big endian order. Each
	      array will be 32 bytes long.
	    </t>
	    <t>
	      Concatenate the two byte arrays in the order R and then S.
	    </t>
	    <t>
	      Base64url encode the 64 byte array, as defined in this
	      specification.
	    </t>
	  </list>

	  The output is the JWS Crypto Output for the JWS.
	</t>

	<t>
	  The ECDSA P-256 SHA-256 signature for a JWS is validated as follows:

	  <list style="numbers">
	    <t>
	      Take the JWS Crypto Output and base64url decode it into
	      a byte array. If decoding fails, the signed content MUST
	      be rejected.
	    </t>
	    <t>
	      The output of the base64url decoding MUST be a 64 byte
	      array.
	    </t>
	    <t>
	      Split the 64 byte array into two 32 byte arrays. The first
	      array will be R and the second S. Remember that the byte
	      arrays are in big endian byte order; please check the
	      ECDSA validator in use to see what byte order it requires.
	    </t>
	    <t>
	      Submit the UTF-8 representation of the JWS Signing
	      Input, R, S and the public key (x, y) to the ECDSA P-256
	      SHA-256 validator.
	    </t>
	    <t>
	      If the validation fails, the signed content MUST be rejected.
	    </t>
	  </list>

	  The ECDSA validator will then determine if the digital
	  signature is valid, given the inputs.  Note that ECDSA digital
	  signature contains a value referred to as K, which is a random
	  number generated for each digital signature instance. This
	  means that two ECDSA digital signatures using exactly the same
	  input parameters will output different signatures because
	  their K values will be different. The consequence of this is
	  that one must validate an ECDSA signature by submitting the
	  previously specified inputs to an ECDSA validator.
	</t>
	<t>
	  Signing with the ECDSA P-384 SHA-384 and ECDSA P-521 SHA-512
	  algorithms is performed identically to the procedure for ECDSA
	  P-256 SHA-256 - just with correspondingly longer key and
	  result values.
	</t>

      </section>

      <section title="Additional Algorithms" anchor="MoreAlgs">

	<t>
	  Additional algorithms MAY be used to protect JWSs with
	  corresponding <spanx style="verb">alg</spanx> header parameter values being defined to
	  refer to them. New <spanx style="verb">alg</spanx> header parameter values SHOULD
	  either be defined in the IANA JSON Web Signature Algorithms
	  registry or be a URI that contains a collision resistant
	  namespace.  In particular, the use of algorithm identifiers
	  defined in <xref target="RFC3275">XML DSIG</xref> and
	  related specifications is permitted.
	</t>

      </section>
    </section>

    <section title="IANA Considerations" anchor="IANA">
      <t>
	This specification calls for:

        <list style="symbols">

          <t>
	    A new IANA registry entitled "JSON Web Signature Header
	    Parameters" for reserved header parameter names is defined
	    in <xref target="ReservedHeaderParameterName"></xref>.
	    Inclusion in the registry is RFC Required in the <xref
	    target="RFC5226">RFC 5226</xref> sense for reserved JWS
	    header parameter names that are intended to be
	    interoperable between implementations.  The registry will
	    just record the reserved header parameter name and a
	    pointer to the RFC that defines it. This specification
	    defines inclusion of the header parameter names defined in
	    <xref target="HeaderParameterTable"></xref>.
	  </t>
          <t>
	    A new IANA registry entitled "JSON Web Signature Algorithms"
	    for reserved values used with the <spanx style="verb">alg</spanx> header parameter
	    values is defined in <xref target="MoreAlgs"></xref>. Inclusion
	    in the registry is RFC Required in the <xref
	    target="RFC5226">RFC 5226</xref> sense. The registry will
	    just record the <spanx style="verb">alg</spanx> value and a pointer to the RFC that
	    defines it.  This specification defines inclusion of the
	    algorithm values defined in <xref
	    target="AlgTable"></xref>.
	  </t>
        </list>
      </t>
    </section>

    <section title="Security Considerations" anchor="Security">
      <t>
	TBD: Lots of work to do here. We need to remember to look into
	any issues relating to security and JSON parsing. One wonders
	just how secure most JSON parsing libraries are. Were they
	ever hardened for security scenarios? If not, what kind of
	holes does that open up? Also, we need to walk through the
	JSON standard and see what kind of issues we have especially
	around comparison of names.  For instance, comparisons of
	header parameter names and other parameters must occur after
	they are unescaped. Need to also put in text about: Importance
	of keeping secrets secret. Rotating keys. Strengths and
	weaknesses of the different algorithms.
      </t>
      <t>
	TBD: Need to put in text about why strict JSON validation is
	necessary.  Basically, that if malformed JSON is received then
	the intent of the sender is impossible to reliably discern.
      </t>
	<t>
	  TBD: Write security considerations about the implications of
	  using a SHA-1 hash (for compatibility reasons) for the
	  <spanx style="verb">x5t</spanx> (x.509 certificate
	  thumbprint).
	</t>

      <section title="Unicode Comparison Security Issues">

        <t>
	  Header parameter names in JWSs are Unicode strings.  For
	  security reasons, the representations of these names must be
	  compared verbatim after performing any escape processing (as
	  per <xref target="RFC4627">RFC 4627</xref>, Section 2.5).
	</t>
        <t>
	  This means, for instance, that these JSON strings must
	  compare as being equal ("sig", "\u0073ig"), whereas these
	  must all compare as being not equal to the first set or to
	  each other ("SIG", "Sig", "si\u0047").
	</t>
	<t>
	  JSON strings MAY contain characters outside the Unicode
	  Basic Multilingual Plane.  For instance, the G clef
	  character (U+1D11E) may be represented in a JSON string as
	  "\uD834\uDD1E".  Ideally, JWS implementations SHOULD ensure
	  that characters outside the Basic Multilingual Plane are
	  preserved and compared correctly; alternatively, if this is
	  not possible due to these characters exercising limitations
	  present in the underlying JSON implementation, then input
	  containing them MUST be rejected.
	</t>

      </section>
    </section>

    <section title="Open Issues and Things To Be Done (TBD)" anchor="TBD">

      <t>
	The following items remain to be done in this draft (and related drafts):
      </t>

      <list style="symbols">

	<t>
	  Consider whether there is a better term than "Digital
	  Signature" for the concept that includes both HMACs and
	  digital signatures using public keys.
	</t>
	<t>
	  Consider whether we really want to allow private header
	  parameter names that are not registered with IANA and are
	  not in collision-resistant namespaces.  Eventually this
	  could result in interop nightmares where you need to have
	  different code to talk to different endpoints that "knows"
	  about each endpoint's private parameters.
	</t>
	<t>
	  Clarify the optional ability to provide type information in
	  the JWS header.  Specifically, clarify the intended use of
	  the <spanx style="verb">typ</spanx> Header Parameter,
	  whether it conveys syntax or semantics, and indeed, whether
	  this is the right approach.  Also clarify the relationship
	  between these type values and <xref
	  target="RFC2045">MIME</xref> types.
	</t>
	<t>
	  Clarify the semantics of the <spanx style="verb">kid</spanx>
	  (key ID) header parameter.  Open issues include: What
	  happens if a <spanx style="verb">kid</spanx> header is
	  received with an unrecognized value? Is that an error?
	  Should it be treated as if it's empty? What happens if the
	  header has a recognized value but the value doesn't match
	  the key associated with that value, but it does match
	  another key that is associated with the issuer? Is that an
	  error?
	</t>
	<t>
	  Consider whether a key type parameter should also be introduced.
	</t>
	<t>
	  Since RFC 3447 Section 8 explicitly calls for people NOT to
	  adopt RSASSA-PKCS1 for new applications and instead requests
	  that people transition to RSASSA-PSS, we probably need some
	  Security Considerations text explaining why RSASSA-PKCS1 is
	  being used (it's what's commonly implemented) and what the
	  potential consequences are.
	</t>
	<t>
	  Add Security Considerations text on timing attacks.
	</t>
	<t>
	  Finish the Security Considerations section.
	</t>
	<t>
	  Sort out what to do with the IANA registries if this is
	  first standardized as an OpenID specification.
	</t>
	<t>
	  Finish the companion encryption specification, per the
	  agreements documented at http://self-issued.info/?p=378.
	</t>

      </list>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      &RFC1421;

      &RFC1738;

      &RFC2045;

      &RFC2104;

      &rfc2119;

      &RFC3339;

      &RFC3447;

      &RFC3629;

      &RFC3986;

      &RFC4627;

      &RFC4648;

      &RFC5226;

      &RFC5280;

      &RFC5785;

      <reference anchor="FIPS.180-3">
        <front>
          <title>Secure Hash Standard (SHS)</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="October" year="2008" />
        </front>
        <format target="http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf" type="PDF" />
        <seriesInfo name="FIPS" value="PUB 180-3" />
      </reference>

      <reference anchor="FIPS.186-3">
        <front>
          <title>Digital Signature Standard (DSS)</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="June" year="2009" />
        </front>
        <format target="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf" type="PDF" />
        <seriesInfo name="FIPS" value="PUB 186-3" />
      </reference>

      <reference anchor="USA15">
        <front>
          <title>Unicode Normalization Forms</title>

          <author fullname="Mark Davis" initials="M." surname="Davis">
            <address>
              <email>markdavis@google.com</email>
            </address>
          </author>

          <author fullname="Ken Whistler" initials="K." surname="Whistler">
            <address>
              <email>ken@unicode.org</email>
            </address>
          </author>

          <author fullname="Martin D&uuml;rst" initials="M."
                  surname="D&uuml;rst"></author>

          <date day="03" month="09" year="2009" />
        </front>

        <seriesInfo name="Unicode Standard Annex" value="15" />
      </reference>

      <reference anchor="JWT">
        <front>
          <title>JSON Web Token (JWT)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="Dirk Balfanz" initials="D." surname="Balfanz">
	    <organization>Google</organization>
	    <address>
	      <email>balfanz@google.com</email>
	    </address>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	    <address>
	      <email>ve7jtb@ve7jtb.com</email>
	    </address>
	  </author>

	  <author fullname="Yaron Y. Goland" initials="Y.Y." surname="Goland">
	    <organization>Microsoft</organization>
	    <address>
	      <email>yarong@microsoft.com</email>
	    </address>
	  </author>

	  <author fullname="John Panzer" initials="J." surname="Panzer">
	    <organization>Google</organization>
	    <address>
	      <email>jpanzer@google.com</email>
	    </address>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization>Nomura Research Institute</organization>
	    <address>
	      <email>n-sakimura@nri.co.jp</email>
	    </address>
	  </author>

	  <author fullname="Paul Tarjan" initials="P." surname="Tarjan">
	    <organization>Facebook</organization>
	    <address>
	      <email>pt@fb.com</email>
	    </address>
	  </author>

	  <date day="28" month="March" year="2011" />
        </front>
        <format target="http://self-issued.info/docs/draft-jones-json-web-token.html" type="HTML" />
      </reference>

      <reference anchor="JWK">
        <front>
	  <title>JSON Web Key (JWK)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <date day="29" month="April" year="2011" />
        </front>
        <format target="http://self-issued.info/docs/draft-jones-json-web-key.html" type="HTML" />
      </reference>

    </references>

    <references title="Informative References">
      &RFC3275;

      <reference anchor="MagicSignatures">
        <front>
          <title>Magic Signatures</title>

          <author fullname="John Panzer (editor)" initials="J." surname="Panzer (editor)"></author>

          <author fullname="Ben Laurie" initials="B." surname="Laurie"></author>

          <author fullname="Dirk Balfanz" initials="D." surname="Balfanz"></author>

          <date month="August" year="2010" />
        </front>
        <format target="http://salmon-protocol.googlecode.com/svn/trunk/draft-panzer-magicsig-experimental-00.html" type="HTML" />
      </reference>

      <reference anchor="JSS">
        <front>
          <title>JSON Simple Sign</title>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	  </author>

	  <author fullname="Nat Sakimura (editor)" initials="N. " surname="Sakimura (editor)">
	    <organization>Nomura Research Institute</organization>
	  </author>

          <date month="September" year="2010" />
        </front>
        <format target="http://jsonenc.info/jss/1.0/" type="HTML" />
      </reference>

      <reference anchor="CanvasApp">
        <front>
          <title>Canvas Applications</title>

          <author fullname="Facebook" surname="Facebook"></author>

          <date year="2010" />
        </front>
        <format target="http://developers.facebook.com/docs/authentication/canvas" type="HTML" />
      </reference>

      <reference anchor="JWE">
        <front>
          <title>JSON Web Encryption (JWE)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	    <address>
	      <email>ve7jtb@ve7jtb.com</email>
	    </address>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization>Nomura Research Institute</organization>
	    <address>
	      <email>n-sakimura@nri.co.jp</email>
	    </address>
	  </author>

	  <date day="28" month="March" year="2011" />
        </front>
        <format target="http://self-issued.info/docs/draft-jones-json-web-encryption.html" type="HTML" />
      </reference>

      <reference anchor="JCA">
        <front>
          <title>Java Cryptography Architecture</title>

	  <author fullname="Oracle" surname="Oracle">
	  </author>

          <date year="2011" />
        </front>
        <format target="http://download.java.net/jdk7/docs/technotes/guides/security/SunProviders.html" type="HTML" />
      </reference>


    </references>

    <section title="JWS Examples" anchor="JWSExamples">

      <t>
	This section provides several examples of JWSs.  While these
	examples all represent JSON Web Tokens (JWTs) <xref
	target="JWT" />, the payload can be any base64url encoded
	content.
      </t>

      <section title="JWS using HMAC SHA-256" anchor="HMACSHA256Example">
	<section title="Encoding">
	  <t>
	    The following example JSON header object declares that the
	    data structure is a JSON Web Token (JWT) <xref target="JWT" />
	    and the JWS Signing Input is signed using
	    the HMAC SHA-256 algorithm.  Note that white space is
	    explicitly allowed in Decoded JWS Header Input strings and
	    no canonicalization is performed before encoding.
	  </t>

	  <artwork><![CDATA[{"typ":"JWT",
 "alg":"HS256"}]]></artwork>

	  <t>
	    The following byte array contains the UTF-8 characters for
	    the Decoded JWS Header Input:
	  </t>
	  <t>

[123, 34, 116, 121, 112, 34, 58, 34, 74, 87, 84, 34, 44, 13, 10, 32, 34, 97, 108, 103, 34, 58, 34, 72, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Base64url encoding this UTF-8 representation yields this
	    JWS Header Input value:
	  </t>

	  <artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9]]></artwork>

	  <t>
	    The Decoded JWS Payload Input used in this example
	    follows.  (Note that the payload can be any base64url
	    encoded content, and need not be a base64url encoded JSON
	    object.)
	  </t>

	  <artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork>

	  <t>
	     The following byte array contains the UTF-8 characters
	     for the Decoded JWS Payload Input:
	  </t>
	  <t>

[123, 34, 105, 115, 115, 34, 58, 34, 106, 111, 101, 34, 44, 13, 10, 32, 34, 101, 120, 112, 34, 58, 49, 51, 48, 48, 56, 49, 57, 51, 56, 48, 44, 13, 10, 32, 34, 104, 116, 116, 112, 58, 47, 47, 101, 120, 97, 109, 112, 108, 101, 46, 99, 111, 109, 47, 105, 115, 95, 114, 111, 111, 116, 34, 58, 116, 114, 117, 101, 125]

	  </t>
	  <t>
	    Base64url encoding the above yields the JWS Payload Input value:
	  </t>

          <artwork><![CDATA[eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork>

	  <t>
	    Concatenating the JWS Header Input, a period character,
	    and the JWS Payload Input yields this JWS Signing Input
	    value (with line breaks for display purposes only):
	  </t>

	  <artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork>

	  <t>
	    The UTF-8 representation of the JWS Signing Input is the
	    following byte array:
	  </t>
	  <t>

[101, 121, 74, 48, 101, 88, 65, 105, 79, 105, 74, 75, 86, 49, 81, 105, 76, 65, 48, 75, 73, 67, 74, 104, 98, 71, 99, 105, 79, 105, 74, 73, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    HMACs are generated using keys. This example uses the key
	    represented by the following byte array:
	  </t>
	  <t>

[3, 35, 53, 75, 43, 15, 165, 188, 131, 126, 6, 101, 119, 123, 166, 143, 90, 179, 40, 230, 240, 84, 201, 40, 169, 15, 132, 178, 210, 80, 46, 191, 211, 251, 90, 146, 210, 6, 71, 239, 150, 138, 180, 195, 119, 98, 61, 34, 61, 46, 33, 114, 5, 46, 79, 8, 192, 205, 154, 245, 103, 208, 128, 163]

	  </t>
	  <t>
	    Running the HMAC SHA-256 algorithm on the UTF-8
	    representation of the JWS Signing Input with this key
	    yields the following byte array:
	  </t>
	  <t>

[116, 24, 223, 180, 151, 153, 224, 37, 79, 250, 96, 125, 216, 173, 187, 186, 22, 212, 37, 77, 105, 214, 191, 240, 91, 88, 5, 88, 83, 132, 141, 121]

	  </t>
	  <t>
	    Base64url encoding the above HMAC output yields the JWS Crypto
	    Output value:
	  </t>

	  <artwork><![CDATA[dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk]]></artwork>

	</section>
	<section title="Decoding">

	  <t>
	    Decoding the JWS first requires removing the base64url
	    encoding from the JWS Header Input, the JWS Payload
	    Input, and the JWS Crypto Output. We base64url decode
	    the inputs per <xref target="base64urllogic"></xref> and
	    turn them into the corresponding byte arrays.  We
	    translate the header input byte array containing UTF-8
	    encoded characters into the Decoded JWS Header Input
	    string.
	  </t>

	</section>
	<section title="Validating">

	  <t>
	    Next we validate the decoded results.  Since the <spanx style="verb">alg</spanx>
	    parameter in the header is "HS256", we validate the HMAC
	    SHA-256 signature contained in the JWS Crypto Output.  If
	    any of the validation steps fail, the signed content MUST be
	    rejected.
	  </t>
	  <t>
	    First, we validate that the decoded JWS Header Input
	    string is legal JSON.
	  </t>
          <t>
	    To validate the signature, we repeat the previous process
	    of using the correct key and the UTF-8 representation of
	    the JWS Signing Input as input to a SHA-256 HMAC function
	    and then taking the output and determining if it matches
	    the Decoded JWS Crypto Output.  If it matches exactly,
	    the signature has been validated.
	  </t>
	</section>
      </section>

      <section title="JWS using RSA SHA-256" anchor="RSASHA256Example">

	<section title="Encoding">
	  <t>
	    The Decoded JWS Header Input in this example is different
	    from the previous example in two ways:  First, because a
	    different algorithm is being used, the <spanx style="verb">alg</spanx> value is
	    different.  Second, for illustration purposes only, the
	    optional "typ" parameter is not used.  (This difference is
	    not related to the signature algorithm employed.)  The
	    Decoded JWS Header Input used is:
	  </t>

	  <artwork><![CDATA[{"alg":"RS256"}]]></artwork>

	  <t>
	    The following byte array contains the UTF-8 characters for
	    the Decoded JWS Header Input:
	  </t>
	  <t>

[123, 34, 97, 108, 103, 34, 58, 34, 82, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Base64url encoding this UTF-8 representation yields this
	    JWS Header Input value:
	  </t>

	  <artwork><![CDATA[eyJhbGciOiJSUzI1NiJ9]]></artwork>

	  <t>
	    The Decoded JWS Payload Input used in this example, which
	    follows, is the same as in the previous example.  Since
	    the JWS Payload Input will therefore be the same, its
	    computation is not repeated here.
	  </t>

	  <artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork>

	  <t>
	    Concatenating the JWS Header Input, a period character,
	    and the JWS Payload Input yields this JWS Signing Input
	    value (with line breaks for display purposes only):
	  </t>

	  <artwork><![CDATA[eyJhbGciOiJSUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork>

	  <t>
	    The UTF-8 representation of the JWS Signing Input is the
	    following byte array:
	  </t>
	  <t>

[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    The RSA key consists of a public part (n, e), and a
	    private exponent d.  The values of the RSA key used in
	    this example, presented as the byte arrays representing
	    big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Parameter Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>n</c>
	    <c>

[161, 248, 22, 10, 226, 227, 201, 180, 101, 206, 141, 45, 101, 98, 99, 54, 43, 146, 125, 190, 41, 225, 240, 36, 119, 252, 22, 37, 204, 144, 161, 54, 227, 139, 217, 52, 151, 197, 182, 234, 99, 221, 119, 17, 230, 124, 116, 41, 249, 86, 176, 251, 138, 143, 8, 154, 220, 75, 105, 137, 60, 193, 51, 63, 83, 237, 208, 25, 184, 119, 132, 37, 47, 236, 145, 79, 228, 133, 119, 105, 89, 75, 234, 66, 128, 211, 44, 15, 85, 191, 98, 148, 79, 19, 3, 150, 188, 110, 155, 223, 110, 189, 210, 189, 163, 103, 142, 236, 160, 198, 104, 247, 1, 179, 141, 191, 251, 56, 200, 52, 44, 226, 254, 109, 39, 250, 222, 74, 90, 72, 116, 151, 157, 212, 185, 207, 154, 222, 196, 199, 91, 5, 133, 44, 44, 15, 94, 248, 165, 193, 117, 3, 146, 249, 68, 232, 237, 100, 193, 16, 198, 182, 71, 96, 154, 164, 120, 58, 235, 156, 108, 154, 215, 85, 49, 48, 80, 99, 139, 131, 102, 92, 111, 111, 122, 130, 163, 150, 112, 42, 31, 100, 27, 130, 211, 235, 242, 57, 34, 25, 73, 31, 182, 134, 135, 44, 87, 22, 245, 10, 248, 53, 141, 154, 139, 157, 23, 195, 64, 114, 143, 127, 135, 216, 154, 24, 216, 252, 171, 103, 173, 132, 89, 12, 46, 207, 117, 147, 57, 54, 60, 7, 3, 77, 111, 96, 111, 158, 33, 224, 84, 86, 202, 229, 233, 161]

	    </c>

	    <c>e</c>
	    <c>

[1, 0, 1]

	    </c>

	    <c>d</c>
	    <c>

[18, 174, 113, 164, 105, 205, 10, 43, 195, 126, 82, 108, 69, 0, 87, 31, 29, 97, 117, 29, 100, 233, 73, 112, 123, 98, 89, 15, 157, 11, 165, 124, 150, 60, 64, 30, 63, 207, 47, 44, 211, 189, 236, 136, 229, 3, 191, 198, 67, 155, 11, 40, 200, 47, 125, 55, 151, 103, 31, 82, 19, 238, 216, 193, 90, 37, 216, 213, 206, 160, 2, 94, 227, 171, 46, 139, 127, 121, 33, 111, 198, 59, 234, 86, 39, 83, 180, 6, 68, 198, 161, 81, 39, 217, 178, 149, 69, 64, 160, 187, 225, 163, 5, 86, 152, 45, 78, 159, 222, 95, 100, 37, 241, 77, 75, 113, 52, 65, 181, 93, 199, 59, 155, 74, 237, 204, 146, 172, 227, 146, 126, 55, 245, 125, 12, 253, 94, 117, 129, 250, 81, 44, 143, 73, 97, 169, 235, 11, 128, 248, 168, 7, 70, 114, 138, 85, 255, 70, 71, 31, 52, 37, 6, 59, 157, 83, 100, 47, 94, 222, 30, 132, 214, 19, 8, 26, 250, 92, 34, 208, 81, 40, 91, 214, 59, 148, 59, 86, 93, 137, 138, 5, 104, 84, 19, 229, 60, 60, 108, 101, 37, 255, 31, 227, 78, 61, 220, 112, 240, 213, 100, 80, 253, 164, 139, 161, 46, 16, 78, 157, 235, 159, 184, 24, 129, 225, 196, 189, 242, 93, 146, 71, 244, 80, 200, 101, 146, 121, 104, 231, 115, 52, 244, 65, 79, 117, 167, 80, 225, 57, 84, 110, 58, 138, 115, 157]

	    </c>
	  </texttable>

	  <t>
	    The RSA private key (n, d) is then passed to the RSA
	    signing function, which also takes the hash type, SHA-256,
	    and the UTF-8 representation of the JWS Signing Input as
	    inputs.  The result of the signature is a byte array S,
	    which represents a big endian integer.  In this example, S
	    is:
	  </t>

	  <texttable>
	    <ttcol align="left">Result Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>S</c>
	    <c>

[112, 46, 33, 137, 67, 232, 143, 209, 30, 181, 216, 45, 191, 120, 69, 243, 65, 6, 174, 27, 129, 255, 247, 115, 17, 22, 173, 209, 113, 125, 131, 101, 109, 66, 10, 253, 60, 150, 238, 221, 115, 162, 102, 62, 81, 102, 104, 123, 0, 11, 135, 34, 110, 1, 135, 237, 16, 115, 249, 69, 229, 130, 173, 252, 239, 22, 216, 90, 121, 142, 232, 198, 109, 219, 61, 184, 151, 91, 23, 208, 148, 2, 190, 237, 213, 217, 217, 112, 7, 16, 141, 178, 129, 96, 213, 248, 4, 12, 167, 68, 87, 98, 184, 31, 190, 127, 249, 217, 46, 10, 231, 111, 36, 242, 91, 51, 187, 230, 244, 74, 230, 30, 177, 4, 10, 203, 32, 4, 77, 62, 249, 18, 142, 212, 1, 48, 121, 91, 212, 189, 59, 65, 238, 202, 208, 102, 171, 101, 25, 129, 253, 228, 141, 247, 127, 55, 45, 195, 139, 159, 175, 221, 59, 239, 177, 139, 93, 163, 204, 60, 46, 176, 47, 158, 58, 65, 214, 18, 202, 173, 21, 145, 18, 115, 160, 95, 35, 185, 232, 56, 250, 175, 132, 157, 105, 132, 41, 239, 90, 30, 136, 121, 130, 54, 195, 212, 14, 96, 69, 34, 165, 68, 200, 242, 122, 122, 45, 184, 6, 99, 209, 108, 247, 202, 234, 86, 222, 64, 92, 178, 33, 90, 69, 178, 194, 85, 102, 181, 90, 193, 167, 72, 160, 112, 223, 200, 163, 42, 70, 149, 67, 208, 25, 238, 251, 71]

	    </c>
	  </texttable>

	  <t>
	    Base64url encoding the signature produces this value for
	    the JWS Crypto Output:
	  </t>

	  <artwork><![CDATA[cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqvhJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrBp0igcN_IoypGlUPQGe77Rw]]></artwork>

	</section>
	<section title="Decoding">

	  <t>
	    Decoding the JWS from this example requires processing the
	    JWS Header Input and JWS Payload Input exactly as
	    done in the first example.
	  </t>

	</section>
	<section title="Validating">

	  <t>
	    Since the <spanx style="verb">alg</spanx> parameter in the header is "RS256", we
	    validate the RSA SHA-256 signature contained in the JWS
	    Crypto Output.  If any of the validation steps fail, the
	    signed content MUST be rejected.
	  </t>
	  <t>
	    First, we validate that the decoded JWS Header Input
	    string is legal JSON.
	  </t>
	  <t>
	    Validating the JWS Crypto Output is a little different
	    from the previous example. First, we base64url decode the
	    JWS Crypto Output to produce a signature S to check.  We
	    then pass (n, e), S and the UTF-8 representation of the
	    JWS Signing Input to an RSA signature verifier that has
	    been configured to use the SHA-256 hash function.
	  </t>

	</section>
      </section>

      <section title="JWS using ECDSA P-256 SHA-256" anchor="ECDSASHA256Example">
	<section title="Encoding">
	  <t>
	    The Decoded JWS Header Input for this example differs from
	    the previous example because a different algorithm is
	    being used.  The Decoded JWS Header Input used is:
	  </t>

	  <artwork><![CDATA[{"alg":"ES256"}]]></artwork>

	  <t>
	    The following byte array contains the UTF-8 characters for
	    the Decoded JWS Header Input:
	  </t>
	  <t>

[123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Base64url encoding this UTF-8 representation yields this
	    JWS Header Input value:
	  </t>

	  <artwork><![CDATA[eyJhbGciOiJFUzI1NiJ9]]></artwork>

	  <t>
	    The Decoded JWS Payload Input used in this example, which
	    follows, is the same as in the previous examples.  Since
	    the JWS Payload Input will therefore be the same, its
	    computation is not repeated here.
	  </t>

	  <artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork>

	  <t>
	    Concatenating the JWS Header Input, a period character,
	    and the JWS Payload Input yields this JWS Signing Input
	    value (with line breaks for display purposes only):
	  </t>

	  <artwork><![CDATA[eyJhbGciOiJFUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork>

	  <t>
	    The UTF-8 representation of the JWS Signing Input is the
	    following byte array:
	  </t>
	  <t>

[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 70, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    The ECDSA key consists of a public part, the EC point (x,
	    y), and a private part d.  The values of the ECDSA key
	    used in this example, presented as the byte arrays
	    representing big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Parameter Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>x</c>
	    <c>

[127, 205, 206, 39, 112, 246, 196, 93, 65, 131, 203, 238, 111, 219, 75, 123, 88, 7, 51, 53, 123, 233, 239, 19, 186, 207, 110, 60, 123, 209, 84, 69]

	    </c>

	    <c>y</c>
	    <c>

[199, 241, 68, 205, 27, 189, 155, 126, 135, 44, 223, 237, 185, 238, 185, 244, 179, 105, 93, 110, 169, 11, 36, 173, 138, 70, 35, 40, 133, 136, 229, 173]

	    </c>

	    <c>d</c>
	    <c>

[142, 155, 16, 158, 113, 144, 152, 191, 152, 4, 135, 223, 31, 93, 119, 233, 203, 41, 96, 110, 190, 210, 38, 59, 95, 87, 194, 19, 223, 132, 244, 178]

	    </c>
	  </texttable>

	  <t>
	    The ECDSA private part d is then passed to an ECDSA
	    signing function, which also takes the curve type, P-256,
	    the hash type, SHA-256, and the UTF-8 representation of
	    the JWS Signing Input as inputs.  The result of the
	    signature is the EC point (R, S), where R and S are
	    unsigned integers.  In this example, the R and S values,
	    given as byte arrays representing big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Result Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>R</c>
	    <c>

[14, 209, 33, 83, 121, 99, 108, 72, 60, 47, 127, 21, 88, 7, 212, 2, 163, 178, 40, 3, 58, 249, 124, 126, 23, 129, 154, 195, 22, 158, 166, 101]

	    </c>

	    <c>S</c>
	    <c>

[197, 10, 7, 211, 140, 60, 112, 229, 216, 241, 45, 175, 8, 74, 84, 128, 166, 101, 144, 197, 242, 147, 80, 154, 143, 63, 127, 138, 131, 163, 84, 213]

	    </c>
	  </texttable>

	  <t>
	    Concatenating the S array to the end of the R array and
	    base64url encoding the result produces this value for the
	    JWS Crypto Output:
	  </t>

	  <artwork><![CDATA[DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSApmWQxfKTUJqPP3-Kg6NU1Q]]></artwork>

	</section>
	<section title="Decoding">

	  <t>
	    Decoding the JWS from this example requires processing the
	    JWS Header Input and JWS Payload Input exactly as
	    done in the first example.
	  </t>

	</section>
	<section title="Validating">

	  <t>
	    Since the <spanx style="verb">alg</spanx> parameter in the header is "ES256", we
	    validate the ECDSA P-256 SHA-256 signature contained in
	    the JWS Crypto Output.  If any of the validation steps
	    fail, the signed content MUST be rejected.
	  </t>
	  <t>
	    First, we validate that the decoded JWS Header Input
	    string is legal JSON.
	  </t>
	  <t>
	    Validating the JWS Crypto Output is a little different
	    from the first example. First, we base64url decode the JWS
	    Crypto Output as in the previous examples but we then
	    need to split the 64 member byte array that must result
	    into two 32 byte arrays, the first R and the second S. We
	    then pass (x, y), (R, S) and the UTF-8 representation of
	    the JWS Signing Input to an ECDSA signature verifier that
	    has been configured to use the P-256 curve with the
	    SHA-256 hash function.
	  </t>
	  <t>
	    As explained in <xref target="DefiningECDSA"></xref>, the
	    use of the k value in ECDSA means that we cannot validate
	    the correctness of the signature in the same way we
	    validated the correctness of the HMAC. Instead,
	    implementations MUST use an ECDSA validator to validate
	    the signature.
	  </t>

	</section>
      </section>

    </section>

    <section title="Algorithm Identifier Cross-Reference" anchor="algxref">
      <t>
	This appendix contains a table cross-referencing the <spanx
	style="verb">alg</spanx> values used in this specification
	with the equivalent identifiers used by other standards and
	software packages.  See <xref target="RFC3275">XML DSIG</xref>
	and <xref target="JCA">Java Cryptography Architecture</xref>
	for more information about the names defined by those
	documents.

      </t>
      <texttable title="Algorithm Identifier Cross-Reference" anchor="algxreftable">

	<ttcol align="left">Algorithm</ttcol>
	<ttcol align="left">JWS</ttcol>
	<ttcol align="left">XML DSIG</ttcol>
	<ttcol align="left">JCA</ttcol>
	<ttcol align="left">OID</ttcol>

	<c>HMAC using SHA-256 hash algorithm</c>
	<c>HS256</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#hmac-sha256</c>
	<c>HmacSHA256</c>
	<c>1.2.840.113549.2.9</c>

	<c>HMAC using SHA-384 hash algorithm</c>
	<c>HS384</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#hmac-sha384</c>
	<c>HmacSHA384</c>
	<c>1.2.840.113549.2.10</c>

	<c>HMAC using SHA-512 hash algorithm</c>
	<c>HS512</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#hmac-sha512</c>
	<c>HmacSHA512</c>
	<c>1.2.840.113549.2.11</c>

	<c>RSA using SHA-256 hash algorithm</c>
	<c>RS256</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#rsa-sha256</c>
	<c>SHA256withRSA</c>
	<c>1.2.840.113549.1.1.11</c>

	<c>RSA using SHA-384 hash algorithm</c>
	<c>RS384</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#rsa-sha384</c>
	<c>SHA384withRSA</c>
	<c>1.2.840.113549.1.1.12</c>

	<c>RSA using SHA-512 hash algorithm</c>
	<c>RS512</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#rsa-sha512</c>
	<c>SHA512withRSA</c>
	<c>1.2.840.113549.1.1.13</c>

	<c>ECDSA using P-256 curve and SHA-256 hash algorithm</c>
	<c>ES256</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256</c>
	<c>SHA256withECDSA</c>
	<c>1.2.840.10045.3.1.7</c>

	<c>ECDSA using P-384 curve and SHA-384 hash algorithm</c>
	<c>ES384</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384</c>
	<c>SHA384withECDSA</c>
	<c>1.3.132.0.34</c>

	<c>ECDSA using P-521 curve and SHA-512 hash algorithm</c>
	<c>ES512</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512</c>
	<c>SHA512withECDSA</c>
	<c>1.3.132.0.35</c>

      </texttable>
    </section>

    <section title="Notes on implementing base64url encoding without padding" anchor="base64urlnotes">

      <t>
	This appendix describes how to implement base64url encoding
	and decoding functions without padding based upon standard
	base64 encoding and decoding functions that do use padding.
      </t>
      <t>
	To be concrete, example C# code implementing these functions
	is shown below.  Similar code could be used in other
	languages.
      </t>

      <artwork><![CDATA[static string base64urlencode(byte [] arg)
{
  string s = Convert.ToBase64String(arg); // Standard base64 encoder
  s = s.Split('=')[0]; // Remove any trailing '='s
  s = s.Replace('+', '-'); // 62nd char of encoding
  s = s.Replace('/', '_'); // 63rd char of encoding
  return s;
}

static byte [] base64urldecode(string arg)
{
  string s = arg;
  s = s.Replace('-', '+'); // 62nd char of encoding
  s = s.Replace('_', '/'); // 63rd char of encoding
  switch (s.Length % 4) // Pad with trailing '='s
  {
    case 0: break; // No pad chars in this case
    case 2: s += "=="; break; // Two pad chars
    case 3: s += "="; break; // One pad char
    default: throw new System.Exception(
      "Illegal base64url string!");
  }
  return Convert.FromBase64String(s); // Standard base64 decoder
}]]></artwork>

      <t>
	As per the example code above, the number of '=' padding
	characters that needs to be added to the end of a base64url
	encoded string without padding to turn it into one with
	padding is a deterministic function of the length of the
	encoded string.  Specifically,

	if the length mod 4 is 0, no padding is added;
	if the length mod 4 is 2, two '=' padding characters are added;
	if the length mod 4 is 3, one '=' padding character is added;
	if the length mod 4 is 1, the input is malformed.
      </t>
      <t>
	An example correspondence between unencoded and encoded values
	follows.  The byte sequence below encodes into the string
	below, which when decoded, reproduces the byte sequence.
      </t>

      <artwork>3 236 255 224 193</artwork>

      <artwork>A-z_4ME</artwork>
    </section>

    <section title="Acknowledgements" anchor="Acknowledgements">

      <t>
	Solutions for signing JSON content were previously explored by
	<xref target="MagicSignatures">Magic Signatures</xref>, <xref
	target="JSS">JSON Simple Sign</xref>, and <xref
	target="CanvasApp">Canvas Applications</xref>, all of which
	influenced this draft.
      </t>

    </section>

    <section title='Document History'>
      <t>
        -02
        <list style='symbols'>
	  <t>
	    Reference the JSON Web Key (JWK) specification from the
	    <spanx style="verb">jku</spanx> header parameter.
	  </t>
        </list>
      </t>
      <t>
        -01
        <list style='symbols'>
	  <t>
	    Changed RSA SHA-256 from MUST be supported to RECOMMENDED
	    that it be supported.  Rationale: Several people have
	    objected to the requirement for implementing RSA SHA-256,
	    some because they will only be using HMACs and symmetric
	    keys, and others because they only want to use ECDSA when
	    using asymmetric keys, either for security or key length
	    reasons, or both.
	  </t>
	  <t>
	    Clarified that <spanx style="verb">x5u</spanx> is an HTTPS
	    URL referencing a PEM-encoded certificate or certificate
	    chain.
	  </t>
	  <t>
	    Clarified that the <spanx style="verb">alg</spanx>
	    parameter value is case sensitive.
	  </t>
	  <t>
	    Changed <spanx style="verb">x5t</spanx> (x.509 certificate
	    thumbprint) to use a SHA-1 hash, rather than a SHA-256
	    hash, for compatibility reasons.
	  </t>
        </list>
      </t>
      <t>
        -00
        <list style='symbols'>
          <t>
            Created first signature draft using content split from
            draft-jones-json-web-token-01.  This split introduced no
            semantic changes.
          </t>
        </list>
      </t>
    </section>     

  </back>
</rfc>
