<?xml version="1.0" encoding="UTF-8"?><?rfc linefile="1:draft-ietf-dnsop-rfc4641bis.xml"?>
<!-- automatically generated by xml2rfc v1.35pre1 on 2012-02-14T10:10:12Z -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc rfcedstyle="yes"?>
<?rfc subcompact="no"?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="no" ?>
<?rfc sortrefs="no" ?>

<rfc ipr="pre5378Trust200902" obsoletes="4641" category="info" docName="draft-ietf-dnsop-rfc4641bis-09">
  
  
  
  <front>
    <title>DNSSEC Operational Practices, Version 2</title>
    
    <author initials="O." surname="Kolkman" fullname="Olaf M. Kolkman">
      <organization>NLnet Labs</organization>
      <address>
	<postal>
	  <street>Science Park 400</street>
	  <city>Amsterdam</city>
	  <code>1098 XH</code>
	  <country>The Netherlands</country>
	</postal>
	<email>olaf@nlnetlabs.nl</email>
	<uri>http://www.nlnetlabs.nl</uri>
      </address>
    </author>

    <author initials="W." surname="Mekking" fullname="W. (Matthijs) Mekking">
      <organization>NLnet Labs</organization>
      <address>
	<postal>
	  <street>Science Park 400</street>
	  <city>Amsterdam</city>
	  <code>1098 XH</code>
	  <country>The Netherlands</country>
	</postal>
	<email>matthijs@nlnetlabs.nl</email>
	<uri>http://www.nlnetlabs.nl</uri>
      </address>
    </author>

    <date month="Feb" day="14" year="2012" />
    <area>Operations and Management</area>
    <workgroup>DNSOP</workgroup>
    <keyword>DNSSEC</keyword>
    <keyword>operational</keyword>
    <abstract>
      <t>
	This document describes a set of practices for operating the
	DNS with security extensions (DNSSEC).  The target audience is
	zone administrators deploying DNSSEC.
      </t>
      <t>
	The document discusses operational aspects of using keys and
	signatures in the DNS. It discusses issues of key generation,
	key storage, signature generation, key rollover, and related
	policies.
      </t>
      <t>
        This document obsoletes RFC 4641 as it covers more
        operational ground and gives more up-to-date requirements with
        respect to key sizes and the DNSSEC operations.
      </t>
    </abstract>
  </front>
  
  <!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  -->
  <middle>
    
    
    <?rfc?><?rfc linefile="1:Introduction.xml"?>



<section title="Introduction">
  <t>
    This document describes how to run a DNS Security (DNSSEC)-enabled
    environment. It is intended for operators who have knowledge of
    the DNS (see <xref target="RFC1034">RFC 1034</xref> and <xref
    target="RFC1035">RFC 1035</xref>) and want to deploy DNSSEC (<xref
    target="RFC4033">RFC 4033</xref>, <xref target="RFC4034">RFC
    4034</xref>, and <xref target="RFC4035">RFC 4035</xref>). The
    focus of the document is on serving authoritative DNS information
    and is aimed at zone owners, name server operators, registries,
    registrars and registrants. It assumes that there is no direct
    relation between those entities and the operators of validating
    recursive name servers (validators).
  </t>
  
  <t>
    During workshops and early operational deployment, operators and
    system administrators have gained experience about operating the
    DNS with security extensions (DNSSEC).  This document translates
    these experiences into a set of practices for zone
    administrators. At the time of writing -the root has just been
    signed and the first secure delegations are provisioned- there
    exists relatively little experience with DNSSEC in production
    environments below the TLD level; this document should therefore
    explicitly not be seen as representing 'Best Current Practices'.
    Instead, it describes the decisions that should be made when
    deploying DNSSEC, gives the choices available for each one, and
    provides some operational guidelines. The document does not give
    strong recommendations, that may be subject for a future version
    of this document.
  </t>
  
  <t>
    The procedures herein are focused on the maintenance of signed
    zones (i.e., signing and publishing zones on authoritative
    servers). It is intended that maintenance of zones such as
    re-signing or key rollovers be transparent to any verifying
    clients.
  </t>
  
  
  <t>
    The structure of this document is as follows. In <xref
    target="trustchain"/>, we discuss the importance of keeping the
    "chain of trust" intact.  Aspects of key generation and storage of
    keys are discussed in <xref target="keys"/>; the focus in
    this section is mainly on the security of the private part of the key(s).  <xref
    target="sigs_keyrolls_policies"/> describes considerations
    concerning the public part of the keys. <xref target="keyroll"/> and
    <xref target="emergency"/> deal with the rollover, or replacement, of keys. <xref
    target="parents"/> discusses considerations on how parents deal
    with their children's public keys in order to maintain chains of
    trust. <xref target="time"/> covers all kinds of timing issues around keys publication.
    <xref target="nsec_nsec3"/> covers the considerations regarding selecting and using
    NSEC and <xref target="RFC5155">NSEC3</xref>.
  </t>
  <t>
    The typographic conventions used in this document are explained in
    <xref target="typography" />.
  </t>
  
  <t>
    Since this is a document with operational suggestions and there
    are no protocol specifications, the <xref target="RFC2119">RFC
    2119</xref> language does not apply.
  </t>
  
  <t>
    This document obsoletes <xref target="RFC4641">RFC 4641</xref>.
  </t>
  
  <section title="The Use of the Term 'key'">
    
    <t>
      It is assumed that the reader is familiar with the concept of
      asymmetric keys on which DNSSEC is based (public key
      cryptography <xref target="RFC4949">RFC4949</xref>). Therefore,
      this document will use the term 'key' rather loosely. Where it
      is written that 'a key is used to sign data' it is assumed that
      the reader understands that it is the private part of the key
      pair that is used for signing. It is also assumed that the
      reader understands that the public part of the key pair is
      published in the DNSKEY Resource Record and that it is the
      public part that is used in key exchanges.
    </t>
    
    
  </section> <!-- The usage of the term key -->
  
  
  <section title="Time Definitions">
    
    <t>
      In this document, we will be using a number of time-related
      terms. The following definitions apply:
    </t>
    <t>
      <list style="symbols">
	<t>
	  "Signature validity period" The period that a signature is
	  valid.  It starts at the time specified in the signature
	  inception field of the RRSIG RR and ends at the time
	  specified in the expiration field of the RRSIG RR.
	</t>
		
	<t>
	  "Signature publication period" The period that a signature is published.
	  It starts at the time the signature is introduced in the zone for
	  the first time and ends at the time when the signature is removed
	  or replaced with a new signature.
	  After one stops publishing an RRSIG in a zone, it may take a
	  while before the RRSIG has expired from caches and has
	  actually been removed from the DNS.
	</t>
	
	<t>
	  "Key effectivity period" The period during which a key pair
	  is expected to be effective. It is defined as the
	  time between the first inception time stamp and the last
	  expiration date of any signature made with this key,
	  regardless of any discontinuity in the use of the key.  The
	  key effectivity period can span multiple signature validity
	  periods.
	</t>
	
	<t>
	  "Maximum/Minimum Zone Time to Live (TTL)" The maximum or
	  minimum value of the TTLs from the complete set of RRs in a
	  zone. Note that the minimum TTL is not the same as the
	  MINIMUM field in the SOA RR. See <xref target="RFC2308">RFC2308</xref>
	  for more information.
	</t>
	
	
      </list>
    </t>
  </section> <!--Time definitions -->
  
  
</section> <!-- Introduction -->
<?rfc linefile="75:draft-ietf-dnsop-rfc4641bis.xml"?>

    
    <?rfc?><?rfc linefile="1:trustchain.xml"?>

    <section anchor="trustchain" title="Keeping the Chain of Trust Intact">


      <t>
	Maintaining a valid chain of trust is important because broken
	chains of trust will result in data being marked as Bogus (as
	defined in <xref target="RFC4033">RFC4033</xref> Section 5),
	which may cause entire (sub)domains to become invisible to
	verifying clients. The administrators of secured zones need to
	realize that, to verifying clients, their zone is part of a
	chain of trust.
	</t>
	<t>
	  As mentioned in the introduction, the procedures herein are
	  intended to ensure that maintenance of zones, such as re-signing or
	  key rollovers, will be transparent to the verifying clients on the
	  Internet.
	</t>
	<t>
	Administrators of secured zones will need to keep in mind that data
	published on an authoritative primary server will not be
	immediately seen by verifying clients; it may take some time for
	the data to be transferred to other (secondary) authoritative
	name servers and clients may be fetching data from caching
	non-authoritative servers. In this light, note that
	the time until the data is available on the slave
	can be negligible when
        using NOTIFY <xref target="RFC1996"/> and incremental transfer
        (IXFR) <xref target="RFC1995"/>.  It increases when full zone
        transfers (AXFR) are used in combination
        with NOTIFY.  It increases even more if you rely on full zone
        transfers based on only the SOA timing parameters for refresh.
	</t>
	<t>
	  For the verifying clients, it is important that data from
	  secured zones can be used to build chains of trust
	  regardless of whether the data came directly from an
	  authoritative server, a caching name server, or some middle
	  box. Only by carefully using the available timing parameters
	  can a zone administrator ensure that the data necessary for
	  verification can be obtained.
	</t>

	<t>
	  The responsibility for maintaining the chain of trust is
	  shared by administrators of secured zones in the chain of
	  trust.  This is most obvious in the case of a 'key
	  compromise' when a trade-off must be made  between maintaining a valid
	  chain of trust and replacing the compromised keys as soon as
	  possible.  Then zone administrators will have
	  to decide, between keeping the chain of trust
	  intact - thereby allowing for attacks with the compromised
	  key - or deliberately breaking the chain of trust and making
	  secured subdomains invisible to security-aware
	  resolvers. (Also see <xref target="emergency"/>.)

	</t>


      </section><!-- Keeping the chain of trust intact -->




<?rfc linefile="78:draft-ietf-dnsop-rfc4641bis.xml"?>
    
    <?rfc?><?rfc linefile="1:Keys.xml"?>
<section anchor="keys" title="Keys Generation and Storage"> <!-- Keys -->
  
  <t>
    This section describes a number of considerations with respect to
    the use of keys. For the design of a operational procedure for key
    generation and storage then a number of decisions need to be made:
    <list style='symbols'>
      <t>
	Does one differentiate between Zone Signing Keys and Key Signing
	Keys or is the use of one type of key sufficient?
      </t>
      <t>
	Are Key Signing Keys (likely to be) in use as trust anchors <xref target="RFC4033" />?
      </t>
      <t>
	What are the timing parameters that are allowed by the
	operational requirements?
      </t>
      <t>
	What are the cryptographic parameters that fit the operational
	need?
      </t>
    </list>
    The following section discusses  the considerations that need to be taken into account
    when making those choices.
  </t>
  
  
  <section title="Operational Motivation for Zone Signing Keys and Key Signing Keys" anchor="zsk-ksk-motivation">
    <t>
      The DNSSEC validation protocol does not distinguish between
      different types of DNSKEYs. The motivations to differentiate
      between keys are purely operational; validators will not make a
      distinction.
    </t>
    <t>
      For operational reasons, described below, it is possible to
      designate one or more keys to have the role of Key Signing Keys (KSKs). These
      keys will only sign the apex DNSKEY RRset in a zone. Other keys
      can be used to sign all the other RRsets in a zone that require
      signatures. They are referred to as Zone Signing Keys (ZSKs). In
      case the differentiation between KSK and ZSK is not made, keys have
      both the role of KSK and ZSK, we talk
      about a Single Type signing scheme.
    </t>
    <t>
      If the two functions are separated, then for almost any method
      of key management and zone signing, the KSK is used less
      frequently than the ZSK. Once a key set is signed with the KSK,
      all the keys in the key set can be used as ZSKs.  If there has
      been an event that increases the risk that a ZSK is compromised
      it can be simply dropped from the key set. The new key set is
      then re-signed with the KSK.
    </t>
    <t>
      Changing a key that is a secure entry point (SEP) <xref target="RFC4034" />
      for a zone
      can be relatively expensive as it involves interaction with 3rd
      parties: When a key is only pointed to by a DS record in the
      parent zone, one needs to complete the interaction with the
      parent and wait for the updated DS record to
      appear in the DNS.  In the case where a key is configured as a
      trust anchor, one has to wait until one has sufficient confidence
      that all trust anchors have been replaced. In fact, it may be
      that one is not able to reach the complete user-base with
      information about the key rollover.
    </t>
    <t>
      Given the assumption that for KSKs the SEP flag is set, the
      KSK can be distinguished from a ZSK by examining the flag
      field in the DNSKEY RR: If the flag field is an odd number the RR
      is a KSK; otherwise it is a ZSK.
    </t> 
    <t>
      There is also a risk that keys are compromised through theft or
      loss. For keys that are installed on file-systems of name servers
      that are connected to the network (e.g. for dynamic updates),
      that risk is relatively high. Where keys are stored on Hardware
      Security Modules (HSMs) or stored off-line, such risk is
      relatively low. However, storing keys off-line or with more 
      limitation on access control has a negative effect on the 
      operational flexibility. By separating the KSK and ZSK functionality,
      these risks can be managed while making the tradeoff against the
      involved costs. For example, a KSK can be stored off-line or
      with more limitation on access control than ZSKs which need to
      be readily available for operational purposes such as the
      addition or deletion of zone data. A KSK stored on a smartcard,
      that is kept in a safe, combined with a ZSK stored
      on a filesystem accessible by operators for daily routine may
      provide a better protection against key compromise, without losing
      much operational flexibility. It must be said that some HSMs give
      the option to have your keys online, giving more protection and
      hardly affecting the the operational flexibility. In those cases,
      a KSK-ZSK split is not more beneficial than the Single-Type signing
      scheme.
    </t>
    <t>
      Finally there is a risk of cryptanalysis of the key material.
      The costs of such analysis are correlated to the length of the
      key. However, cryptanalysis arguments provide no strong
      motivation for a KSK/ZSK split. Suppose one differentiates
      between a KSK and a ZSK whereby the KSK effectivity period is X
      times the ZSK effectivity period. Then, in order for the
      resistance to cryptanalysis to be the same for the KSK and the
      ZSK, the KSK needs to be X times stronger than the ZSK. Since
      for all practical purposes X will somewhere of the order of 10
      to 100, the associated key sizes will vary only about a byte in
      size for symmetric keys. When translated to asymmetric keys, is
      still too insignificant a size difference to warrant a
      key-split; it only marginally affects the packet size and
      signing speed.
    </t>
    
    <t>
      The arguments for differentiation between the ZSK and KSK are
      weakest when:
      <list style="symbols">
	<t>
	  the exposure to risk is low (e.g. when keys are stored on
	  HSMs);
	</t>
	<t>
	  one can be certain that a key is not used as a
	  trust anchor; 
	</t>
	<t>
	  maintenance of the various keys cannot be performed
	  through tools (is prone to human error); and
	</t>  
	<t> 
	  the interaction through the child-parent
	  provisioning chain -- in particular the timely appearance
	  of a new DS record in the parent zone in emergency
	  situations -- is predictable.
	</t>
      </list>
      If the above holds then the costs of the operational
      complexity of a KSK-ZSK split may outweigh the costs of
      operational flexibility and choosing a single type signing
      scheme is a reasonable option. In other cases we advise
      that the separation between KSKs and ZSKs is made and that the
      SEP flag is exclusively set on KSKs.
    </t>
  </section>
  <section anchor="zsk-ksk-practicalites" title="Practical
						 Consequences of KSK and ZSK Separation">
   
   <t>
   A key that acts only as a Zone Signing Key can be used to sign all the data except the DNSKEY RRset in a zone on a
   regular basis.  When a ZSK is to be rolled, no
   interaction with the parent is needed.  This allows for signature
   validity periods on the order of days.
   </t>

    <t>
      A key with only the Key Signing Key role is to be used to sign the DNSKEY RRs
      in a zone. If a KSK is to be rolled, there may be
      interactions with other parties. These can include the administrators of the
      parent zone or administrators of verifying resolvers that
      have the particular key configured as secure entry points. In
      the latter case, everyone relying on the trust anchor needs to
      roll over to the new key, a process that may be subject to
      stability costs if automated trust anchor rollover mechanisms
      (such as e.g. <xref target="RFC5011">RFC5011</xref>) are not
      in place.  Hence, the key effectivity period of these keys can
      and should be made much longer.
    </t> 
    
    <section title="Rolling a KSK that is not a trust anchor">
      <t>
	There are 3 schools of thought on rolling a KSK that is not a
	trust anchor:
	<list style="symbols">
	  <t> 
	    It should be done frequently and regularly (possibly every
	    few months) so that a key rollover remains an operational
	    routine.
	  </t>
	  <t> 
	    It should be done frequently but irregularly. Frequently
	    meaning every few months, again based on the argument that
	    a rollover is a practiced and common operational
	    routine, and irregular meaning with a large jitter, so that
	    3rd parties do not start to rely on the key and will not
	    be tempted to configure it as a trust anchor.
	  </t>
	  <t>
	    It should only be done when it is known or strongly
	    suspected that the key can be or has been compromised, or
		when a new algorithm or key storage is required.
	    <!-- I do not understand this sentence : in order to
	         reduce the stability issues on systems where the
	         rollover does not happen cleanly.
	    -->
	  </t>
	</list>
	There is no widespread agreement on which of these three
	schools of thought is better for different deployments of
	DNSSEC.  There is a stability cost every time a non-anchor KSK
	is rolled over, but it is possibly low if the communication
	between the child and the parent is good.  On the other hand,
	the only completely effective way to tell if the communication
	is good is to test it periodically.  Thus, rolling a KSK with
	a parent is only done for two reasons: to test and verify the
	rolling system to prepare for an emergency, and in the case of
	(preventing) an actual emergency.
      </t>
      <t>      
	Finally, in most cases a zone administrator cannot be fully certain
	that the zone's KSK is not in use as a trust anchor
	somewhere. While the configuration of trust anchors is not the
	responsibility of the zone administrator there may be stability costs
	for the validator administrator that (wrongfully) configured
	the trust anchor when the zone administrator rolls a KSK.
      </t>
    </section>
    <section anchor="rolling-ksk-ta" title="Rolling a KSK that is a trust anchor">
      <t>
	The same operational concerns apply to the rollover of KSKs
	that are used as trust anchors: if a trust anchor replacement
	is done incorrectly, the entire domain that the trust anchor
	covers will become bogus until the trust anchor is corrected.
      </t>
      
      <t>
	In a large number of cases it will be safe to work from the
	assumption that one's keys are not in use as trust anchors. If
	a zone administrator publishes a "DNSSEC Signing Policy and Practice
	Statement" <xref target="I-D.ietf-dnsop-dnssec-dps-framework"
	/> that should be explicit about the fact whether the
	existence of trust anchors will be taken into account in any
	way or not. There may be cases where local policies enforce
	the configuration of trust anchors on zones which are mission
	critical (e.g. in enterprises where the trust anchor for the
	enterprise domain is configured in the enterprise's validator).
	It is expected that the zone administrators are aware of such
	circumstances.
      </t>
      
      <t>
	One can argue that because of the difficulty of getting all
	users of a trust anchor to replace an old trust anchor with a
	new one, a KSK that is a trust anchor should never be rolled
	unless it is known or strongly suspected that the key has been
	compromised.  In other words the costs of a KSK rollover are
	prohibitively high because some users cannot be reached.
      </t>
      
      <t>
	However, the "operational habit" argument also applies to
	trust anchor reconfiguration at the clients' validators. If a
	short key effectivity period is used and the trust anchor
	configuration has to be revisited on a regular basis, the odds
	that the configuration tends to be forgotten is smaller. In
	fact, the costs for those users can be minimized by automating
	the rollover with <xref target="RFC5011">RFC5011</xref> and by
	rolling the key regularly (and advertising such) so that the
	operators of validating resolvers will put the appropriate
	mechanism in place to deal with these stability costs: in
	other words, budget for these costs instead of incurring them
	unexpectedly.
      </t>
      <t>
	It is therefore recommended to roll KSKs that are likely to
	be used as trust anchors on a regular basis if and only if
	those rollovers can be tracked using standardized
	(e.g. RFC5011) mechanisms.
      </t>

    </section>
    
    <section anchor="SEP-practicalites" title="The use of the SEP flag">	
      <t>
	The so-called Secure Entry Point (SEP) <xref target="RFC4035" />
	flag can be used to distinguish between keys that are intended
	to be used as the secure entry point into the zone when building
	chains of trust, i.e they are (to be) pointed to by parental DS
	RRs or configured as a trust anchor.
      </t>
      <t>
	While the SEP flag does not play any role in validation, it is
	used in practice for operational purposes such as for the
	rollover mechanism described in <xref
	target="RFC5011">RFC5011</xref>. The common convention is to
	set the SEP flag on any key that is used for key exchanges
	with the parent and/or potentially used for configuration as a
	trust anchor. Therefore it is recommended that the SEP flag is
	set on keys that are used as KSKs and not on keys that are used as ZSKs, while in those cases where a
	distinction between KSK and ZSK is not made (i.e. for a Single
	Type signing scheme) it is recommended that the SEP flag is
	set on all keys.
      </t>
      <t>
	Note that signing tools may assume a KSK/ZSK split and use the
	(non) presence of the SEP flag to determine which key is to be
	used for signing zone data; these tools may get confused when
	a single type signing scheme is used.	
      </t>
    </section>
    
    
  </section> <!-- Motivations for the function -->
  
  
  
  <section anchor="key_lifetime" title="Key Effectivity Period">
    <t> 
      In general the available key length sets an upper limit on the
      Key Effectivity Period. For all practical purposes it is
      sufficient to define the Key Effectivity Period based on purely
      operational requirements and match the key length to that value.
      Ignoring the operational perspective, a reasonable effectivity
      period for KSKs that have corresponding DS records in the parent
      zone is of the order of 2 decades or longer.  That is, if one
      does not plan to test the rollover procedure, the key should be
      effective essentially forever, and only rolled over in case of
      emergency.
    </t>
    <t>
      When one opts for a regular key-rollover, a reasonable key
      effectivity period for KSKs that have a parent zone is one year,
      meaning you have the intent to replace them after 12 months.
      The key effectivity period is merely a policy parameter, and
      should not be considered a constant value. For example, the real
      key effectivity period may be a little bit longer than 12 months,
      because not all actions needed to complete the rollover could be
      finished in time.
    </t>
    <t>
      As
      argued above, this annual rollover gives operational practice of
      rollovers for both the zone and validator
      administrators. Besides, in most environments a year is a
      time-span that is easily planned and communicated.
    </t>
    <t>
      Where keys are stored on on-line systems and the exposure to
      various threats of compromise is fairly high, an intended key
      effectivity period of a month is reasonable for Zone Signing
      Keys.
    </t>

    <t>
      Although very short key effectivity periods are theoretically possible,
      when replacing keys one has to take into account the rollover
      considerations from <xref target="keyroll"/> and <xref
      target="time"/>. Key replacement endures for a couple of Zone TTLs,
      depending on the rollover scenario. Therefore, a multiple of Zone TTL is a reasonable 
      lower limit on the key effectivity period. Forcing a smaller key effectivity
      period will result your zone to have an ever-growing key set.
    </t>

    <t>
      The motivation for having the ZSK's effectivity period shorter
      than the KSK's effectivity period is rooted in the operational
      consideration that it is more likely that operators have more
      frequent read access to the ZSK than to the KSK. If ZSKs are
      maintained on cryptographic Hardware Security Modules (HSM), then
      the motivation to have different key effectivity periods is
      weakened.
    </t>
    <t>
     In fact, if the risk of loss, theft or other compromise is the
     same for a zone and key signing key there is little reason to
     choose different effectivity periods for ZSKs and KSKs. And when
     the split between ZSKs and KSKs is not made, the argument is
     redundant.
    </t>
    <t>
      There are certainly cases (e.g. where the the costs and risk of
      compromise, and the costs and risks involved with having to
      perform an emergency roll are also low) that the use of a single
      type signing scheme with a long key effectivity period is a good
      choice.
    </t>

    
  </section> <!-- key effectivity period -->
  
  <section title="Cryptographic Considerations">
    <section anchor="key algorithm" title="Key Algorithm">
      <t>
	At the time of writing, there are three types of signature
	algorithms that can be used in DNSSEC: RSA, DSA and GOST. Proposals
	for other algorithms are in the making. All three are fully specified
	in many freely-available documents, and are widely considered to be
	patent-free. The creation of signatures with RSA and DSA takes roughly
	the same time, but DSA is about ten times slower for signature
	verification. Also, DSA in context of DNSSEC is limited to the maximum
	of 1024 bit keys.
      </t>

      <t>
	We suggest the use of RSA/SHA-256 as the preferred signature
	algorithms and RSA/SHA-1 as an alternative.  Both have
	advantages and disadvantages.  RSA/SHA-1 has been deployed for
	many years, while RSA/SHA-256 has only begun to be deployed.
	On the other hand, it is expected that if effective attacks on
	either algorithm appear, they will appear for RSA/SHA-1
	first.  RSA/MD5 should not be considered for use because
	RSA/MD5 will very likely be the first common-use signature
	algorithm to have an effective attack.
      </t>
      <t>
	At the time of publication, it is known that the SHA-1 hash
	has cryptanalysis issues and work is in progress on addressing
	them. The use of public key algorithms based on
	hashes stronger than SHA-1 (e.g., SHA-256) is recommended,
	as soon as these
	algorithms are available in implementations (see <xref
	target="RFC5702">RFC5702</xref> and <xref
	target="RFC4509">RFC4509</xref>).
      </t>
    </section> <!-- Key algorithm -->
    
    <section anchor="key sizes" title="Key Sizes">
      <t>
	This section assumes RSA keys, as suggested in the previous section.
      </t>

      <t>
	DNSSEC signing keys should be large enough to avoid all known
	cryptographic attacks during the effectivity period of the key.  To date,
	despite huge efforts, no one has broken a regular 1024-bit key;
	in fact, the best completed attack is estimated to be the
	equivalent of a 700-bit key.  An attacker breaking a 1024-bit
	signing key would need to expend phenomenal amounts of networked
	computing power in a way that would not be detected in order to
	break a single key.  Because of this, it is estimated that most
	zones can safely use 1024-bit keys for at least the next ten
	years (A 1024-bit asymmetric key has an approximate equivalent
	strength of a symmetric 80-bit key).
      </t>
      <t>
	Depending on local policy (e.g. owners of keys that are used as extremely high value trust
	anchors, or non-anchor keys that may be difficult to roll
	over), you may want to use lengths longer than 1024 bits.
	Typically, the next larger key size used is 2048 bits, which
	has the approximate equivalent strength of a symmetric 112-bit
	key (e.g. <xref target="RFC3766">RFC3766</xref>). Signing and 
        verifying with a 2048-bit key takes of course longer than with
	a 1024-bit key. The increase depends on software and hardware
	implementations, but public operations (such as verification)
	are about four times slower, while private operations (such as signing)
	slow down about eight times.
      </t>

      <t>
	Another way to decide on the size of key to use is to remember
	that the effort it takes for an attacker to break a
	1024-bit key is the same regardless of how the key is used.  If
	an attacker has the capability of breaking a 1024-bit DNSSEC
	key, he also has the capability of breaking one of the many
	1024-bit TLS trust anchor keys that are currently installed in web
	browsers.  If the value of a DNSSEC key is lower to the attacker
	than the value of a TLS trust anchor, the attacker will use the
	resources to attack the latter.
      </t>
      <t>
	It is possible that there will be an unexpected improvement in the
	ability for attackers to break keys, and that such an attack
	would make it feasible to break 1024-bit keys but not 2048-bit
	keys.  If such an improvement happens, it is likely that there
	will be a huge amount of publicity, particularly because of the
	large number of 1024-bit TLS trust anchors build into popular
	web browsers. At that time, all 1024-bit keys (both ones with
	parent zones and ones that are trust anchors) can be rolled over
	and replaced with larger keys.
      </t>
      <t>
	Earlier documents (including the previous version of this
	document) urged the use of longer keys in situations where a
	particular key was "heavily used".  That advice may have been
	true 15 years ago, but it is not true today when using RSA
	algorithms and keys of 1024 bits or higher.
      </t>
      
    </section> <!-- Key sizes -->
    
    <section title="Private Key Storage">
      <t>
	It is recommended that, where possible, zone private keys and
	the zone file master copy that is to be signed be kept and used
	in off-line, non-network-connected, physically secure machines
	only.  Periodically, an application can be run to add
	authentication to a zone by adding RRSIG and NSEC/NSEC3 RRs.  Then the
	augmented file can be transferred.
      </t>
      
      <t>
	When relying on dynamic update <xref target="RFC3007"/>, or any
	other update mechanism that runs at a regular interval
	to manage a signed zone, be aware that at least one private key
	of the zone will have to reside on the master server (or
	reside on an HSM to which the server has access).  This key is
	only as secure as the amount of exposure the server receives
	to unknown clients and the security of the host.  Although not
	mandatory, one could administer a zone using a "hidden master"
	scheme that minimize the risk. In this arrangement the master
	that processes the updates is unavailable to general
	hosts on the Internet; it is not listed in the NS RRset. The
	name servers in the NS RRset are able to receive zone updates
	through IXFR, AXFR, or an out-of-band distribution mechanism,
	possibly in combination with NOTIFY or another mechanism to
	trigger zone replication.
      </t>
      
      <t>
	The ideal situation is to have a one-way information flow to
	the network to avoid the possibility of tampering from the
	network.  Keeping the zone master on-line on the network
	and simply cycling it through an off-line signer does not do
	this.  The on-line version could still be tampered with if the
	host it resides on is compromised.  For maximum security, the
	master copy of the zone file should be off-net and should not
	be updated based on an unsecured network mediated
	communication.
      </t>
      <t>
	The ideal situation may not be achievable because of economic
	tradeoffs between risks and costs.  For instance, keeping a
	zone file off-line is not practical and will increase the
	costs of operating a DNS zone. So in practice the machines on
	which zone files are maintained will be connected to a
	network. Operators are advised to take security measures to
	shield unauthorized access to the master copy in order to
	prevent modification of DNS data before its signed.
      </t>
      
      <t>
	Similarly the choice for storing a private key in an HSM will
	be influenced by a tradeoff between various concerns:
      
	<list style="symbols">
	  <t> 
	    The risks that an unauthorized person has unnoticed
	    read-access to the private key
	  </t>
	  <t>
	    The remaining window of opportunity for the attacker.
	  </t>
	  <t>
	    The economic impact of the possible attacks (for a TLD
	    that impact will typically be higher than for an
	    individual users).
	  </t>
	  <t>
	    The costs of rolling the (compromised) keys. (The
	    costs of rolling a ZSK is lowest and the costs of rolling a
	    KSK that is in wide use as a trust anchor is highest.)
	  </t>
	  <t>
	    The costs of buying and maintaining an HSM.
	  </t>
	</list>
	
	
      </t>
      <t>
	For dynamically updated secured zones <xref
	target="RFC3007"/>, both the master copy and the private key
	that is used to update signatures on updated RRs will need to
	be on-line.
      </t>
      
    </section>
    
    <section title="Key Generation">
      <t>
	Careful generation of all keys is a sometimes overlooked but
	is an absolutely essential element in any cryptographically
	secure system.  The strongest algorithms used with the longest
	keys are still of no use if an adversary can guess enough to
	lower the size of the likely key space so that it can be
	exhaustively searched.  Technical suggestions for the
	generation of random keys will be found in <xref
	target="RFC4086">RFC 4086</xref> and <xref
	target="NIST-SP-800-90A">NIST SP 800-90A</xref>. In particular,
	one should carefully assess whether the random number
	generator used during key generation adheres to these
	suggestions. Typically, HSMs tend to provide a good facility for key
	generation.
      </t>
      <t>
	Keys with a long effectivity period are particularly sensitive
	as they will represent a more valuable target and be subject
	to attack for a longer time than short-period keys.  It is
	recommended that long-term key generation occur
	off-line in a manner isolated from the network via an air gap
	or, at a minimum, high-level secure hardware.
      </t>
      
    </section> <!-- Key Generation -->

    
    <section title="Differentiation for 'High-Level' Zones?">
      
      <t>
	An earlier version of this document (<xref
	target="RFC4641">RFC4641</xref>) made a differentiation
	between key lengths for KSKs used for zones that are high in the DNS hierarchy
	and those for KSKs used low down.
      </t>
      <t>
	This distinction is now considered not relevant. Longer key
	lengths for keys higher in the hierarchy are not useful because
	the cryptographic guidance is that everyone should use keys that
	no one can break. Also, it is impossible to judge which zones
	are more or less valuable to an attacker. An attack can only
	take place if the key compromise goes unnoticed and the attacker
	can act as a man-in-the-middle (MITM). For example, if example.com is
	compromised and the attacker forges answers for
	somebank.example.com. and sends them out during an MITM, when the attack
	is discovered it will be simple to prove that example.com has been
	compromised and the KSK will be rolled. 

<!--
 Designing  a long-term
	successful attack is difficult for keys at any level.
-->

      </t>
      
    </section> <!-- High level -->
  </section>    <!-- cryptographic considerations -->
</section> <!-- Key sec considerations -->


  
<?rfc linefile="80:draft-ietf-dnsop-rfc4641bis.xml"?>
    
    <?rfc?><?rfc linefile="1:Rollover.xml"?>
<!-- Included from Rollover.xml -->
<!-- $Id -->


<section anchor="sigs_keyrolls_policies" title="Signature Generation, Key Rollover, and Related Policies">

    <section anchor="keyroll" title="Key Rollovers">

      <t>
	Regardless of whether a zone uses periodic key rollovers,
	or only rolls keys in case of an irregular event,
	key rollovers are a fact of life when using DNSSEC.
	Zone administrators who are in the process of rolling
	their keys have to take into account that data published in
	previous versions of their zone still lives in caches. When
	deploying DNSSEC, this becomes an important consideration;
	ignoring data that may be in caches may lead to loss of
	service for clients.
      </t>
      <t>
	The most pressing example of this occurs when zone material
	signed with an old key is being validated by a resolver that
	does not have the old zone key cached. If the old key is no
	longer present in the current zone, this validation fails,
	marking the data "Bogus".  Alternatively, an attempt could be
	made to validate data that is signed with a new key against an
	old key that lives in a local cache, also resulting in data
	being marked "Bogus".
      </t>
  

      <section anchor="ZSK-Roll" title="Zone Signing Key Rollovers">
	<t>
	  If the choice for splitting zone and key signing keys has
	  been made than those two types of keys can be rolled
	  separately and zone signing keys can be rolled without taking
	  into account DS records from the parent or the configuration
	  of such a key as trust-anchor.
	</t>

	<t> 
	  For "Zone Signing Key rollovers", there are two ways to make
	  sure that during the rollover data still cached can be
	  verified with the new key sets or newly generated signatures
	  can be verified with the keys still in caches. One schema,
	  described in <xref target="pre-pub-zsk"/>, uses key pre-publication;
	  the other uses double signatures (<xref
	  target="dub-sig-zsk" />). The pros, cons, and
	  recommendations are described in <xref target="zsk-pro-con"/>.
	</t>
	
	<section anchor="pre-pub-zsk" title="Pre-Publish Zone Signing Key Rollover">
	  <t>
	    This section shows how to perform a ZSK rollover without
	    the need to sign all the data in a zone twice -- the
	    "Pre-Publish key rollover". This method has advantages in
	    the case of a key compromise. If the old key is
	    compromised, the new key has already been distributed in
	    the DNS. The zone administrator is then able to quickly
	    switch to the new key and remove the compromised key from
	    the zone.  Another major advantage is that the zone size
	    does not double, as is the case with the Double Signature
	    ZSK rollover.<!--  A small "how-to" for this kind of rollover
	    can be found in <xref target="zskhowto" />.-->
	  </t>
	  <t>
	    <figure anchor="pre-publish-key-rollover-fig" title="Pre-Publish Key Rollover">
	      <preamble>
		Pre-Publish key rollover involves four stages as follows:
	      </preamble>
	<?rfc?><?rfc linefile="1:pre-publish-key-rollover-figure.xml"?><artwork>
 ---------------------------------------------------------- 
  initial            new DNSKEY          new RRSIGs       
 ----------------------------------------------------------
  SOA_0              SOA_1               SOA_2              
  RRSIG_Z_10(SOA)    RRSIG_Z_10(SOA)     RRSIG_Z_11(SOA)   

  DNSKEY_K_1         DNSKEY_K_1          DNSKEY_K_1        
  DNSKEY_Z_10        DNSKEY_Z_10         DNSKEY_Z_10       
                     DNSKEY_Z_11         DNSKEY_Z_11
  RRSIG_K_1(DNSKEY)  RRSIG_K_1(DNSKEY)   RRSIG_K_1(DNSKEY) 
 ------------------------------------------------------------ 

 ------------------------------------------------------------ 
  DNSKEY removal
 ------------------------------------------------------------ 
  SOA_3
  RRSIG_Z_11(SOA)

  DNSKEY_K_1
  DNSKEY_Z_11

  RRSIG_K_1(DNSKEY)
 ------------------------------------------------------------ 

</artwork>
<?rfc linefile="72:Rollover.xml"?>
	  </figure>
	  </t>
	  <t>
	    <list style="hanging">
	      <t hangText="initial:"> Initial version of the zone: DNSKEY_K_1
	      is the Key Signing Key. DNSKEY_Z_10 is used to sign all
	      the data of the zone, the Zone Signing Key.
	      </t>
	      <t hangText="new DNSKEY:"> DNSKEY_Z_11 is introduced into
	      the key set (note that no signatures are generated with
	      this key yet, but this does not secure against brute
	      force attacks on its public key). The minimum duration
	      of this pre-roll phase is the time it takes for the
	      data to propagate to the authoritative servers plus
	      TTL value of the key set.
	      <!--This equates to two times the Maximum Zone TTL. -->
	      </t>

	      <t hangText="new RRSIGs:"> At the "new RRSIGs" stage (SOA serial
	      2), DNSKEY_Z_11 is used to sign the data in the zone
	      exclusively  (i.e., all the signatures from DNSKEY_Z_10 are
	      removed from the zone). DNSKEY_Z_10 remains published in
	      the key set. This way, data that was loaded into caches
	      from the zone in the "new DNSKEY" step can still be verified with
	      key sets fetched from this version of the zone.
	      The minimum time that the key set including DNSKEY_Z_10
	      is to be published is the time that it takes for
	      zone data from the previous version of the zone to
	      expire from old caches, i.e., the time it takes for
	      this zone to propagate to all authoritative servers
	      plus the Maximum Zone TTL value of any of the data
	      in the previous version of the zone.
	      </t>

	      <t hangText="DNSKEY removal:"> DNSKEY_Z_10 is removed from the
	      zone. The key set, now only containing DNSKEY_K_1 and
	      DNSKEY_Z_11, is re-signed with the DNSKEY_K_1 and DNSKEY_Z_11.

	      </t>
	    </list>
	  </t>
	  <t> The above scheme can be simplified by always
	  publishing the "future" key immediately after the rollover.
	  The scheme would look as follows (we show two rollovers); the
	  future key is introduced in "new DNSKEY" as DNSKEY_Z_12 and again
	  a newer one, numbered 13, in "new DNSKEY (II)":

	  </t>
	  <t>

	    <figure anchor="Pre-publish-two-rolovers-fig" title="Pre-Publish Zone Signing Key Rollover, Showing Two Rollovers">
            <preamble/>
	    <?rfc?><?rfc linefile="1:Pre-publish-two-rolovers.xml"?><artwork>
    initial             new RRSIGs          new DNSKEY
   -----------------------------------------------------------------
    SOA_0               SOA_1               SOA_2
    RRSIG_Z_10(SOA)     RRSIG_Z_11(SOA)     RRSIG_Z_11(SOA)

    DNSKEY_K_1          DNSKEY_K_1          DNSKEY_K_1
    DNSKEY_Z_10         DNSKEY_Z_10         DNSKEY_Z_11
    DNSKEY_Z_11         DNSKEY_Z_11         DNSKEY_Z_12
    RRSIG_K_1(DNSKEY)   RRSIG_K_1 (DNSKEY)  RRSIG_K_1(DNSKEY)
    ----------------------------------------------------------------

    ----------------------------------------------------------------
    new RRSIGs (II)        new DNSKEY (II)
    ----------------------------------------------------------------
    SOA_3                  SOA_4
    RRSIG_Z_12(SOA)        RRSIG_Z_12(SOA)

    DNSKEY_K_1             DNSKEY_K_1
    DNSKEY_Z_11            DNSKEY_Z_12
    DNSKEY_Z_12            DNSKEY_Z_13
    RRSIG_K_1(DNSKEY)      RRSIG_K_1(DNSKEY)
    ----------------------------------------------------------------

</artwork>
<?rfc linefile="125:Rollover.xml"?>
	    </figure>
	  </t>
	  <t> 
	    Note that the key introduced in the "new DNSKEY" phase is not
	    used for production yet; the private key can thus be
	    stored in a physically secure manner and does not need to
	    be 'fetched' every time a zone needs to be signed.
	    
	  </t>

	  </section>

	  <section anchor="dub-sig-zsk" title="Double Signature Zone Signing Key Rollover">

	    <t>This section shows how to perform a ZSK key rollover
	    using the double zone data signature scheme, aptly named
	    "Double Signature rollover".
	    </t>
	    <t>During the "new DNSKEY" stage the new version of the zone
	    file will need to propagate to all authoritative servers
	    and the data that exists in (distant) caches will need to
	    expire, requiring at least the Maximum Zone TTL of previous versions of the zone.

	    </t>
	    <figure anchor="double-sig-zsk-roll-fig" title="Double Signature Zone Signing Key Rollover">
            <preamble>

        Double Signature ZSK rollover involves three stages
        as follows:

            </preamble>
	    <?rfc?><?rfc linefile="1:Double-Sig-ZSK-Roll.xml"?><artwork>
   ----------------------------------------------------------------
   initial             new DNSKEY         DNSKEY removal
   ----------------------------------------------------------------
   SOA_0               SOA_1              SOA_2
   RRSIG_Z_10(SOA)     RRSIG_Z_10(SOA)
                       RRSIG_Z_11(SOA)    RRSIG_Z_11(SOA)
   DNSKEY_K_1          DNSKEY_K_1         DNSKEY_K_1
   DNSKEY_Z_10         DNSKEY_Z_10
                       DNSKEY_Z_11        DNSKEY_Z_11
   RRSIG_K_1(DNSKEY)   RRSIG_K_1(DNSKEY)  RRSIG_K_1(DNSKEY)
   ----------------------------------------------------------------

</artwork>
<?rfc linefile="157:Rollover.xml"?>
	      
	      <!--
		  Stages of Deployment for Double Signature Zone Signing
		  Key Rollover.
	      -->
	    </figure>


	    <t>
	    <list style="hanging">
            <t hangText="initial:"> Initial Version
	    of the zone: DNSKEY_K_1 is the Key Signing Key. DNSKEY_Z_10 is used
	    to sign all the data of the zone, the
	    Zone Signing Key.
	    </t>
	    <t hangText="new DNSKEY:"> At the "New DNSKEY" stage (SOA
	    serial 1) DNSKEY_Z_11 is introduced into the key set and
	    all the data in the zone is signed with DNSKEY_Z_10 and
	    DNSKEY_Z_11. The rollover period will need to continue
	    until all data from version 0 of the zone has expired from
	    remote caches. This will take at least the Maximum Zone
	    TTL of version 0 of the zone.

	    </t>
	    <t hangText="DNSKEY removal:"> DNSKEY_Z_10 is removed from
	    the zone as are all signatures created with it.
	    The key set, now only containing DNSKEY_Z_11, is
	    re-signed with DNSKEY_K_1 and DNSKEY_Z_11.</t>
	    </list>
	    </t>

	    <t> At every instance, RRSIGs from the previous version of
	    the zone can be verified with the DNSKEY RRset from the
	    current version and vice-versa.
	    The duration of the "new DNSKEY"
	    phase and the period between rollovers should be at least
	    the Maximum Zone TTL of the previous version of the zone.

	    </t>
<!--
	    <t>Making sure that the "new DNSKEY" phase lasts until the
	    signature expiration time of the data in the initial version of the
	    zone is recommended. This way all caches are cleared of the old
	    signatures.  However, this duration could be
	    considerably longer than the Maximum Zone TTL, making the
	    rollover a lengthy procedure.
	    </t>
-->
	    <t>Note that in this example we assumed that the zone was
	    not modified during the rollover. New data can be
	    introduced in the zone as long as it is signed with both
	    keys.
	    </t>


	  </section> <!--double sig rollover-->


	  <section anchor="zsk-pro-con" title="Pros and Cons of the Schemes">

	    <t>
	      <list style="hanging">
		<t hangText="Pre-Publish key rollover:">
		  This rollover does not involve signing the zone data
		  twice. Instead, before the actual rollover, the
		  new key is published in the key set and thus is
		  available for cryptanalysis attacks. A small
		  disadvantage is that this process requires four
		  steps. Also the Pre-Publish scheme involves more
		  parental work when used for KSK rollovers as
		  explained in <xref target="diff_zsk_ksk"/>.
		</t>


		<t hangText="Double Signature ZSK rollover:">
		  The drawback of this signing scheme is that during the
		  rollover the number of signatures in your zone doubles;
		  this may be prohibitive if you have very big zones. An
		  advantage is that it only requires three steps.

		</t>

	      </list>
	    </t>

	  </section> <!-- Pros and cons of the schemes -->



	</section><!--Zone Signing key rollovers-->

	<section  anchor="ksk-rollover" title="Key Signing Key Rollovers">

	  <t> 
	    For the rollover of a Key Signing Key, the same
	    considerations as for the rollover of a Zone Signing Key
	    apply. However, we can use a Double Signature scheme to
	    guarantee that old data (only the apex key set) in caches
	    can be verified with a new key set and vice versa.  Since
	    only the key set is signed with a KSK, zone size
	    considerations do not apply.
	  </t>
	  <t>
	    <figure anchor="double-sig-ksk-roll-fig" title="Stages of Deployment for a Double Signature Key 
							    Signing Key Rollover">
	      <preamble/>
	      <?rfc?><?rfc linefile="1:Double-Sig-KSK-Roll.xml"?><artwork>
---------------------------------------------------------------------
 initial            new DNSKEY        DS change    DNSKEY removal
---------------------------------------------------------------------
Parent: 
 SOA_0 -----------------------------&gt; SOA_1 ------------------------&gt;
 RRSIG_par(SOA) --------------------&gt; RRSIG_par(SOA) ---------------&gt;
 DS_K_1 ----------------------------&gt; DS_K_2 -----------------------&gt;
 RRSIG_par(DS) ---------------------&gt; RRSIG_par(DS) ----------------&gt;

Child:
 SOA_0              SOA_1 -----------------------&gt; SOA_2
 RRSIG_Z_10(SOA)    RRSIG_Z_10(SOA) -------------&gt; RRSIG_Z_10(SOA)

 DNSKEY_K_1         DNSKEY_K_1 ------------------&gt;
                    DNSKEY_K_2 ------------------&gt; DNSKEY_K_2
 DNSKEY_Z_10        DNSKEY_Z_10 -----------------&gt; DNSKEY_Z_10
 RRSIG_K_1(DNSKEY)  RRSIG_K_1 (DNSKEY) ----------&gt;
                    RRSIG_K_2 (DNSKEY) ----------&gt; RRSIG_K_2(DNSKEY)
---------------------------------------------------------------------
</artwork>
<?rfc linefile="264:Rollover.xml"?>

	    </figure>
	  </t>

	  <t>
	    <list style="hanging"> 
	      <t hangText="initial:">
		Initial version of the zone.  The parental DS points
		to DNSKEY_K_1. Before the rollover starts, the child
		will have to verify what the TTL is of the DS RR that
		points to DNSKEY_K_1 -- it is needed during the
		rollover and we refer to the value as TTL_DS.
	      </t>

	      <t hangText="new DNSKEY:">
		During the "new DNSKEY" phase, the zone administrator
		generates a second KSK, DNSKEY_K_2. The key is provided
		to the parent, and the child will have to wait until a
		new DS RR has been generated that points to
		DNSKEY_K_2. After that DS RR has been published on all
		servers authoritative for the parent's zone, the zone
		administrator has to wait at least TTL_DS to make sure
		that the old DS RR has expired from caches.
	  </t>

          <t hangText="DS change:"> 
	    The parent replaces DS_K_1 with DS_K_2.
          </t>

	  <t hangText="DNSKEY removal:"> 
	    DNSKEY_K_1 has been removed.
	  </t>
	  </list>
	  </t>
	  <t>
	    The scenario above puts the responsibility for maintaining
	    a valid chain of trust with the child. It also is based on
	    the premise that the parent only has one DS RR (per
	    algorithm) per zone.  An alternative mechanism has been
	    considered.  Using an established trust relation, the
	    interaction can be performed in-band, and the removal of
	    the keys by the child can possibly be signaled by the
	    parent. In this mechanism, there are periods where there
	    are two DS RRs at the parent.
	  </t>
	  <section anchor="5011KSK" title="Special Considerations for RFC5011 KSK rollover">
	  <t>
	    The scenario sketched above assumes that the KSK is not in
	    use as a trust-anchor too but that validating name servers
	    exclusively depend on the parental DS record to establish
	    the zone's security. If it is known that validating
	    name servers have configured trust-anchors then such needs
	    to be taken into account. Here we assume that zone administrators
	    will deploy <xref target="RFC5011">RFC5011</xref>
	    style rollovers.
	  </t>
	  <t>
	    RFC5011 style rollovers increase the duration of key
	    rollovers: the key to be removed must first be
	    revoked. Thus, before the DNSKEY_K_1 removal phase,
	    DNSKEY_K_1 must be published for one more Maximum Zone TTL
	    with the REVOKE bit set. The revoked key must be
	    self-signed, so in this phase the DNSKEY RRset must also
	    be signed with DNSKEY_K_1.
	  </t>

	  </section><!-- "Special Considerations for RFC5011 KSK rollover" -->>
	</section><!--Key signing key rollovers-->


      <section anchor="diff_zsk_ksk" title="Difference Between ZSK and KSK Rollovers">

	<t> Note that KSK rollovers and ZSK rollovers are different in the
	sense that a KSK rollover requires interaction with the parent (and
	possibly replacing of trust anchors) and the ensuing delay while waiting
	for it.
	</t>

	<t>
	  A ZSK rollover can be handled in two different ways, meaningful: Pre-Publish (<xref
	  target="pre-pub-zsk"/>) and Double Signature (<xref
	  target="dub-sig-zsk"/>).
	</t>
	<t>
	  As the KSK is used to validate the key set and because the
	  KSK is not changed during a ZSK rollover, a cache is able to
	  validate the new key set of the zone.  A Pre-Publish
	  method is also possible for KSKs, known as the Double-DS rollover.
	  The name being a give away, the record that needs to be pre-published is the DS RR at the parent.
	  The Pre-Publish method has some drawbacks for KSKs. We first describe the
	  rollover scheme and then indicate these drawbacks.
        </t>
	<t>
	  <figure anchor="pre-pubkish-ksk-roll-fig" title="Stages of Deployment for a Double-DS Key Signing Key
            Rollover">
          <preamble/>
	      <?rfc?><?rfc linefile="1:Pre-Publish-KSK-Roll.xml"?><artwork>
--------------------------------------------------------------------
  initial         new DS         new DNSKEY       DS removal
--------------------------------------------------------------------
Parent:
  SOA_0           SOA_1 ------------------------&gt; SOA_2
  RRSIG_par(SOA)  RRSIG_par(SOA) ---------------&gt; RRSIG_par(SOA)
  DS_K_1          DS_K_1 -----------------------&gt;
                  DS_K_2 -----------------------&gt; DS_K_2
  RRSIG_par(DS)   RRSIG_par(DS) ----------------&gt; RRSIG_par(DS)

Child:
  SOA_0 -----------------------&gt; SOA_1 ----------------------------&gt;
  RRSIG_Z_10(SOA) -------------&gt; RRSIG_Z_10(SOA) ------------------&gt;

  DNSKEY_K_1 ------------------&gt; DNSKEY_K_2 -----------------------&gt;
  DNSKEY_Z_10 -----------------&gt; DNSKEY_Z_10 ----------------------&gt;
  RRSIG_K_1 (DNSKEY) ----------&gt; RRSIG_K_2 (DNSKEY) ---------------&gt;
--------------------------------------------------------------------

</artwork>
<?rfc linefile="361:Rollover.xml"?>

	  </figure>
	</t>

        <t>
	  When the child zone wants to roll, it notifies the
	  parent during the "new DS" phase and submits the new key (or
	  the corresponding DS) to the parent.
	  The parent publishes DS_S_1 and DS_S_2, pointing to
	  DNSKEY_S_1 and DNSKEY_S_2, respectively. During the rollover ("new DNSKEY"
          phase), which
	  can take place as soon as the new DS set propagated through
	  the DNS, the child replaces DNSKEY_S_1 with
   	  DNSKEY_S_2. Immediately after that ("DS/DNSKEY removal" phase),
          it can notify the parent that the old DS record can be deleted.
	</t>

        <t> 
	  The drawbacks of this scheme are that during the
	  "new DS" phase the parent cannot verify the match between the
	  DS_S_2 RR and DNSKEY_S_2 using the DNS -- as DNSKEY_S_2 is not
	  yet published. Besides, we introduce a
	  "security lame" key (see <xref target="lame"/>). Finally, the
	  child-parent interaction consists of two steps. The "Double
	  Signature" method only needs one interaction.
	  
	</t>
      </section> <!-- Difference Between ZSK and KSK Rollovers -->


      <section title="Rollover for a Single Type Signing Key rollover" anchor="STSrollover">
	
	<t>
	  The rollover of a DNSKEY when a Single Type Signing Scheme
	  is used is subject to the same requirement as the rollover
	  of a KSK or ZSK: During any stage of the rollover the chain
	  of trust needs to continue to validate for any combination
	  of data in the zone as well as data that may still live in
	  distant caches.
	</t>
	<t>
	  There are two variants for this rollover. Since the choice
	  for a Single Type Signing Scheme is motivated by operational
	  simplicity we first describe the most straightforward
	  rollover scheme first.
	</t>
	<t>
	  <figure anchor="single-type-roll-fig" title="Stages of the Straightforward rollover in a Single Type Signing Scheme">
	      <?rfc?><?rfc linefile="1:Single-type-roll.xml"?><artwork>
  ----------------------------------------------------------------
  initial           new DNSKEY      DS change     DNSKEY removal
  ----------------------------------------------------------------
Parent:
  SOA_0 --------------------------&gt; SOA_1 ----------------------&gt;
  RRSIG_par(SOA) -----------------&gt; RRSIG_par(SOA) -------------&gt;
  DS_S_1 -------------------------&gt; DS_S_2 ---------------------&gt;
  RRSIG_par(DS_S_1) --------------&gt; RRSIG_par(DS_S_2) ----------&gt;

Child:
  SOA_0             SOA_1 ----------------------&gt; SOA_2
  RRSIG_S_1(SOA)    RRSIG_S_1(SOA) -------------&gt;
                    RRSIG_S_2(SOA) -------------&gt; RRSIG_S_2(SOA)
  DNSKEY_S_1        DNSKEY_S_1 -----------------&gt;
                    DNSKEY_S_2 -----------------&gt; DNSKEY_S_2
  RRSIG_S_1(DNSKEY) RRSIG_S_1(DNSKEY) ----------&gt;
                    RRSIG_S_2(DNSKEY) ----------&gt; RRSIG_S_2(DNSKEY)
  -----------------------------------------------------------------
</artwork>
<?rfc linefile="410:Rollover.xml"?>
	  </figure>	
	</t>
	  <t>
	    <list style="hanging"> 
	      <t hangText="initial:">
		Parental DS points to DNSKEY_S_1. All RR sets in the zone are signed with DNSKEY_S_1.
	      </t>
	      <t hangText="new DNSKEY:">
		A new key (DNSKEY_S_2) is introduced and all the RR sets are signed with both DNSKEY_S_1 and DNSKEY_S_2.
	      </t>
	      <t hangText="DS change:">
		After the DNSKEY RRset with the two keys had time to
		propagate into distant caches (that is the key set
		exclusively containing DNSKEY_S_1 has been expired) the
		parental DS record can be changed.
	      </t>
	      <t hangText="DNSKEY removal:">
		After the DS RRset containing DS_S_1 has expired from
		distant caches DNSKEY_S_1 can be removed from the DNSKEY
		RRset .
	      </t>
	    </list>
	  </t>
	  <t>
	    There is a second variety of this rollover during which
	    one introduces a new DNSKEY into the key set and signs the
	    key set with both keys while signing the zone data with
	    only the original DNSKEY_S_1. One replaces the DNSKEY_S_1
	    signatures with signatures made with DNSKEY_S_2 at the moment
	    of DNSKEY_S_1 removal.
	  </t>
	  <t>
	    The second variety of this rollover can be considered when
	    zone size considerations prevent the introduction of
	    double signatures over all of the zone data although in
	    that case choosing for a KSK/ZSK split may be a better
	    option.
	  </t>
	  <t>
	    A Double-DS rollover scheme is compatible with a rollover
	    using a Single Type Signing Scheme although in order to
	    maintain a valid chain of trust, the zone data would need
	    to be published with double signatures or a double 
	    key set. Since this leads to
	    increase in zone and packet size at both child and parent
	    there are little benefits to a Double-DS rollover with a
	    Single Type Signing Scheme.
	  </t>

   <t>
   There is also a second variety of the Double-DS rollover during
   which one introduces a new DNSKEY into the key set and submit the
   new DS to the parent. The new key is not yet used to sign RRsets.
   One replaces the DNSKEY_S_1 signatures with signatures
   made with DNSKEY_S_2 at the moment that DNSKEY_S_2 and DS_S_2 have
   been propagated.
   </t>

   <t>
   Again, this second variety of this rollover can be considered when
   zone size considerations prevent the introduction of double
   signatures over all of the zone data although also in this case,
   choosing for a KSK/ZSK split may be a better option.
   </t>

      </section>


      <section title="Algorithm rollovers" anchor="KAR">
      <t>
	A special class of key rollover is the one needed for a change
	of key algorithms (either adding a new algorithm, removing an
	old algorithm, or both). Additional steps are needed to retain
	integrity during this rollover. We first describe the generic
	case, special considerations for rollovers that involve
	trust-anchors and single type keys are discussed below.
      </t>

      <t>
	There exist a conservative and a liberal approach for algorithm
	rollover. This has to do with section 2.2 in RFC4035 <xref target="RFC4035"/>:

<artwork>

    There MUST be an RRSIG for each RRset using at least one DNSKEY of
    each algorithm in the zone apex DNSKEY RRset.  The apex DNSKEY RRset
    itself MUST be signed by each algorithm appearing in the DS RRset
    located at the delegating parent (if any).

</artwork>

	The conservative approach interprets this section very strictly, meaning
	that it expects that every RRset has a valid signature for every algorithm
	signalled by the zone apex DNSKEY RRset - including RRsets in caches.
	The liberal approach uses a more loose interpretation of the section
	and limits the rule to RRsets in the zone at the authoritative name servers.
	There is a reasonable argument for saying that this is valid, because the specific section is a subsection
	of section 2. in RFC4035: Zone Signing.
      </t>

      <t>
	When following the more liberal approach, algorithm rollover is just as
	easy as a regular Double-Signature KSK rollover (<xref target="ksk-rollover"/>).
	Note that the Double-DS rollover method cannot be used, since that would 
	introduce a parental DS of which the apex DNSKEY RRset has not been signed
	with the introduced algorithm. 
      </t>

      <t>
	However, there are implementations of validators known that follow the 
	more conservative approach. Performing a Double-Signature KSK algorithm rollover
	will temporarily make your zone appear as Bogus by such validators during the
	rollover. Therefore, the rollover described in this section will explain the stages of
	deployment assuming the conservative approach.
      </t>
      
      <t>
	When adding a new algorithm, the signatures should be added
	first.  After the TTL of RRSIGS has expired, and caches have
	dropped the old data covered by those signatures, the DNSKEY
	with the new algorithm can be added.
      </t>

      <t>
	After the new algorithm has been added, the DS record can be
	exchanged using Double Signature Key Rollover.  The 
	Pre-Publish key rollover method cannot be used to change algorithms.
      </t>
      <t>
	When removing an old algorithm, the DS for the algorithm should be
	removed from the parent zone first, followed by the DNSKEY and the
	signatures.
      </t>
      <t>
	<xref target="alg-rollover-fig"/> describes the steps.

<!--
	The underscored number indicates the algorithm and ZSK and KSK
	indicate the obvious difference in key use. For example
	DNSKEY_K_1 is a the DNSKEY RR representing the public part
	of the old key signing key of algorithm type 1 while
	RRSIG_Z_2(SOA) is the RRSIG RR made with the private part
	of the new zone signing key of algorithm type 2 over a SOA RR.
	It is assumed that the key that signs
	the SOA RR also signes all other non-DNSKEY RRset data.
-->

      </t>
	<t>
      <figure anchor="alg-rollover-fig" title="Stages of Deployment during an Algorithm Rollover">
	<preamble>
	  <!-- nothing -->
	</preamble>
	<?rfc?><?rfc linefile="1:Algorithm-rollover-figure.xml"?><artwork>
----------------------------------------------------------------
 initial              new RRSIGs           new DNSKEY
----------------------------------------------------------------
Parent:
 SOA_0 --------------------------------------------------------&gt;
 RRSIG_par(SOA) -----------------------------------------------&gt;
 DS_K_1 -------------------------------------------------------&gt;
 RRSIG_par(DS_K_1) --------------------------------------------&gt;

Child:
 SOA_0                SOA_1                SOA_2
 RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)
                      RRSIG_Z_2(SOA)       RRSIG_Z_2(SOA)
  
 DNSKEY_K_1           DNSKEY_K_1           DNSKEY_K_1
                                           DNSKEY_K_2
 DNSKEY_Z_1           DNSKEY_Z_1           DNSKEY_Z_1
                                           DNSKEY_Z_2
 RRSIG_K_1(DNSKEY)    RRSIG_K_1(DNSKEY)    RRSIG_K_1(DNSKEY)
                                           RRSIG_K_2(DNSKEY)

----------------------------------------------------------------
 new DS               DNSKEY removal       RRSIGs removal
----------------------------------------------------------------
Parent:
 SOA_0 -------------------------------------------------------&gt;
 RRSIG_par(SOA) ----------------------------------------------&gt;
 DS_K_2 ------------------------------------------------------&gt;
 RRSIG_par(DS_K_2) -------------------------------------------&gt;

Child:
 -------------------&gt; SOA_3                SOA_4 
 -------------------&gt; RRSIG_Z_1(SOA)     
 -------------------&gt; RRSIG_Z_2(SOA)       RRSIG_Z_2(SOA)
                     
 -------------------&gt;
 -------------------&gt; DNSKEY_K_2           DNSKEY_K_2
 -------------------&gt;
 -------------------&gt; DNSKEY_Z_2           DNSKEY_Z_2
 -------------------&gt;
 -------------------&gt; RRSIG_K_2(DNSKEY)    RRSIG_K_2(DNSKEY)
----------------------------------------------------------------

</artwork>
<?rfc linefile="564:Rollover.xml"?>
      </figure>
	</t>

	<t>
      <list style="hanging">
      <t hangText="initial:">
	Describes state of the zone before any transition is done.
	The number of the keys may vary, but the algorithm of keys in the zone is
	same for all DNSKEY records.
      </t>
      <t hangText="new RRSIGs:">
	The signatures made with the new key over all
	records in the zone are added, but the key itself is not.
	This step is needed to propagate the signatures created with
	the new algorithm to the caches.
	If this is not done, it is possible for a resolver
	to retrieve the new DNSKEY RRset (containing the new algorithm)
	but to have a RRsets in cache with signatures created by the old
	DNSKEY RRset (i.e. without the new algorithm).
      </t>
      <t>
        The RRSIG for the DNSKEY RRset does not need to be
        pre-published, since these records will travel together and
        does not need special processing in order to keep them synchronized.
      </t>
      <t hangText="new DNSKEY:">
	After the cache data has expired, the new key can be
	added to the zone.
      </t>
      <t hangText="new DS:">
	After the cache data for the DNSKEY has expired, the
	DS record for the new key can be added to the parent zone and
	the DS record for the old key can be removed in the same step.
      </t>
      <t hangText="DNSKEY removal:">
	After the cache data for the DS has expired, the old
	algorithm can be removed.  This time the key needs to be
	removed first, before removing the signatures.
      </t>
      <t hangText="RRSIGs removal:">
	After the cache data for the DNSKEY has
	expired, the signatures can also be removed during this step.
      </t>
      </list>
	</t>

      <t>
	Below we deal with a few special cases of algorithm rollovers.
	<list style="hanging">

	  <t hangText="1: Single Type Signing Scheme Algorithm
	  Rollover">: when you have chosen not to differentiate
	  between Zone and Key signing keys (<xref
	  target="SingleTypeAlg"/>) </t>

	  <t hangText="2: RFC5011 Algorithm Rollover">: when trust-anchors can track the
	  roll via RFC5011 style rollover (<xref
	  target="5011style"/>)</t>

	  <t hangText="3: 1 and 2 combined">: when a Single Type
	  Signing Scheme Algorithm rollover is RFC5011-enabled (<xref
	  target="5011andSingleType"/>)</t>

	</list>
	In addition to the narrative below these special cases are represented in 
	<xref target="single-type-algorithm-roll-fig"/>,
	<xref target="5011-algorithm-roll-fig"/> and
	<xref target="single-type-5011-roll-fig"/>
	in <xref target="AlgoFigures"/>.
      </t>

      <section anchor="SingleTypeAlg" title="Single Type Signing Scheme Algorithm Rollover">
	<t>
	  If one key is used that acts both as ZSK and KSK, the same
	  scheme and figure as above applies whereby all DNSKEY_Z_*
	  records from the table are removed and all RRSIG_Z_* are
	  replaced with RRSIG_S_*. All DNSKEY_K_* records are replaced with DNSKEY_S_*
	  and all RRSIG_K_* records are replaced with RRSIG_S_*. The requirement to sign with both
	  algorithms and make sure that old RRSIGS have the opportunity
	  to expire from distant caches before introducing the new
	  algorithm in the DNSKEY RRset is still valid.
	</t>
	<t> 
	  Also see <xref target="single-type-algorithm-roll-fig"/> in <xref target="AlgoFigures"/>.
	</t>
      </section>

      <section anchor="5011style" title="Algorithm rollover, RFC5011 style">
	<t>
	  Trust anchor algorithm rollover is almost as simple as a regular
	  RFC5011 based rollover. However, the old trust anchor must
	  be revoked before it is removed from the zone.
	</t>

	<t>
	  The timeline (see <xref target="5011-algorithm-roll-fig"/> in <xref target="AlgoFigures"/>) is similar to that of Figure 7 above, but after the
	  "new DS" step, an additional step is required where the DNSKEY is
	  revoked.  The details of this step ("revoke DNSKEY") are shown in
	  figure <xref target="revoke-key-fig"/> below.
	</t>

	<t>	
	<figure anchor="revoke-key-fig" title="The Revoke DNSKEY state that is added to an algorithm
	    rollover when RFC5011 is in use.">
	  <preamble>
	    <!-- nothing -->
	  </preamble>
	  <?rfc?><?rfc linefile="1:revoke-key-figure.xml"?><artwork>
---------------------------------
  revoke DNSKEY
---------------------------------
Parent:
  -----------------------------&gt;
  -----------------------------&gt;
  -----------------------------&gt;
  -----------------------------&gt;

Child:
  SOA_3
  RRSIG_Z_1(SOA)
  RRSIG_Z_2(SOA)

  DNSKEY_K_1_REVOKED
  DNSKEY_K_2
  DNSKEY_Z_1
  DNSKEY_Z_2
  RRSIG_K_1(DNSKEY)
  RRSIG_K_2(DNSKEY)
--------------------------------
</artwork>
<?rfc linefile="672:Rollover.xml"?>
	</figure>
	</t>

	<t>
	  There is one exception to the requirement from RFC 4035 quoted in
	  section 4.1.5 above: while all zone data
	  must be signed with an unrevoked key, it is permissible
	  to sign the key set with a revoked key. The somewhat esoteric
	  argument follows.
	</t>
	
	<t>
	  Resolvers that do not understand the RFC5011 Revoke flag
	  will handle DNSKEY_K_1_REVOKED the same as if it was
	  DNSKEY_K_1. In other words, they will handle the revoked key as
	  a normal key, and thus RRsets signed with this key will validate.
	  As a result, the signature matches the algorithm listed in the
	  DNSKEY RRset. Resolvers that do implement RFC5011
	  will remove DNSKEY_K_1 from the set of trust anchors. That
	  is okay, since they have already added DNSKEY_K_2 as the new
	  trust anchor. Thus, algorithm 2 is the only signaled
	  algorithm by now. That means, we only need RRSIG_K_2(DNSKEY)
	  to authenticate the DNSKEY RRset, and we still are compliant
	  with section 2.2 from RFC 4035: There must be a RRSIG for
	  each RRset using at least one DNSKEY of each algorithm in
	  the zone apex DNSKEY RRset.
         </t>
  
      </section>
      <section anchor="5011andSingleType" title="Single Signing Type Algorithm Rollover, RFC5011 style">
	<t>
	  Combining the Single Signing Type Scheme Algorithm Rollover and RFC5011 style rollovers is
	  not trivial, see <xref target="5011-algorithm-roll-fig"/> in <xref target="AlgoFigures"/>.
	</t>

	<t>
	  Should you choose to perform an RFC5011 style rollover with a Single Signing Type key then remember that
	  section 2.1, RFC 5011 states:
<artwork>

    Once the resolver sees the REVOKE bit, it MUST NOT use this key
    as a trust anchor or for any other purpose except to validate
    the RRSIG it signed over the DNSKEY RRset specifically for the
    purpose of validating the revocation.

</artwork>

          This means that if you revoke DNSKEY_S_1, it cannot be
          used to validate its signatures over non-DNSKEY
          RRsets. Thus, those RRsets should be signed with a shadow
          key, DNSKEY_Z_1, during the algorithm rollover.  This
          shadow key can be introduced at the same time the signatures
          are pre-published, in step 2 (new RRSIGs). The shadow key
          must be removed at the same time the revoked DNSKEY_S_1 is
          removed from the zone. De-facto you temporarily falling back
          to a KSK/ZSK split model.
	</t>

	<t>
	  In other words, the rule that at every RRset there must be
	  at least one signature for each algorithm used in the DNSKEY
	  RRset still applies. This means that a different key with
	  the same algorithm, other than the revoked key, must sign
	  the entire zone. This can be the ZSK. Thus, more operations are
	  needed if the Single Type Signing Scheme is used. Before
	  rolling the algorithm, a new key must be introduced with the
	  same algorithm as the key that is candidate for
	  revocation. That key can than temporarily act as ZSK during
	  the algorithm rollover.
	</t>

	<t>
	  Just like with algorithm rollover RFC5011 style, while all zone
	  data must be signed with an unrevoked key, it is permissible
	  to sign the key set with a revoked key, for the same esoteric
	  argument described in <xref target="5011style"/>.
	</t>

      <t>
	The lesson of all of this is that a Single Type Signing
	scheme algorithm rollover using RFC5011 is as
	complicated as the name of the rollover implies, one is better off
	explicitly using a split key temporarily.
      </t>

      </section>

     
      <section anchor="NSEC-NSEC3" title="NSEC to NSEC3 algorithm rollover">
      <t>
	A special case is the rollover from an NSEC signed zone to an
	NSEC3 signed zone. In this case algorithm numbers are used to
	signal support for NSEC3 but they do not mandate the use of
	NSEC3. Therefore NSEC records should remain in the zone until
	the rollover to a new algorithm has completed and the new
	DNSKEY RR set has populated distant caches, at the end of
	the "new DNSKEY" stage. At that point
	the validators that have not implemented NSEC3 will treat the
	zone as unsecured as soon as they follow the chain of trust to
	DS that points to a DNSKEY of the new algorithm while
	validators that support NSEC3 will happily validate using
	NSEC. Turning on NSEC3 can then be done during the "new DS" step,
	increasing the serial number, realizing that this involves a re-signing
	of the zone and the introduction of the NSECPARAM record in
	order to signal authoritative servers to start serving NSEC3
	authenticated denial of existence.
      </t>
      <t>
	Summarizing, an NSEC to NSEC3 rollover is an ordinary algorithm
	rollover whereby NSEC is used all the time and only after that
	rollover finished NSEC3 needs to be deployed. The
	procedures are also listed in Sections 10.4 and 10.5 of
	<xref target="RFC5155">RFC 5155</xref>.
      </t>      
      </section>

    </section><!-- key algorithm rollover-->


	<!-- Adopted from gilles - ambivalent on whether this is
	     useful -->
	<section anchor="autokeyroll" title="Considerations for Automated Key Rollovers">
	  <t>
	    As keys must be renewed periodically, there is some
	    motivation to automate the rollover process. Consider the
	    following:
	  </t>
	  <t>
	    <list style="symbols">
	      <t>
		ZSK rollovers are easy to automate as only the child
		zone is involved.
	      </t>

	      <t>
		A KSK rollover needs interaction between parent and
		child.  Data exchange is needed to provide the new
		keys to the parent; consequently, this data must be
		authenticated and integrity must be guaranteed in
		order to avoid attacks on the rollover.
	      </t>

	    </list>
	  </t>

	</section> <!-- Automated Key Rollovers -->

      </section><!--Key rollover-->

      <section anchor="emergency" title="Planning for Emergency Key Rollover">

	<t>
	  This section deals with preparation for a possible key
	  compromise. It is advised to have a documented procedure
	  ready for when a key compromise is suspected or confirmed.
	</t>
	
	<t> 
	  When the private material of one of your keys is compromised
	  it can be used by an attacker for as long as a valid trust chain
	  exists.  A
	  trust chain remains intact for
	  <list style="symbols">
	    <t> 
	      as long as a signature over the compromised key in the
	      trust chain is valid, and
	    </t>
	    <t> 
	      as long as the DS RR in the parent zone points to the
	      compromised key, and
	    </t>
	    <t> 
	      as long as the key is anchored in a resolver and is used
	      as a starting point for validation (this is generally
	      the hardest to update).
	  </t>
	</list>
	
	
	</t>
	<t>
	  While a trust chain to your compromised key exists, your
	  namespace is vulnerable to abuse by anyone who has obtained
	  illegitimate possession of the key. Zone administrators have to
	  make a decision as to whether the abuse of the compromised key is
	  worse than having data in caches that cannot be
	  validated. If the zone administrator chooses to break the trust
	  chain to the compromised key, data in caches signed with
	  this key cannot be validated. However, if the zone
	  administrator chooses to take the path of a regular
	  rollover, during the rollover the malicious key holder
	  can continue to spoof data so that it appears to be valid.
	</t>

	<section title="KSK Compromise">

	  <t> 
	    A compromised KSK can be used to sign the key set of an
	    attacker's version of the zone. That zone could be used to poison the
	    DNS.
	   </t>

          <t> 
	    A zone containing a DNSKEY RRset with a compromised KSK is
	    vulnerable as long as the compromised KSK is configured as
	    trust anchor or a DS record in the parent zone points to it.
	  </t>
	  
	   <t>
	     Therefore, when the KSK has been compromised, the trust
	     anchor or the parent DS record should be replaced as soon as
	     possible. It is local policy whether to break the trust
	     chain during the emergency rollover. The trust chain
	     would be broken when the compromised KSK is removed from
	     the child's zone while the parent still has a DS record pointing
	     to the compromised KSK (the assumption is that there is
	     only one DS record at the parent. If there are multiple DS records
	     this does not apply -- however the chain of trust of this
	     particular key is broken).  
	   </t>
	   
	   <t> 
	     Note that an attacker's version of the zone still uses the compromised
	     KSK and the presence of the corresponding DS record in
	     the parent would cause the data in this zone to appear as
	     valid. Removing the compromised key would cause the
	     attacker's version of the zone to appear as valid and the original zone
	     as Bogus. Therefore, we advise not to remove the KSK
	     before the parent has a DS record for the new KSK in
	     place.
	   </t>

	   <section title="Keeping the Chain of Trust Intact">
	     
	     <t>
	       If we follow this advice, the timing of the replacement
	       of the KSK is somewhat critical. The goal is to remove
	       the compromised KSK as soon as the new DS RR is
	       available at the parent.  We therefore have to make
	       sure that the signature made with a new KSK over the
	       key set that contains the compromised KSK expires just
	       after the new DS appears at the parent. Expiration of
	       that signature will cause expiration of that key set
	       from the caches.
	     </t>
	     
	     <t>
	       The procedure is as follows:
	       <list style="numbers">


          <t>Introduce a new KSK into the key set, keep the
          compromised KSK in the key set. Lower the TTL for DNSKEYs
	  so that the DNSKEY RRset will expire from caches sooner.
	  </t>

          <t>Sign the key set, with a short validity period. The validity
             period should expire shortly after the DS is expected to appear
             in the parent and the old DSes have expired from caches.
             This provides an upper limit on how long the compromised KSK
             can be used in a replay attack.
          </t>

	  <t>Upload the DS for this new key to the parent.</t>

          <t>Follow the procedure of the regular KSK rollover: Wait
          for the DS to appear at the authoritative servers and then
          wait as long as the TTL of the old DS RRs. If necessary re-sign the DNSKEY RRset
          and modify/extend the expiration time.
          </t>

         <t> Remove the compromised
             DNSKEY RR from the zone and re-sign the key set using your
             "normal" TTL and signature validity interval.
	 </t>

        </list>
	
     </t>

           <t>
          An additional danger of a key compromise is that the
          compromised key could be used to facilitate a legitimately looking
          DNSKEY/DS rollover and/or name server changes at the parent. When
          that happens, the domain may be in dispute. An
          authenticated out-of-band and secure notify mechanism to
          contact a parent is needed in this case.
                  </t>
                  <!-- This is only when as DNSSEC keys are used to
                  validate the rollover -->
                  <t>
                  Note that this is only a problem when the DNSKEY and or
                  DS records are used for authentication to the parent.
                  </t>

	</section> <!-- Keeping the Chain of Trust Intact -->

	<section title="Breaking the Chain of Trust">
        <t> 
	  There are two methods to break the chain of trust. The first
	  method causes the child zone to appear 'Bogus' to validating
	  resolvers. The other causes the child zone to appear
	  'insecure'. These are described below.
	</t>
	
	<t>
	  In the method that causes the child zone to appear 'Bogus'
	  to validating resolvers, the child zone replaces the current
	  KSK with a new one and re-signs the key set. Next, it sends
	  the DS of the new key to the parent. Only after the parent
	  has placed the new DS in the zone is the child's chain of
	  trust repaired. Note that until that time, the child zone
	  is still vulnerable to spoofing: the attacker is still in
	  possesion of the compromised key that the DS points to.
	</t>
        <t>
	  An alternative method of breaking the chain of trust is by
	  removing the DS RRs from the parent zone altogether. As a
	  result, the child zone would become insecure.
	</t>
      </section> <!-- Breaking the Chain of Trust -->
      
      
    </section><!--KSK compromise-->
    
    <section title="ZSK Compromise">
      
      <t>
	Primarily because there is no interaction with the parent required
	when a ZSK is compromised, the situation is less severe than
	with a KSK compromise. The zone must still be re-signed with a
	new ZSK as soon as possible. As this is a local operation and
	requires no communication between the parent and child, this
	can be achieved fairly quickly. However, one has to take into
	account that just as with a normal rollover the immediate
	disappearance of the old compromised key may lead to
	verification problems.  Also note that until the RRSIG
	over the compromised ZSK has expired, the zone may be still
	at risk.
      </t>
    </section><!--ZSK compromise-->
    
    <section title="Compromises of Keys Anchored in Resolvers">
      
      <t>
	A key can also be pre-configured in resolvers as a trust-anchor.
	If trust-anchor keys are compromised, the administrators of
	resolvers using these keys should be notified of this
	fact. Zone administrators may consider setting up a mailing
	list to communicate the fact that a SEP key is about to be
	rolled over. This communication will of course need to be
	authenticated by some means, e.g. by using digital signatures.
      </t>
      <t>
	End-users faced with the task of updating an anchored key
	should always verify the new key. New keys should be
	authenticated out-of-band, for example, through the use of an
	announcement website that is secured using secure sockets
	(TLS) <xref target="RFC5246"/>.
	  </t>
    </section><!--Pre-configured key compromise-->

    <section title="Stand-by Keys">
	<t>
	Stand-by keys are keys that are published in your zone, but
	are not used to sign RRsets. There are two reasons why someone
	would want to use stand-by keys. One is to speed up the
	emergency key rollover. The other is to recover from a disaster
	that leaves your production private keys inaccessible.
        </t>

	<t>
	The way to deal with stand-by keys differs for ZSKs and KSKs.
	To make a stand-by ZSK, you need to publish its DNSKEY RR.
	To make a stand-by KSK, you need to get its DS RR published at the parent.
        </t>

        <t>
        Assuming you have your DNS operation at location A, to prepare stand-by keys
        you need to:

	<list style="symbols">
        <t>Generate a stand-by ZSK and KSK. Store them safely in a different
	   location (B) than the currently used ZSK and KSK (that are at location A).</t>
	<t>Pre-publish DNSKEY RR of the stand-by ZSK in the zone.</t>
	<t>Pre-publish DS of the stand-by KSK in the parent zone.</t>
        </list>

        Now suppose a disaster occurs and disables access to the currently used keys.
        To recover from that situation, follow these procedures:
  
	<list style="symbols">
	<t>Set up your DNS operations and import the stand-by keys from location B.</t>
	<t>Post-publish the current ZSK and sign the zone with the stand-by keys.</t>
	<t>After some time, when the new signatures have been propagated, 
	   the old ZSK and DS can be removed.</t>
	<t>Generate a new stand-by key set at a different location and continue "normal" operation.</t>
	</list>
	</t>

    </section> <!--Stand-by Keys -->


      </section> <!--Planning for key compromise -->


      <!--  -->

      <section anchor="parents" title="Parent Policies">


	<section title="Initial Key Exchanges and Parental Policies Considerations">

	  <t> The initial key exchange is always subject to the
	  policies set by the parent.  It is specifically important in
	  a registry-registrar model where the key material is to be
	  passed from the DNS operator, to the (parent) registry via a registrar,
	  where both DNS operator and registrar are selected by the
	  registrant and might be different organisations. When
	  designing a key exchange policy one should take into account
	  that the authentication and authorization mechanisms used
	  during a key exchange should be as strong as the
	  authentication and authorization mechanisms used for the
	  exchange of delegation information between parent and
	  child. That is, there is no implicit need in DNSSEC to make
	  the authentication process stronger than it is for regular DNS.</t>


	  <t> Using the DNS itself as the source for the actual DNSKEY
	  material has the benefit that it reduces the chances of user
	  error. A DNSKEY query tool can make use of the
	  SEP bit <xref target="RFC4035"/> to select the proper
	  key from a DNSSEC key set, thereby reducing the chance that
	  the wrong DNSKEY is sent. It can validate the self-signature
	  over a key; thereby verifying the ownership of the private
	  key material. Fetching the DNSKEY from the DNS ensures that
	  the chain of trust remains intact once the parent publishes
	  the DS RR indicating the child is secure.  </t>

	  <t> Note: out-of-band verification is still needed when the
	  key material is fetched for the first time, even via DNS.
	  The parent can never be
	  sure whether or not the DNSKEY RRs have been spoofed.
	  </t>

	  <t> With some type of key rollovers, the DNSKEY is not
	  pre-published and a DNSKEY query tool is not able to retrieve
	  the successor key. In this case, the out-of-band method is
	  required. This also allows the child to determine the digest
	  algorithm of the DS record.
	  </t>

	</section>

	<section title="Storing Keys or Hashes?">

	  <t>When designing a registry system one should consider
	  whether to store the DNSKEYs and/or the corresponding DSes.
	  Since a child zone might wish to have a DS published using a
	  message digest algorithm not yet understood by the registry,
	  the registry can't count on being able to generate the DS
	  record from a raw DNSKEY.  Thus, we recommend that registry
	  systems should be able to store DS RRs, even if they also
	  store DNSKEYS (see also <xref
	  target="I-D.ietf-dnsop-dnssec-trust-anchor">draft-ietf-dnsop-dnssec-trust-anchor</xref>).
	  </t>

	  <t>
	    The storage considerations also relate to the design of
	    the customer interface and the method by which data is
	    transferred between registrant and registry; Will the
	    child zone administrator be able to upload DS RRs with
	    unknown hash algorithms or does the interface only allow
	    DNSKEYs? When registries support the Extensible
	    Provisioning Protocol (EPP) <xref target="RFC5910"/>,
	    that can be used for registrar-registry interactions since
	    that protocol allows the transfer of both DS and optionally
	    DNSKEY RRs. There is no standardized way for moving the
	    data between the customer and the registrar.  Different registrars have different mechanisms,
	    ranging from simple web interfaces to various APIs. In
	    some cases the use of the DNSSEC extensions to EPP may be
	    applicable.
	  </t>

	  <t>Having an
	  out-of-band mechanism, such as a registry directory (e.g., Whois),
	  to find out which keys are used to generate DS Resource Records for
	  specific owners and/or zones may also help with
	  troubleshooting.
	  </t>

	</section>

	<section title="Security Lameness" anchor="lame">

	  <t> Security lameness is defined as the state whereby the
	  parent has a DS RR pointing to a non-existing DNSKEY
	  RR. Security lameness may occur temporarily during a
	  Double-DS rollover scheme. However care should be taken that
	  not all DS RRs are security lame which may cause the child's
	  zone to be marked "Bogus" by verifying DNS clients.
	  </t>

	 <t> As part of a comprehensive delegation check, the parent could,
	 at key exchange time, verify that the child's key is actually
	 configured in the DNS.
	  However, if a parent does not understand the hashing algorithm used
	  by child, the parental checks are limited to only comparing the key
	  id.
	  </t>

	  <t>
	    Child zones should be very careful in removing DNSKEY material,
	    specifically SEP keys, for which a DS RR exists.
	  </t>

	  <t> Once a zone is "security lame", a fix (e.g., removing a
	  DS RR) will take time to propagate through the DNS.

	  </t>
	</section>

	<section anchor="DSvalidity" title="DS Signature Validity Period">

	  <t>
	    Since the DS can be replayed as long as it has a valid
	    signature, a short signature validity period for the DS
	    RRSIG minimizes the time a child is vulnerable in the case
	    of a compromise of the child's KSK(s).  A signature
	    validity period that is too short introduces the
	    possibility that a zone is marked "Bogus" in case of a
	    configuration error in the signer. There may not be enough
	    time to fix the problems before signatures expire (this is
	    a generic argument also see <xref target="sigval"/>).
	    Something as mundane as zone administrator unavailability during
	    weekends shows the need for DS signature validity periods
	    longer than two days. Just like any signature validity period,
	    we recommend an absolute minimum for
	    the DS signature validity period of a few days.
	  </t>

	  <t>
	    The maximum signature validity period of the DS record
	    depends on how long child zones are willing to be
	    vulnerable after a key compromise. On the other hand,
	    shortening the DS signature validity interval increases
	    the operational risk for the parent. Therefore, the parent
	    may have policy to use a signature validity interval that
	    is considerably longer than the child would hope for.
	  </t>

	  <t> 
	    A compromise between the policy/operational constraints of the
	    parent and minimizing damage for the child may result in a
	    DS signature validity period somewhere between a week and
	    months.
	  </t>
	  
	  <t>
	    In addition to the signature validity period, which sets a
	    lower bound on the number of times the zone administrator will
	    need to sign the zone data and which sets an upper bound
	    to the time a child is vulnerable after key compromise,
	    there is the TTL value on the DS RRs. Shortening the TTL
	    reduces the damage of a successful replay attack. It does
	    mean that the authoritative servers will see more
	    queries. But on the other hand, a short TTL lowers the
	    persistence of DS RRsets in caches thereby increasing the
	    speed with which updated DS RRsets propagate through the
	    DNS.
	  </t>
	</section>
	<section title="Changing DNS Operators" anchor="changing-operators">
	    <t>
	      The parent-child relation is often described in terms of
	      a registry-registrar-registrant model, where a registry maintains the
	      parent zone, and the registrant (the user of the
	      child-domain name) deals with the registry through an
	      intermediary called a registrar. (See <xref
	      target="RFC3375"/> for a comprehensive
	      definition). Registrants may out-source the maintenance
	      of their DNS system, including the maintenance of DNSSEC
	      key material, to the registrar or to another third
	      party, which we will call the DNS operator. The DNS
	      operator that has control over the DNS zone and its keys
	      may prevent the registrant to make a timely move to a
	      different DNS operator.

	    </t>
	    
	    <t>
	      For various reasons, a registrant may want to move
	      between DNS operators.  How easy this move will be
	      depends principally on the DNS operator from which the
	      registrant is moving (the losing operator), as they have
	      control over the DNS zone and its keys.  The following
	      sections describe the two cases: where the losing
	      operator cooperates with the new operator (the gaining
	      operator), and where the two do not cooperate.
	    </t>
	  <section title="Cooperating DNS operators" anchor="cooperating_registrars">

	    <t>
	    In this scenario, it is assumed that losing operator will not
	    pass any private key material to the gaining operator (that would
	    constitute a trivial case) but is otherwise fully cooperative.
	    </t>

	    
	    <t>
	      In this environment, the change could be made with a
	      Pre-Publish ZSK rollover whereby the losing operator
	      pre-publishes the ZSK of the gaining operator, combined
	      with a Double Signature KSK rollover where the two
	      registrars exchange public keys and independently
	      generate a signature over those key sets that they
	      combine and both publish in their copy of the zone. Once
	      that is done they can use their own private keys to sign
	      any of their zone content during the transfer.
	    </t>

 	    <figure anchor="operator-roll-fig" title="Rollover for cooperating operators">
	<?rfc?><?rfc linefile="1:Operator-roll.xml"?><artwork>
 ------------------------------------------------------------
 initial            |        pre-publish                    |
 ------------------------------------------------------------
 Parent:
  NS_A                            NS_A          
  DS_A                            DS_A           
 ------------------------------------------------------------
 Child at A:            Child at A:        Child at B:
  SOA_A0                 SOA_A1             SOA_B0
  RRSIG_Z_A(SOA)         RRSIG_Z_A(SOA)     RRSIG_Z_B(SOA)
                           
  NS_A                   NS_A               NS_B
  RRSIG_Z_A(NS)          NS_B               RRSIG_Z_B(NS)
                         RRSIG_Z_A(NS)

  DNSKEY_Z_A             DNSKEY_Z_A         DNSKEY_Z_A            
                         DNSKEY_Z_B         DNSKEY_Z_B
  DNSKEY_K_A             DNSKEY_K_A         DNSKEY_K_A            
                         DNSKEY_K_B         DNSKEY_K_B
  RRSIG_K_A(DNSKEY)      RRSIG_K_A(DNSKEY)  RRSIG_K_A(DNSKEY)
                         RRSIG_K_B(DNSKEY)  RRSIG_K_B(DNSKEY)
 ------------------------------------------------------------

 ------------------------------------------------------------
       Redelegation                 |   post migration      |
 ------------------------------------------------------------
 Parent:
           NS_B                           NS_B
           DS_B                           DS_B
 ------------------------------------------------------------
 Child at A:        Child at B:           Child at B:

  SOA_A2             SOA_B1                SOA_B2
  RRSIG_Z_A(SOA)     RRSIG_Z_B(SOA)        RRSIG_Z_B(SOA)

  NS_A               NS_B                  NS_B
  NS_B               RRSIG_Z_B(NS)         RRSIG_Z_B(NS)
  RRSIG_Z_A(NS)

  DNSKEY_Z_A         DNSKEY_Z_A
  DNSKEY_Z_B         DNSKEY_Z_B            DNSKEY_Z_B
  DNSKEY_K_A         DNSKEY_K_A
  DNSKEY_K_B         DNSKEY_K_B            DNSKEY_K_B            
  RRSIG_K_A(DNSKEY)  RRSIG_K_A(DNSKEY)
  RRSIG_K_B(DNSKEY)  RRSIG_K_B(DNSKEY)     RRSIG_K_B(DNSKEY)

 ------------------------------------------------------------
</artwork>
<?rfc linefile="1295:Rollover.xml"?>
 	    </figure>
	      <t>
		In this figure A denotes the losing operator and
		B the gaining operator. RRSIG_Z is the RRSIG
		produced by a ZSK, RRSIG_K is produced with a KSK, the
		appended A or B indicates the producers of the key
		pair. "Child at A" is how the zone content is represented
 		by the losing DNS operator and "Child at B" is how the
 		zone content is represented by the gaining DNS
		operator.
	      </t>

		<t>
		The zone is initially delegated from the parent to the name servers
		of operator A. Operator A uses his own ZSK and KSK to sign the zone.
		The cooperating operator A will pre-publish the new NS record and
		the ZSK and KSK of
		operator B, including the RRSIG over the DNSKEY RRset generated
		by the KSK of B. Operator B needs to publish the same DNSKEY RRset.
		When that DNSKEY RRset has populated the caches, the redelegation can be
		made. And after all DNSSEC records related to A have expired from
		the caches, operator B can stop publishing the keys and signatures
		belonging to operator A.
		</t>
		
	    <t>
		The requirement to exchange signatures has a couple of drawbacks.
		It requires more operational overhead, because not only the operators have to exchange
		public keys, they also have to exchange the signatures of the new DNSKEY RRset.
		Also, it disallows the children to refresh the signatures when they expire for a
		certain period.
		Both drawbacks do not exist if you replace the Double Signature KSK rollover with a
		Double-DS KSK rollover.
		See <xref target="coop_registrars" /> in <xref target="DNSOPFigures" /> for the diagram.
		</t>

	    <t>
		Thus, if the registry and registrars allow for DS records to
	      be published that do not point to a published DNSKEY in the child zone,
	      the Double-DS KSK rollover is preferred (also known as Pre-Publication KSK Rollover, see <xref target="pre-pubkish-ksk-roll-fig"/>),
	      in combination with the Pre-Publish ZSK rollover. This does not require to share the KSK signatures between the
	      operators. Both the losing and the gaining operator still need to publish the public ZSK of each other.
	    </t>

	  </section>
	  <section title="Non Cooperating DNS operators" anchor="non_cooperating_registrars">

	      <t>
	      In the non-cooperative case matters are more complicated. The
	      losing operator may not cooperate and
	      leave the data in the DNS as is. In the extreme case
	      the losing operator may become obstructive and publish
	      a DNSKEY RR with a high TTL and corresponding signature
	      validity so that registrar A's DNSKEY could end up in
	      caches for (in theory at least) tens of years.
	    </t>
	    
	    <t>
	      The problem arises when a validator tries to validate
	      with the losing operator's key and there is no
	      signature material produced with the losing operator
	      available in the delegation path after redelegation from
	      the losing operator to the gaining operator has taken
	      place.  One could imagine a rollover scenario where the
	      gaining operator pulls all RRSIGs created by the losing
	      operator and publishes those in conjunction with its own
	      signatures, but that would not allow any changes in the
	      zone content. Since a redelegation took place the NS
	      RRset has - by definition - changed so such rollover
	      scenario will not work. Besides if zone transfers are
	      not allowed by the losing operator and NSEC3 is
	      deployed in the losing operator's zone, then the
	      gaining operator's zone will not have certainty that
	      all of A's RRSIGs are transferred.
	    </t>
	    <t>
	      The only viable option for the registrant is to publish
	      its zone unsigned and ask the registry to remove the DS RR
	      pointing to the losing operator's DNSKEY.
	    </t>
	    <t>
	      Note that some behavior of resolver implementations may aid in
              the process of changing DNS operators:
		<list style="symbols">
		<t>TTL sanity checking, as described in RFC2308
		   <xref target="RFC2308"/>, will limit the impact
		   the actions of an obstructive, losing operator.
		   Resolvers that implement TTL sanity checking will
		   use an upper limit for TTLs on RRsets in responses.
		</t>
		<t>If RRsets at the zone cut (are about to) expire,
		the resolver restarts its search above the zone cut.
		Otherwise, the resolver risks to keep using a name server
		that might be undelegated by the parent.
		</t>
		<t>Limiting the time DNSKEYS that seem to be unable to validate
		signatures are cached and/or trying to recover from cases where
		DNSKEYs do not seem to be able to validate data, also
		reduces the effects of the problem of non-cooperating registars.
		</t>
		</list>
	    </t>
	    <t>
	      However, there is no operational methodology to work
	      around this business issue, and proper contractual
	      relationships between all involved parties seems to be
	      the only solution to cope with these problems. It should
	      be noted that in many cases, the problem with temporary
	      broken delegations already exists when a zone changes
	      from one DNS operator to another. Besides, it is often
	      the case that when operators are changed the services
	      that that zone references also change operator, possibly
	      involving some downtime.
	    </t>
	    <t>
	      In any case, to minimise such problems, the classic
	      recommendation is to have relative short TTL on all
	      involved resource records. That will solve many of the
	      problems regarding changes to a zone regardless of
	      whether DNSSEC is used.

	    </t>
	    
	    
	</section><!--noncooperative registrars-->
      </section>
    </section><!-- Parental policies -->



    <section anchor="time" title="Time in DNSSEC">
      <t>
	Without DNSSEC, all times in the DNS are relative. The SOA
	fields REFRESH, RETRY, and EXPIRATION are timers used to
	determine the time elapsed after a slave server synchronized
	with a master server. The Time to Live (TTL) value and the SOA
	RR minimum TTL parameter <xref target="RFC2308" /> are used to
	determine how long a forwarder should cache data after it has
	been fetched from an authoritative server. By using a
	signature validity period, DNSSEC introduces the notion of an
	absolute time in the DNS. Signatures in DNSSEC have an
	expiration date after which the signature is marked as invalid
	and the signed data is to be considered Bogus.
      </t>
      <t>
	The considerations in this section are all qualitative and
	focused on the operational and managerial issues. A more
	thorough quantitative analysis of rollover timing parameters
	can be found in <xref
	target="I-D.ietf-dnsop-dnssec-key-timing">draft-ietf-dnsop-dnssec-key-timing</xref>
      </t>

      <section anchor="time_considerations" title="Time Considerations">

	<t>
	  Because of the expiration of signatures, one should consider the
	  following:
	</t>
	<t>
	  <list style="symbols">

	    <t>
	      We suggest the Maximum Zone TTL of your zone data to be a
	      fraction of your signature validity period.

	      <list style="hanging">
		<t>
		  If the TTL was of similar order as the signature
		  validity period, then all RRsets fetched during the
		  validity period would be cached until the signature
		  expiration time.  <xref target="RFC4033">Section 8.1
		  of RFC4033</xref> suggests that "the resolver may
		  use the time remaining before expiration of the
		  signature validity period of a signed RRset as an
		  upper bound for the TTL". As a result, query load on
		  authoritative servers would peak at signature
		  expiration time, as this is also the time at which
		  records simultaneously expire from caches.
		</t>
		<t>
		  To avoid query load peaks, we suggest the TTL on all
		  the RRs in your zone to be at least a few times
		  smaller than your signature validity period.
		</t>
	      </list>
	    </t>
	    <t>
	      We suggest the signature publication period to end at
	      least one Maximum Zone TTL duration (but preferably 
	      a minumum of a few days) before the end of the signature validity period.
	      <list style="hanging">

		<t>
		  Re-signing a zone shortly before the end of the
		  signature validity period may cause simultaneous
		  expiration of data from caches. This in turn may
		  lead to peaks in the load on authoritative
		  servers. To avoid this schemes are deployed whereby
		  the zone is periodically visited for a re-signing
		  operation and those signatures that are within a so
		  called refresh interval from signature expiration
		  are recreated. Also see <xref target="sigval"/>
		  below.
		</t>

		<t>
		In case of an operational error, you would have one
		Maximum Zone TTL duration to resolve the problem.
		Re-signing a zone a few days before the end of the 
		signature validity period ensures the signatures
		will survive a weekend in case of such operational havoc.
		This is called the Refresh period (see <xref target="sigval"/>).
		</t>

	      </list>
	    </t>
	    <t>
	      We suggest the Minimum Zone TTL to be long enough to
	      both fetch and verify all the RRs in the trust chain. In
	      workshop environments, it has been demonstrated <xref
	      target="NIST-workshop" /> that a low TTL (under 5 to 10
	      minutes) caused disruptions because of the following two
	      problems:

	      <list style="hanging">
		
		<t>
		  1. During validation, some data may expire before
		  the validation is complete. The validator should be
		  able to keep all data until it is completed. This
		  applies to all RRs needed to complete the chain of
		  trust: DS, DNSKEY, RRSIG, and the final answers,
		  i.e., the RRset that is returned for the initial
		  query.
		</t>
		<t>
		  2. Frequent verification causes load on recursive
		  name servers. Data at delegation points, DS, DNSKEY, and
		  RRSIG RRs benefit from caching. The TTL on those should be
		  relatively long. Data at the leafs in the DNS tree
		  has less impact on recursive name servers.
		</t>
	      </list>
	    </t>
	    <t>
	      Slave servers will need to be able to fetch newly signed
	      zones well before the RRSIGs in the zone served by the
	      slave server pass their signature expiration time.
	      <list style="hanging">
		
		
		<t>
		  When a slave server is out of synchronization with its master
		  and data in a zone is signed by expired signatures,
		  it may be better for the slave server not to give
		  out any answer.
		</t>

		<t>
		  Normally, a slave server that is not able to contact
		  a master server for an extended period will expire a
		  zone. When that happens, the server will respond
		  differently to queries for that zone. Some servers
		  issue SERVFAIL, whereas others turn off the 'AA' bit
		  in the answers.

		  The time of expiration is set in the SOA
		  record and is relative to the last successful refresh
		  between the master and the slave servers. There exists no
		  coupling between the signature expiration of RRSIGs in
		  the zone and the expire parameter in the SOA.
		</t>

		<t>
		  If the server serves a DNSSEC zone, then it may well
		  happen that the signatures expire well before the SOA
		  expiration timer counts down to zero. It is not possible
		  to completely prevent this by modifying
		  the SOA parameters.
		</t>
		<t>
		  However, the effects can be minimized where the SOA
		  expiration time is equal to or shorter than the
		  Refresh period (see <xref target="sigval"/>).
		</t>

		<t>
		  The consequence of an authoritative server not being
		  able to update a zone for an extended period of time
		  is that signatures may expire. In this case
		  non-secure resolvers will continue to be able to
		  resolve data served by the particular slave servers
		  while security-aware resolvers will experience
		  problems because of answers being marked as Bogus.
		</t>


		<t>
		  We suggest the SOA expiration timer being approximately
		  one third or a quarter of the signature validity period.
		  It will allow problems with transfers from the master server
		  to be noticed before the actual signature times out.
		</t>


		<t>
		  We also suggest that operators of name servers that
		  supply secondary services develop systems to identify
		  upcoming signature expirations in zones they slave and
		  take appropriate action where such an event is detected.
		</t>

		<t>
		  When determining the value for the expiration parameter
		  one has to take the following into account: what are the
		  chances that all my secondaries expire the zone? How quickly
		  can I reach an administrator of secondary servers to
		  load a valid zone? These questions are not DNSSEC
		  specific but may influence the choice of your signature
		  validity intervals.
	      </t>
	      </list>
	    </t>

	  </list>
	</t>
      </section> <!-- time considerations -->


    <section title="Signature Validation Periods" anchor="sigval">

      <section title="Maximum Value">
      <t>
	The first consideration for choosing a maximum signature
	validity period is the risk of a replay attack. For low-value,
	long-term stable resources the risks may be minimal and the
	signature validity period may be several months. Although
	signature validity periods of many years are allowed the same
	operational habit arguments as in <xref
	target="rolling-ksk-ta"/> play a role: when a zone is re-signed
	with some regularity, then zone administrators remain conscious about the
	operational necessity of re-signing.
      </t>
      </section>
      <section title="Minimum Value">
	<t> 
	  The minimum value of the signature validity period is set for
	  the time by which one would like to survive operational
	  failure in provisioning: what is the time that a failure
	  will be noticed, what is the time that action is expected to
	  be taken? By answering these questions availability of
	  zone administrators during (long) weekends or time taken to access to backup media
	  can be taken into account. The result could easily suggest a
	  minimum Signature Validity period of a few days.
	</t>
	<t>
	  Note however, the argument above is assuming that zone data
	  has just been signed and published when the problem
	  occurred. In practice it may be that a zone is signed
	  according to a frequency set by the Re-Sign Period whereby
	  the signer visits the zone content and only refreshes
	  signatures that are close to expiring: the signer will only
	  refresh signatures if they are within the Refresh Period
	  from the signature expiration time.  The Re-Sign Period must
	  be smaller than the Refresh Period in order for zone data to
	  be signed in timely fashion.
	</t>
	<t>
	  If an operational problem occurs during re-signing then the
	  signatures in the zone to expire first are the ones
	  that have been generated longest ago. In the worst case
	  these signatures are the Refresh Period minus the Re-Sign
	  Period away from signature expiration.
	</t>
	<t>
	  To make matters slightly more complicated, some signers vary
	  the signature validity period over a small range (the jitter
	  interval) so that not all signatures expire at the same
	  time. 
	</t>
	<t>
	  In other words, the minimum Signature Validity interval is
	  set by first choosing the Refresh Period (usually a few
	  days), then defining the Re-Sign period in such a way that 
	  the Refresh Period minus the Re-Sign period, minus the maximum
	  jitter sets the time in which operational havoc can be resolved.
	</t>

	<t>
	  The relationship between signature times is illustrated in
	  <xref target="signature-fig" />. 
	</t>

	<figure anchor="signature-fig" title="Signature Timing Parameters">
	<?rfc?><?rfc linefile="1:SignatureFigure.xml"?><artwork>

 Inception          Signing                                 Expiration
 time               time                                    time
 |                  |                                 |     |     |
 |------------------|---------------------------------|.....|.....|
 |                  |                                 |     |     |
                                                        +/-jitter

 | Inception offset |                                       |
 |&lt;----------------&gt;|            Validity Period            |
 |               |&lt;----------------------------------------&gt;|



                          
 Inception          Signing Reuse   Reuse   Reuse   New     Expiration
 time               time                            RRSIG   time
 |                  |       |       |       |       |       |
 |------------------|-------------------------------|-------|
 |                  |       |       |       |       |       |
                     &lt;-----&gt; &lt;-----&gt; &lt;-----&gt; &lt;-----&gt;
                   Resign Period
                    
                                       |                  |
                                       |&lt;-Refresh Period-&gt;|
                                       |                  |
</artwork>
<?rfc linefile="1690:Rollover.xml"?>
	</figure>	
	<t> 
	  Note that in the figure the validity of the signature starts shortly before the
	  signing time. That is done to deal with 
	  validators that might have some clock skew. The inception offset
	  should be chosen so that you minimize the false negatives to a 
	  reasonable level.
	</t>
      </section>
      <section title="Differentiation between RR sets">
	<t>
	  It is possible to vary signature validity periods between
	  signatures over different RR sets in the zone. In practice
	  this could be done when zones contain highly volatile data
	  (which may be the case in dynamic update environments). Note
	  however that the risk of replay (e.g. by stale secondary
	  servers) is what should be leading in determining the
	  signature validity period since the TTLs on the data itself
	  still are still the primary parameter for cache expiry.  
	</t>
	<t>
	  In some cases the risk of replaying existing data might be
	  different from the risk of replaying the denial of data. In
	  those cases the signature validity period on NSEC or NSEC3
	  records may be tweaked accordingly.
	</t>
	<t>
	  When a zone contains secure delegations, then a relatively
	  short signature validity interval protects the child against
	  replay attacks in the case the child's key is compromised
	  (see <xref target="DSvalidity"/>). Since there is a higher
	  operational risk for the parent registry when choosing a
	  short validity interval and a higher operational risk for
	  the child when choosing a long validity period some (price)
	  differentiation may occur for validity periods between
	  individual DS RRs in a single zone.
	</t>
	<t>
	  There seem to be no other arguments for differentiation in
	  validity periods.
	</t>
      </section>
      
    </section>
    
    
    </section> <!-- time in DNS -->


      
      
    </section><!-- Signature generation key rollover and related policies -->
<?rfc linefile="82:draft-ietf-dnsop-rfc4641bis.xml"?>
    
    <?rfc?><?rfc linefile="1:NSEC_NSEC3.xml"?>
<!-- Included from NSEC_NSEC3.xml -->
<!-- $Id -->

<section anchor="nsec_nsec3" title="Next Record type">
  <t>
    One of the design tradeoffs made during the development of DNSSEC
    was to separate the signing and serving operations instead of
    performing cryptographic operations as DNS requests are being
    serviced. It is therefore necessary to create records that cover
    the very large number of non-existent names that lie between the
    names that do exist.
  </t>
  <t>
    There are two mechanisms to provide authenticated proof of
    non-existence of domain names in DNSSEC: a clear text one and an
    obfuscated-data one.  Each mechanism:
    <list style="symbols">
      <t>
	includes a list of all the RRTYPEs present which can be used
	to prove the non-existence of RRTYPEs at a certain name;
      </t>
      <t>
	stores only the name for which the zone is authoritative (that
	is, glue in the zone is omitted); and
      </t>
      <t>
	uses a specific RRTYPE to store information about the RRTYPEs
	present at the name: the clear-text mechanism uses NSEC, and
	the obfuscated-data mechanism uses NSEC3.
      </t>
    </list>
  </t>
  
  <section title="Differences between  NSEC and NSEC3">
    <t>
      The clear text mechanism (NSEC) is implemented using a sorted
      linked list of names in the zone.  The obfuscated-data mechanism
      (NSEC3) is similar but first hashes the names using a one-way
      hash function, before creating a sorted linked list of the
      resulting (hashed) strings.
    </t>
 
    <t>
      The NSEC record requires no cryptographic operations aside from
      the validation of its associated signature record. It is human
      readable and can be used in manual queries to determine correct
      operation.  The disadvantage is that it allows for "zone
      walking", where one can request all the entries of a zone by
      following the linked list of NSEC RRs via the "Next Domain Name"
      field.
    </t>
    <t>
      Though all agree DNS data is accessible through query
      mechanisms, a side effect of NSEC is that it allows the contents
      of a zone file to be enumerated in full by sequential
      queries. Whilst for some zone administrators this behavior is acceptable
      or even desirable, for others it is undesirable for policy,
      regulatory or other reasons.  This is the first difference
      between NSEC and NSEC3.
    </t>
    <t>
      The second difference between NSEC and NSEC3 is that NSEC
      requires a signature over every RR in the zonefile, thereby
      ensuring that any denial of existence is cryptographically
      signed. However, in a large zonefile containing many delegations
      very few of which are to signed zones, this may produce
      unacceptable additional overhead especially where insecure
      delegations are subject to frequent update (a typical example
      might be a TLD operator with few registrants using secure
      delegations). NSEC3 allows intervals between two such
      delegations to "Opt-out" in which case they may contain one more
      more insecure delegations, thus reducing the size and
      cryptographic complexity of the zone at the expense of the
      ability to cryptographically deny the existence of names in a
      specific span.
    </t>
    <t>
      The NSEC3 record uses a hashing method of the requested RRlabel.
      To increase the workload required to guess entries in the zone,
      the number of hashing iteration's can be specified in the NSEC3
      record. Additionally, a salt can be specified that also modifies
      the hashes. Note that NSEC3 does not give full protection
      against information leakage from the zone.
    </t>
  </section>
  <section title="NSEC or NSEC3">

    <t> 
      The first motivation to deploy NSEC3, prevention of zone
      enumeration, only makes sense when zone content is not highly
      structured or trivially guessable. Highly structured zones such
      as the in-addr.arpa, ip6.arpa and e164.arpa can be trivially
      enumerated using ordinary DNS properties while for small zones
      that only contain contain records in the APEX and a few common
      RRlabels such as "www" or "mail" guessing zone content and
      proving completeness is also trivial when using NSEC3.
    </t>
    <t>
      In those cases the use of NSEC is recommended to ease the work
      required by signers and validating resolvers.
    </t>
    <t>
      
      For large zones where there is an implication of "not readily
      available" RRlabels, such as those where one has to sign a
      non-disclosure agreement before obtaining it, NSEC3 is
      recommended. The second reason to consider NSEC3 is opt-out, which
	can reduce the number of NSEC3 records required.  This is discussed
	further below (<xref target="opt-out"/>).</t>
    
  </section>
  
  <section title="NSEC3 parameters">
	<t>
	NSEC3 is controlled by
	a number of parameters, some of which can be varied: this section
	discusses the choice of those parameters.
	</t>
    <section title="NSEC3 Algorithm">
    <t>
      The NSEC3 hashing algorithm is performed on the Fully Qualified
      Domain Name (FQDN) in its uncompressed form. This ensures brute
      force work done by an attacker for one (FQDN) RRlabel cannot be
      re-used for another (FQDN) RRlabel attack, as these entries are,
      by definition unique.
    </t>
      <t>
	At the moment of writing there is only one NSEC3 Hashing
	algorithm defined. <xref target="RFC5155"/> specifically calls
	out: "When a new hash algorithm for use with NSEC3 is
	specified, a transition mechanism MUST also be
	defined."
	 Therefore this document does not consider NSEC3 hash
	algorithm transition.
	</t>

    </section>
    <section title="NSEC3 Iterations">
      <t>
	One of the concerns with NSEC3 is  a pre-calculated dictionary attack could be made in order to assess
	if certain domain names exist within the zones or not. Two
	mechanisms are introduced in the NSEC3 specification to
	increase the costs of such dictionary attacks: Iterations and
	Salt.
      </t>
      
	<t>
  	Iterations define the number of additional times the hash
	  function has been performed. A higher value results in greater
	resiliency against dictionary attacks, at a higher computational
	cost for both the server and resolver.
	</t>

      <t>
	<xref target="RFC5155">RFC5155 Section 10.3</xref> considers the trade-offs
	between incurring cost during the signing process and imposing
	costs to the validating name server, while still providing a
	reasonable barrier against dictionary attacks. It provides
	useful limits of iterations for a given RSA key size. These
	are 150 iterations for 1024 bit keys, 500 iterations for 2048
	bit keys and 2,500 iterations for 4096 bit keys. Choosing
	a value of 100 iterations is deemed to be a sufficiently costly yet
	not excessive value: In the worst case scenario, the performance of your
	name servers would be halved, regardless of key size <xref target="nsec3hp"/>.
      </t>
    </section>
    <section title="NSEC3 Salt">
      <t>
	While the NSEC3 iterations parameter increases the cost of
	hashing a dictionary word, the NSEC3 salt reduces the lifetime
	for which that calculated hash can be used. A change of the
	salt value by the zone administrator would cause an attacker to lose
	all precalculated work for that zone.
      </t>
      <t>
	The FQDN RRlabel, which is part of the value that is hashed,
	already ensures that brute force work for one RRlabel can not
	be re-used to attack other RRlabel (e.g. in other domains) due
	to their uniqueness.
      </t>

      <t>
	The salt of all NSEC3 records in a zone needs to be the same.
	Since changing the salt requires all the NSEC3 records to be
	regenerated, and thus requires generating new RRSIG's over
	these NSEC3 records, it is recommended to align the change of
	the salt with a change of the Zone Signing Key, as that
	process in itself already usually requires all RRSIG's to be
	regenerated. If there is no critical dependency on incremental
	signing and the zone can be signed with little effort
	there is no need for such alignment. However, unlike Zone
	Signing Key changes, NSEC3 salt changes do not need special
	rollover procedures.  It is possible to change the salt each
	time the zone is updated.
      </t>
    </section>
    <section anchor="opt-out" title="Opt-out">
      <t>
	The Opt-Out mechanism was introduced to allow for a gradual
	introduction of signed records in zones that contain mostly
	delegation records. The use of the OPT-OUT flag changes the
	meaning of the NSEC3 span from authoritative denial of the
	existence of names within the span to a proof that DNSSEC is
	not available for the delegations within the span.
	This allows for the addition or removal of the
	delegations covered by the span without recalculating or re-
	signing RRs in the NSEC3 RR chain.
      </t>
      <t>
	Opt-Out is specified to be used only over delegation points
	and will therefore only bring relief to zones with a large
	number of zones and where the number of secure delegations is
	small. This consideration typically holds for large
	top-level-domains and similar zones; in most other
	circumstances Opt-Out should not be deployed. Further
	considerations can be found in <xref target="RFC5155">RFC5155
	section 12.2</xref>.
	
      </t>
    </section>
  </section>
</section>
<?rfc linefile="84:draft-ietf-dnsop-rfc4641bis.xml"?>
    
    
    
    
    
    <section title="Security Considerations">
      
      <t> 
	DNSSEC adds data integrity to the DNS. This document tries to
	assess the operational considerations to maintain a stable and
	secure DNSSEC service. Not taking into account the 'data
	propagation' properties in the DNS will cause validation
	failures and may make secured zones unavailable to
	security-aware resolvers.  
      </t>
      
      
    </section><!--Security considerations-->
    
    
    <section title="IANA considerations">
      <t>
	There are no IANA considerations with respect to this document
      </t>
    </section>
    
    <section title="Contributors and Acknowledgments">
      <t>
	Significant parts of the text of this document is copied from <xref
	target="RFC4641">RFC4641</xref>. That document was edited by
	Olaf Kolkman and Miek Gieben. Other people that contributed or
	where otherwise involved in that work were in random order:
	Rip Loomis, Olafur Gudmundsson, Wesley Griffin, Michael
	Richardson, Scott Rose, Rick van Rein, Tim McGinnis, Gilles
	Guette, Olivier Courtay, Sam Weiler, Jelte Jansen, Niall
	O'Reilly, Holger Zuleger, Ed Lewis, Hilarie Orman, Marcos
	Sanz, Peter Koch, Mike StJohns, Emma Bretherick, Adrian
	Bedford, and Lindy Foster, and O. Courtay.
	</t>
	<t>
	  For this version of the document we would like to
	  acknowledge a few people for significant contributions:
	  <list style="hanging">

	    <t hangText="Paul Hoffman">for his contribution on the choice of
	    cryptographic parameters and addressing some of the
	    trust anchor issues;</t>
	    
	    <t hangText="Jelte Jansen">who provided the initial
	    text in <xref target="KAR"/>;</t>    
	    
	    <t hangText="Paul Wouters">who provided the initial text for <xref
	    target="nsec_nsec3"/> and Alex Bligh who improved it;</t>
	    
	    <t hangText="Erik Rescorla">whose blogpost on "the Security of ZSK
	    rollovers" inspired text in <xref
	    target="zsk-ksk-motivation"/>;</t>
	    
	    <t hangText="Stephen Morris">who made a pass on English style and
	    grammar;</t>
	    
	    <t hangText="Matthijs Mekking">thorougly reviewed and provided
	    concrete improvements on the specific types of
	    keyrollovers (e.g. he provided the tables in <xref
	    target="AlgoFigures"/>); and </t>
    
	    <t hangText="Olafur Gudmundsson and Ondrej Sury">who provided input
	    on <xref target="KAR"/> based on actual operational
	    experience.</t>

	    <t hangText="Rickard Bellgrim">reviewed the document extensively.</t>

	  </list>
	</t>
	<t> The figure in <xref target="sigval"/> was adapted from
	the OpenDNSSEC user documentation.
	</t>
	<t>
	  In addition valuable contributions in the form of text,
	  comments, or review where provided by Mark Andrews, Patrik Faltstrom, Tony
	  Finch, Alfred Hines, Bill Manning, Scott Rose, and Wouter Wijngaards.
	</t>
	
	
      </section><!-- Acknowledgments -->
      
            
      
  </middle>
  
  
  <back>
    
    
    <references title='Normative References'>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.1034.xml"?>

<reference anchor='RFC1034'>

<front>
<title abbrev='Domain Concepts and Facilities'>Domain names - concepts and facilities</title>
<author initials='P.' surname='Mockapetris' fullname='P. Mockapetris'>
<organization>Information Sciences Institute (ISI)</organization></author>
<date year='1987' day='1' month='November' /></front>

<seriesInfo name='STD' value='13' />
<seriesInfo name='RFC' value='1034' />
<format type='TXT' octets='129180' target='ftp://ftp.isi.edu/in-notes/rfc1034.txt' />
</reference>
<?rfc linefile="180:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.1035.xml"?>

<reference anchor='RFC1035'>

<front>
<title abbrev='Domain Implementation and Specification'>Domain names - implementation and specification</title>
<author initials='P.' surname='Mockapetris' fullname='P. Mockapetris'>
<organization>USC/ISI</organization>
<address>
<postal>
<street>4676 Admiralty Way</street>
<city>Marina del Rey</city>
<region>CA</region>
<code>90291</code>
<country>US</country></postal>
<phone>+1 213 822 1511</phone></address></author>
<date year='1987' day='1' month='November' /></front>

<seriesInfo name='STD' value='13' />
<seriesInfo name='RFC' value='1035' />
<format type='TXT' octets='125626' target='ftp://ftp.isi.edu/in-notes/rfc1035.txt' />
</reference>
<?rfc linefile="181:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4033.xml"?>

<reference anchor='RFC4033'>

<front>
<title>DNS Security Introduction and Requirements</title>
<author initials='R.' surname='Arends' fullname='R. Arends'>
<organization /></author>
<author initials='R.' surname='Austein' fullname='R. Austein'>
<organization /></author>
<author initials='M.' surname='Larson' fullname='M. Larson'>
<organization /></author>
<author initials='D.' surname='Massey' fullname='D. Massey'>
<organization /></author>
<author initials='S.' surname='Rose' fullname='S. Rose'>
<organization /></author>
<date year='2005' month='March' />
<abstract>
<t>The Domain Name System Security Extensions (DNSSEC) add data origin authentication and data integrity to the Domain Name System.  This document introduces these extensions and describes their capabilities and limitations.  This document also discusses the services that the DNS security extensions do and do not provide.  Last, this document describes the interrelationships between the documents that collectively describe DNSSEC. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4033' />
<format type='TXT' octets='52445' target='ftp://ftp.isi.edu/in-notes/rfc4033.txt' />
</reference>
<?rfc linefile="182:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4034.xml"?>

<reference anchor='RFC4034'>

<front>
<title>Resource Records for the DNS Security Extensions</title>
<author initials='R.' surname='Arends' fullname='R. Arends'>
<organization /></author>
<author initials='R.' surname='Austein' fullname='R. Austein'>
<organization /></author>
<author initials='M.' surname='Larson' fullname='M. Larson'>
<organization /></author>
<author initials='D.' surname='Massey' fullname='D. Massey'>
<organization /></author>
<author initials='S.' surname='Rose' fullname='S. Rose'>
<organization /></author>
<date year='2005' month='March' />
<abstract>
<t>This document is part of a family of documents that describe the DNS Security Extensions (DNSSEC). The DNS Security Extensions are a collection of resource records and protocol modifications that provide source authentication for the DNS. This document defines the public key (DNSKEY), delegation signer (DS), resource record digital signature (RRSIG), and authenticated denial of existence (NSEC) resource records. The purpose and format of each resource record is described in detail, and an example of each resource record is given.&lt;/t>&lt;t> This document obsoletes RFC 2535 and incorporates changes from all updates to RFC 2535. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4034' />
<format type='TXT' octets='63879' target='ftp://ftp.isi.edu/in-notes/rfc4034.txt' />
</reference>
<?rfc linefile="183:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4035.xml"?>

<reference anchor='RFC4035'>

<front>
<title>Protocol Modifications for the DNS Security Extensions</title>
<author initials='R.' surname='Arends' fullname='R. Arends'>
<organization /></author>
<author initials='R.' surname='Austein' fullname='R. Austein'>
<organization /></author>
<author initials='M.' surname='Larson' fullname='M. Larson'>
<organization /></author>
<author initials='D.' surname='Massey' fullname='D. Massey'>
<organization /></author>
<author initials='S.' surname='Rose' fullname='S. Rose'>
<organization /></author>
<date year='2005' month='March' />
<abstract>
<t>This document is part of a family of documents that describe the DNS Security Extensions (DNSSEC). The DNS Security Extensions are a collection of new resource records and protocol modifications that add data origin authentication and data integrity to the DNS. This document describes the DNSSEC protocol modifications. This document defines the concept of a signed zone, along with the requirements for serving and resolving by using DNSSEC. These techniques allow a security-aware resolver to authenticate both DNS resource records and authoritative DNS error indications.&lt;/t>&lt;t> This document obsoletes RFC 2535 and incorporates changes from all updates to RFC 2535. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4035' />
<format type='TXT' octets='130589' target='ftp://ftp.isi.edu/in-notes/rfc4035.txt' />
</reference>
<?rfc linefile="184:draft-ietf-dnsop-rfc4641bis.xml"?>
    </references>
    
    
    
    
    <references title='Informative References'>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.2119.xml"?>

<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='ftp://ftp.isi.edu/in-notes/rfc2119.txt' />
<format type='HTML' octets='17491' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>
<?rfc linefile="191:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.1995.xml"?>

<reference anchor='RFC1995'>

<front>
<title>Incremental Zone Transfer in DNS</title>
<author initials='M.' surname='Ohta' fullname='Masataka Ohta'>
<organization>Computer Center Tokyo Institute of Technology</organization>
<address>
<postal>
<street>2-12-1, O-okayama</street>
<street>Meguro-ku</street>
<city>Tokyo</city>
<code>152</code>
<country>JP</country></postal>
<phone>+81 3 57343299</phone>
<facsimile>+81 3 57343415</facsimile>
<email>mohta@necom830.hpcl.titech.ac.jp</email></address></author>
<date year='1996' month='August' />
<abstract>
<t>This document proposes extensions to the DNS protocols to provide an incremental zone transfer (IXFR) mechanism.</t></abstract></front>

<seriesInfo name='RFC' value='1995' />
<format type='TXT' octets='16810' target='ftp://ftp.isi.edu/in-notes/rfc1995.txt' />
</reference>
<?rfc linefile="192:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.1996.xml"?>

<reference anchor='RFC1996'>

<front>
<title>A Mechanism for Prompt Notification of Zone Changes (DNS NOTIFY)</title>
<author initials='P.' surname='Vixie' fullname='Paul Vixie'>
<organization>Internet Software Consortium</organization>
<address>
<postal>
<street>Star Route Box 159A</street>
<city>Woodside</city>
<region>CA</region>
<code>94062</code>
<country>US</country></postal>
<phone>+1 415 747 0204</phone>
<email>paul@vix.com</email></address></author>
<date year='1996' month='August' />
<abstract>
<t>This memo describes the NOTIFY opcode for DNS, by which a master server advises a set of slave servers that the master's data has been changed and that a query should be initiated to discover the new data.</t></abstract></front>

<seriesInfo name='RFC' value='1996' />
<format type='TXT' octets='15247' target='ftp://ftp.isi.edu/in-notes/rfc1996.txt' />
</reference>
<?rfc linefile="193:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.2308.xml"?>

<reference anchor='RFC2308'>

<front>
<title abbrev='DNS NCACHE'>Negative Caching of DNS Queries (DNS NCACHE)</title>
<author initials='M.' surname='Andrews' fullname='Mark Andrews'>
<organization>CSIRO - Mathematical and Information Sciences</organization>
<address>
<postal>
<street>Locked Bag 17</street>
<street>North Ryde NSW 2113</street>
<country>AUSTRALIA</country></postal>
<phone>+61 2 9325 3148</phone>
<email>Mark.Andrews@cmis.csiro.au</email></address></author>
<date year='1998' month='March' />
<area>Applications</area>
<keyword>domain name system</keyword>
<keyword>DNS</keyword>
<abstract>
<t>

   [RFC1034] provided a description of how to cache negative responses.

   It however had a fundamental flaw in that it did not allow a name

   server to hand out those cached responses to other resolvers, thereby

   greatly reducing the effect of the caching.  This document addresses

   issues raise in the light of experience and replaces [RFC1034 Section

   4.3.4].
</t>
<t>



   Negative caching was an optional part of the DNS specification and

   deals with the caching of the non-existence of an RRset [RFC2181] or

   domain name.

</t>
<t>


   Negative caching is useful as it reduces the response time for

   negative answers.  It also reduces the number of messages that have

   to be sent between resolvers and name servers hence overall network

   traffic.  A large proportion of DNS traffic on the Internet could be

   eliminated if all resolvers implemented negative caching.  With this

   in mind negative caching should no longer be seen as an optional part

   of a DNS resolver.
</t></abstract></front>

<seriesInfo name='RFC' value='2308' />
<format type='TXT' octets='41428' target='ftp://ftp.isi.edu/in-notes/rfc2308.txt' />
<format type='XML' octets='41491' target='http://xml.resource.org/public/rfc/xml/rfc2308.xml' />
</reference>
<?rfc linefile="194:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.3007.xml"?>

<reference anchor='RFC3007'>

<front>
<title>Secure Domain Name System (DNS) Dynamic Update</title>
<author initials='B.' surname='Wellington' fullname='B. Wellington'>
<organization /></author>
<date year='2000' month='November' />
<abstract>
<t>This document proposes a method for performing secure Domain Name System (DNS) dynamic updates. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3007' />
<format type='TXT' octets='18056' target='ftp://ftp.isi.edu/in-notes/rfc3007.txt' />
</reference>
<?rfc linefile="195:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.3375.xml"?>

<reference anchor='RFC3375'>

<front>
<title>Generic Registry-Registrar Protocol Requirements</title>
<author initials='S.' surname='Hollenbeck' fullname='S. Hollenbeck'>
<organization /></author>
<date year='2002' month='September' /></front>

<seriesInfo name='RFC' value='3375' />
<format type='TXT' octets='46022' target='http://www.rfc-editor.org/rfc/rfc3375.txt' />
</reference>
<?rfc linefile="196:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.3766.xml"?>

<reference anchor='RFC3766'>

<front>
<title>Determining Strengths For Public Keys Used For Exchanging Symmetric Keys</title>
<author initials='H.' surname='Orman' fullname='H. Orman'>
<organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'>
<organization /></author>
<date year='2004' month='April' />
<abstract>
<t>Implementors of systems that use public key cryptography to exchange symmetric keys need to make the public keys resistant to some predetermined level of attack.  That level of attack resistance is the strength of the system, and the symmetric keys that are exchanged must be at least as strong as the system strength requirements.  The three quantities, system strength, symmetric key strength, and public key strength, must be consistently matched for any network protocol usage.  While it is fairly easy to express the system strength requirements in terms of a symmetric key length and to choose a cipher that has a key length equal to or exceeding that requirement, it is harder to choose a public key that has a cryptographic strength meeting a symmetric key strength requirement.  This document explains how to determine the length of an asymmetric key as a function of a symmetric key strength requirement.  Some rules of thumb for estimating equivalent resistance to large-scale attacks on various algorithms are given.  The document also addresses how changing the sizes of the underlying large integers (moduli, group sizes, exponents, and so on) changes the time to use the algorithms for key exchange.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='86' />
<seriesInfo name='RFC' value='3766' />
<format type='TXT' octets='55939' target='ftp://ftp.isi.edu/in-notes/rfc3766.txt' />
</reference>
<?rfc linefile="197:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4086.xml"?>

<reference anchor='RFC4086'>

<front>
<title>Randomness Requirements for Security</title>
<author initials='D.' surname='Eastlake' fullname='D. Eastlake'>
<organization /></author>
<author initials='J.' surname='Schiller' fullname='J. Schiller'>
<organization /></author>
<author initials='S.' surname='Crocker' fullname='S. Crocker'>
<organization /></author>
<date year='2005' month='June' />
<abstract>
<t>Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts. However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities. The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.&lt;/t>&lt;t> Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult. This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities. It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='106' />
<seriesInfo name='RFC' value='4086' />
<format type='TXT' octets='114321' target='ftp://ftp.isi.edu/in-notes/rfc4086.txt' />
</reference>
<?rfc linefile="198:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4641.xml"?>

<reference anchor='RFC4641'>

<front>
<title>DNSSEC Operational Practices</title>
<author initials='O.' surname='Kolkman' fullname='O. Kolkman'>
<organization /></author>
<author initials='R.' surname='Gieben' fullname='R. Gieben'>
<organization /></author>
<date year='2006' month='September' />
<abstract>
<t>This document describes a set of practices for operating the DNS with security extensions (DNSSEC). The target audience is zone administrators deploying DNSSEC.&lt;/t>&lt;t> The document discusses operational aspects of using keys and signatures in the DNS. It discusses issues of key generation, key storage, signature generation, key rollover, and related policies.&lt;/t>&lt;t> This document obsoletes RFC 2541, as it covers more operational ground and gives more up-to-date requirements with respect to key sizes and the new DNSSEC specification. This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='4641' />
<format type='TXT' octets='79894' target='http://www.rfc-editor.org/rfc/rfc4641.txt' />
</reference>
<?rfc linefile="199:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4949.xml"?>

<reference anchor='RFC4949'>

<front>
<title>Internet Security Glossary, Version 2</title>
<author initials='R.' surname='Shirey' fullname='R. Shirey'>
<organization /></author>
<date year='2007' month='August' />
<abstract>
<t>This Glossary provides definitions, abbreviations, and explanations of terminology for information system security.  The 334 pages of entries offer recommendations to improve the comprehensibility of written material that is generated in the Internet Standards Process (RFC 2026).  The recommendations follow the principles that such writing should (a) use the same term or definition whenever the same concept is mentioned; (b) use terms in their plainest, dictionary sense; (c) use terms that are already well-established in open publications; and (d) avoid terms that either favor a particular vendor or favor a particular technology or mechanism over other, competing techniques that already exist or could be developed.  This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='4949' />
<format type='TXT' octets='867626' target='http://www.rfc-editor.org/rfc/rfc4949.txt' />
</reference>
<?rfc linefile="200:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.5011.xml"?>

<reference anchor='RFC5011'>

<front>
<title>Automated Updates of DNS Security (DNSSEC) Trust Anchors</title>
<author initials='M.' surname='StJohns' fullname='M. StJohns'>
<organization /></author>
<date year='2007' month='September' />
<abstract>
<t>This document describes a means for automated, authenticated, and authorized updating of DNSSEC "trust anchors". The method provides protection against N-1 key compromises of N keys in the trust point key set. Based on the trust established by the presence of a current anchor, other anchors may be added at the same place in the hierarchy, and, ultimately, supplant the existing anchor(s).&lt;/t>&lt;t> This mechanism will require changes to resolver management behavior (but not resolver resolution behavior), and the addition of a single flag bit to the DNSKEY record. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5011' />
<format type='TXT' octets='30138' target='http://www.rfc-editor.org/rfc/rfc5011.txt' />
</reference>
<?rfc linefile="201:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.5910.xml"?>

<reference anchor='RFC5910'>

<front>
<title>Domain Name System (DNS) Security Extensions Mapping for the Extensible Provisioning Protocol (EPP)</title>
<author initials='J.' surname='Gould' fullname='J. Gould'>
<organization /></author>
<author initials='S.' surname='Hollenbeck' fullname='S. Hollenbeck'>
<organization /></author>
<date year='2010' month='May' />
<abstract>
<t>This document describes an Extensible Provisioning Protocol (EPP) extension mapping for the provisioning and management of Domain Name System security (DNSSEC) extensions for domain names stored in a shared central repository.  Specified in XML, this mapping extends the EPP domain name mapping to provide additional features required for the provisioning of DNS security extensions.  This document obsoletes RFC 4310. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5910' />
<format type='TXT' octets='72490' target='http://www.rfc-editor.org/rfc/rfc5910.txt' />
</reference>
<?rfc linefile="202:draft-ietf-dnsop-rfc4641bis.xml"?>
      
      
      <reference anchor="NIST-workshop">
	<front>
	  <title>NIST DNSSEC workshop notes</title>
	  
	  <author initials="S." surname="Rose" fullname="S. Rose">
	    <organization></organization>
	  </author>
	  
	  <date month ="June" year="2001" />
	</front>
	<seriesInfo name="" value="" />
      </reference>
      
      
      <reference anchor="NIST-SP-800-90A">
	<front>
	  <title>
	    Recommendation for Random Number Generation Using
	    Deterministic Random Bit Generators (Revised)
	  </title>
	  
	  <author initials="E." surname="Barker" fullname="Elaine Barker">
	    <organization>Computer Security Division, Information Technology Laboratory
	    
	    </organization>
	  </author>
	  <author initials="J." surname="Kelsey" fullname="John Kelsey">
	    <organization>Computer Security Division, Information Technology Laboratory
	    
	    </organization>
	  </author>
	  
	  
	  <date year="2007" month="March"/>
	</front>
	<seriesInfo name="NIST Special Publication" value="800-90" />
      </reference>

      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4509.xml"?>

<reference anchor='RFC4509'>

<front>
<title>Use of SHA-256 in DNSSEC Delegation Signer (DS) Resource Records (RRs)</title>
<author initials='W.' surname='Hardaker' fullname='W. Hardaker'>
<organization /></author>
<date year='2006' month='May' />
<abstract>
<t>This document specifies how to use the SHA-256 digest type in DNS Delegation Signer (DS) Resource Records (RRs).  DS records, when stored in a parent zone, point to DNSKEYs in a child zone. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4509' />
<format type='TXT' octets='14155' target='ftp://ftp.isi.edu/in-notes/rfc4509.txt' />
</reference>
<?rfc linefile="243:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.5155.xml"?>

<reference anchor='RFC5155'>

<front>
<title>DNS Security (DNSSEC) Hashed Authenticated Denial of Existence</title>
<author initials='B.' surname='Laurie' fullname='B. Laurie'>
<organization /></author>
<author initials='G.' surname='Sisson' fullname='G. Sisson'>
<organization /></author>
<author initials='R.' surname='Arends' fullname='R. Arends'>
<organization /></author>
<author initials='D.' surname='Blacka' fullname='D. Blacka'>
<organization /></author>
<date year='2008' month='March' />
<abstract>
<t>The Domain Name System Security (DNSSEC) Extensions introduced the NSEC resource record (RR) for authenticated denial of existence.  This document introduces an alternative resource record, NSEC3, which similarly provides authenticated denial of existence.  However, it also provides measures against zone enumeration and permits gradual expansion of delegation-centric zones. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5155' />
<format type='TXT' octets='112338' target='http://www.rfc-editor.org/rfc/rfc5155.txt' />
</reference>
<?rfc linefile="244:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.5246.xml"?>

<reference anchor='RFC5246'>

<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2008' month='August' />
<abstract>
<t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5246' />
<format type='TXT' octets='222395' target='http://www.rfc-editor.org/rfc/rfc5246.txt' />
</reference>
<?rfc linefile="245:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.5702.xml"?>

<reference anchor='RFC5702'>

<front>
<title>Use of SHA-2 Algorithms with RSA in DNSKEY and RRSIG Resource Records for DNSSEC</title>
<author initials='J.' surname='Jansen' fullname='J. Jansen'>
<organization /></author>
<date year='2009' month='October' />
<abstract>
<t>This document describes how to produce RSA/SHA-256 and RSA/SHA-512 DNSKEY and RRSIG resource records for use in the Domain Name System Security Extensions (RFC 4033, RFC 4034, and RFC 4035). [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5702' />
<format type='TXT' octets='19425' target='http://www.rfc-editor.org/rfc/rfc5702.txt' />
</reference>
<?rfc linefile="246:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.I-D.draft-ietf-dnsop-dnssec-key-timing-02.xml"?>

<reference anchor='I-D.ietf-dnsop-dnssec-key-timing'>
<front>
<title>DNSSEC Key Timing Considerations</title>

<author initials='S' surname='Morris' fullname='Stephen Morris'>
    <organization />
</author>

<author initials='J' surname='Ihren' fullname='Johan Ihren'>
    <organization />
</author>

<author initials='J' surname='Dickinson' fullname='John Dickinson'>
    <organization />
</author>

<date month='March' day='10' year='2011' />

<abstract><t>This document describes the issues surrounding the timing of events in the rolling of a key in a DNSSEC-secured zone.  It presents timelines for the key rollover and explicitly identifies the relationships between the various parameters affecting the process.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-dnsop-dnssec-key-timing-02' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-dnsop-dnssec-key-timing-02.txt' />
</reference>
<?rfc linefile="247:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.I-D.draft-ietf-dnsop-dnssec-dps-framework-05.xml"?>

<reference anchor='I-D.ietf-dnsop-dnssec-dps-framework'>
<front>
<title>DNSSEC Policy &amp; Practice Statement Framework</title>

<author initials='F' surname='Ljunggren' fullname='Fredrik Ljunggren'>
    <organization />
</author>

<author initials='A' surname='Eklund-Lowinder' fullname='Anne-Marie Eklund-Lowinder'>
    <organization />
</author>

<author initials='T' surname='Okubo' fullname='Tomofumi Okubo'>
    <organization />
</author>

<date month='September' day='2' year='2011' />

<abstract><t>This document presents a framework to assist writers of DNSSEC Policy and Practice Statements such as Domain Managers and Zone Operators on both the top-level and secondary level, who is managing and operating a DNS zone with Security Extensions (DNSSEC) implemented.  In particular, the framework provides a comprehensive list of topics that should be considered for inclusion into a DNSSEC Policy definition and Practice Statement.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-dnsop-dnssec-dps-framework-05' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-dnsop-dnssec-dps-framework-05.txt' />
</reference>
<?rfc linefile="248:draft-ietf-dnsop-rfc4641bis.xml"?>      
      <?rfc?><?rfc linefile="1:bibxml/reference.I-D.draft-ietf-dnsop-dnssec-trust-anchor-04.xml"?>

<reference anchor='I-D.ietf-dnsop-dnssec-trust-anchor'>
<front>
<title>DNSSEC Trust Anchor Configuration and Maintenance</title>

<author initials='M' surname='Larson' fullname='Matt Larson'>
    <organization />
</author>

<author initials='O' surname='Gudmundsson' fullname='Olafur Gudmundsson'>
    <organization />
</author>

<date month='October' day='23' year='2010' />

<abstract><t>This document recommends a preferred format for specifying trust anchors in DNSSEC validating security-aware resolvers and describes how such a resolver should initialize trust anchors for use.  This document also describes different mechanisms for keeping trust anchors up to date over time.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-dnsop-dnssec-trust-anchor-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-dnsop-dnssec-trust-anchor-04.txt' />
</reference>
<?rfc linefile="249:draft-ietf-dnsop-rfc4641bis.xml"?>      

      <reference anchor="nsec3hp">
	<front>
	  <title>NSEC3 Hash Performance</title>
	  
	  <author initials="Y." surname="Schaeffer" fullname="Yuri Schaeffer">
	    <organization>NLnet Labs</organization>
	  </author>
	  
	  <date month ="March" year="2010" />
	</front>
	<seriesInfo name="NLnet Labs document" value="2010-02" />
      </reference>
      
    </references>

    <section title="Terminology" anchor="terminology">
      
      <t> 
	In this document, there is some jargon used that is defined in
	other documents. In most cases, we have not copied the text
	from the documents defining the terms but have given a more
	elaborate explanation of the meaning. Note that these
	explanations should not be seen as authoritative.
      </t>
      
      <t>
	<list style="hanging">
	  
	  <t hangText="Anchored key:">
	    A DNSKEY configured in resolvers around the globe. This key
	    is hard to update, hence the term anchored.
	  </t>
	  	  
	  <t hangText="Bogus:">
	    Also see <xref target="RFC4033">Section
	    5 of RFC4033</xref>.  An RRset in DNSSEC is marked "Bogus" when a
	    signature of an RRset does not validate against a DNSKEY.
	  </t>
  	  
	  <t hangText="Key rollover:">
	    A key rollover (also called key supercession in some
	    environments) is the act of replacing one key pair with
	    another at the end of a key effectivity period.
	  </t>

	  <t hangText="Key Signing Key or KSK:">
	    A Key Signing Key (KSK) is a key that is used exclusively for
	    signing the apex key set.  The fact that a key is a KSK is
	    only relevant to the signing tool.
	  </t>
	  
	  <t hangText="Key size:">
	    The term 'key size' can be substituted by 'modulus size'
	    throughout the document for RSA keys. It is mathematically more correct to
	    use modulus size for RSA keys, but as this is a document directed at
	    operators we feel more at ease with the term key size.
	  </t>
	  
	  <t hangText="Private and public keys:">
	    DNSSEC secures the DNS through the use of public key
	    cryptography. Public key cryptography is based on the
	    existence of two (mathematically related) keys, a public
	    key and a private key. The public keys are published in
	    the DNS by use of the DNSKEY Resource Record (DNSKEY
	    RR). Private keys should remain private.
	  </t>
	  
	  <t hangText="Refresh Period:">
	    The period before the expiration time of the signature, during which the signature is refreshed by the signer.
	  </t>
	  
	  <t hangText="Re-Signing frequency:"> 
	    Frequency with which a signing pass on the zone is
	    performed. Alternatively expressed as "Re-Signing
	    Period". It defines when the zone is exposed to the
	    signer. During a signing pass, not all signatures in the
	    zone may be regenerated: that depends on the refresh
	    period.
	  </t>
	  
	  <t hangText="Secure Entry Point (SEP) key:">
	    A KSK that has a DS record in the parent zone pointing to it or is
	    configured as a trust anchor. Although not required by the
	    protocol, we recommend that the SEP flag <xref
	    target="RFC4034"/> is set on these keys.
	  </t>
	  <t hangText="Self-signature:">
            This only applies to signatures over DNSKEYs; a signature
            made with DNSKEY x, over DNSKEY x is called a
            self-signature.  Note: without further information,
            self-signatures convey no trust. They are useful to check
            the authenticity of the DNSKEY, i.e., they can be used as
            a hash.
	  </t>
	  <t hangText="Signing Jitter:">
            A random variation in the signature validity
	    interval of RRSIGs in a zone to prevent all of them expiring at the same time.
	  </t>	  

	  <t hangText="Signer:">
	    The system that has access to the private key material and
	    signs the Resource Record sets in a zone. A signer may be
	    configured to sign only parts of the zone, e.g., only
	    those RRsets for which existing signatures are about to
	    expire.
	  </t>

	  <t hangText="Singing the zone file:">
	    The term used for the event where an administrator joyfully
	    signs its zone file while producing melodic sound patterns.
	  </t>

	  <t hangText="Single Type Signing Scheme:">
	    A signing scheme whereby the distinction between Zone Signing Keys
	    and Key Signing Keys is not made.
	  </t>
	  
	  <t hangText="Zone administrator:">
	    The 'role' that is responsible for signing a zone and
	    publishing it on the primary authoritative server.
	  </t>

	  <t hangText="Zone Signing Key (ZSK):">
	    A key that is used for signing all data in a zone
	    (except, perhaps, the DNSKEY RRset).  The fact that a
	    key is a ZSK is only relevant to the signing tool.
	  </t>

	</list>
	
      </t>
    </section>
    
        <section anchor="typography" title="Typographic Conventions">
      <t>
	The following typographic conventions are used in this document:
	
	<list style="hanging">
	  <t hangText="Key notation:">
	    A key is denoted by DNSKEY_x_y, where x is an identifier
	    for the type of key: K for Keys Signing Key, Z for Zone
	    Signing Key and S when there is no distinction made
	    between KSK and ZSKs but the key is used as a secure entry
	    point. The 'y' denotes a number or an identifier, y could be thought
	    of as the key id.
	  </t>

  	  <t hangText="RRsets ignored:">
	    If the signature of non DNSKEY RRsets have the same
	    parameters as the SOA than those are not
	    mentioned. e.g. In the example below the SOA is signed
	    with the same parameters as the foo.example.com A RRset
	    and the latter is therefore ignored in the abbreviated
	    notation.
	  </t>

	  <t hangText="RRset notations:">
	    RRs are only denoted by the type. All other information
	    -- owner, class, rdata, and TTL -- is left out. Thus:
	    "example.com 3600 IN A 192.0.2.1" is reduced to
	    "A". RRsets are a list of RRs. A example of this would
	    be "A1, A2", specifying the RRset containing two "A"
	    records. This could again be abbreviated to just "A".
	  </t>
	  <t hangText="Signature notation:">
	    Signatures are denoted as RRSIG_x_y(RRset), which means
	    that RRset is signed with DNSKEY_x_y.
	  </t>
	  
	  <t hangText="SOA representation:">
	    SOAs are represented as SOA_x, where x is the serial
	    number.
	  </t>

	  <t hangText="Zone representation:">
	    Using the above notation we have simplified the
	    representation of a signed zone by leaving out all
	    unnecessary details such as the names and by
	    representing all data by "SOA_x"
	  </t>

	</list>
	
	Using this notation the following signed zone:
	
	<figure>
	  <artwork>
 example.com.  3600  IN SOA   ns1.example.com. olaf.example.net. (
                         2005092303 ; serial
                         450        ; refresh (7 minutes 30 seconds)
                         600        ; retry (10 minutes)
                         345600     ; expire (4 days)
                         300        ; minimum (5 minutes)
                         )
        3600    RRSIG    SOA 5 2 3600 20120824013000 (
                         20100424013000 14 example.com.
                         NMafnzmmZ8wevpCOI+/JxqWBzPxrnzPnSXfo
                         ...
                         OMY3rTMA2qorupQXjQ== )
        3600    NS    ns1.example.com.
        3600    NS    ns2.example.com.
        3600    NS    ns3.example.com.
        3600    RRSIG    NS 5 2 3600 20120824013000 (
                         20100424013000 14 example.com.
                         p0Cj3wzGoPFftFZjj3jeKGK6wGWLwY6mCBEz
                         ...
                         +SqZIoVHpvE7YBeH46wuyF8w4XknA4Oeimc4
                         zAgaJM/MeG08KpeHhg== )
        3600    TXT      "Net::DNS  domain"
        3600    RRSIG    TXT 5 2 3600 20120824013000 (
                         20100424013000 14 example.com.
                         o7eP8LISK2TEutFQRvK/+U3wq7t4X+PQaQkp
                         ...
                         BcQ1o99vwn+IS4+J1g== )
        300    NSEC      foo.example.com. NS SOA TXT RRSIG NSEC DNSKEY
        300    RRSIG     NSEC 5 2 300 20120824013000 (
                         20100424013000 14 example.com.
                         JtHm8ta0diCWYGu/TdrE1O1sYSHblN2i/IX+
                         ...
                         PkXNI/Vgf4t3xZaIyw== )
        3600    DNSKEY   256 3 5 (
                         AQPaoHW/nC0fj9HuCW3hACSGiP0AkPS3dQFX
                         ...
                         sAuryjQ/HFa5r4mrbhkJ
                         ) ; key id = 14
        3600    DNSKEY   257 3 5 (
                         AQPUiszMMAi36agx/V+7Tw95l8PYmoVjHWvO
                         ...
                         oy88Nh+u2c9HF1tw0naH
                         ) ; key id = 15
        3600    RRSIG    DNSKEY 5 2 3600 20120824013000 (
                         20100424013000 14 example.com.
                         HWj/VEr6p/FiUUiL70QQWtk+NBIlsJ9mdj5U
                         ...
                         QhhmMwV3tIxJk2eDRQ== )
        3600    RRSIG    DNSKEY 5 2 3600 20120824013000 (
                         20100424013000 15 example.com.
                         P47CUy/xPV8qIEuua4tMKG6ei3LQ8RYv3TwE
                         ...
                         JWL70YiUnUG3m9OL9w== )
foo.example.com.  3600  IN A 192.0.2.2
        3600    RRSIG    A 5 3 3600 20120824013000 (
                         20100424013000 14 example.com.
                         xHr023P79YrSHHMtSL0a1nlfUt4ywn/vWqsO
                         ...
                         JPV/SA4BkoFxIcPrDQ== )
        300    NSEC      example.com. A RRSIG NSEC
        300    RRSIG     NSEC 5 3 300 20120824013000 (
                        20100424013000 14 example.com.
                         Aaa4kgKhqY7Lzjq3rlPlFidymOeBEK1T6vUF
                         ...
                         Qe000JyzObxx27pY8A== )
 	  </artwork>
	</figure>
	
	is reduced to the following representation:
	
	<figure>
	  <artwork>
         SOA_2005092303
         RRSIG_Z_14(SOA_2005092303)
         DNSKEY_K_14
         DNSKEY_Z_15
         RRSIG_K_14(DNSKEY)
         RRSIG_Z_15(DNSKEY)
	  </artwork>
	</figure>
	
	
	
	
	The rest of the zone data has the same signature as the SOA
	record, i.e., an RRSIG created with DNSKEY 14.
	
      </t>
      
    </section>


    <section title="Transition Figures for Special Case Algorithm Rollovers" anchor="AlgoFigures">
      <t> The figures appendix complement and illustrate the special
      cases of algorithm rollovers as described in <xref
      target="KAR"/>
      </t>
      
      <t>
	<figure anchor="single-type-algorithm-roll-fig" title="Single Type Signing Scheme Algorithm Roll">
	  <preamble>
	  </preamble>
	  <?rfc?><?rfc linefile="1:Single-Type-Algorithm-Roll.xml"?><artwork>
----------------------------------------------------------------
 initial              new RRSIGs           new DNSKEY
----------------------------------------------------------------
Parent:
 SOA_0 --------------------------------------------------------&gt;
 RRSIG_par(SOA) -----------------------------------------------&gt;
 DS_S_1 -------------------------------------------------------&gt;
 RRSIG_par(DS_S_1) --------------------------------------------&gt;

Child:
 SOA_0                SOA_1                SOA_2
 RRSIG_S_1(SOA)       RRSIG_S_1(SOA)       RRSIG_S_1(SOA)
                      RRSIG_S_2(SOA)       RRSIG_S_2(SOA)
  
 DNSKEY_S_1           DNSKEY_S_1           DNSKEY_S_1
                                           DNSKEY_S_2
 RRSIG_S_1(DNSKEY)    RRSIG_S_1(DNSKEY)    RRSIG_S_1(DNSKEY)
                      RRSIG_S_2(DNSKEY)    RRSIG_S_2(DNSKEY)

----------------------------------------------------------------
 new DS               DNSKEY removal       RRSIGs removal
----------------------------------------------------------------
Parent:
 SOA_1 -------------------------------------------------------&gt;
 RRSIG_par(SOA) ----------------------------------------------&gt;
 DS_S_2 ------------------------------------------------------&gt;
 RRSIG_par(DS_S_2) -------------------------------------------&gt;

Child:
 -------------------&gt; SOA_3                SOA_4 
 -------------------&gt; RRSIG_S_1(SOA)     
 -------------------&gt; RRSIG_S_2(SOA)       RRSIG_S_2(SOA)
                     
 -------------------&gt;
 -------------------&gt; DNSKEY_S_2           DNSKEY_S_2
 -------------------&gt; RRSIG_S_1(DNSKEY)
 -------------------&gt; RRSIG_S_2(DNSKEY)    RRSIG_S_2(DNSKEY)
----------------------------------------------------------------

</artwork>
<?rfc linefile="540:draft-ietf-dnsop-rfc4641bis.xml"?>
	  <postamble>
	    <t>  Also see <xref target="SingleTypeAlg"/>.</t>
	  </postamble>
	</figure>
	
	<figure anchor="5011-algorithm-roll-fig" title="RFC5011 Style algorithm roll">
	  <preamble>
	  </preamble>
	  <?rfc?><?rfc linefile="1:5011-algorithm-roll.xml"?><artwork>
----------------------------------------------------------------
 initial              new RRSIGs           new DNSKEY
----------------------------------------------------------------
Parent:
 SOA_0 --------------------------------------------------------&gt;
 RRSIG_par(SOA) -----------------------------------------------&gt;
 DS_K_1 -------------------------------------------------------&gt;
 RRSIG_par(DS_K_1) --------------------------------------------&gt;

Child:
 SOA_0                SOA_1                SOA_2
 RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)
                      RRSIG_Z_2(SOA)       RRSIG_Z_2(SOA)
  
 DNSKEY_K_1           DNSKEY_K_1           DNSKEY_K_1
                                           DNSKEY_K_2
 DNSKEY_Z_1           DNSKEY_Z_1           DNSKEY_Z_1
                                           DNSKEY_Z_2
 RRSIG_K_1(DNSKEY)    RRSIG_K_1(DNSKEY)    RRSIG_K_1(DNSKEY)
                                           RRSIG_K_2(DNSKEY)

----------------------------------------------------------------
 new DS               revoke DNSKEY        DNSKEY removal
----------------------------------------------------------------
Parent:
 SOA_0 -------------------------------------------------------&gt;
 RRSIG_par(SOA) ----------------------------------------------&gt;
 DS_K_2 ------------------------------------------------------&gt;
 RRSIG_par(DS_K_2) -------------------------------------------&gt;

Child:
 -------------------&gt; SOA_3                SOA_4 
 -------------------&gt; RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)    
 -------------------&gt; RRSIG_Z_2(SOA)       RRSIG_Z_2(SOA)
                     
 -------------------&gt; DNSKEY_K_1_REVOKED
 -------------------&gt; DNSKEY_K_2           DNSKEY_K_2
 -------------------&gt;
 -------------------&gt; DNSKEY_Z_2           DNSKEY_Z_2
 -------------------&gt; RRSIG_K_1(DNSKEY)
 -------------------&gt; RRSIG_K_2(DNSKEY)    RRSIG_K_2(DNSKEY)
----------------------------------------------------------------

 RRSIGs removal
----------------------------------------------------------------
Parent:
 -------------------------------------&gt;
 -------------------------------------&gt;
 -------------------------------------&gt;
 -------------------------------------&gt;

Child:
 SOA_5
 RRSIG_Z_2(SOA)

 DNSKEY_K_2
 DNSKEY_Z_2
 RRSIG_K_2(DNSKEY)
----------------------------------------------------------------

</artwork>
<?rfc linefile="549:draft-ietf-dnsop-rfc4641bis.xml"?>
	  <postamble>
	    <t>  Also see <xref target="5011style"/>.</t>
	  </postamble>
	</figure>

	<figure anchor="single-type-5011-roll-fig" title="RFC5011 algorithm roll in a Single Type Signing Scheme Environment">
	  <preamble>
	  </preamble>
	  <?rfc?><?rfc linefile="1:single-type-5011-roll.xml"?><artwork>
----------------------------------------------------------------
 initial              new RRSIGs           new DNSKEY
----------------------------------------------------------------
Parent:
 SOA_0 --------------------------------------------------------&gt;
 RRSIG_par(SOA) -----------------------------------------------&gt;
 DS_S_1 -------------------------------------------------------&gt;
 RRSIG_par(DS_S_1) --------------------------------------------&gt;

Child:
 SOA_0                SOA_1                SOA_2
 RRSIG_S_1(SOA)
 RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)
                      RRSIG_S_2(SOA)       RRSIG_S_2(SOA)

 DNSKEY_S_1           DNSKEY_S_1           DNSKEY_S_1
 DNSKEY_Z_1           DNSKEY_Z_1           DNSKEY_Z_1
                                           DNSKEY_S_2 
 RRSIG_S_1(DNSKEY)    RRSIG_S_1(DNSKEY)    RRSIG_S_1(DNSKEY)
                      RRSIG_S_2(DNSKEY)    RRSIG_S_2(DNSKEY)

----------------------------------------------------------------
 new DS               revoke DNSKEY        DNSKEY removal
----------------------------------------------------------------
Parent:
 SOA_0 -------------------------------------------------------&gt;
 RRSIG_par(SOA) ----------------------------------------------&gt;
 DS_S_2 ------------------------------------------------------&gt;
 RRSIG_par(DS_S_2) -------------------------------------------&gt;

Child:
 -------------------&gt; SOA_3                SOA_4 
 -------------------&gt; RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)    
 -------------------&gt; RRSIG_S_2(SOA)       RRSIG_S_2(SOA)
                     
 -------------------&gt; DNSKEY_S_1_REVOKED
 -------------------&gt; DNSKEY_S_2           DNSKEY_S_2
 -------------------&gt; DNSKEY_Z_1           
 -------------------&gt; RRSIG_S_1(DNSKEY)    RRSIG_S_1(DNSKEY)
 -------------------&gt; RRSIG_S_2(DNSKEY)    RRSIG_S_2(DNSKEY)

----------------------------------------------------------------
 RRSIGs removal
----------------------------------------------------------------
Parent:
 -------------------------------------&gt;
 -------------------------------------&gt;
 -------------------------------------&gt;
 -------------------------------------&gt;

Child:
 SOA_5
 RRSIG_S_2(SOA)

 DNSKEY_S_2
 RRSIG_S_2(DNSKEY)
----------------------------------------------------------------

</artwork>
<?rfc linefile="558:draft-ietf-dnsop-rfc4641bis.xml"?>
	  <postamble>
	    <t>  Also see <xref target="5011andSingleType"/>.</t>
	  </postamble>
	</figure>


      </t>
    </section>

    <section title="Transition Figure for Changing DNS Operators" anchor="DNSOPFigures">
      <t> The figures appendix complement and illustrate the special
      case of changing DNS operators as described in <xref target="changing-operators"/>
      </t>

	<figure anchor="coop_registrars" title="An alternative rollover approach for cooperating operators">
	  <preamble>
	  </preamble>
	  <?rfc?><?rfc linefile="1:CoopRegistrars.xml"?><artwork>
 ------------------------------------------------------------
 new DS             |        pre-publish                    |
 ------------------------------------------------------------
 Parent:
  NS_A                            NS_A
  DS_A DS_B                       DS_A DS_B
 ------------------------------------------------------------
 Child at A:            Child at A:        Child at B:
  SOA_A0                 SOA_A1             SOA_B0
  RRSIG_Z_A(SOA)         RRSIG_Z_A(SOA)     RRSIG_Z_B(SOA)

  NS_A                   NS_A               NS_B
  RRSIG_Z_A(NS)          NS_B               RRSIG_Z_B(NS)
                         RRSIG_Z_A(NS)
 
  DNSKEY_Z_A             DNSKEY_Z_A         DNSKEY_Z_A
                         DNSKEY_Z_B         DNSKEY_Z_B
  DNSKEY_K_A             DNSKEY_K_A         DNSKEY_K_B
  RRSIG_K_A(DNSKEY)      RRSIG_K_A(DNSKEY)  RRSIG_K_A(DNSKEY)
                         RRSIG_K_B(DNSKEY)  RRSIG_K_B(DNSKEY)
 ------------------------------------------------------------

 ------------------------------------------------------------
       Redelegation                 |   post migration      |
 ------------------------------------------------------------
 Parent:
           NS_B                           NS_B
           DS_A DS_B                      DS_B
 ------------------------------------------------------------
 Child at A:        Child at B:           Child at B:

  SOA_A2             SOA_B1                SOA_B2
  RRSIG_Z_A(SOA)     RRSIG_Z_B(SOA)        RRSIG_Z_B(SOA)

  NS_A               NS_B                  NS_B
  NS_B               RRSIG_Z_B(NS)         RRSIG_Z_B(NS)
  RRSIG_Z_A(NS)

  DNSKEY_Z_A         DNSKEY_Z_A
  DNSKEY_Z_B         DNSKEY_Z_B            DNSKEY_Z_B
  DNSKEY_K_A         DNSKEY_K_B            DNSKEY_K_B            
  RRSIG_K_A(DNSKEY)  RRSIG_K_B(DNSKEY)     RRSIG_K_B(DNSKEY)

 ------------------------------------------------------------
</artwork>
<?rfc linefile="576:draft-ietf-dnsop-rfc4641bis.xml"?>
	  <postamble>
	    <t>  Also see <xref target="cooperating_registrars"/>.</t>
	  </postamble>
	</figure>

    </section>
    
    <section anchor="DED" title="Document Editing History">
      <t>
      [To be removed prior to publication as an RFC]
      </t>
      <section title="draft-ietf-dnsop-rfc4641-00">
	<t>
	  Version 0 was differs from RFC4641 in the following ways.
	  <list style="symbols">
	    <t>
	      Status of this memo appropriate for I-D
	    </t>
	    <t>
	      TOC formatting differs.
	    </t>
	    <t>
	      Whitespaces, linebreaks, and pagebreaks may be slightly different
	      because of xml2rfc generation.
	    </t>
	    <t>
	      References slightly reordered.
	    </t>
	    <t>
	      Applied the errata from
	      http://www.rfc-editor.org/errata_search.php?rfc=4641
	    </t>
	    <t>
	      Inserted trivial "IANA considerations" section.
	    </t>
	  </list>

	  In other words it should not contain substantive changes in
	  content as intended by the working group for the original RFC4641.
	  </t>
	</section>
	<section title="version 0->1">
	  <t>Cryptography details rewritten.
	  (See http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/cryptography_flawed)
	  </t>
	  <t>
	    <list style="symbols">
	      <t>Reference to NIST 800-90 added</t>
	      <t>RSA/SHA256 is being recommended in addition to RSA/SHA1.</t>
	      <t> Complete rewrite of <xref target="key sizes"/>
	      removing the table and suggesting a keysize of 1024 for
	      keys in use for less than 8 years, issued up to at least
	      2015.  </t>
	      <t>Replaced the reference to Schneiers' applied cryptography with a reference to RFC4949.
	      </t>
	      <t> Removed the KSK for high level zones consideration</t>
	    </list>
	  </t>
	  <t>
	    Applied some differentiation with respect of the use of a
	    KSK for parent or trust anchor relation
	    http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/differentiation_trustanchor_parent
	  </t>
	  <t>
	    http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/rollover_assumptions
	  </t>
	  <t>
	    Added <xref target="KAR"/> as suggested by Jelte Jansen in
	    http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/Key_algorithm_roll
	  </t> 
	  
	  <t>
	    Added <xref target="non_cooperating_registrars"/> Issue
	    identified by Antoin Verschuren
	    http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/non-cooperative-registrars
	  </t>
	  <t>
	  In <xref target="terminology"/>: ZSK does not necessarily sign the DNSKEY RRset.
	  </t>
	</section>
	
	<section title="version 1->2">
	  <t>
	    <list style="symbols">
	      <t>
		Significant rewrite of <xref target="keys"/> whereby the
		argument is made that the timescales for rollovers are
		made purely on operational arguments hopefully resolving
		http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/discussion_of_timescales
	      </t>
	      <t>
		Added <xref target="nsec_nsec3"/> based on
		http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/NSEC-NSEC3
	      </t>
	      <t>
		Added a reference to <xref
		target="I-D.ietf-dnsop-dnssec-key-timing">draft-morris-dnsop-dnssec-key-timing</xref>
		for the quantitative analysis on keyrolls 
	      </t>
	      <t> 
		Updated <xref target="changing-operators"/> to reflect
		that the problem occurs when changing DNS operators, and
		not DNS registrars, also added the table indicating the
		redelegation procedure. Added text about the fact that
		implementations will dismiss keys that fail to validate
		at some point.
	      </t>
	      <t> 
		Updated a number of references.
	      </t>
	      
	    </list>
	  </t>
	</section>
	<section title="version 2->3">
	  <t>
	  <list style="symbols">
	    
	    <t>
	      Added bulleted list to serve as an introduction on the
	      decision tree in <xref target="keys"/>.
	    </t>
	   
	    <t>
	      In section <xref target="zsk-ksk-motivation"/>:
	    <list style="symbols">
	      <t>
		tried to motivate that key length is not a strong
		motivation for KSK ZSK split (based on
		http://www.educatedguesswork.org/2009/10/on_the_security_of_zsk_rollove.html)
	      </t>
	      <t>
		Introduced Common Signing Key terminology and made the
		arguments for the choice of a Common Signing Key more
		explicit.
	      </t>
	      <t>
		Moved the SEP flag considerations to its own paragraph
	      </t>
	    </list>
	    </t>
	    
	    <t>
	      In a few places in the document, but section <xref
	      target="sigs_keyrolls_policies"/> in particular the
	      comments from Patrik Faltstrom (On Mar 24, 2010) on the
	      clarity on the roles of the registrant, dns operator,
	      registrar and registry was addressed.
	    </t>
	    <t>
	      Added some terms based on
	      http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/timing_terminology
	    </t>
	    <t>
	      Added paragraph 2 and clarified the second but last
	      paragraph of <xref target="rolling-ksk-ta"/>.
	    </t>
	    <t>
	      Clarified the table and some text in <xref
	      target="KAR"/>. Also added some text on what happens
	      when the algorithm rollover also involves a roll from
	      NSEC to NSEC3.
	    </t>
	    <t>
	      Added a paragraph about rolling KSKs that are also
	      configured as trust anchors in <xref target="ksk-rollover"/>
	    </t>
	    <t>
	      Added <xref target="STSrollover"/>.
	    </t>

	    <t>
	      Added <xref target="sigval"/> to address issue "Signature_validity"
	    </t>

	  </list>
	  </t>
	</section>


	<section title="version 3->4">
	  <t>
	  <list style="symbols">
	    <t>Stephen Morris submitted a large number of language, style and editorial nits.</t>
	    <t><xref target="KAR"/> improved based on comments from  Olafur Gudmundsson and Ondrej Sury.</t>
	    <t>Tried to improve consistency of notation in the various rollover figures</t>
	  </list>
	  </t>
	</section>

	<section title="version 4->5">
	  <t>
	  <list style="symbols">
	    <t>Improved consistency of notation</t>

	    <t>Matthijs Mekking provided substantive feedback on algorithm rollover and suggested the content of the subsections of <xref target="KAR"/> and the content of the figures in <xref target="AlgoFigures"/></t>
	  </list>
	  </t>
	</section>

	<section title="version 5->6">
	  <t>
	  <list style="symbols">
	    <t>More improved consistency of notation and some other nits</t>

	    <t>Review of Rickard Bellgrim</t>

	    <t>Review of Sebastian Castro</t>

	    <t>Added a section about Stand-by keys</t>

	    <t>Algorithm rollover: Conservative or Liberal Approach</t>

	    <t>Added a reference to NSEC3 hash performance report</t>

	    <t>More clarifications on the topic of non cooperating operators</t>

	  </list>
	  </t>
	</section>

	<section title="version 6->7">
	  <t>
	  <list style="symbols">
	    <t>Fixed minor nits.</t>

	    <t>Clarified the Double DS Rollover in Changing DNS Operator sections.</t>

	    <t>Adjusted STSS Rollover Figures.</t>

	    <t>Remove the ZSK RRSIGs over DNSKEY RRset in Figures.</t>

            <t>Added text: second variety on STSS Double DS Rollover.</t>

            <t>Reviewed by Antoin Verschuren, Marc Lampo, George Barwood.</t>
	  </list>
	  </t>
	</section>

	<section title="version 7->8">
	  <t>
	  <list style="symbols">
            <t>Signatures over DNSKEY RRset does not need to be propagated in the
		new RRSIGS step.</t>
	  </list>
	  </t>
	</section>

	<section title="version 8->9">
	  <t>
	  <list style="symbols">
            <t>Peter Koch and Stephen Morris review</t>
	    <t>Editorial changes</t>
	    <t>Added <xref target="DNSOPFigures"/> for clarifying the
		alternative approach on rollover for cooperating operators.</t>
            <t>Added a paragraph to explain the rollover
		described in the figure in a bit more detail, in
		 <xref target="changing-operators"/>.</t>
	  </list>
	  </t>
	</section>

	<section title="Subversion information">
	  <t>www.nlnetlabs.nl/svn/rfc4641bis/</t>
	  <t>$Id: draft-ietf-dnsop-rfc4641bis.xml 113 2012-02-07 13:13:30Z matje $</t>
	</section>
      </section>

      <section title="RFC Editor Questions">
	<t>

	[To be removed prior to publication as an RFC]

	<list style="symbols">
	<t>Appendix B explains the typographical conventions. Is an explanation in the body
		text needed, if so where?</t>
	<t>Second and third persion style has been observed not to be used uniformly.
	 	The editors would appreciate guidance and, potentially, an update.</t>
	<t>The reference to the <xref target="NIST-workshop">NIST Workshop</xref> does not
	  have a location where the document can be obtained, except for a mail archive page:
		http://www.cafax.se/dnssec/maillist/0000-00/msg00153.html.
	  Is it acceptable to include that URL into the reference?</t>
	</list>
	</t>
      </section>


    
    </back>
    
  </rfc>
  
