<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" >
<!-- may be omitted for very short documents -->
<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<!-- these two save paper: start new sections from the same page etc. -->
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<!-- other categories: bcp, exp, historic, std -->
<!-- Removed obsoletes="RFC 1305" tag -->
<rfc category="info" docName="draft-ietf-ntp-autokey-08" ipr="pre5378Trust200902">
<front>
    <title abbrev="NTPv4 Autokey">Network Time Protocol Version 4
    Autokey Specification</title>

    <!-- add 'role="editor"' below for the editors if requiring designation -->

    <author fullname="Brian Haberman" initials="B." role="editor" surname="Haberman">
      <organization abbrev="JHU/APL">The Johns Hopkins University Applied
      Physics Laboratory</organization>
      <address>
        <postal>
          <street>11100 Johns Hopkins Road</street>
          <city>Laurel</city>
          <region>MD</region>
          <code>20723-6099</code>
          <country>US</country>
        </postal>
        <phone>+1 443 778 1319</phone>
        <email>brian@innovationslab.net</email>
      </address>
    </author>

    <author fullname="Dr. David L. Mills" initials="D.L." surname="Mills">
      <organization abbrev="U. Delaware">University of Delaware</organization>
      <address>
        <postal>
          <street></street>
          <city>Newark</city>
          <region>DE</region>
          <code>19716</code>
          <country>US</country>
        </postal>
        <phone>+1 302 831 8247</phone>
        <email>mills@udel.edu</email>
      </address>
    </author>

    <date month="March" day="5" year="2010" />

<abstract>

<t>This memo describes the Autokey security model for authenticating servers to clients using the Network Time Protocol (NTP) and public key cryptography. Its design is based on the premise that IPsec schemes cannot be adopted intact, since that would preclude stateless servers and severely compromise timekeeping accuracy. In addition, PKI schemes presume authenticated time values are always available to enforce certificate lifetimes; however, cryptographically verified timestamps require interaction between the timekeeping and authentication functions.</t>

<t>This memo includes the Autokey requirements analysis, design principles and protocol specification. A detailed description of the protocol states, events and transition functions is included. A prototype of the Autokey design based on this memo has been implemented, tested and documented in the NTP Version 4 (NTPv4) software distribution for Unix, Windows and VMS at http://www.ntp.org.</t>

</abstract>

</front>

<middle>

<section anchor="intro" title="Introduction">

<t>A distributed network service requires reliable, ubiquitous and survivable provisions to prevent accidental or malicious attacks on the servers and clients in the network or the values they exchange. Reliability requires that clients can determine that received packets are authentic; that is, were actually sent by the intended server and not manufactured or modified by an intruder. Ubiquity requires that a client can verify the authenticity of a server using only public information. Survivability requires protection from faulty implementations, improper operation and possibly malicious clogging and replay attacks.</t>

<t>This memo describes a cryptographically sound and efficient methodology for use in the Network Time Protocol (NTP) <xref target="I-D.ietf-ntp-ntpv4-proto"></xref>. The various key agreement schemes <xref target="RFC2408"></xref><xref target="RFC2412"></xref><xref target="RFC2522"></xref> proposed require per-association state variables, which contradicts the principles of the remote procedure call (RPC) paradigm in which servers keep no state for a possibly large client population. An evaluation of the PKI model and algorithms, e.g., as implemented in the OpenSSL library, leads to the conclusion that any scheme requiring every NTP packet to carry a PKI digital signature would result in unacceptably poor timekeeping performance.</t>

<t>The Autokey protocol is based on a combination of PKI and a pseudo-random sequence generated by repeated hashes of a cryptographic value involving both public and private components. This scheme has been implemented, tested and deployed in the Internet of today. A detailed description of the security model, design principles and implementation is presented in this memo.</t>

<t>This informational document describes the NTP extensions for Autokey as implemented in an NTPv4 software distribution available from http://www.ntp.org.  This description is provided to offer a basis for future work and a reference for the software release.  This document also describes the motivation for the extensions within the protocol.</t>

</section>
<section anchor="secmod" title="NTP Security Model">

<t>NTP security requirements are even more stringent than most other distributed services. First, the operation of the authentication mechanism and the time synchronization mechanism are inextricably intertwined. Reliable time synchronization requires cryptographic keys which are valid only over a designated time intervals; but, time intervals can be enforced only when participating servers and clients are reliably synchronized to UTC. In addition, the NTP subnet is hierarchical by nature, so time and trust flow from the primary servers at the root through secondary servers to the clients at the leaves.</t>

<t>A client can claim authentic to dependent applications only if all servers on the path to the primary servers are bone-fide authentic. In order to emphasize this requirement, in this memo the notion of "authentic" is replaced by "proventic", a noun new to English and derived from provenance, as in the provenance of a painting. Having abused the language this far, the suffixes fixable to the various derivatives of authentic will be adopted for proventic as well. In NTP each server authenticates the next lower stratum servers and proventicates (authenticates by induction) the lowest stratum (primary) servers. Serious computer linguists would correctly interpret the proventic relation as the transitive closure of the authentic relation.</t>

<t>It is important to note that the notion of proventic does not necessarily imply the time is correct. A NTP client mobilizes a number of concurrent associations with different servers and uses a crafted agreement algorithm to pluck truechimers from the population possibly including falsetickers. A particular association is proventic if the server certificate and identity have been verified by the means described in this memo. However, the statement "the client is synchronized to proventic sources" means that the system clock has been set using the time values of one or more proventic associations and according to the NTP mitigation algorithms.</t>

<t>Over the last several years the IETF has defined and evolved the IPsec infrastructure for privacy protection and source authentication in the Internet. The infrastructure includes the Encapsulating Security Payload (ESP) <xref target="RFC2406"></xref> and Authentication Header (AH) <xref target="RFC2402"></xref> for IPv4 and IPv6. Cryptographic algorithms that use these headers for various purposes include those developed for the PKI, including various message digest, digital signature and key agreement algorithms. This memo takes no position on which message digest or which digital signature algorithm is used. This is established by a profile for each community of users.</t>

<t>It will facilitate the discussion in this memo to refer to the reference implementation available at http://www.ntp.org. It includes Autokey as described in this memo and is available to the general public; however, it is not part of the specification itself. The cryptographic means used by the reference implementation and its user community are based on the OpenSSL cryptographic software library available at http://www.openssl.org, but other libraries with equivalent functionality could be used as well. It is important for distribution and export purposes that the way in which these algorithms are used precludes encryption of any data other than incidental to the construction of digital signatures.</t>

<t> The fundamental assumption in NTP the security model is that packets transmitted over the Internet can be intercepted by other than the intended recipient, remanufactured in various ways and replayed in whole or part. These packets can cause the client to believe or produce incorrect information, cause protocol operations to fail, interrupt network service or consume precious network and processor resources.</t>

<t>In the case of NTP, the assumed goal of the intruder is to inject false time values, disrupt the protocol or clog the network, servers or clients with spurious packets that exhaust resources and deny service to legitimate applications. The mission of the algorithms and protocols described in this memo is to detect and discard spurious packets sent by other than the intended sender or sent by the intended sender, but modified or replayed by an intruder.</t>

<t>There are a number of defense mechanisms already built in the NTP architecture, protocol and algorithms. The on-wire timestamp exchange scheme is inherently resistant to spoofing, packet loss and replay attacks. The engineered clock filter, selection and clustering algorithms are designed to defend against evil cliques of Byzantine traitors. While not necessarily designed to defeat determined intruders, these algorithms and accompanying sanity checks have functioned well over the years to deflect improperly operating but presumably friendly scenarios. However, these mechanisms do not securely identify and authenticate servers to clients. Without specific further protection, an intruder can inject any or all of the following attacks.</t>

<list style="numbers">

<t>An intruder can intercept and archive packets forever, as well as all the public values ever generated and transmitted over the net.</t>

<t>An intruder can generate packets faster than the server, network or client can process them, especially if they require expensive cryptographic computations.</t>

<t>In a wiretap attack the intruder can intercept, modify and replay a packet. However, it cannot permanently prevent onward transmission of the original packet; that is, it cannot break the wire, only tell lies and congest it. Except in unlikely cases considered in <xref target="secSEC"></xref>, the modified packet cannot arrive at the victim before the original packet, nor does it have the server private keys or identity parameters.</t>

<t>In a man-in-the-middle or masquerade attack the intruder is positioned between the server and client, so it can intercept, modify and replay a packet and prevent onward transmission of the original packet. Except in unlikely cases considered in <xref target="secSEC"></xref>, the middleman does not have the server private keys.</t>

</list>

<t>The NTP security model assumes the following possible limitations.</t>

<list style="numbers">

<t>The running times for public key algorithms are relatively long and highly variable. In general, the performance of the time synchronization function is badly degraded if these algorithms must be used for every NTP packet.</t>

<t>In some modes of operation it is not feasible for a server to retain state variables for every client. It is however feasible to regenerated them for a client upon arrival of a packet from that client.</t>

<t>The lifetime of cryptographic values must be enforced, which requires a reliable system clock. However, the sources that synchronize the system clock must be cryptographically proventicated. This circular interdependence of the timekeeping and proventication functions requires special handling.</t>

<t>Client security functions must involve only public values transmitted over the net. Private values must never be disclosed beyond the machine on which they were created, except in the case of a special trusted agent (TA) assigned for this purpose.</t>

</list>

<t>Unlike the Secure Shell security model, where the client must be securely authenticated to the server, in NTP the server must be securely authenticated to the client. In ssh each different interface address can be bound to a different name, as returned by a reverse-DNS query. In this design separate public/private key pairs may be required for each interface address with a distinct name. A perceived advantage of this design is that the security compartment can be different for each interface. This allows a firewall, for instance, to require some interfaces to authenticate the client and others not.</t>

</section>
<section anchor="approach" title="Approach">

<t>The Autokey protocol described in this memo is designed to meet the following objectives. In-depth discussions on these objectives is in the web briefings and will not be elaborated in this memo. Note that here and elsewhere in this memo mention of broadcast mode means multicast mode as well, with exceptions as noted in the NTP software documentation.</t>

<list style="numbers">

<t>It must interoperate with the existing NTP architecture model and protocol design. In particular, it must support the symmetric key scheme described in <xref target="RFC1305"></xref>. As a practical matter, the reference implementation must use the same internal key management system, including the use of 32-bit key IDs and existing mechanisms to store, activate and revoke keys.</t>

<t>It must provide for the independent collection of cryptographic values and time values. A NTP packet is accepted for processing only when the required cryptographic values have been obtained and verified and the packet has passed all header sanity checks.</t>

<t>It must not significantly degrade the potential accuracy of the NTP synchronization algorithms. In particular, it must not make unreasonable demands on the network or host processor and memory resources.</t>

<t>It must be resistant to cryptographic attacks, specifically those identified in the security model above. In particular, it must be tolerant of operational or implementation variances, such as packet loss or disorder, or suboptimal configurations.</t>

<t>It must build on a widely available suite of cryptographic algorithms, yet be independent of the particular choice. In particular, it must not require data encryption other than incidental to signature and cookie encryption operations.</t>

<t>It must function in all the modes supported by NTP, including server, symmetric and broadcast modes.</t>


</list>

</section>
<section anchor="crypto" title="Autokey Cryptography">

<t>Autokey cryptography is based on the PKI algorithms commonly used in the Secure Shell and Secure Sockets Layer applications. As in these applications Autokey uses message digests to detect packet modification, digital signatures to verify credentials and public certificates to provide traceable authority. What makes Autokey cryptography unique is the way in which these algorithms are used to deflect intruder attacks while maintaining the integrity and accuracy of the time synchronization function.</t>

<t>Autokey, like many other remote procedure call (RPC) protocols, depends on message digests for basic authentication; however, it is important to understand that message digests are also used by NTP when Autokey is not available or not configured. Selection of the digest algorithm is a function of NTP configuration and is transparent to Autokey.</t>

<t>The protocol design and reference implementation support both 128-bit and 160-bit message digest algorithms, each with a 32-bit key ID. In order to retain backward compatibility with NTPv3, the NTPv4 key ID space is partitioned in two subspaces at a pivot point of 65536. Symmetric key IDs have values less than the pivot and indefinite lifetime. Autokey key IDs have pseudo-random values equal to or greater than the pivot and are expunged immediately after use.</t>

<t>Both symmetric key and public key cryptography authenticate as shown in <xref target="msgauthfig"></xref>. The server looks up the key associated with the key ID and calculates the message digest from the NTP header and extension fields together with the key value. The key ID and digest form the message authentication code (MAC) included with the message. The client does the same computation using its local copy of the key and compares the result with the digest in the MAC. If the values agree, the message is assumed authentic.</t>

<figure anchor="msgauthfig" title="Message Authentication">
<artwork xml:space="preserve">
		+------------------+
		| NTP Header and   |
		| Extension Fields |
		+------------------+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                      |       |        |    Message Authenticator Code |
		     \|/     \|/       +              (MAC)            +
		********************   | +-------------------------+   |
		*   Compute Hash   *&lt;----| Key ID | Message Digest |   +
		********************   | +-------------------------+   |
		          |            +-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+-+
			 \|/                        \|/
		+------------------+       +-------------+
		|  Message Digest  |------&gt;|   Compare   |
		+------------------+       +-------------+
	</artwork>
</figure>

<t>Autokey uses specially contrived session keys, called autokeys, and a precomputed pseudo-random sequence of autokeys which are saved in the autokey list. The Autokey protocol operates separately for each association, so there may be several autokey sequences operating independently at the same time.</t>

<figure anchor="fieldsfig" title="NTPv4 Autokey">
<artwork xml:space="preserve">
		+-------------+-------------+--------+--------+
		| Src Address | Dst Address | Key ID | Cookie |
		+-------------+-------------+--------+--------+
	</artwork>
</figure>

<t>An autokey is computed from four fields in network byte order as shown in <xref target="fieldsfig"></xref>. The four values are hashed using  the MD5 algorithm to produce the 128-bit autokey value, which in the reference implementation is stored along with the key ID in a cache used for symmetric keys as well as autokeys. Keys are retrieved from the cache by key ID using hash tables and a fast lookup algorithm.</t>

<t>For use with IPv4 the Src Address and Dst Address fields contain 32 bits; for use with IPv6 these fields contain 128 bits. In either case the Key ID and Cookie fields contain 32 bits. Thus, an IPv4 autokey has four 32-bit words, while an IPv6 autokey has ten 32-bit words. The source and destination addresses and key ID are public values visible in the packet, while the cookie can be a public value or shared private value, depending on the NTP mode.</t>

<t>The NTP packet format has been augmented to include one or more extension fields piggybacked between the original NTP header and the MAC. For packets without extension fields, the cookie is a shared private value. For packets with extension fields, the cookie has a default public value of zero, since these packets are validated independently using digital signatures.</t>

<t>There are some scenarios where the use of endpoint IP addresses may be difficult or impossible. These include configurations where network address translation (NAT) devices are in use or when addresses are changed during an association lifetime due to mobility constraints. For Autokey, the only restriction is that the address fields visible in the transmitted packet must be the same as those used to construct the autokey list and that these fields be the same as those visible in the received packet. [The use of alternative means, such as Autokey host names (discussed later) or hashes of these names may be a topic for future study.]</t>

<figure anchor="klistfig" title="Constructing the Key List">
	<artwork xml:space="preserve">
+-----------+-----------+------+------+   +---------+  +-----+------+
|Src Address|Dst Address|Key ID|Cookie|--&gt;|         |  |Final|Final |
+-----------+-----------+------+------+   | Session |  |Index|Key ID|
     |           |         |        |     | Key ID  |  +-----+------+
    \|/         \|/       \|/      \|/    |  List   |     |       |
   *************************************  +---------+    \|/     \|/
   *          COMPUTE HASH             *             *******************
   *************************************             *COMPUTE SIGNATURE*
     |                    Index n                    *******************
    \|/                                                       |
   +--------+                                                 |
   |  Next  |                                                \|/
   | Key ID |                                           +-----------+
   +--------+                                           | Signature |
   Index n+1                                            +-----------+
	</artwork>
</figure>

<t><xref target="klistfig"></xref> shows how the autokey list and autokey values are computed. The key IDs used in the autokey list consists of a sequence starting with a random 32-bit nonce (autokey seed) equal to or greater than the pivot as the first key ID. The first autokey is computed as above using the given cookie and autokey seed and assigned index 0. The first 32 bits of the result in network byte order become the next key ID. The MD5 hash of the autokey is the key value saved in the key cache along with the key ID. The first 32 bits of the key become the key ID for the next autokey assigned index 1.</t>

<t>Operations continue to generate the entire list. It may happen that a newly generated key ID is less than the pivot or collides with another one already generated (birthday event). When this happens, which occurs only rarely, the key list is terminated at that point. The lifetime of each key is set to expire one poll interval after its scheduled use. In the reference implementation, the list is terminated when the maximum key lifetime is about one hour, so for poll intervals above one hour a new key list containing only a single entry is regenerated for every poll.</t>

<figure anchor="msgxmitfig" title="Transmitting Messages">
<artwork xml:space="preserve">
		+------------------+
		|  NTP Header and  |
		| Extension Fields |
		+------------------+
		     |       |
		    \|/     \|/                     +---------+
		  ****************    +--------+    | Session |
		  * COMPUTE HASH *&lt;---| Key ID |&lt;---| Key ID  |
		  ****************    +--------+    |  List   |
		          |                |        +---------+
			 \|/              \|/
		+----------------------------------+
		| Message Authenticator Code (MAC) |
		+----------------------------------+
	</artwork>
</figure>

<t>The index of the last autokey in the list is saved along with the key ID for that entry, collectively called the autokey values. The autokey values are then signed for use later. The list is used in reverse order as shown in <xref target="msgxmitfig"></xref>, so that the first autokey used is the last one generated.</t>

<t>The Autokey protocol includes a message to retrieve the autokey values and verify the signature, so that subsequent packets can be validated using one or more hashes that eventually match the last key ID (valid) or exceed the index (invalid). This is called the autokey test in the following and is done for every packet, including those with and without extension fields. In the reference implementation the most recent key ID received is saved for comparison with the first 32 bits in network byte order of the next following key value. This minimizes the number of hash operations in case a single packet is lost.</t>

</section>

<section anchor="ProtoOverview" title="Autokey Protocol Overview">

<t>The Autokey protocol includes a number of request/response exchanges that must be completed in order. In each exchange a client sends a request message with data and expects a server response message with data. Requests and responses are contained in extension fields, one request or response in each field, as described later. An NTP packet can contain one request message and one or more response messages. Following is a list of these messages.</t>

<list style="symbols">

<t>Parameter exchange. The request includes the client host name and status word; the response includes the server host name and status word. The status word specifies the digest/signature scheme to use and the identity schemes supported.</t>

<t>Certificate exchange. The request includes the subject name of a certificate; the response consists of a signed certificate with that subject name. If the issuer name is not the same as the subject name, it has been signed by a host one step closer to a trusted host, so certificate retrieval continues for the issuer name. If it is trusted and self-signed, the trail concludes at the trusted host. If nontrusted and self-signed, the host certificate has not yet been signed, so the trail temporarily loops. Completion of this exchange lights the VAL bit as described below.</t>

<t>Identity exchange. The certificate trail is generally not considered sufficient protection against man-in-the-middle attacks unless additional protection such as the proof-of-possession scheme described in <xref target="RFC2875"></xref> is available, but this is expensive and requires servers to retain state. Autokey can use one of the challenge/response identity schemes described in <xref target="AppID"></xref>. Completion of this exchange lights the IFF bit as described below.</t>

<t>Cookie exchange. The request includes the public key of the server. The response includes the server cookie encrypted with this key. The client uses this value when constructing the key list. Completion of this exchange lights the COOK bit as described below.</t>

<t>Autokey exchange. The request includes either no data or the autokey values in symmetric modes. The response includes the autokey values of the server. These values are used to verify the autokey sequence. Completion of this exchange lights the AUT bit as described below.</t>

<t>Sign exchange. This exchange is executed only when the client has synchronized to a proventic source. The request includes the self-signed client certificate. The server acting as CA interprets the certificate as a X.509v3 certificate request. It extracts the subject, issuer, and extension fields, builds a new certificate with these data along with its own serial number and expiration time, then signs it using its own private key and includes it in the response. The client uses the signed certificate in its own role as server for dependent clients. Completion of this exchange lights the SIGN bit as described below.</t>

<t>Leapseconds exchange. This exchange is executed only when the client has synchronized to a proventic source. This exchange occurs when the server has the leapseconds values, as indicated in the host status word. If so, the client requests the values and compares them with its own values, if available. If the server values are newer than the client values, the client replaces its own with the server values. The client, acting as server, can now provide the most recent values to its dependent clients. In symmetric mode, this results in both peers having the newest values. Completion of this exchange lights the LPT bit as described below.</t>

</list>

<t>Once the certificates and identity have been validated, subsequent packets are validated by digital signatures and the autokey sequence. The association is now proventic with respect to the downstratum trusted host, but is not yet selectable to discipline the system clock. The associations accumulate time values and the mitigation algorithms continue in the usual way. When these algorithms have culled the falsetickers and cluster outlyers and at least three survivors remain, the system clock has been synchronized to a proventic source.</t>

<t>The time values for truechimer sources form a proventic partial ordering relative to the applicable signature timestamps. This raises the interesting issue of how to mitigate between the timestamps of different associations. It might happen, for instance, that the timestamp of some Autokey message is ahead of the system clock by some presumably small amount. For this reason, timestamp comparisons between different associations and between associations and the system clock are avoided, except in the NTP intersection and clustering algorithms and when determining whether a certificate has expired.</t>

</section>

<section anchor="secgrp" title="NTP Secure Groups">

<t>NTP secure groups are used to define cryptographic compartments and security hierarchies. A secure group consists of a number of hosts dynamically assembled as a forest with roots the trusted hosts (THs) at the lowest stratum of the group. The THs do not have to be, but often are, primary (stratum 1) servers. A trusted authority (TA), not necessarily a group host, generates private identity keys for servers and public identity keys for clients at the leaves of the forest. The TA deploys the server keys to the THs and other designated servers using secure means and posts the client keys on a public web site.</t>

<t>For Autokey purposes all hosts belonging to a secure group have the same group name but different host names, not necessarily related to the DNS names. The group name is used in the subject and issuer fields of the TH certificates; the host name is used in these fields for other hosts. Thus, all host certificates are self-signed. During the Autokey protocol a client requests the server to sign its certificate and caches the result. A certificate trail is constructed by each host, possibly via intermediate hosts and ending at a TH. Thus, each host along the trail retrieves the entire trail from its server(s) and provides this plus its own signed certificates to its clients.</t> 

<t>Secure groups can be configured as hierarchies where a TH of one group can be a client of one or more other groups operating at a lower stratum. In one scenario, THs for groups RED and GREEN can be cryptographically distinct, but both be clients of group BLUE operating at a lower stratum. In another scenario, THs for group CYAN can be  clients of multiple groups YELLOW and MAGENTA, both operating at a lower stratum. There are many other scenarios, but all must be configured to include only acyclic certificate trails.</t>

<A ID="pgfId-960744"></A>

<t>In <xref target="secgrpfig"></xref>, the Alice group consists of THs Alice, which is also the TA, and Carol. Dependent servers Brenda and Denise have configured Alice and Carol, respectively, as their time sources. Stratum 3 server Eileen has configured both Brenda and Denise as her time sources. Public certificates are identified by the subject and signed by the issuer. Note that the server group keys have been previously installed on Brenda and Denise and the client group keys installed on all machines.</t> 

<figure anchor="secgrpfig" title="NTP Secure Groups">
	<artwork xml:space="preserve">
                  +-------------+ +-------------+ +-------------+
                  | Alice Group | |    Brenda   | |    Denise   |
                  |    Alice    | |             | |             |
                  | +-+-+-+-+   | | +-+-+-+-+   | | +-+-+-+-+   |
Certificate       | | Alice |   | | | Brenda|   | | | Denise|   |
+-+-+-+-+-+       | +-+-+-+-+   | | +-+-+-+-+   | | +-+-+-+-+   |
| Subject |       | | Alice*| 1 | | | Alice | 4 | | | Carol | 4 |
+-+-+-+-+-+       | +-+-+-+-+   | | +-+-+-+-+   | | +-+-+-+-+   |
| Issuer  | S     |             | |             | |             |
+-+-+-+-+-+       | +=======+   | | +-+-+-+-+   | | +-+-+-+-+   |
                  | ||Alice|| 3 | | | Alice |   | | | Carol |   |
 Group Key        | +=======+   | | +-+-+-+-+   | | +-+-+-+-+   |
+=========+       +-------------+ | | Alice*| 2 | | | Carol*| 2 |
|| Group || S     | Alice Group | | +-+-+-+-+   | | +-+-+-+-+   |
+=========+       |     Carol   | |             | |             |
                  | +-+-+-+-+   | | +-+-+-+-+   | | +-+-+-+-+   |
 S = step         | | Carol |   | | | Brenda|   | | | Denise|   |
 * = trusted      | +-+-+-+-+   | | +-+-+-+-+   | | +-+-+-+-+   |
                  | | Carol*| 1 | | | Brenda| 1 | | | Denise| 1 |
                  | +-+-+-+-+   | | +-+-+-+-+   | | +-+-+-+-+   |
    		  |             | |             | |             |
		  | +=======+   | | +=======+   | | +=======+   |
		  | ||Alice|| 3 | | ||Alice|| 3 | | ||Alice|| 3 |
		  | +=======+   | | +=======+   | | +=======+   |
		  +-------------+ +-------------+ +-------------+
		     Stratum 1                Stratum 2

		  +---------------------------------------------+
		  |                  Eileen                     |
		  |                                             |
		  |           +-+-+-+-+   +-+-+-+-+             |
		  |           | Eileen|   | Eileen|             |
		  |           +-+-+-+-+   +-+-+-+-+             |
		  |           | Brenda| 4 | Carol | 4           |
		  |           +-+-+-+-+   +-+-+-+-+             |
		  |                                             |
		  |           +-+-+-+-+   +-+-+-+-+             |
		  |           | Alice |   | Carol |             |
		  |           +-+-+-+-+   +-+-+-+-+             |
		  |           | Alice*| 2 | Carol*| 2           |
		  |           +-+-+-+-+   +-+-+-+-+             |
		  |                                             |
		  |           +-+-+-+-+   +-+-+-+-+             |
		  |           | Brenda|   | Denise|             |
		  |           +-+-+-+-+   +-+-+-+-+             |
		  |           | Alice | 2 | Carol | 2           |
		  |           +-+-+-+-+   +-+-+-+-+             |
		  |                                             |
		  |                 +-+-+-+-+                   |
		  |                 | Eileen|                   |
		  |                 +-+-+-+-+                   |
		  |                 | Eileen| 1                 |
		  |                 +-+-+-+-+                   |
		  |                                             |
		  |                 +=======+                   |
		  |                 ||Alice|| 3                 |
		  |                 +=======+                   |
		  +---------------------------------------------+
		                    Stratum 3
	</artwork>
</figure>

<t>The steps in hiking the certificate trails and verifying identity are as follows. Note the step number in the description matches the step number in the figure.</t>

<list style="numbers">

<t>The girls start by loading the host key, sign key, self-signed certificate and group key. Each client and server acting as a client starts the Autokey protocol by retrieving the server host name and digest/signature. This is done using the ASSOC exchange described later.</t>

<t>They continue to load certificates recursively until a self-signed trusted certificate is found. Brenda and Denise immediately find trusted certificates for Alice and Carol, respectively, but Eileen will loop because neither Brenda nor Denise have their own certificates signed by either Alice or Carol. This is done using the CERT exchange described later.</t>

<t>Brenda and Denise continue with the selected identity schemes to verify that Alice and Carol have the correct group key previously generated by Alice. This is done using one of the identity schemes IFF, GQ or MV described later. If this succeeds, each continues in step 4.</t>

<t>Brenda and Denise present their certificates for signature using the SIGN exchange described later. If this succeeds, either or both Brenda and Denise can now provide these signed certificates to Eileen, which may be looping in step 2. Eileen can now verify the trail via either Brenda or Denise to the trusted certificates for Alice and Carol. Once this is done, Eileen can complete the protocol just as Brenda and Denise.</t>

</list>

<t>For various reasons it may be convenient for a server to have client keys for more than one group. For example, <xref target="hogfig"></xref> shows three secure groups Alice, Helen and Carol arranged in a hierarchy. Hosts A, B, C and D belong to Alice with A and B her THs. Hosts R and S belong to Helen with R her TH. Hosts X and Y belong to Carol withi X her TH. Note that the TH for a group is always the lowest stratum and that the hosts of the combined groups form an acyclic graph. Note also that the certificate trail for each group terminates on a TH for that group.</t>

<figure anchor="hogfig" title="Hierarchical Overlapping Groups">
<artwork xml:space="preserve">
                      *****     *****     @@@@@
        Stratum 1     * A *     * B *     @ R @
                      *****     *****     @@@@@
                          \     /         /
                           \   /         /
                           *****     @@@@@                *********
                2          * C *     @ S @                * Alice *
                           *****     @@@@@                *********
                           /   \     /
                          /     \   /                     @@@@@@@@@
                      *****     #####                     @ Helen @
                3     * D *     # X #                     @@@@@@@@@
                      *****     #####
                                /   \                     #########
                               /     \                    # Carol #
                           #####     #####                #########
                4          # Y #     # Z #
                           #####     #####
</artwork>
</figure>

<t>The intent of the scenario is to provide security separation, so that servers cannot masquerade as in other groups and clients cannot masquerade as servers. Assume for example that Alice and Helen belong to national standards laboratories and their server keys are used to confirm identity between members of each group. Carol is a prominent corporation receiving standards products and requiring cryptographic authentication. Perhaps under contract, host X belonging to Carol has client keys for both Alice and Helen and server keys for Carol. The Autokey protocol operates for each group separately while preserving security separation. Host X can prove identity in Carol to clients Y and Z, but cannot prove to anybody that it belongs to either Alice or Helen.</t>

</section>
<section anchor="IDsec" title="Identity Schemes">

<t>A digital signature scheme provides secure server authentication, but it does not provide protection against masquerade, unless the server identity is verified by other means. The PKI model requires a server to prove identity to the client by a certificate trail, but independent means such as a driver's license are required for a CA to sign the server certificate. While Autokey supports this model by default, in a hierarchical ad-hoc network, especially with server discovery schemes like NTP Manycast, proving identity at each rest stop on the trail must be an intrinsic capability of Autokey itself.</t>

<t>While the identity scheme described in <xref target="RFC2875"></xref> is based on a ubiquitous Diffie-Hellman infrastructure, it is expensive to generate and use when compared to others described in <xref target="AppID"></xref>. In principle, an ordinary public key scheme could be devised for this purpose, but the most stringent Autokey design requires that every challenge, even if duplicated, results in a different acceptable response.</t>

<list style="numbers">

<t>The scheme  must have a relatively long lifetime, certainly longer than a typical certificate, and have no specific lifetime or expiration date. At the time the scheme is used the host has not yet synchronized to a proventic source, so the scheme cannot depend  time..</t>

<t>As the scheme can be used many times where the data might be exposed to potential intruders, the data must be either nonces or encrypted nonces.</t> 

<t>The scheme should allow designated servers to prove identity to designated clients, but not allow clients acting as servers to prove identity to dependent clients.</t>

<t>To the geatest extent possible, the scheme should represent a zero-knowledge proof; that is, the client should be able to verify the server has the correct group key, but without knowing the key itself.</t>

</list>

<t>There are five schemes now implemented in the NTPv4 reference implementation to prove identity: (1) private certificate (PC), (2) trusted certificate (TC), (3) a modified Schnorr algorithm (IFF aka Identify Friendly or Foe), (4) a modified Guillou-Quisquater algorithm (GQ), and (5) a modified Mu-Varadharajan algorithm (MV). Not all of these provide the same level of protection and one, TC, provides no protection but is included for comparison. Following is a brief summary description of each; details are given in <xref target="AppID"></xref>.</t>

<t>The PC scheme involves a private certificate as group key. The certificate is distributed to all other group members by secure means and is never revealed outside the group. In effect, the private certificate is used as a symmetric key. This scheme is used primarily for testing and development and is not recommended for regular use and is not considered further in this memo.</t>

<t>All other schemes involve a conventional certificate trail as described in <xref target="RFC5280"></xref>. This is the default scheme when an identity scheme is not required. While the remaining identity schemes incorporate TC, it is not by itself considered further in this memo.</t>

<t>The three remaining schemes IFF, GQ and MV involve a cryptographically strong challenge-response exchange where an intruder cannot deduce the server key, even after repeated observations of multiple exchanges. In addition, the MV scheme is properly described as a zero-knowledge proof, because the client can verify the server has the correct group key without either the server or client knowing its value. These schemes start when the client sends a nonce to the server, which then rolls its own nonce, performs a mathematical operation and sends the results to the client. The client performs another mathematical operation and verifies the results are correct.</t>

</section>
<section title="Timestamps and Filestamps">

<t>While public key signatures provide strong protection against misrepresentation of source, computing them is expensive. This invites the opportunity for an intruder to clog the client or server by replaying old messages or originating bogus messages. A client receiving such messages might be forced to verify what turns out to be an invalid signature and consume significant processor resources. In order to foil such attacks, every Autokey message carries a timestamp in the form of the NTP seconds when it was created. If the system clock is synchronized to a proventic source, a signature is produced with valid (nonzero) timestamp. Otherwise, there is no signature and the timestamp is invalid (zero). The protocol detects and discards extension fields with old or duplicate timestamps, before any values are used or signatures are verified.</t>

<t>Signatures are computed only when cryptographic values are created or modified, which is by design not very often. Extension fields carrying these signatures are copied to messages as needed, but the signatures are not recomputed. There are three signature types:</t>

<list style="numbers">

<t>Cookie signature/timestamp. The cookie is signed when created by the server and sent to the client.</t>

<t>Autokey signature/timestamp. The autokey values are signed when the key list is created.</t>

<t>Public values signature/timestamp. The public key, certificate and leapsecond values are signed at the time of generation, which occurs when the system clock is first synchronized to a proventic source, when the values have changed and about once per day after that, even if these values have not changed.</t>

</list>

<t>The most recent timestamp received of each type is saved for comparison. Once a signature with valid timestamp has been received, messages with invalid timestamps or earlier valid timestamps of the same type are discarded before the signature is verified. This is most important in broadcast mode, which could be vulnerable to a clogging attack without this test.</t>

<t>All cryptographic values used by the protocol are time sensitive and are regularly refreshed. In particular, files containing cryptographic values used by signature and encryption algorithms are regenerated from time to time. It is the intent that file regenerations occur without specific advance warning and without requiring prior distribution of the file contents. While cryptographic data files are not specifically signed, every file is associated with a filestamp showing the NTP seconds at the creation epoch.</t>

<t>Filestamps and timestamps can be compared in any combination and use the same conventions. It is necessary to compare them from time to time to determine which are earlier or later. Since these quantities have a granularity only to the second, such comparisons are ambiguous if the values are in the same second.</t>

<t>It is important that filestamps be proventic data; thus, they cannot be produced unless the producer has been synchronized to a proventic source. As such, the filestamps throughout the NTP subnet represent a partial ordering of all creation epochs and serve as means to expunge old data and insure new data are consistent. As the data are forwarded from server to client, the filestamps are preserved, including those for certificate and leapseconds values. Packets with older filestamps are discarded before spending cycles to verify the signature. </t>

</section>
<section anchor="AKOps" title="Autokey Operations">

<t>The NTP protocol has three principal modes of operation: client/server, symmetric and broadcast and each has its own Autokey program, or dance. Autokey choreography is designed to be nonintrusive and to require no additional packets other than for regular NTP operations. The NTP and Autokey protocols operate simultaneously and independently. When the dance is complete, subsequent packets are validated by the autokey sequence and thus considered proventic as well. Autokey assumes NTP clients poll servers at a relatively low rate, such as once per minute or slower. In particular, it assumes that a request sent at one poll opportunity will normally result in a response before the next poll opportunity; however the protocol is robust against a missed or duplicate response.</t>

<t>The server dance was suggested by Steve Kent over lunch some time ago, but considerably modified since that meal. The server keeps no state for each client, but uses a fast algorithm and a 32-bit random private value (server seed) to regenerate the cookie upon arrival of a client packet. The cookie is calculated as the first 32 bits of the autokey computed from the client and server addresses, key ID zero and the server seed as cookie. The cookie is used for the actual autokey calculation by both the client and server and is thus specific to each client separately.</t>

<t>In the server dance the client uses the cookie and each key ID on the key list in turn to retrieve the autokey and generate the MAC. The server uses the same values to generate the message digest and verifies it matches the MAC. It then generates the MAC for the response using the same values, but with the client and server addresses interchanged. The client generates the message digest and verifies it matches the MAC. In order to deflect old replays, the client verifies the key ID matches the last one sent. In this dance the sequential structure of the key list is not exploited, but doing it this way simplifies and regularizes the implementation while making it nearly impossible for an intruder to guess the next key ID.</t>

<t>In the broadcast dance clients normally do not send packets to the server, except when first starting up. At that time the client runs the server dance to verify the server credentials and calibrate the propagation delay. The dance requires the association ID of the particular server association, since there can be more than one operating in the same server. For this purpose, the server packet includes the association ID in every response message sent and, when sending the first packet after generating a new key list, it sends the autokey values as well. After obtaining and verifying the autokey values, no extension fields are necessary and the client verifies further server packets using the autokey sequence.</t>

<t>The symmetric dance is similar to the server dance and requires only a small amount of state between the arrival of a request and departure of the response. The key list for each direction is generated separately by each peer and used independently, but each is generated with the same cookie. The cookie is conveyed in a way similar to the server dance, except that the cookie is a simple nonce. There exists a possible race condition where each peer sends a cookie request before receiving the cookie response from the other peer. In this case each peer winds up with two values, one it generated and one the other peer generated. The ambiguity is resolved simply by computing the working cookie as the EXOR of the two values.</t>

<t>Once the autokey dance has completed, it is normally dormant. In all except the broadcast dance, packets are normally sent without extension fields, unless the packet is the first one sent after generating a new key list or unless the client has requested the cookie or autokey values. If for some reason the client clock is stepped, rather than slewed, all cryptographic and time values for all associations are purged and the dances in all associations restarted from scratch. This insures that stale values never propagate beyond a clock step.</t>

</section>
<section anchor="ProtoMsgs" title="Autokey Protocol Messages">

<t>The Autokey protocol data unit is the extension field, one or more of which can be piggybacked in the NTP packet. An extension field contains either a request with optional data or a response with optional data. To avoid deadlocks, any number of responses can be included in a packet, but only one request. A response is generated for every request, even if the requestor is not synchronized to a proventic source, but most contain meaningful data only if the responder is synchronized to a proventic source. Some requests and most responses carry timestamped signatures. The signature covers the entire extension field, including the timestamp and filestamp, where applicable. Only if the packet has correct format, length and message digest are cycles spent to verify the signature.</t>

<t>There are currently eight Autokey requests and eight corresponding responses. The NTP packet format is described in <xref target="I-D.ietf-ntp-ntpv4-proto"></xref> and the extension field format used for these messages is illustrated in <xref target="extfldfig"></xref>.</t>

<figure anchor="extfldfig" title="NTPv4 Extension Field Format">
<artwork xml:space="preserve">
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|R|E|   Code    |  Field Type   |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Association ID                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Timestamp                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Filestamp                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Value Length                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               /

/                             Value                             \
\                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Signature Length                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               /
/                           Signature                           \
\                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               /
/                      Padding (if needed)                      \
\                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>
</figure>

<t>While each extension field is zero-padded to a 4-octet (word) boundary, the entire extension is not word-aligned. The Length field covers the entire extension field, including the Length and Padding fields.  While the minimum field length is 8 octets, a maximum field length remains to be established.  The reference implementation discards any packet with a field length more than 1024 octets.</t>

<t>One or more extension fields follow the NTP packet header and the last followed by the MAC. The extension field parser initializes a pointer to the first octet beyond the NTP packet header and calculates the number of octets remaining to the end of the packet. If the remaining length is 20 (128-bit digest plus 4-octet key ID) or 22 (160-bit digest plus 4-octet key ID), the remaining data are the MAC and parsing is complete. If the remaining length is greater than 22 an extension field is present. If the remaining length is less than 8 or not a multiple of 4, a format error has occurred and the packet is discarded; otherwise, the parser increments the pointer by the extension field length and then uses the same rules as above to determine whether a MAC is present or another extension field.</t>

<t>In Autokey the 8-bit Field Type field is interpreted as the version number, currently 2. For future versions values 1-7 have been reserved for Autokey; other values may be assigned for other applications. The 6-bit Code field specifies the request or response operation. There are two flag bits: bit 0 is the Response Flag (R) and bit 1 is the Error Flag (E); the Reserved field is unused and should be set to 0. The remaining fields will be described later.</t>

<t>In the most common protocol operations, a client sends a request to a server with an operation code specified in the Code field and both the R bit and E bit dim. The server returns a response with the same operation code in the Code field and lights the R bit. The server can also light the E bit in case of error. Note that it is not necessarily a protocol error to send an unsolicited response with no matching request. If the R bit is dim, the client sets the Association ID field to the client association ID which the servert returns for verification. If the two values do not match, the response is discarded as if never sent. If the R bit is lit, the Association ID field is set the the server association ID obtained in the initial protocol exchange. If the Association ID field does not match any mobilized association ID, the request is discarded as if never sent.</t>

<t>In some cases not all fields may be present. For requests, until a client has synchronized to a proventic source, signatures are not valid. In such cases the Timestamp field and Signature Length field (which specifies the length of the Signature) are zero and the Signature field is absent. Some request and error response messages carry no value or signature fields, so in these messages only the first two words (8 octests) are present.</t>

<t>The Timestamp and Filestamp words carry the seconds field of an NTP timestamp. The timestamp establishes the signature epoch of the data field in the message, while the filestamp establishes the generation epoch of the file that ultimately produced the data that is signed. A signature and timestamp are valid only when the signing host is synchronized to a proventic source; otherwise, the timestamp is zero. A cryptographic data file can only be generated if a signature is possible; otherwise, the filestamp is zero, except in the ASSOC response message, where it contains the server status word.</t>

<t>As in all other TCP/IP protocol designs, all data are sent in network byte order. Unless specified otherwise in the descriptions to follow, the data referred to are stored in the Value field. The Value Length field specifies the length of the data in the Value field.</t>

<section title="No-Operation">
<t>A No-operation request (Code 0) does nothing except return an empty response which can be used as a crypto-ping.</t>

</section>

<section title="Association Message (ASSOC)">

<t>An Association Message (Code 1) is used in the parameter exchange to obtain the host name and status word. The request contains the client status word in the Filestamp field and the Autokey host name in the Value field.  The response contains the server status word in the Filestamp field and the Autokey host name in the Value field. The Autokey host name is not necessarily the DNS host name. A valid response lights the ENAB bit and possibly others in the association status word.</t>

<t>When multiple identity schemes are supported, the host status word determine which ones are available. In server and symmetric modes the response status word contains bits corresponding to the supported schemes. In all modes the scheme is selected based on the client identity parameters which are loaded at startup.</t>

</section>
<section title="Certificate Message (CERT)">

<t>A Certificate Message (Code 2) is used in the certificate exchange to obtain a certificate by subject name. The request contains the subject name; the response contains the certificate encoded in X.509 format with ASN.1 syntax as described in <xref target="AppASN"></xref>.</t>

<t>If the subject name in the response does not match the issuer name, the exchange continues with the issuer name replacing the subject name in the request. The exchange continues until a trusted, self-signed certificate is found and lights the CERT bit in the association status word.</t>

</section>
<section title="Cookie Message (COOKIE)">

<t>The Cookie Message (Code 3) is used in server and symmetric modes to obtain the server cookie. The request contains the host public key encoded with ASN.1 syntax as described in <xref target="AppASN"></xref>. The response contains the cookie encrypted by the public key in the request. A valid response lights the COOKIE bit in the association status word.</t>

</section>
<section title="Autokey Message (AUTO)">

<t>The Autokey Message (Code 4) is used to obtain the autokey values. The request contains no value for a client or the autokey values for a symmetric peer. The response contains two 32-bit words, the first is the final key ID, while the second is the index of the final key ID. A valid response lights the AUTO bit in the association status word.</t>

</section>
<section title="Leapseconds Values Message (LEAP)">

<t>The Leapseconds Values Message (Cpde 5) is used to obtain the leapseconds values as parsed from the leapseconds table from NIST. The request contains no values. The response contains three 32-bit integers: first the NTP seconds of the latest leap event followed by the NTP seconds when the latest NIST table expires and then the TAI offset following the leap event. A valid response lights the LEAP bit in the association status word.</t>

</section>
<section title="Sign Message (SIGN)">

<t>The Sign Message (Code 6) requests the server to sign and return a certificate presented in the request. The request contains the client certificate encoded in X.509 format with ASN.1 syntax as described in <xref target="AppASN"></xref>. The response contains the client certificate signed by the server private key. A valid response lights the SIGN bit in the association status word.</t>

</section>
<section title="Identity Messages (IFF, GQ, MV)">

<t>The Identity Messages (Code 7 (IFF), 8 (GQ), or 9 (MV)) contains the client challenge, usually a 160- or 512-bit nonce. The response contains the result of the mathematical operation defined in <xref target="AppID"></xref>. The Response is encoded in ASN.1 syntax as described in <xref target="AppASN"></xref>. A valid response lights the VRFY bit in the association status word.</t>

</section>
</section>

<section anchor="StateMachine" title="Autokey State Machine">

	<t>This section describes the formal model of the Autokey state machine, its state variables and the state transition functions.</t>

<section anchor="StatusWord" title="Status Word">

<t>The server implements a host status word, while each client implements an association status word. These words have the format and content shown in <xref target="statusfig"></xref>. The low order 16 bits of the status word define the state of the Autokey dance, while the high order 16 bits specify the Numerical Identifier (NID) as generated by the OpenSSL library of the OID for one of the message digest/signature encryption schemes defined in <xref target="RFC3279"></xref>. The NID values for the digest/signature algorithms defined in RFC 3279 are as follows:</t>

<texttable>
   <ttcol align="center">Algorithm</ttcol>
   <ttcol align="left">OID</ttcol>
   <ttcol align="right">NID</ttcol>

   <c>pkcs-1</c>
   <c>1.2.840.113549.1.1</c>
   <c>2</c>

   <c>md2</c>
   <c>1.2.840.113549.2.2</c>
   <c>3</c>

   <c>md5</c>
   <c>1.2.840.113549.2.5</c>
   <c>4</c>

   <c>rsaEncryption</c>
   <c>1.2.840.113549.1.1.1</c>
   <c>6</c>

   <c>md2WithRSAEncryption</c>
   <c>1.2.840.113549.1.1.2</c>
   <c>7</c>

   <c>md5WithRSAEncryption</c>
   <c>1.2.840.113549.1.1.4</c>
   <c>8</c>

   <c>id-sha1</c>
   <c>1.3.14.3.2.26</c>
   <c>64</c>

   <c>sha-1WithRSAEncryption</c>
   <c>1.2.840.113549.1.1.5</c>
   <c>65</c>

   <c>id-dsa-wth-sha1</c>
   <c>1.2.840.10040.4.3</c>
   <c>113</c>

   <c>id-dsa</c>
   <c>1.2.840.10040.4.1</c>
   <c>116</c>

</texttable>

<t>Bits 24-31 are reserved for server use, while bits 16-23 are reserved for client use. In the host portion bits 24-27 specify the available identity schemes, while bits 28-31 specify the server capabilities. There are two additional bits implemented separately.</t>

<figure anchor="statusfig" title="Status Word">
<artwork xml:space="preserve">
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Digest / Signature NID     |    Client     | Ident |  Host |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>
</figure>

<t>The host status word is included in the ASSOC request and response messages. The client copies this word to the association status word and then lights additional bits as the dance proceeds. Once enabled, these bits ordinarily never come dark unless a general reset occurs and the protocol is restarted from the beginning.</t>

<t>The host status bits are defined as follows:</t>

<list style="symbols">

<t>ENAB (31) Lit if the server implements the Autokey protocol.</t>

<t>LVAL (30) Lit if the server has installed leapseconds values, either from the NIST leapseconds file or from another server.</t>

<t>Bits (28-29) are reserved - always dark.</t>

<t>Bits 24-27 select which server identity schemes are available. While specific coding for various schemes is yet to be determined, the schemes available in the reference implementation and described in <xref target="AppID"></xref> include the following:</t>

<list style="symbols">

<t>none - Trusted Certificate (TC) Scheme (default).</t>
<t>PC (27) Private Certificate Scheme.</t>
<t>IFF (26) Schnorr aka Identify-Friendly-or-Foe Scheme.</t>
<t>GQ (25) Guillard-Quisquater Scheme.</t>
<t>MV (24) Mu-Varadharajan Scheme.</t>

</list>

<t>The PC scheme is exclusive of any other scheme. Otherwise, the IFF, GQ and MV bits can be enabled in any combination.</t>

</list>

<t>The association status bits are defined as follows:</t>

<list style="symbols">

<t>CERT (23) Lit when the trusted host certificate and public key are validated.</t>

<t>VRFY (22) Lit when the trusted host identity credentials are confirmed.</t>

<t>PROV (21) Lit when the server signature is verified using its public key and identity credentials. Also called the proventic bit elsewhere in this memo. When enabled, signed values in subsequent messages are presumed proventic.</t>

<t>COOK (20) Lit when the cookie is received and validated. When lit, key lists with nonzero cookies are generated; when dim, the cookie is zero.</t>

<t>AUTO (19) Lit when the autokey values are received and validated. When lit, clients can validate packets without extension fields according to the autokey sequence.</t>

<t>SIGN (18) Lit when the host certificate is signed by the server.</t>

<t>LEAP (17) Lit when the leapseconds values are received and validated.</t>

<t>Bit 16 is reserved - always dark.</t>

</list>

<t>There are three additional bits: LIST, SYNC and PEER not included in the association status word. LIST is lit when the key list is regenerated and dim when the autokey values have been transmitted. This is necessary to avoid livelock under some conditions. SYNC is lit when the client has synchronized to a proventic source and never dim after that. PEER is lit when the server has synchronized, as indicated in the NTP header, and never dim after that.</t>

</section>
<section anchor="HostStateVars" title="Host State Variables">

<t>Following is a list of host state variables.</t>

<t>Host Name - The name of the host, by default the string returned by the Unix gethostname() library function. In the reference implementation this is a configurable value.</t>

<t>Host Status Word - This word is initialized when the host first starts up. The format is described above.</t>

<t>Host Key - The RSA public/private key pair used to encrypt/decrypt cookies. This is also the default sign key.</t>

<t>Sign Key - The RSA or DSA public/private key pair used to encrypt/decrypt signatures when the host key is not used for this purpose.</t>

<t>Sign Digest - The message digest algorithm used to compute the message digest before encryption.</t>

<t>IFF Parameters - The parameters used in the optional IFF identity scheme described in <xref target="AppID"></xref>.</t>

<t>GQ Parameters - The parameters used in the optional GQ identity scheme described in <xref target="AppID"></xref>.</t>

<t>MV Parameters - The parameters used in the optional MV identity scheme described in <xref target="AppID"></xref>.</t>

<t>Server Seed - The private value hashed with the IP addresses and key identifier to construct the cookie.</t>

<t>Certificate Information Structure (CIS) - This structure includes certain information fields from an X.509v3 certificate, together with the certificate itself. The fields extracted include the subject and issuer names, subject public key and message digest algorithm (pointers), and the beginning and end of the valid period in NTP seconds.</t>

<t>The certificate itself is stored as an extension field in network byte order so it  can be copied intact to the message. The structure is signed using the sign key and carries the public values timestamp at signature time and the filestamp of the original certificate file. The structure is used by the CERT response message and SIGN request and response messages.</t>

<t>A flags field in the CIS determines the status of the certificate. The field is encoded as follows:</t>

<list style="symbols">

<t>TRUST (0x01) - The certificate has been signed by a trusted issuer. If the certificate is self-signed and contains "trustRoot" in the Extended Key Usage field, this bit is lit when the CIS is constructed.</t>

<t>SIGN (0x02) - The certificate signature has been verified. If the certificate is self-signed and verified using the contained public key, this bit is lit when the CIS is constructed.</t>

<t>VALID (0x04) - The certificate is valid and can be used to verify signatures. This bit is lit when a trusted certificate has been found on a valid certificate trail.</t>

<t>PRIV (0x08) - The certificate is private and not to be revealed. If the certificate is self-signed and contains "Private" in the Extended Key Usage field, this bit is lit when the CIS is constructed.</t>

<t>ERROR (0x80) - The certificate is defective and not to be used in any way.</t>

</list>

<t>Certificate List - CIS structures are stored on the certificate list in order of arrival, with the most recently received CIS placed first on the list. The list is initialized with the CIS for the host certificate, which is read from the host certificate file. Additional CIS entries are added to the list as certificates are obtained from the servers during the certificate exchange. CIS entries are discarded if overtaken by newer ones.</t>

<t>The following values are stored as an extension field structure in network byte order so they can be copied intact to the message. They are used to send some Autokey requests and responses. All but the Host Name Values structure are signed using the sign key and all carry the public values timestamp at signature time.</t>

<t>Host Name Values. This is used to send ASSOC request and response messages. It contains the host status word and host name.</t>

<t>Public Key Values - This is used to send the COOKIE request message. It contains the public encryption key used for the COOKIE response message.</t>

<t>Leapseconds Values. This is used to send the LEAP response message. In contains the leapseconds values in the LEAP message description.</t>

</section>
<section anchor="ClientStateVars" title="Client State Variables (all modes)">

<t>Following is a list of state variables used by the various dances in all modes.</t>

<t>Association ID - The association ID used in responses. It is assigned when the association is mobilized.</t>

<t>Association Status Word - The status word copied from the ASSOC response; subsequently modified by the state machine.</t>

<t>Subject Name - The server host name copied from the ASSOC response.</t>

<t>Issuer Name - The host name signing the certificate. It is extracted from the current server certificate upon arrival and used to request the next host on the certificate trail.</t>

<t>Server Public Key - The public key used to decrypt signatures. It is extracted from the server host certificate.</t>

<t>Server Message Digest - The digest/signature scheme determined in the parameter exchange.</t>

<t>Group Key - A set of values used by the identity exchange. It identifies the cryptographic compartment shared by the server and client.</t>

<t>Receive Cookie Values - The cookie returned in a COOKIE response, together with its timestamp and filestamp</t>

<t>Receive Autokey Values - The autokey values returned in an AUTO response, together with its timestamp and filestamp.</t>

<t>Send Autokey Values - The autokey values with signature and timestamps.</t>

<t>Key List - A sequence of key IDs starting with the autokey seed and each pointing to the next. It is computed, timestamped and signed at the next poll opportunity when the key list becomes empty.</t>

<t>Current Key Number - The index of the entry on the Key List to be used at the next poll opportunity.</t>

</section>

<section anchor="StateTrans" title="Protocol State Transitions">

<t>The protocol state machine is very simple but robust. The state is determined by the client status word bits defined above. The state transitions of the three dances are shown below. The capitalized truth values represent the client status bits. All bits are initialized dark and are lit upon the arrival of a specific response message as detailed above.</t>

<section title="Server Dance">

<t>The server dance begins when the client sends an ASSOC request to the server. The clock is updated when PREV is lit and the dance ends when LEAP is lit. In this dance the autokey values are not used, so an autokey exchange is not necessary. Note that the SIGN and LEAP requests are not issued until the client has synchronized to a proventic source. Subsequent packets without extension fields are validated by the autokey sequence. This example and others assumes the IFF identity scheme has been selected in the parameter exchange..</t>

<figure anchor="serverfig" title="Server Dance">
<artwork xml:space="preserve">
1	while (1) {
2		wait_for_next_poll;
3		make_NTP_header;
4		if (response_ready)
5			send_response;
6		if (!ENB)			/* parameter exchange */
7			ASSOC_request;
8		else if (!CERT)		/* certificate exchange */
9			CERT_request(Host_Name);
10		else if (!IFF)		/* identity exchange */
11			IFF_challenge;
12		else if (!COOK)		/* cookie exchange */
13			COOKIE_request;
14		else if (!SYNC)		/* wait for synchronization */
15			continue;
16		else if (!SIGN)		/* sign exchange */
17			SIGN_request(Host_Certificate);
18		else if (!LEAP)		/* leapsecond values exchange */
19			LEAP_request;
20		send packet;
21	}

</artwork>
</figure>

<t>If the server refreshes the private seed, the cookie becomes invalid. The server responds to an invalid cookie with a crypto_NAK message, which causes the client to restart the protocol from the beginning.</t>

</section>
<section title="Broadcast Dance">

<t>The broadcast dance is similar to the server dance with the cookie exchange replaced by the autokey values exchange. The broadcast dance begins when the client receives a broadcast packet including an ASSOC response with the server association ID. This mobilizes a client association in order to proventicate the source and calibrate the propagation delay. The dance ends when the LEAP bit is lit, after which the client sends no further packets. Normally, the broadcast server includes an ASSOC response in each transmitted packet. However, when the server generates a new key list, it includes an AUTO response instead.</t>

<t>In the broadcast dance extension fields are used with every packet, so the cookie is always zero and no cookie exchange is necessary. As in the server dance, the clock is updated when PREV is lit and the dance ends when LEAP is lit. Note that the SIGN and LEAP requests are not issued until the client has synchronized to a proventic source. Subsequent packets without extension fields are validated by the autokey sequence.</t>

<figure anchor="broadcastfig" title="Broadcast Dance">
<artwork xml:space="preserve">
1	while (1) {
2		wait_for_next_poll;
3		make_NTP_header;
4		if (response_ready)
5			send_response;
6		if (!ENB)			/* parameters exchange */
7			ASSOC_request;
8		else if (!CERT)		/* certificate exchange */
9			CERT_request(Host_Name);
10		else if (!IFF)		/* identity exchange */
11			IFF_challenge;
12		else if (!AUT)		/* autokey values exchange */
13			AUTO_request;
14		else if (!SYNC)		/* wait for synchronization */
15			continue;
16		else if (!SIGN)		/* sign exchange */	
17			SIGN_request(Host_Certificate);
18		else if (!LEAP)		/* leapsecond values exchange */
19			LEAP_request;
20		send NTP_packet;
21	}
</artwork>
</figure>

<t>If a packet is lost and the autokey sequence is broken, the client hashes the current autokey until either it matches the previous autokey or the number of hashes exceeds the count given in the autokey values. If the latter, the client sends an AUTO request to retrieve the autokey values. If the client receives a crypto-NAK during the dance, or if the association ID changes, the client restarts the protocol from the beginning.</t>

</section>
<section title="Symmetric Dance">

<t>The symmetric dance is intricately choreographed. It begins when the active peer sends an ASSOC request to the passive peer. The passive peer mobilizes an association and both peers step a three-way dance where each peer completes a parameter exchange with the other. Until one of the peers has synchronized to a proventic source (which could be the other peer) and can sign messages, the other  peer loops waiting for a valid timestamp in the ensuing CERT response.</t>

<figure anchor="symmetricfig" title="Symmetric Dance">
<artwork xml:space="preserve">
1	while (1) {
2		wait_for_next_poll;
3		make_NTP_header;
4		if (!ENB)			/* parameters exchange */
5			ASSOC_request;
6		else if (!CERT)		/* certificate exchange */
7			CERT_request(Host_Name);
8		else if (!IFF)		/* identity exchange */
9			IFF_challenge;
10		else if (!COOK &amp;&amp; PEER)	/* cookie exchange */
11			COOKIE_request);
12		else if (!AUTO)		/* autokey values exchange */
13			AUTO_request;
14		else if (LIST)		/* autokey values response */
15			AUTO_response;
16		else if (!SYNC)		/* wait for synchronization */
17			continue;
18		else if (!SIGN)		/* sign exchange */
19			SIGN_request;
20		else if (!LEAP)		/* leapsecond values exchange */
21			LEAP_request;
22		send NTP_packet;
23	}
</artwork>
</figure>

<t>Once a peer has synchronized to a proventic source, it includes timestamped signatures in its messages. The other peer, which has been stalled waiting for valid timestamps, now mates the dance. It retrives the now nonzero cookie using a cookie exchange and then the updated autokey values using an autokey exchange.</t>
<t>As in the broadcast dance, if a packet is lost and the autokey sequence broken, the peer hashes the current autokey until either it matches the previous autokey or the number of hashes exceeds the count given in the autokey values. If the latter, the client sends an AUTO request to retrive the autokey values. If the peer receives a crypto-NAK during the dance, or if the association ID changes, the peer restarts the protocol from the beginning.</t>

</section>
</section>

<section title="Error Recovery">

<t>The Autokey protocol state machine includes provisions for various kinds of error conditions that can arise due to missing files, corrupted data, protocol violations and packet loss or misorder, not to mention hostile intrusion. This section describes how the protocol responds to reachability and timeout events which can occur due to such errors.</t> 

<t>A persistent NTP association is mobilized by an entry in the configuration file, while an ephemeral association is mobilized upon the arrival of a broadcast or symmetric active packet with no matching association. Subsequently, a general reset reinitializes all association variables to the initial state when first mobilized. In addition, if the association is ephemeral, the association is demobilized and all resources acquired are returned to the system.</t>

<t>Every NTP association has two variables which maintain the liveness state of the protocol, the 8-bit reach register and the unreach counter defined in <xref target="I-D.ietf-ntp-ntpv4-proto"></xref>. At every poll interval the reach register is shifted left, the low order bit is dimmed and the high order bit is lost. At the same time the unreach counter is incremented by one. If an arriving packet passes all authentication and sanity checks, the rightmost bit of the reach register is lit and the unreach counter is set to zero. If any bit in the reach register is lit, the server is reachable, otherwise it is unreachable.</t>

<t>When the first poll is sent from an association, the reach register and unreach counter are set to zero. If the unreach counter reaches 16, the poll interval is doubled. In addition, if association is persistent, it is demobilized. This reduces the network load for packets that are unlikely to elicit a response.</t>

<t>At each state in the protocol the client expects a particular response from the server. A request is included in the NTP packet sent at each poll interval until a valid response is received or a general reset occurs, in which case the protocol restarts from the beginning. A general reset also occurs for an association when an unrecoverable protocol error occurs. A general reset occurs for all associations when the system clock is first synchronized or the clock is stepped or when the server seed is refreshed.</t>

<t>There are special cases designed to quickly respond to broken associations, such as when a server restarts or refreshes keys. Since the client cookie is invalidated, the server rejects the next client request and returns a crypto-NAK packet. Since the crypto-NAK has no MAC, the problem for the client is to determine whether it is legitimate or the result of intruder mischief. In order to reduce the vulnerability in such cases, the crypto-NAK, as well as all responses, is believed only if the result of a previous packet sent by the client and not a replay, as confirmed by the NTP on-wire protocol. While this defense can be easily circumvented by a man-in-the-middle, it does deflect other kinds of intruder warfare.</t>

<t>There are a number of situations where some event happens that causes the remaining autokeys on the key list to become invalid. When one of these situations happens, the key list and associated autokeys in the key cache are purged. A new key list, signature and timestamp are generated when the next NTP message is sent, assuming there is one. Following is a list of these situations:</t>

<list style="numbers">

<t>When the cookie value changes for any reason.</t>

<t>When the poll interval is changed. In this case the calculated expiration times for the keys become invalid.</t>

<t>If a problem is detected when an entry is fetched from the key list. This could happen if the key was marked non-trusted or timed out, either of which implies a software bug.</t>

</list>

</section>
</section>

<section anchor="secSEC" title="Security Considerations">

<t>This section discusses the most obvious security vulnerabilities in the various Autokey dances. In the following discussion the cryptographic algorithms and private values themselves are assumed secure; that is, a brute force cryptanalytic attack will not reveal the host private key, sign private key, cookie value, identity parameters, server seed or autokey seed. In addition, an intruder will not be able to predict random generator values.</t>

<section title="Protocol Vulnerability">

<t>While the protocol has not been subjected to a formal analysis, a few preliminary assertions can be made. In the client/server and symmetric dances the underlying NTP on-wire protocol is resistant to lost, duplicate and bogus packets, even if the clock is not synchronized, so the protocol is not vulnerable to a wiretapper attack. The on-wire protocol is resistant to replays of both the client request packet and the server reply packet. A man-in-the-middle attack, even if it could simulate a valid cookie, could not prove identity.</t>

<t>In the broadcast dance the client begins with a volley in client/server mode to obtain the autokey values and signature, so has the same protection as in that mode. When continuing in receive-only mode, a wiretapper cannot produce a key list with valid signed autokey values. If it replays an old packet, the client will reject it by the timestamp check. The most it can do is manufacture a future packet causing clients to repeat the autokey hash operations until exceeding the maximum key number. If this happens the broadcast client temporarily reverts to client mode to refresh the autokey values.</t>

<t>By assumption, a man-in-the-middle attacker that intercepts a packet cannot break the wire or delay an intercepted packet. If this assumption is removed, the middleman could intercept a broadcast packet and replace the data and message digest without detection by the clients.</t>

<t>As mentioned previously in this memo, the TC identity scheme is vulnerable to a man-in-the-middle attack where an intruder could create a bogus certificate trail. To foil this kind of attack, either the PC, IFF, GQ or MV identity schemes must be used.</t> 

<t>A client instantiates cryptographic variables only if the server is synchronized to a proventic source. A server does not sign values or generate cryptographic data files unless synchronized to a proventic source. This raises an interesting issue: how does a client generate proventic cryptographic files before it has ever been synchronized to a proventic source? [Who shaves the barber if the barber shaves everybody in town who does not shave himself?] In principle, this paradox is resolved by assuming the primary (stratum 1) servers are proventicated by external phenomenological means.</t>

</section>
<section title="Clogging Vulnerability">

<t>A self-induced clogging incident cannot happen, since signatures are computed only when the data have changed and the data do not change very often. For instance, the autokey values are signed only when the key list is regenerated, which happens about once an hour, while the public values are signed only when one of them is updated during a dance or the server seed is refreshed, which happens about once per day.</t>

<t>There are two clogging vulnerabilities exposed in the protocol design: an encryption attack where the intruder hopes to clog the victim server with needless cryptographic calculations, and a decryption attack where the intruder attempts to clog the victim client with needless cryptographic calculations. Autokey uses public key cryptography and the algorithms that perform these functions consume significant resources.</t>

<t>In client/server and peer dances an encryption hazard exists when a wiretapper replays prior cookie request messages at speed. There is no obvious way to deflect such attacks, as the server retains no state between requests. Replays of cookie request or response messages are detected and discarded by the client on-wire protocol.</t>

<t>In broadcast mode a client a decryption hazard exists when a wiretapper replays autokey response messages at speed. Once synchronized to a proventic source, a legitimate extension field with timestamp the same as or earlier than the most recently received of that type is immediately discarded. This foils a man-in-the-middle cut-and-paste attack using an earlier response, for example. A legitimate extension field with timestamp in the future is unlikely, as that would require predicting the autokey sequence. However, this causes the client to refresh and verify the autokey values and signature.</t>

<t>A determined attacker can destabilize the on-wire protocol or an Autokey dance in various ways by replaying old messages before the client or peer has synchronized for the first time. For instance, replaying an old symmetric mode message before the peers have synchronize will prevent the peers from ever synchronizing. Replaying out of order Autokey messages in any mode during a dance could prevent the dance from ever completing. There is nothing new in these kinds of attack; a similar vulnerabily even exists in TCP.</t>

</section>
</section>

<section anchor="secIANA" title="IANA Considerations">

<t>This document has no IANA Actions.</t>

</section>

</middle>

<back>

<references title="Normative References">
<?rfc include="reference.I-D.ietf-ntp-ntpv4-proto" ?>
</references>

<references title="Informative References">
<?rfc include="reference.RFC.1305" ?>
<?rfc include="reference.RFC.2522" ?>
<?rfc include="reference.RFC.2510" ?>
<?rfc include="reference.RFC.2412" ?>
<?rfc include="reference.RFC.2408" ?>
<?rfc include="reference.RFC.2406" ?>
<?rfc include="reference.RFC.2402" ?>
<?rfc include="reference.RFC.2875" ?>
<?rfc include="reference.RFC.5280" ?>
<?rfc include="reference.RFC.3279" ?>

<reference anchor="SCHNORR">
<front>
<title>Efficient signature generation for smart cards</title>
<author fullname="Schnorr, C.P." initials="C.P." surname="Schnorr"></author>
<date year="1991"></date>
</front>
<seriesinfo name="J. Cryptology 4"></seriesinfo>
</reference>

<reference anchor="STINSON">
<front>
<title>Cryptography - Theory and Practice</title>
<author fullname="Stinson, D.R." initials="D.R." surname="Stinson"></author>
<date year="1995"></date>
</front>
<series name="CRC Press"></series>
</reference>


<reference anchor="GUILLOU">
<front>
<title>A "paradoxical" identity-based signature scheme resulting from zero-knowledge</title>
<author fullname="Guillou, L.C." initials="L.C." surname="Guillou"></author>
<author fullname="Quisquatar, J.-J." initials="J.-J." surname="Quisquatar"></author>
<date year="1990"></date>
</front>
<series name="Proc. CRYPTO 88 Advances in Cryptology"></series>
</reference>

<reference anchor="DASBUCH">
<front>
<title>Computer Network Time Synchronization - the Network Time Protocol</title>
<author fullname="Mills, D.L." initials="D.L." surname="Mills"></author>
<date year="2006"></date>
</front>
<series name="CRC Press"></series>
</reference>

<reference anchor="MV">
<front>
<title>Robust and secure broadcasting</title>
<author fullname="Mu, Y." initials="Y." surname="Mu"></author>
<author fullname="Varadharajan, V." initials="V." surname="Varadharajan"></author>
<date year="2001"></date>
</front>
<series name="Proc. INDOCRYPT 2001, LNCS 2247"></series>
</reference>

</references>

<section anchor="PKSig" title="Timestamps, Filestamps and Partial Ordering">

<t>When the host starts, it reads the host key and host certificate files, which are required for continued operation. It also reads the sign key and leapseconds values, when available. When reading these files the host checks the file formats and filestamps for validity; for instance, all filestamps must be later than the time the UTC timescale was established in 1972 and the certificate filestamp must not be earlier than its associated sign key filestamp. At the time the files are read the host is not synchronized, so it cannot determine whether the filestamps are bogus other than these simple checks. It must not produce filestamps or timestamps until synchronized to a proventic source.</t>

<t>In the following the relation A --&gt; B is Lamport's "happens before" relation, which is true if event A happens before event B. When timestamps are compared to timestamps, the relation is false if A &lt;--&gt; B; that is, false if the events are simultaneous. For timestamps compared to filestamps and filestamps compared to filestamps, the relation is true if A &lt;--&gt; B. Note that the current time plays no part in these assertions except in (6) below; however, the NTP protocol itself insures a correct partial ordering for all current time values.</t>

<t>The following assertions apply to all relevant responses:</t>

<list style="numbers">

<t>The client saves the most recent timestamp T0 and filestamp F0 for the respective signature type. For every received message carrying timestamp T1 and filestamp F1, the message is discarded unless T0 --&gt; T1 and F0 --&gt; F1. The requirement that T0 --&gt; T1 is the primary defense against replays of old messages.</t>

<t>For timestamp T and filestamp F, F --&gt; T; that is, the filestamp must happen before the timestamp. If not, this could be due to a file generation error or a significant error in the system clock time.</t>

<t>For sign key filestamp S, certificate filestamp C, cookie timestamp D and autokey timestamp A, S --&gt; C --&gt; D --&gt; A; that is, the autokey must be generated after the cookie, the cookie after the certificate and the certificate after the sign key.</t>

<t>For sign key filestamp S and certificate filestamp C specifying begin time B and end time E, S --&gt; C--&gt; B --&gt; E; that is, the valid period must not be retroactive.</t>

<t>A certificate for subject S signed by issuer I and with filestamp C1 obsoletes, but does not necessarily invalidate, another certificate with the same subject and issuer but with filestamp C0, where C0 --&gt; C1.</t>

<t>A certificate with begin time B and end time E is invalid and can not be used to verify signatures if t --&gt; B or E --&gt; t, where t is the current proventic time. Note that the public key previously extracted from the certificate continues to be valid for an indefinite time. This raises the interesting possibility where a truechimer server with expired certificate or a falseticker with valid certificate are not detected until the client has synchronized to a proventic source.</t>

</list>

</section>
<section anchor="AppID" title="Identity Schemes">

<t>There are five identity schemes in the NTPv4 reference implementation: (1) private certificate (PC), (2) trusted certificate (TC), (3) a modified Schnorr algorithm (IFF - Identify Friend or Foe), (4) a modified Guillou-Quisquater algorithm (GQ), and (5) a modified Mu-Varadharajan algorithm (MV).</t>

<t>The PC scheme is intended for testing and development and not recommended for general use. The TC scheme uses a certificate trail, but not an identity scheme. The IFF, GQ and MV identity schemes use a cryptographically strong challenge-response exchange where an intruder cannot learn the group key, even after repeated observations of multiple exchanges. These schemes begin when the client sends a nonce to the server, which then rolls its own nonce, performs a mathematical operation and sends the results to the client. The client performs a second mathematical operation to prove the server has the same group key as the client.</t>

</section>
<section title="Private Certificate (PC) Scheme">

<t>The PC scheme shown in <xref target="PCertIDfig"></xref> uses a private certificate as the group key.</t>

<figure anchor="PCertIDfig" title="Private Certificate (PC) Identity Scheme">
<artwork xml:space="preserve">

                          Trusted
			 Authority
           Secure     +-------------+    Secure
       +--------------| Certificate |-------------+
       |              +-------------+             |
       |                                          |
      \|/                                        \|/
+-------------+                            +-------------+
| Certificate |                            | Certificate |
+-------------+                            +-------------+
    Server                                     Client

</artwork>
</figure>

<t>A certificate is designated private when the X509v3 Extended Key Usage extension field is present and contains "Private". The private certificate is distributed to all other group members by secret means, so in fact becomes a symmetric key. Private certificates are also trusted, so there is no need for a certificate trail or identity scheme.</t>

</section>
<section title="Trusted Certificate (TC) Scheme">

<t>All other schemes involve a conventional certificate trail as shown in <xref target="TCertIDfig"></xref>.</t>

<figure anchor="TCertIDfig" title="Trusted Certificate (TC) Identity Scheme">
<artwork xml:space="preserve">

                                                        Trusted
                Host                 Host                 Host
           +-----------+        +-----------+        +-----------+
      +---&gt;|  Subject  |   +---&gt;|  Subject  |   +---&gt;|  Subject  |
      |    +-----------+   |    +-----------+   |    +-----------+
...---+    |  Issuer   |---+    |  Issuer   |---+    |  Issuer   |
           +-----------+        +-----------+        +-----------+
           | Signature |        | Signature |        | Signature |
           +-----------+        +-----------+        +-----------+

</artwork>
</figure>

<t>As described in RFC-2510 <xref target="RFC2510"></xref>, each certificate is signed by an issuer one step closer to the trusted host, which has a self-signed trusted certificate. A certificate is designated trusted when an X509v3 Extended Key Usage extension field is present and contains "trustRoot". If no identity scheme is specified in the parameter exchange, this is the default scheme.</t>

</section>
<section title="Schnorr (IFF) Identity Scheme">

<t>The IFF scheme is useful when the group key is concealed, so that client keys need not be protected. The primary disadvantage is that when the server key is refreshed all hosts must update the client key. The scheme shown in <xref target="Schnorrfig"></xref> involves a set of public parameters and a group key including both private and public components. The public component is the client key.</t>

<figure anchor="Schnorrfig" title="Schnorr (IFF) Identity Scheme">
<artwork xml:space="preserve">

		                  Trusted
                                 Authority
                               +------------+
                               | Parameters |
                    Secure     +------------+   Insecure
                 +-------------| Group Key  |-----------+
                 |             +------------+           |
		\|/                                    \|/
           +------------+         Challenge       +------------+
           | Parameters |&lt;------------------------| Parameters |
           +------------+                         +------------+
	   |  Group Key |------------------------&gt;| Client Key |
	   +------------+         Response        +------------+
	       Server                                 Client

</artwork>
</figure>

<t>By happy coincidence, the mathematical principles on which IFF is based are similar to DSA. The scheme is a modification an algorithm described in <xref target="SCHNORR"></xref> and <xref target="STINSON"></xref> p. 285. The parameters are generated by routines in the OpenSSL library, but only the moduli p, q and generator g are used. The p is a 512-bit prime, g a generator of the multiplicative group Z_p* and q a 160-bit prime that divides (p-1) and is a qth root of 1 mod p; that is, g^q = 1 mod p. The TA rolls a private random group key b (0 &lt; b &lt; q), then computes public client key v = g^(q-b) mod p. The TA distributes (p, q, g, b) to all servers using secure means and (p, q, g, v) to all clients not necessarily using secure means.</t>

<t>The TA hides IFF parameters and keys in an OpenSSL DSA cuckoo structure. The IFF parameters are identical to the DSA parameters, so the OpenSSL library can be used directly. The structure shown in Figure<xref target="IFFfig"></xref> is written to a file as a DSA private key encoded in PEM. Unused structure members are set to one.</t>

<figure anchor="IFFfig" title="IFF Identity Scheme Structure">
<artwork xml:space="preserve">

	   +----------------------------------+-------------+
	   |   IFF   |   DSA    |   Item      |   Include   |
	   +=========+==========+=============+=============+
	   |    p    |    p     | modulus     |    all      |
	   +---------+----------+-------------+-------------+
	   |    q    |    q     | modulus     |    all      |
	   +---------+----------+-------------+-------------+
	   |    g    |    g     | generator   |    all      |
	   +---------+----------+-------------+-------------+
	   |    b    | priv_key | group key   |   server    |
	   +---------+----------+-------------+-------------+
	   |    v    | pub_key  | client key  |   client    |
	   +---------+----------+-------------+-------------+

</artwork>
</figure>

<t>Alice challenges Bob to confirm identity using the following protocol exchange.</t>

<list style="numbers">

<t>Alice rolls random r (0 &lt; r &lt; q) and sends to Bob.</t>

<t>Bob rolls random k (0 &lt; k &lt; q), computes y = k + br mod q and x = g^k mod p, then sends (y, hash(x)) to Alice.</t>

<t>Alice computes z = g^y * v^r mod p and verifies hash(z) equals hash(x).</t>

</list>

<t>If the hashes match, Alice knows that Bob has the group key b. Besides making the response shorter, the hash makes it effectively impossible for an intruder to solve for b by observing a number of these messages. The signed response binds this knowledge to Bob's private key and the public key previously received in his certificate.</t>

</section>
<section title="Guillard-Quisquater (GQ) Identity Scheme">

<t>The GQ scheme is useful when the server key must be refreshed from time to time without changing the group key. The NTP utility programs include the GQ client key in the X509v3 Subject Key Identifier extension field. The primary disadvantage of the scheme is that the group key must be protected in both the server and client. A secondary disadvantage is that when a server key is refreshed, old extension fields no longer work. The scheme is shown in <xref target="GQIDfig"></xref>a  involves a set of public parameters and group key used to generate private server keys and client keys.</t>

<figure anchor="GQIDfig" title="Schnorr (IFF) Identity Scheme">
<artwork xml:space="preserve">

		                  Trusted
                                 Authority
                               +------------+
                               | Parameters |
                    Secure     +------------+   Secure
                 +-------------| Group Key  |-----------+
                 |             +------------+           |
		\|/                                    \|/
           +------------+         Challenge       +------------+
           | Parameters |&lt;------------------------| Parameters |
           +------------+                         +------------+
	   |  Group Key |                         |  Group Key |
	   +------------+         Response        +------------+
	   | Server Key |------------------------&gt;| Client Key |
           +------------+                         +------------+
	       Server                                 Client

</artwork>
</figure>

<t>By happy coincidence, the mathematical principles on which GQ is based are similar to RSA. The scheme is a modification of an algorithm described in <xref target="GUILLOU"></xref> and <xref target="STINSON"></xref> p. 300 (with errors). The parameters are generated by routines in the OpenSSL library, but only the moduli p and q are used. The 512-bit public modulus is n=pq, where p and q are secret large primes. The TA rolls random large prime b (0 &lt; b &lt; n) and distributes (n, b) to all group servers and clients using secure means, since an intruder in possession of these values could impersonate a legitimate server. The private server key and public client key are constructed later.</t>

<t>The TA hides GQ parameters and keys in an OpenSSL RSA cuckoo structure. The GQ parameters are identical to the RSA parameters, so the OpenSSL library can be used directly. When generating a certificate, the server rolls random server key u (0 &lt; u &lt; n) and client key its inverse obscured by the group key v = (u^-1)^b mod n. These values replace the private and public keys normally generated by the RSA scheme. The client key is conveyed in a X.509 certificate extension. The updated GQ structure shown in <xref target="GQtablefig"></xref> is written as an RSA private key encoded in PEM. Unused structure members are set to one.</t>

<figure anchor="GQtablefig" title="GQ Identity Scheme Structure">
<artwork xml:space="preserve">

	   +---------------------------------+-------------+
	   |   GQ    |   RSA    |   Item     |   Include   |
	   +=========+==========+============+=============+
	   |    n    |    n     | modulus    |    all      |
	   +---------+----------+------------+-------------+
	   |    b    |    e     | group key  |    all      |
	   +---------+----------+------------+-------------+
	   |    u    |    p     | server key |   server    |
	   +---------+----------+------------+-------------+
	   |    v    |    q     | client key |   client    |
	   +---------+----------+------------+-------------+

</artwork>
</figure>

<t>Alice challenges Bob to confirm identity using the following exchange.</t>

<list style="numbers">

<t>Alice rolls random r (0 &lt; r &lt; n) and sends to Bob.</t>

<t>Bob rolls random k (0 &lt; k &lt; n) and computes y = ku^r mod n and x = k^b mod n, then sends (y, hash(x)) to Alice.</t>

<t>Alice computes z = (v^r)*(y^b) mod n and verifies hash(z) equals hash(x).</t>

</list>
<t>If the hashes match, Alice knows that Bob has the corresponding server key u. Besides making the response shorter, the hash makes it effectively impossible for an intruder to solve for u by observing a number of these messages. The signed response binds this knowledge to Bob's private key and the client key previously received in his certificate.</t>

</section>
<section title="Mu-Varadharajan (MV) Identity Scheme">

<t>The MV scheme is perhaps the most interesting and flexible of the three challenge/response schemes, but is devilishly complicated. It is most useful when a small number of servers provide synchronization to a large client population where there might be considerable risk of compromise between and among the servers and clients. The client population can be partitioned into a modest number of subgroups, each associated with an individual client key.</t>

<t>The TA generates an intricate cryptosystem involving encryption and decryption keys, together with a number of activation keys and associated client keys. The TA can activate and revoke individual client keys without changing the client keys themselves. The TA provides to the servers an encryption key E and partial decryption keys g-bar and g-hat which depend on the activated keys. The servers have no additional information and, in particular, cannot masquerade as a TA. In addition, the TA provides to each client j individual partial decryption keys x-bar_j and x-hat_j, which do not need to be changed if the TA activates or deactivates any client key. The clients have no further information and, in particular, cannot masquerade as a server or TA.</t>

<t>The scheme uses an encryption algorithm similar to El Gamal cryptography and a polynomial formed from the expansion of product terms (x-x_1)(x-x_2)(x-x_3)...(x-x_n), as described in <xref target="MV"></xref>. The paper has significant errors and serious omissions. The cryptosystem is constructed so that, for every encryption key E its inverse is (g-bar^x-hat_j)(g-hat^x-bar_j) mod p for every j. This remains true if both quantities are raised to the power k mod p. The difficulty in finding E is equivalent to the discrete log problem.</t>   

<t>The scheme is shown in <xref target="MVIDfig"></xref>. The TA generates the parameters, group key, server keys and client keys, one for each client, all of which must be protected to prevent theft of service. Note that only the TA has the group key, which is not known to either the servers or clients. In this sense the MV scheme is a zero-knowledge proof.</t>

<figure anchor="MVIDfig" title="Mu-Varadharajan (MV) Identity Scheme">
<artwork xml:space="preserve">

		                  Trusted
                                 Authority
                               +------------+
                               | Parameters |
                               +------------+
			       | Group Key  |
                               +------------+
			       | Server Key |
                    Secure     +------------+   Secure
                 +-------------| Client Key |-----------+
                 |             +------------+           |
		\|/                                    \|/
           +------------+         Challenge       +------------+
           | Parameters |&lt;------------------------| Parameters |
	   +------------+                         +------------+
	   | Server Key |------------------------&gt;| Client Key |
           +------------+         Response        +------------+
	       Server                                 Client

</artwork>
</figure>

<t>The TA hides MV parameters and keys in OpenSSL DSA cuckoo structures. The MV parameters are identical to the DSA parameters, so the OpenSSL library can be used directly. The structure shown in the figures below are written to files as a the fkey encoded in PEM. Unused structure members are set to one. The <xref target="MVSrvfig"></xref> shows the data structure used by the servers, while Figure <xref target="MVClifig"></xref> shows the client data structure associated with each activation key.</t>

<figure anchor="MVSrvfig" title="MV Scheme Server Structure">
<artwork xml:space="preserve">

	   +---------------------------------+-------------+
	   |   MV    |   DSA    |   Item     |   Include   |
	   +=========+==========+============+=============+
	   |    p    |    p     | modulus    |    all      |
	   +---------+----------+------------+-------------+
	   |    q    |    q     | modulus    |   server    |
	   +---------+----------+------------+-------------+
	   |    E    |    g     | private    |   server    |
	   |         |          | encrypt    |             |
	   +---------+----------+------------+-------------+
	   |  g-bar  | priv_key | public     |   server    |
	   |         |          | decrypt    |             |
	   +---------+----------+------------+-------------+
	   |  g-hat  | pub_key  | public     |   server    |
	   |         |          | decrypt    |             |
	   +---------+----------+------------+-------------+

</artwork>
</figure>

<figure anchor="MVClifig" title="MV Scheme Client Structure">
<artwork xml:space="preserve">

	   +---------------------------------+-------------+
	   |   MV    |   DSA    |   Item     |   Include   |
	   +=========+==========+============+=============+
	   |    p    |    p     | modulus    |    all      |
	   +---------+----------+------------+-------------+
	   | x-bar_j | priv_key | public     |   client    |
	   |         |          | decrypt    |             |
	   +---------+----------+------------+-------------+
	   | x-hat_j | pub_key  | public     |   client    |
	   |         |          | decrypt    |             |
	   +---------+----------+------------+-------------+

</artwork>
</figure>

<t>The devil is in the details, which are beyond the scope of this memo. The steps in generating the cryptosystem activating the keys and generating the partial decryption keys are in <xref target="DASBUCH"></xref> page 170 ff.</t>

<t>Alice challenges Bob to confirm identity using the following exchange.</t>

<list style="numbers">

<t>Alice rolls random r (0 &lt; r &lt; q) and sends to Bob.</t>

<t>Bob rolls random k (0 &lt; k &lt; q) and computes the session encryption key E-prime = E^k mod p and partial decryption keys g-bar-prime = g-bar^k mod p and g-hat-prime = g-hat^k mod p. He encrypts x = E-prime * r mod p and sends (x, g-bar-prime, g-hat-prime) to Alice.</t>

<t>Alice computes the session decryption key E^-1 = (g-bar-prime)^x-hat_j (g-hat-prime)^x-bar_j mod p and verifies that r = E^-1 x.</t>

</list>

</section>
<section anchor="AppASN" title="ASN.1 Encoding Rules">

<t>Certain value fields in request and response messages contain data encoded in ASN.1 distinguished encoding rules (DER). The BNF grammar for each encoding rule is given below along with the OpenSSL routine used for the encoding in the reference implementation. The object identifiers for the encryption algorithms and message digest/signature encryption schemes are specified in <xref target="RFC3279"></xref>. The particular algorithms required for conformance are not specified in this memo.</t>

</section>

<section title="COOKIE request, IFF response, GQ response, MV response">

<t>The value field of the COOKIE request message contains a sequence of two integers (n, e) encoded by the i2d_RSAPublicKey() routine in the OpenSSL distribution. In the request, n is the RSA modulus in bits and e is the public exponent.</t>

<figure>
<artwork xml:space="preserve">
RSAPublicKey ::= SEQUENCE {
	n ::= INTEGER,
	e ::= INTEGER
}
</artwork>
</figure>

<t>The IFF and GQ responses contain a sequence of two integers (r, s) encoded by the i2d_DSA_SIG() routine in the OpenSSL distribution. In the responses, r is the challenge response and s is the hash of the private value.</t>

<figure>
<artwork xml:space="preserve">
DSAPublicKey ::= SEQUENCE {
	r ::= INTEGER,
	s ::= INTEGER
}
</artwork>
</figure>

<t>The MV response contains a sequence of three integers (p, q, g) encoded by the i2d_DSAparams() routine in the OpenSSL library. In the response, p is the hash of the encrypted challenge value and (q, g) is the client portion of the decryption key.</t>

<figure>
<artwork xml:space="preserve">
DSAparameters ::= SEQUENCE {
	p ::= INTEGER,
	q ::= INTEGER,
	g ::= INTEGER
}
</artwork>
</figure>

</section>
<section title="Certificates">

<t>Certificate extension fields are used to convey information used by the identity schemes. While the semantics of these fields generally conforms with conventional usage, there are subtle variations. The fields used by Autokey Version 2 include:</t>

<list style="symbols">

<t>Basic Constraints. This field defines the basic functions of the certificate. It contains the string "critical,CA:TRUE", which means the field must be interpreted and the associated private key can be used to sign other certificates. While included for compatibility, Autokey makes no use of this field.</t>

<t>Key Usage. This field defines the intended use of the public key contained in the certificate. It contains the string "digitalSignature,keyCertSign", which means the contained public key can be used to verify signatures on data and other certificates. While included for compatibility, Autokey makes no use of this field.</t>

<t>Extended Key Usage. This field further refines the intended use of the public key contained in the certificate and is present only in self-signed certificates. It contains the string "Private" if the certificate is designated private or the string "trustRoot" if it is designated trusted. A private certificate is always trusted.</t>

<t>Subject Key Identifier. This field contains the client identity key used in the GQ identity scheme. It is present only if the GQ scheme is in use.</t>

</list>

<t>The value field contains a X509v3 certificate encoded by the i2d_X509() routine in the OpenSSL distribution. The encoding follows the rules stated in <xref target="RFC5280"></xref>, including the use of X509v3 extension fields.</t>

<figure>
<artwork xml:space="preserve">
Certificate ::= SEQUENCE {
        tbsCertificate                  TBSCertificate,
        signatureAlgorithm              AlgorithmIdentifier,
        signatureValue                  BIT STRING
}
</artwork>
</figure>

<t>The signatureAlgorithm is the object identifier of the message digest/signature encryption scheme used to sign the certificate. The signatureValue is computed by the certificate issuer using this algorithm and the issuer private key.</t>

<figure>
<artwork xml:space="preserve">
TBSCertificate ::= SEQUENCE {
        version                         EXPLICIT v3(2),
        serialNumber                    CertificateSerialNumber,
        signature                       AlgorithmIdentifier,
        issuer                          Name,
        validity                        Validity,
        subject                         Name,
        subjectPublicKeyInfo            SubjectPublicKeyInfo,
        extensions                      EXPLICIT Extensions OPTIONAL
}
</artwork>
</figure>

<t>The serialNumber is an integer guaranteed to be unique for the generating host. The reference implementation uses the NTP seconds when the certificate was generated. The signature is the object identifier of the message digest/signature encryption scheme used to sign the certificate. It must be identical to the signatureAlgorithm.</t>

<figure>
<artwork xml:space="preserve">
CertificateSerialNumber
SET { ::= INTEGER
        Validity ::= SEQUENCE {
                notBefore              UTCTime,
                notAfter               UTCTime
        }
}
</artwork>
</figure>

<t>The notBefore and notAfter define the period of validity as defined in <xref target="AppID"></xref>.</t>

<figure>
<artwork xml:space="preserve">
SubjectPublicKeyInfo ::= SEQUENCE {
        algorithm                       AlgorithmIdentifier,
        subjectPublicKey                BIT STRING
}
</artwork>
</figure>

<t>The AlgorithmIdentifier specifies the encryption algorithm for the subject public key. The subjectPublicKey is the public key of the subject.</t>

<figure>
<artwork xml:space="preserve">
Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension
Extension ::= SEQUENCE {
        extnID                          OBJECT IDENTIFIER,
        critical                        BOOLEAN DEFAULT FALSE,
        extnValue                       OCTET STRING
}
</artwork>
</figure>

<figure>
<artwork xml:space="preserve">
SET {
        Name ::= SEQUENCE {
                OBJECT IDENTIFIER       commonName
                PrintableString         HostName
        }
}
</artwork>
</figure>

<t>For trusted host certificates the subject and issuer HostName is the NTP name of the group, while for all other host certificates the subject and issuer HostName is the NTP name of the host. In the reference implementation if these names are not explicitly specified, they default to the string returned by the Unix gethostname() routine (trailing NUL removed). For other than self-signed certificates, the issuer HostName is the unique DNS name of the host signing the certificate.</t>

<t>It should be noted that the Autokey protocol itself has no provisions to revoke certificates. The reference implementation is purposely restarted about once a week, leading to the regeneration of the certificate and a restart of the Auokey protocol. This restart is not enforced for the Autokey protocol but rather for NTP functionality reasons.</t>

<t>Each group host operates with only one certificate at a time and constructs a trail by induction. Since the group configuration must form an acyclic graph, with roots at the trusted hosts, it does not matter which, of possibly several, signed certificates is used. The reference implementation chooses a single certificate and operates with only that certificate until the protocol is restarted.</t>
</section>

</back>
</rfc>
