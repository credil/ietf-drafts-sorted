<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>

<rfc category="std" docName="draft-ietf-mediactrl-mrb-13" ipr="trust200902">
	<front>

		<title abbrev="Media Resource Brokering">Media Resource
		Brokering</title>
		
		<author fullname="Chris Boulton" initials="C." surname="Boulton">
			<organization>NS-Technologies</organization>
			<address>
				<email>chris@ns-technologies.com</email>
			</address>
		</author>

	<author initials="L." surname="Miniero" fullname="Lorenzo Miniero">
	<organization>Meetecho</organization>
	<address>
		<postal>
			<street>Via Carlo Poerio 89</street>
			<code>80100</code> 
			<city>Napoli</city> 
			<country>Italy</country>
		</postal>
		<email>lorenzo@meetecho.com</email>
	</address>
	</author>


	<author initials="G." surname="Munson" fullname="Gary Munson">
	<organization>AT&T</organization>
	<address>
		<postal>
			<street>200 Laurel Avenue South</street>
			<street>Middletown</street>
			<code>07748</code> 
			<city>New Jersey</city> 
			<country>USA</country>
		</postal>
		<email>gamunson@att.com</email>
	</address>
	</author>
	
		<date year="2012"/>
		<workgroup/>
		<abstract>

			<t>The MediaCtrl work group in the IETF has proposed an architecture 
			for controlling media services.  The Session Initiation Protocol (SIP) is used as 
			the signalling protocol which provides many inherent capabilities for 
			message routing.  In addition to such signalling properties, a need 
			exists for intelligent, application level media service selection based 
			on non-static signalling properties.  This is especially true when considered in 
			conjunction with deployment architectures that include 1:M and M:N combinations 
			of Application Servers and Media Servers.  This document introduces a Media
			Resource Broker (MRB) entity which manages the availability of Media Servers and the
			media resource demands of Application Servers.  The document includes potential deployment
			options for an MRB and appropriate interfaces to Application Servers and Media Servers.	
			</t>

		</abstract>
		<!-- Abstract -->
	</front>
	<middle>

	  <section anchor="sec:Introduction" title="Introduction">

		<t>As IP based multimedia infrastructures mature, the complexity and demands from 
		deployments increase.  Such complexity will result in a wide variety of capabilities
		from a range of vendors that should all be interoperable using the architecture
		and protocols produced by the MediaCtrl work group.  It should be possible 
		for a controlling entity to be assisted in Media Server selection so that 
		the most appropriate resource is selected for a particular operation.  The
	       	importance increases when you introduce a flexible level of deployment scenarios, 
		as specified in the <xref target="RFC5167">RFC 5167</xref> and <xref target="RFC5567">RFC 5567</xref> documents.  
		These documents make statements like
		&quot;it should be possible to have a many-to-many relationship between Application 
		Servers and Media Servers that use this protocol&quot;.  This leads to the following 
		deployment architectures being possible when considering media resources, to provide
		what can be effectively described as Media Resource Brokering.
		</t>

		<t>The simplest deployment view is illustrated in <xref target="fig:arch1"/>. 
		</t>
			
		<figure anchor="fig:arch1" title="Basic Architecture">
			<artwork><![CDATA[
 
     
+---+-----+---+                         +---+-----+---+
| Application |                         |    Media    |
|   Server    |<-------MS Control------>|    Server   |
+-------------+                         +-------------+
                         

			]]></artwork>
		</figure>

		<t>This simply involves a single Application Server and Media Server.  Expanding 
		on this view, it is also possible for an Application Server to control 
		multiple (greater that 1) Media Server instances at any one time.  This deployment view is illustrated in 
		<xref target="fig:arch2"/>.  Typically, such architectures are associated with 
		application logic that requires high demand media services.  It is more than possible 
		that each media server possesses a different media capability set.  Media servers 
		may offer different media services as specified in the Mediactrl architecture document. 
		A Media server may have similar media functionality but may have different capacity 
		or media codec support.</t>

<figure anchor="fig:arch2" title="Multiple Media Servers">
			<artwork><![CDATA[
 

                         		+---+-----+---+
                       		 	|    Media    |
				 +----->|    Server   |
                          	 |	+-------------+
                                 |    
+---+-----+---+                  |      +---+-----+---+
| Application |                  |      |    Media    |
|   Server    |<--MS Control-----+----->|    Server   |
+-------------+                  |      +-------------+
                                 |
                                 |      +---+-----+---+
                       		 +----->|    Media    |
          				|    Server   |
                          		+-------------+

			]]></artwork>
	</figure>

		<t><xref target="fig:arch3"/> conveys the opposite view to that in <xref target="fig:arch2"/>.  
		In this model there are a number of (greater than 1) application servers, possibly supporting
		dissimilar applications, controlling a single media server.  Typically, such architectures are
		associated with application logic that requires low demand media services.	
		</t>

<figure anchor="fig:arch3" title="Multiple Application Servers">
			<artwork><![CDATA[
 
+---+-----+---+                        
| Application |                  
|   Server    |<-----+               
+-------------+      |           
                     |   
+---+-----+---+      |                  +---+-----+---+
| Application |      |                  |    Media    |
|   Server    |<-----+-----MS Control-->|    Server   |
+-------------+      |                  +-------------+
                     |
+---+-----+---+      |                
| Application |      |              
|   Server    |<-----+
+-------------+                        
                            

			]]></artwork>
	</figure>

	<t>The final deployment view is the most complex.  In this model (M:N) there 
	exists any number of Application Servers and any number of Media Servers.  It is  
	again possible in this model that media servers might not be homogeneous and have 
	different capability sets and capacity.</t>

<figure anchor="fig:arch4" title="Basic Architecture">
			<artwork><![CDATA[
 
+---+-----+---+                         +---+-----+---+
| Application |                         |    Media    | 
|   Server    |<-----+            +---->|    Server   |
+-------------+      |            |     +-------------+
                     |            |
+---+-----+---+      |            |     +---+-----+---+
| Application |      |            |     |    Media    |
|   Server    |<-----+-MS Control-+---->|    Server   |
+-------------+      |            |     +-------------+
                     |            |
+---+-----+---+      |            |     +---+-----+---+
| Application |      |            +---->|    Media    |
|   Server    |<-----+                  |    Server   |
+-------------+                         +---+-----+---+
                
			]]></artwork>
		</figure>

		<t>The remaining sections in this specification will focus on a new entity called
		a Media Resource Broker (MRB) which can be utilised in the deployment architectures
	       	described previously in this section.  The MRB entity provides the ability to obtain
		media resource information and appropriately allocate(broker) on behalf of client
	       	applications.</t>
		
		<t>The high level deployment options discussed in this section rely
		on network architecture and policy to prohibit inappropriate use.  Such
		policies are out of the scope of this document.</t>

		<t>This document will take a look at the specific problem areas related 
		to such deployment architectures.  It is recognised that the solutions 
		proposed in this document should be equally adaptable to all of the 
		previously described deployment models.  It is also recognised that 
		the solution is far more relevant to some of the previously discussed 
	       	deployment models and can almost be viewed as redundant
		on others.</t>
        
	  </section>
		


<!-- Introduction -->
		
<section anchor="Terminology" title="Conventions and Terminology">

	<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      <xref target="RFC2119">RFC 2119</xref>.</t>

	<t>This document inherits terminology proposed in
	<xref target="RFC5567">RFC 5567</xref> and
	<xref target="RFC6230">Media Control Channel Framework</xref> documents.  
	In addition, the following terms are defined for use in this document and for 
	use in the context of the MediaCtrl Work group in the IETF:
			
<list style="hanging">

	<t hangText="Media Resource Broker (MRB): ">A logical entity that is responsible for
     	both collection of appropriate published Media Server (MS)
      	information and selecting appropriate MS resources on behalf of
      	consuming entities.</t>

	<t hangText="Query MRB: ">An instantiation of an MRB (See previous definition) that provides 
	an interface for an Application Server to retrieve the address of an appropriate Media Server.  The result 
	returned to the Application Server can be influenced by information contained in the query 
	request.</t>

	<t hangText="In-line MRB: ">An instantiation of an MRB (See definition) that
      	directly receives requests on the signalling path. There is no
	separate query.</t>

	<t hangText="CFW: ">Media Control Channel Framework, as specified in <xref target="RFC6230"/>.</t>

</list>

	Within the context of In-line MRBs, additional terms are defined:

<list style="hanging">

	<t hangText="In-line Aware MRB Mode (IAMM): ">Defined in <xref target="sec:IAMM_CFW"/>.</t>

	<t hangText="In-line Unaware MRB Mode (IUMM): ">Defined in <xref target="sec:In_Line"/>.</t>

</list>
	
	The document will often specify when a specific identifier in a protocol message
	needs to be unique. Unless differently stated, such uniqueness will always need to
	be intended within the scope of the Media Servers controlled by the same Media
	Resource Broker. The interaction among different Media Resource Brokers, as the
	partitioning of a logical Media Resource Broker, is out of scope to this document.
</t>

</section>

<!-- Terminology -->


	<section anchor="sec:Problem" title="Problem Discussion">			
     
		<t>As anticipated in <xref target="sec:Introduction"/>, the main aim of the MediaCtrl group
		is to produce a solution that must service a wide variety of deployment architectures.  
		These range from the simplest 1:1 relationship between Media Servers and Application 
		Servers to potentially linearly scaling 1:M, M:1 and M:N deployments.</t>

		<t>This still does not seem like a major issue for the proposed solution until 
		you add a number of additional factors into the equation that increase 
		complexity.  As Media Servers evolve it must be taken into consideration that, 
		where many can exist in a deployment, they may not have been produced by the same 
		vendor and may not have the same capability set.  It should be possible for an 
		Application Server that exists in a deployment to select a Media Service based 
		on a common, appropriate capability set.  In conjunction with capabilities, it is 
		also important to take available resources into consideration.  The ability 
		to select an appropriate Media Service function is an extremely useful  
		feature but becomes even more powerful when considered with 
		available resources for servicing a request.</t>
		
		<t>In conclusion, the intention is to create a tool set that allows MediaCtrl 
		deployments to effectively utilize the available media resources.  It should 
		be noted that in the simplest deployments where only a single media server exists, 
		an MRB function is probably not required.  Only a single capability set exists 
		and resource unavailability can be handled using the appropriate underlying 
		signalling, e.g., SIP response.  This document does not prohibit such uses of 
		an MRB, it simply provides the tools for various entities to interact 
		where appropriate.  It is also worth noting that the tools provided 
       		in this document aim to provide a 'best effort' view of media resources 
		at the time of request for initial Media Server routing decisions.  Any 
		dramatic change in media capabilities after a request has taken place
		should be handled by the underlying protocol.</t>
		
		<t>Please note that there may be additional information that it is
		desirable for the MRB to have for purposes of selecting a MS resource, such as
		resource allocation rules across different applications, planned or unplanned
		downtime of Media Server resources, the planned addition of future Media Server
		resources, or MS resource capacity models. How the MRB acquires such information
		is outside the scope of this document.  The techniques used for selecting an
		appropriate Media Resource by an MRB is outside the scope of this document.</t>

	</section>
	<!-- Problem -->

	<section anchor="sec:Deployment" title="Deployment Scenario Options ">			
     
		<t>On researching Media Resource Brokering it became clear that a couple of high level 
		models exist.  The general principles of &quot;in-line&quot; and &quot;query&quot; 
		MRB concepts are discussed in the rest of this section.  It should be noted that while
		the interfaces are different they both use common mechanisms.
		</t>

		<section anchor="sec:Query" title="Query MRB">			
     
		<t>The &quot;Query&quot; model for MRB interactions provides the ability for 
		a client of media services (for example an Application Server) to 
		&quot;ask&quot; an MRB for an appropriate Media Server, as illustrated 
		in <xref target="fig:arch5"/>.
		</t>

		<figure anchor="fig:arch5" title="Query MRB">
			<artwork><![CDATA[
 
                     +---+-----+---+ 
       +------------>|     MRB     |<----------+----<-----+---+
       |             +-------------+        (1)|          |   |
       |                                       |          |   |
       |(2)                             +---+--+--+---+   |   |
       |                                |    Media    |   |   |
       |                          +---->|    Server   |   |   |
       |                          |     +-------------+   |   |
       |                          |                    (1)|   |
+---+--+--+---+                   |     +---+-----+---+   |   |
| Application |                   |     |    Media    |   |   |
|   Server    |<-----+-MS Control-+---->|    Server   |->-+   |
+-------------+          (3)      |     +-------------+       |
                                  |                           |
                                  |     +---+-----+---+    (1)|
                                  +---->|    Media    |       |
                                        |    Server   |--->---+
                                        +---+-----+---+
                
			]]></artwork>
		</figure>
		
		<t>In this deployment, the Media Servers use the &quot;Media Server Resource 
		Publish Interface&quot;, as discussed in <xref target="sec:MS_Pub"/>, to 
		convey capability sets as well as resource information.  This is depicted 
		by (1) in <xref target="fig:arch5"/>.  It is then the MRB's responsibility to 
		accumulate all appropriate information relating to media services in the 
		logical deployment cluster.  The Application Server (or other media 
		services client) is then able to query the MRB for an appropriate resource (as 
		identified by (2) in <xref target="fig:arch5"/>).  Such a query would carry 
	       	specific information related to the Media Service required and enable the MRB 
		to provide an increased accuracy in its response.  This particular interface 
		is discussed in &quot;Media Resource Consumer Interface&quot; in 
		<xref target="sec:Res_Cons"/>.  The Application Server is then able 
		to direct control commands (for example create conference) and Media Dialogs 
		to the appropriate Media Server, as shown by (3) in <xref target="fig:arch5"/>. 
		Additionally, with Query MRB, the MRB is not in the signaling path
		between the AS and the selected MS resource.</t>

		<section anchor="sec:Query_hybrid" title="Hybrid Query MRB">			
     
		<t>As mentioned previously, it is the intention that a tool kit is provided 
		for MRB functionality within a MediaCtrl architecture.  It is expected that in
		specific deployment scenarios the role of the MRB might be co-hosted as a hybrid 
		logical entity with an Application Server, as shown in <xref target="fig:arch6"/>.
		</t>

	<figure anchor="fig:arch6" title="Hybrid Query MRB - AS Hosted">
			<artwork><![CDATA[
  
       +------------<----------------<---------+----<-----+---+
       |                     (1)               |          |   |
       |                                       |          |   |
       |                                +---+--+--+---+   |   |
       |                                |    Media    |   |   |
       V                          +---->|    Server   |   |   |
+------+------+                   |     +-------------+   |   |
|     MRB     |                   |                       |   |
+---+--+--+---+                   |     +---+-----+---+   |   |
| Application |                   |     |    Media    |   |   |
|   Server    |<-----+-MS Control-+---->|    Server   |->-+   |
+-------------+                   |     +-------------+       |
                                  |                           |
                                  |     +---+-----+---+       |
                                  +---->|    Media    |       |
				        |    Server   |--->---+
                                        +---+-----+---+
                
			]]></artwork>
		</figure>

		<t>This diagram is identical to that in <xref target="fig:arch5"/> with the exception 
		that the MRB is now hosted on the Application Server.  The &quot;Media Server 
		Publish Interface&quot; is still being used to accumulate resource information 
		at the MRB but as it is co-hosted on the Application Server, the &quot;Media
		Server Consumer Interface&quot; has collapsed.  It might still exist within the 
		Application Server/MRB interaction but this is an implementation issue.  This 
		type of deployment suits a single Application Server environment but it should be noted 
		that a &quot;Media Server Consumer Interface&quot; could then be offered from the
		hybrid if required.	
		</t>

		<t>In a similar manner, the Media Server could also act as a hybrid for the deployment 
		cluster, as illustrated in <xref target="fig:arch7"/>.
		</t>

	<figure anchor="fig:arch7" title="Hybrid Query MRB - MS Hosted">
			<artwork><![CDATA[
 
                                (1)                 +---+-----+---+ 
+---+---+------------->---------------->----------->|     MRB     |
|   |   |   +---+--+--+---+                         +---+-----+---+   
|   |   +-<-| Application |                         |    Media    |   
|   |       |   Server    |<--+-MS Control-+------->|    Server   |   
|   |       +-------------+                   |     +-------------+
|   |                                         |
|   |       +---+--+--+---+                   | 
|   +---<---| Application |                   |   
|           |   Server    |<--+-MS Control-+--+   
|           +-------------+                   | 
|                                             |
|           +---+--+--+---+                   | 
+---<-------| Application |                   |   
            |   Server    |<--+-MS Control-+--+   
            +-------------+            




			]]></artwork>
		</figure>
		
		<t>This time the MRB has collapsed and is co-hosted by the Media Server.  The 
		&quot;Media Server Consumer Interface&quot; is still available to the Application 
		Servers (1) to query Media Server resources.  This time the &quot;Media
		Server Publish Interface&quot; has collapsed onto the Media Server.  It might 
		still exist within the Media Server/MRB interaction but this is an implementation 
		issue.  This type of deployment suits a single Media Server environment but 
		it should be noted that a &quot;Media Server Publish Interface&quot; could then 
		be offered from the hybrid if required. A typical use case scenario for such a
		topology would be a single MS representing a pool of MSs in a cluster. In that case,
		the MRB would actually be handling a cluster of MSs, rather than one.
		</t>

		</section>
		<!-- Hybrid Query MRB -->

		</section>
		<!-- Query MRB -->

	<section anchor="sec:Inline" title="In-Line MRB">			
     
	<t>The &quot;In-line&quot; MRB is architecturally different from the &quot;Query&quot; model 
	that was discussed in the previous section.  The concept of a separate
	query disappears.  The client of the MRB simply uses the media resource
	control and media dialog signalling to involve the MRB.  This type of deployment is illustrated
	in <xref target="fig:arch8"/>.</t>

	<figure anchor="fig:arch8" title="In-line MRB">
			<artwork><![CDATA[
  
                            +-------<----------+----<-------+---+
                            |                  | (1)        |   |
                            |                  |            |   |
                            |             +---+--+--+---+   |   |
                            |             |    Media    |   |   |
                            |     +------>|    Server   |   |   |
                            |     |(3)    +-------------+   |   |
                            |     |                      (1)|   |
+---+--+--+---+             |     |       +---+-----+---+   |   |
| Application |  (2) +---+--V--+---+  (3) |    Media    |   |   |
|   Server    |----->|     MRB     |----->|    Server   |->-+   |
+-------------+      +---+-----+---+      +-------------+       |
                                  |                             |
                                  |   (3) +---+-----+---+    (1)|
                                  +------>|    Media    |       |
				          |    Server   |--->---+
                                          +---+-----+---+
                
			]]></artwork>
		</figure>
	
	<t>The Media Servers still use the 'Media Server Publish Interface' to convey 
	capabilities and resources to the MRB - as illustrated by (1).  The media server 
	Control (and Media dialogs as well, if required) is sent to the MRB (2) which then selects an 
	appropriate Media Server (3) and would stay in the signaling path between the AS
	and the MS resource for the handled dialogs.</t>

	<t>In-line MRB can be split into two distinct logical roles which can be applied on a per
	request basis.  They are:

	<list style="hanging">

		<t hangText="In-line Unaware MRB Mode (IUMM):">Allows an MRB to act on behalf of clients requiring
			media services who are not aware of an MRB or its operation.  In this case the AS does not
			provide explicit information on the kind of MS resource it needs
			(as in <xref target="sec:Res_Cons"/>) and the
			MRB is left to deduce it by potentially inspecting other information in the request from
			the AS; for example, SDP content, or address of the requesting AS, or additional Request-URI
			parameters as per <xref target="RFC4240">RFC 4240</xref>.</t>

		<t hangText="In-line Aware MRB Mode (IAMM):">Allows an MRB to act on behalf of clients requiring 
			media services who are aware of an MRB and its operation.  In particular it allows the AS
			to explicitly the convey the same kinds of MS characteristics desired as does the Query MRB
			mode (as in <xref target="sec:Res_Cons"/>).
		
		</t>

	</list>

	In either role, signalling as specified by the Media Control Channel
		Framework (<xref target="RFC6230"/>) would be involved, and the MRB would deduce
		that the selected MS resources are no longer needed when the AS 
	or MS terminates the corresponding dialog.  The two modes are discussed in more detail
	in <xref target="sec:In_Line"/>.</t>

	</section>
	<!-- In-Line -->

	</section>
	<!-- Deployment -->


<section anchor="sec:Interfaces" title="MRB Interface Definitions">			
     
	<t>The intention is to 
	provide a tool-kit for a variety of deployment architectures where media resource 
	brokering can take place.  Two main interfaces are required to 
	support the differing requirements.  The two interfaces are described in the 
	remainder of this section and have been named the 'Media Server Resource
	Publish' and 'Media Server Resource Consumer' interfaces.
	</t>

	<t>It is beyond the scope of this document to define exactly how to 
	construct an MRB using the interfaces described.  It 
	is, however, important that the two interfaces are complimentary so that 
	development of appropriate MRB functionality is supported.</t>

	<section anchor="sec:MS_Pub" title="Media Server Resource Publish Interface">	
	
		<t>The Media Server Resource Publish interface is responsible for 
		providing an MRB with appropriate Media Server resource information.  
		As such, this interface is assumed to provide both general 
		and specific details related to Media Server resources.  This 
		information needs to be conveyed using an industry standard mechanism 
		to provide increased levels of adoption and interoperability.  A
		Control Package for the Media Control Channel Framework will be specified to fulfil this interface
		requirement.  It provides an establishment and monitoring
		mechanism to enable a Media Server to report appropriate statistics
		to an MRB.  The Publish interface is used with both Query and In-line modes of
		MRB operation.
		</t>

		<t>As already anticipated in the introduction, the MRB view
   		of MS resource availability will in practice be approximate - i.e.,
		partial and imperfect. The MRB Publish interface does not provide an exhaustive
   		view of current MS resource consumption, the MS may in some cases
		provide a best-effort computed view of resource consumption 
   		parameters conveyed in the Publish interface (e.g., DSP's with a
		fixed number of streams versus GPU's with CPU availability).  Media Resource
		information may only be
		reported periodically over the Publish interface to MRB.</t>

		<t>It is also worth noting that, while the scope of the MRB is in providing interested
		Application Servers with
		the available resources, the MRB also allows for the retrieval of information about
		consumed resources. While this is of course a relevant piece of information (e.g., for monitoring
		purposes), such functionality inevitably raises security considerations, and implementations
		should take this into account. See <xref target="sec:security"/> for more details.</t>

		<t>The MRB Publish interface uses the Media Control Channel
		Framework (<xref target="RFC6230"/>) as the basis for interaction
		between a Media Server and an MRB.  The Media Control Channel Framework uses an extension mechanism
		to allow specific usages which are known as control packages.  <xref target="sec:Control_Package_Definition"/>
		defines the control package that MUST be implemented by any Media Server wanting to interact
		with an MRB entity.</t>
		
<section anchor="sec:Control_Package_Definition" title="Control Package Definition">

<t>This section fulfils the mandatory requirement for information that
must be specified during the definition of a Control Framework Package,
as detailed in Section 8 of <xref target="RFC6230"/>.</t>
		  
<section anchor="sec:Control_Package_Name" title="Control Package Name">

<t>The Media Channel Control Framework requires a Control Package definition to
specify and register a unique name and version.</t>

<t>The name and version of this Control Package is "mrb-publish/1.0".  </t>
		     
</section>

<!-- Control Package Name -->

<section anchor="sec:Message_Usage" title="Framework Message Usage">

	<t>The MRB publish interface allows a media server to convey available capabilities
	and resources to an MRB entity.</t>

	<t>This package defines XML elements in <xref target="definitions"/> and provides an XML
	Schema in <xref target="sec:publisher_xml"/>. </t>

	<t>The XML elements in this package are split into requests, responses
    	and event notifications.

    	Requests are carried in CONTROL message bodies; &lt;mrbrequest> element is defined as a package request.
    	This request can be used for creating new subscriptions and updating/removing existing subscriptions.

    	Event notifications are also carried in CONTROL message bodies; the
	&lt;mrbnotification> element is defined for package event notifications.

    	Responses are carried either in REPORT message or Control Framework
	200 response bodies; the &lt;mrbresponse> element is defined as a
	package level response. 
</t>


	<t>Note that package responses are different from framework response
	codes. Framework error response codes (see Section 7 of
	<xref target="RFC6230"/>) are
	used when the request or event notification is
	invalid; for example, a request has invalid XML (400), or is not
	understood (500). Package level responses are carried in framework 200 
	response or
	REPORT message bodies. This package's response codes are defined
	in  <xref target="sec:responses"/>. </t>

</section>

<!--Framework Message Usage -->

<section anchor="sec:Common_XML" title="Common XML Support">

	<t>The Media Control Channel Framework <xref target="RFC6230"/>
	requires a Control Package definition to
	specify if the attributes for media dialog or conference references are required.</t>

	<t>The Publish interface defined in <xref target="sec:publisher_xml"/> does import and make use of the
	common XML schema defined in the Media Control Channel Framework.</t>

	<t>The Consumer interface defined in <xref target="sec:consumer_xml"/> does import and make use of the
	common XML schema defined in the Media Control Channel Framework.</t>

</section>

<!-- Common XML Support -->

<section anchor="sec:Control_Body" title="CONTROL Message Body">

<t>A valid CONTROL body message MUST conform to the schema defined in <xref target="sec:publisher_xml"/> and described in
    <xref target="definitions"/>. XML messages appearing in CONTROL messages
    MUST contain either a &lt;mrbrequest> or &lt;mrbnotification> element.  </t>


</section>

<!-- CONTROL Message Body -->

<section anchor="sec:REPORT_Body" title="REPORT Message Body">

<t>A valid REPORT body MUST conform to the schema defined in <xref target="sec:publisher_xml"/>
and described in <xref target="definitions"/>. XML
messages appearing in REPORT messages MUST contain a &lt;mrbresponse> element.

</t>

</section>

<!-- REPORT Message Body -->

<section anchor="sec:Audit" title="Audit">

	<t>The 'mrb-publish/1.0' Media Control Channel Framework package does not require any
	additional auditing capability.</t>
	

</section>

<!-- Audit -->

</section>
<!-- Package Definition -->


<section anchor="definitions" title="Element Definitions">

	<t>This section defines the XML elements for the Publish interface Media Control Channel package
	defined in <xref target="sec:MS_Pub"/>.  The formal XML schema definition for the Publish
	interface can be found in <xref target="sec:publisher_xml"/>.</t>

	<t>The root element is &lt;mrbpublish>.  All other XML elements (requests, responses, notifications) are
	contained within it.  The MRB Publish interface request element is detailed in <xref target="sec:requests"/>. 
	The MRB Publish interface notification element is detailed in <xref target="sec:notifications"/>.
	MRB Publish interface response element is contained in <xref target="sec:responses"/>.</t>

	<t>The &lt;mrbpublish> element has zero or more of the following attributes:

	<list style="hanging">
	<t hangText="version:">a token specifying the mrb-publish package version.  The value
      	is fixed as '1.0' for this version of the package.  The attribute MUST be present.</t>
	</list>
	</t>

	<t>The &lt;mrbpublish> element has the following child elements, only one of which is allowed
	to occur in a request.

	<list style="hanging">
		<t>&lt;mrbrequest> for sending an MRB request.  See <xref target="sec:requests"/>.</t>
		<t>&lt;mrbresponse> for sending an MRB response.  See <xref target="sec:responses"/>.</t>
		<t>&lt;mrbnotification> for sending an MRB notification.  See <xref target="sec:notifications"/>.</t>
	</list>
	</t>
	
</section>
<!-- Element Definitions -->

<section anchor="sec:requests" title="&lt;mrbrequest>">

	<t>This section defines the &lt;mrbrequest> element used to initiate requests from an
	MRB to a Media Server.  The element describes information relevant for the interrogation
	of a media server.</t>

	<t>The &lt;mrbrequest> element has no defined attributes.</t>

	<t>The &lt;mrbrequest> element has zero or more of the following child elements:

	<list style="hanging">
	<t>&lt;subscription> for initiating a subscription to a Media Server from an MRB.  See <xref target="sec:subscription"/>.</t>
	</list>
	</t>

<section anchor="sec:subscription" title="&lt;subscription>">

	<t>The &lt;subscription> element is included in a request from an MRB to a Media Server to provide the
	details relating to the configuration of updates.  This element can be used either to request a new subscription
	or to update an existing one (e.g., to change the frequency of the updates), and to remove ongoing subscriptions as
	well (e.g., to stop an indefinite update). The MRB will inform the Media Server how long
	it wishes to receive updates for and the frequency that updates should be sent. Updates related
	to the subscription are sent using the  &lt;mrbnotification> element.</t>

	<t>The &lt;subscription> element has the following attributes:
	
	<list style="hanging">
		<t hangText="id:"> indicates a unique token representing the subscription session between the MRB
		and the Media Server.  The attribute MUST be present.</t>
		<t hangText="seqnumber:"> indicates a sequence number to be used in conjunction
		with the subscription session id to identify a specific subscription command.
		The first subscription
		MUST have 1 as 'seqnumber', and following subscriptions MUST increment by 1 the
		previous 'seqnumber' value.
		The attribute MUST be present.</t>
		<t hangText="action:"> provides the operation that should be carried out on the subscription:
		<list style="symbols">
		<t>The value of 'create' instructs the MS to attempt to set-up a new subscription.</t>
		<t>The value of 'update' instructs the MS to attempt to update an existing subscription.</t>
		<t>The value of 'remove' instructs the MS to attempt to remove an existing subscription
		and consequently stop any ongoing related notification.</t>
		</list>
		The attribute MUST be present.</t>
	</list>
	</t>

	<t>The &lt;subscription> element has zero or more of the following child elements:


	<list style="hanging">
		<t hangText="<expires>: ">Provides the amount of time in seconds that a subscription should be installed for notifications
		at the Media Server.  Once the amount of time has passed, the subscription expires and the MRB has to subscribe
		again in case it is still interested in receiving notifications from the MS. The element MAY be present.</t>
		<t hangText="<minfrequency>: ">Provides the minimum frequency in seconds that the MRB wishes to receive notifications
		from the MS.  The element MAY be present.</t>
		<t hangText="<maxfrequency>: ">Provides the maximum frequency in seconds that the MRB wishes to receive notifications
		from the MS.  The element MAY be present.</t>
	</list>
	</t>
	
	<t>
	Please note that these three optional pieces of
	information provided by the MRB only act as a suggestion: the MS MAY change the proposed values if it considers
	the suggestions unacceptable (e.g., if the MRB has requested a too high notification frequency). In such case,
	the request would not fail, but the updated, acceptable values would be reported in the &lt;mrbresponse> accordingly.
	</t>

</section>
<!--subscription -->

</section>
<!-- mrbrequest -->

<section anchor="sec:responses" title="&lt;mrbresponse>">

	<t>Responses to requests are indicated by a &lt;mrbresponse> element. </t>

<t>The &lt;mrbresponse> element has the following attributes:

<list style="hanging">

<t hangText="status:">numeric code indicating the response status. The
attribute MUST be present.</t>

<t hangText="reason:">string specifying a reason for the response status. The
attribute MAY be present.</t>

</list>
</t>

	<t>The &lt;mrbresponse> element has zero or more of the following child elements:

	<list style="hanging">
	<t>&lt;subscription> for providing details related to a subscription a Media Server requested (see below in this section).</t>
	</list>
	</t>


    <t>The following status codes are defined for 'status': </t>


       <texttable anchor="defn.response.statuscodes"
                title="&lt;mrbresponse> status codes" >
                <ttcol align="left" width="15%">code</ttcol>
                <ttcol align="left" width="85%">description</ttcol>
				<c>200</c>
					<c>OK</c>
				<c>400</c>
					<c>Syntax error</c>
				<c>401</c>
					<c>Unable to create Subscription</c>
				<c>402</c>
					<c>Unable to update Subscription</c>
				<c>403</c>
					<c>Unable to remove Subscription</c>
				<c>404</c>
					<c>Subscription does not exist</c>
				<c>405</c>
					<c>Subscription already exists</c>
				<c>420</c>
					<c>Unsupported attribute or element</c>
       </texttable>

<t>
In case a new subscription request made by an MRB (action='create') has been accepted,
the MS MUST reply with a &lt;mrbresponse> with status code 200. The same rule applies
whenever a request to update (action='update') or remove (action='remove') an
existing transaction can be fulfilled by the MS.
</t>
<t>
A subscription request, nevertheless, may fail for several reasons. In such
a case, the status codes defined in <xref target="defn.response.statuscodes"/>
must be used instead. Specifically, if the MS fails to handle a request
due to a syntax error in the request itself (e.g., incorrect XML,
violation of the schema constraints or invalid values in any of the
attributes/elements) the MS MUST reply with a &lt;mrbresponse> with status code 400.
If a syntactically correct request fails because the request also includes any
attribute/element the MS doesn't understand, the MS MUST reply with a &lt;mrbresponse> with status code 420.
If a syntactically correct request fails because the MRB wants to create a new subscription,
but the provided intended id for the subscription already exists, the MS MUST reply
with a &lt;mrbresponse> with status code 405. If a syntactically correct request
fails because the MRB wants to update/remove a subscription that doesn't exist,
the MS MUST reply with a &lt;mrbresponse> with status code 404.
If the MS is unable to accept a request for any other
reason (e.g., the MRB has no more resources to fulfil the request),
the MS MUST reply with a &lt;mrbresponse> with status code 401/402/403,
depending on the action the MRB provided in its request:
<list style="symbols">
<t>action='create' --&gt; 401;</t>
<t>action='update' --&gt; 402;</t>
<t>action='remove' --&gt; 403;</t>
</list>
</t>

<t>
    A response to a subscription request that has a status of "200"
    indicates that the request is successful.  The response MAY also
    contain a &lt;subscription>  child that describes the subscription.
    The &lt;subscription>  child MAY contain 'expires', 'minfrequency' and
    'maxfrequency' values even if they were not contained in the
    request.
</t>
<t>
    The MS MAY change the suggested 'expires', 'minfrequency' and
    'maxfrequency' values provided by the MRB in its &lt;mrbrequest>, if
    it considers them unacceptable (e.g., the requested frequency range
    is too high).  In such a case, the response MUST contain a
    &lt;subscription>  element describing the subscription as the MS
    accepted it, and the MS MUST include in the &lt;subscription>  element
    all of those values that it modified relative to the request, to
    inform the MRB about the change.</t>

</section>
<!-- Responses -->

<section anchor="sec:notifications" title="&lt;mrbnotification>">

	<t>The &lt;mrbnotification> element is included in a request from a Media Server to an MRB to provide the
	details relating current status.  The Media Server will inform the MRB of its current status as defined by
	the information in the &lt;subscription> element.  Updates are sent
	using the &lt;mrbnotification> element.</t>

	<t>The &lt;mrbnotification> element has the following attributes:
	
	<list style="hanging">
		<t hangText="id:"> indicates a unique token representing the session between the MRB
		and the Media Server and is the same as the one appearing in the &lt;subscription> element. 
		The attribute MUST be present.</t>
		<t hangText="seqnumber:"> indicates a sequence number to be used in conjunction
		with the subscription session id to identify a specific notification update.
		The first notification
		MUST have 1 as 'seqnumber', and following notifications MUST increment by 1 the
		previous 'seqnumber' value.
		The attribute MUST be present.</t>
	</list>
	</t>

	<t>It's important to point out that the 'seqnumber' that appears in a &lt;mrbnotification>
	is not related to the 'seqnumber' appearing in a &lt;mrbsubscription>. In fact, the latter
	is associated with subscriptions and would increase at every command issued by the MRB, while
	the former is associated with the asynchronous notifications the MS would trigger according
	to the subscription, and as such would increase at every notification message to let
	the MRB keep track of them.</t>
	
	<t>The following subsections provide details of the child elements that are the content of the
	&lt;mrbnotification> element.</t>

<section anchor="sec:media-server-id" title="&lt;media-server-id>">

	<t>The &lt;media-server-id> element provides a unique system wide identifier for a Media Server
	instance.  The element MUST be present, and MUST chosen such that it is extremely unlikely
	that two different media servers would present the same id to a given MRB.</t>

</section>
<!--media-server-id -->

<section anchor="sec:supported-pacakges" title="&lt;supported-packages>">

	<t>The &lt;supported-packages> element provides the list of Media Control
	Channel Packages supported by the media server.  The element MAY be present.</t>

	<t>The &lt;supported-packages> element has no attributes.</t>

	<t>The &lt;supported-packages> element has zero or more of the following child elements:


	<list style="hanging">
		<t hangText="<package>: "> The &lt;package> element gives the name of a package
		supported by the media server.  The &lt;package> element has a single attribute,
		'name', which provides the name of the supported Media Control Channel Framework
		package, compliant with the Section 13.1.1 of <xref target="RFC6230"/>.</t>
	</list>
	</t>

</section>
<!--supported-packages -->

<section anchor="sec:active-rtp-sessions" title="&lt;active-rtp-sessions>">

	<t>The &lt;active-rtp-sessions> element provides information detailing the current active
	Real-time Transport Protocol(RTP) sessions.  The element MAY be present.</t>

	<t>The &lt;active-rtp-sessions> element has no attributes.</t>

	<t>The &lt;active-rtp-sessions> element has zero or more of the following child elements:


	<list style="hanging">
		<t hangText="<rtp-codec>: "> Describes a supported codec and the number of active sessions using that codec. 
		The &lt;rtp-codec> element has one attribute.  The value of the attribute 'name' is a media type
     		(which can include parameters per <xref target="RFC6381"/>). The &lt;rtp-codec> element has two child
      		elements.  The child element, &lt;decoding>, has as content the decimal number of
    		RTP sessions being decoded using the specified codec.  The child element, &lt;encoding>, has as content
		the decimal number of RTP sessions being encoded using the specified codec.</t>
	</list>
	</t>

</section>
<!--active-rtp-sessions -->

<section anchor="sec:active-mixer-sessions" title="&lt;active-mixer-sessions>">

	<t>The &lt;active-mixer-sessions> element provides information detailing the current active
	mixed RTP sessions.  The element MAY be present.</t>

	<t>The &lt;active-mixer-sessions> element has no attributes.</t>
	<t>The &lt;active-mixer-sessions> element has zero or more of the following child elements:


	<list style="hanging">
		<t hangText="<active-mix>: "> Describes a mixed active RTP session. 
		The &lt;active-mix> element has one attribute.  The value of the attribute 'conferenceid' is the name of the mix. 
		The &lt;active-mix> element has one child element.  The child element,
		&lt;rtp-codec>, contains the same information relating to RTP sessions as defined in
	     	<xref target="sec:active-rtp-sessions"/>.  The element MAY be present.</t>
	</list>
	</t>

</section>
<!--active-mixer-sessions -->

<section anchor="sec:non-active-rtp-sessions" title="&lt;non-active-rtp-sessions>">

	<t>The &lt;non-active-rtp-sessions> element provides information detailing the currently available inactive
	RTP sessions, that is, how many more RTP streams this MS can support.  The element MAY be present.</t>

	<t>The &lt;non-active-rtp-sessions> element has no attributes.</t>

	<t>The &lt;non-active-rtp-sessions> element has zero or more of the following child elements:

	<list style="hanging">

	<t hangText="<rtp-codec>: ">  Describes a supported codec and the number of non-active sessions for that codec. 
		The &lt;rtp-codec> element has one attribute.  The value of the attribute 'name' is a media type
     		(which can include parameters per <xref target="RFC6381"/>). The &lt;rtp-codec> element has two child
      		elements.  The child element, &lt;decoding>, has as content the decimal number of
    		RTP sessions available for decoding using the specified codec.  The child element, &lt;encoding>, has as content
		the decimal number of RTP sessions available for encoding using the specified codec.</t>

	</list>
	</t>

</section>
<!--non-active-rtp-sessions -->

<section anchor="sec:non-active-mixer-sessions" title="&lt;non-active-mixer-sessions>">

	<t>The &lt;non-active-mixer-sessions> element provides information detailing the current inactive
	mixed RTP sessions, that is, how many more mixing sessions this MS can support.  The element MAY be present.</t>

	<t>The &lt;non-active-mixer-sessions> element has no attributes.</t>

	<t>The &lt;non-active-mixer-sessions> element has zero of more of the following child element:


	<list style="hanging">
		<t hangText="<non-active-mix>: "> Describes available mixed RTP sessions. 
		The &lt;non-active-mix> element has one attribute.  The value of the attribute 'available' is the number
		of mixes that could be used using that profile.  The &lt;non-active-mix> element has one child element. 
		The child element, &lt;rtp-codec>, contains the same information relating to RTP sessions as defined in
	     	<xref target="sec:non-active-rtp-sessions"/>.  The element MAY be present.</t>
	</list>
	</t>

</section>
<!--non-active-mixer-sessions -->

<section anchor="sec:media-server-status" title="&lt;media-server-status>">

	<t>The &lt;media-server-status> element provides information detailing the current status of the media
	server.  The element MUST be present.  It can return one of the following values:
	
	<list style="hanging">
		<t hangText="active: "> Indicating that the Media Server is available for service.</t>
		<t hangText="deactivated: "> Indicating that the Media Server has been withdrawn from service,
		and as such requests should not be sent to it before it becomes 'active' again.</t>
		<t hangText="unavailable: "> Indicating that the Media Server continues to process past requests but
		cannot accept new requests, and as such should not be contacted before it becomes 'active' again.</t>
			
	</list>
</t>

	<t>The &lt;media-server-status> element has no attributes.</t>

	<t>The &lt;media-server-status> element has no child elements.</t>

</section>
<!--media-server-status -->

<section anchor="sec:supported-codecs" title="&lt;supported-codecs>">

	<t>The &lt;supported-codecs> element provides information detailing the current codecs
	supported by a media server and associated actions.  The element MAY be present.</t>

	<t>The &lt;supported-codecs> element has no attributes.</t>

	<t>The &lt;supported-codecs> element has zero or more of the following child element:


	<list style="hanging">
		<t hangText="<supported-codec>: "> has a single attribute, 'name', which provides the
		name of the codec about which this element provides information.  A valid value is a media type
		which, depending on its definition, can include
      		additional parameters (e.g., <xref target="RFC6381"/>). The &lt;supported-codec> element then has
		a further child element, &lt;supported-codec-package>.  The &lt;supported-codec-package>
		element has a single attribute, 'name', which provides the name of the Media Control Channel
		Framework package, compliant with the Section 13.1.1 of <xref target="RFC6230"/>,
		for which the codec support applies.  The &lt;supported-codec-package> 
		element has zero or more &lt;supported-action>  children, each one of which describes an action
       		that a Media Server can apply to this codec:
       	<list style="symbols">
       	<t>'decoding', meaning a decoder for this codec is available;</t>
       	<t>'encoding', meaning an encoder for this codec is available;</t>
       	<t>'passthrough', meaning the MS is able to pass a stream encoded using that codec through without re-encoding.</t>
       	</list></t>
	</list>
	</t>

</section>
<!--supported-codecs -->

<section anchor="sec:application-data" title="&lt;application-data>">

	<t>The &lt;application-data> element provides an arbitrary string of
    characters as application level data.  This data is meant to only
    have meaning at the application level logic and as such is not
    otherwise restricted by this specification.  The set of allowed
    characters are the same as those in XML (viz., tab, carriage
    return, line feed, and the legal characters of Unicode and ISO/IEC
    10646 [see http://www.w3.org/TR/xml/ section 2.2]).  The element MAY be present.</t>

	<t>The &lt;application-data> element has no attributes.</t>

	<t>The &lt;application-data> element has no child elements.</t>

</section>
<!--application-data -->

<section anchor="sec:file-formats" title="&lt;file-formats>">

	<t>The &lt;file-formats> element provides a list of file formats supported for the
	purpose of playing media.  The element MAY be present.</t>

	<t>The &lt;file-formats> element has no attributes.</t>

	<t>The &lt;file-formats> element has zero of more the following child elements:


	<list style="hanging">
		<t hangText="<supported-format>: "> has a single attribute, 'name', which provides the
		type of file format that is supported. A valid value is a media type
		which, depending on its definition, can include
      additional parameters (e.g., <xref target="RFC6381"/>). The &lt;supported-format> element then has
		a further child element, &lt;supported-file-package>.  The &lt;supported-file-package>
		element provides the name of the Media Control Channel
		Framework package, compliant with the Section 13.1.1 of <xref target="RFC6230"/>, for which the file format support applies.</t>
	</list>
	</t>

</section>
<!--file-formats -->

<section anchor="sec:max-prepared-duration" title="&lt;max-prepared-duration>">

	<t>The &lt;max-prepared-duration> element provides the maximum amount of time a media dialog
	will be kept in the preparted state before timing out before it is executed (see section
	4.4.2.2.6 of RFC 6231<xref target="RFC6231"/>.  The element MAY be present.</t>

	<t>The &lt;max-prepared-duration> element has no attributes.</t>

	<t>The &lt;max-prepared-duration> element has zero or more of the following child elements:


	<list style="hanging">
		<t hangText="<max-time>: "> has a single attribute, 'max-time-seconds', which provides the
		amount of time in seconds that a media dialog can be in the prepared state.  The &lt;max-time> element then has
		a further child element, &lt;max-time-package>.  The &lt;max-time-package>
		element provides the name of the Media Control Channel
		Framework package, compliant with the Section 13.1.1 of <xref target="RFC6230"/>, for which the time period applies.</t>
	</list>
	</t>

</section>
<!--max-prepared-duration -->


<section anchor="sec:dtmf-support" title="&lt;dtmf-support>">

	<t>The &lt;dtmf-support> element specifies the supported methods to detect DTMF tones and to generate them. 
	The element MAY be present.</t>

	<t>The &lt;dtmf-support> element has no attributes.</t>

	<t>The &lt;dtmf-support> element has zero of more of the following child elements:


	<list style="hanging">
		<t hangText="<detect>: ">Indicates the support for DTMF detection.
		The &lt;detect> element has no attributes.  The &lt;detect> element then has
		a further child element, &lt;dtmf-type>.  The &lt;dtmf-type>
		element has two attributes, 'name' and 'package.  The 'name' attribute provides the
		type of DTMF being used, and it can only be a case insensitive string containing
		either 'RFC4733' <xref target="RFC4733"/> or 'Media' (detecting tones as signals from the audio stream).
		The 'package' attribute provides the name of the Media Control Channel
		Framework package, compliant with the specification in the related IANA registry
		(e.g., "msc-ivr/1.0"), for which the DTMF type applies.</t>

		<t hangText="<generate>: ">Indicates the support for DTMF generation.
		The &lt;generate> element has no attributes.  The &lt;generate> element then has
		a further child element, &lt;dtmf-type>.  The &lt;dtmf-type>
		element has two attributes, 'name' and 'package.  The 'name' attribute provides the
		type of DTMF being used, and it can only be a case insensitive string containing
		either 'RFC4733' <xref target="RFC4733"/> or 'Media' (generating tones as signals in the audio stream).
		The 'package' attribute provides the name of the Media Control Channel
		Framework package, compliant with the specification in the related IANA registry
		(e.g., "msc-ivr/1.0"), for which the DTMF type applies.</t>

		<t hangText="<passthrough>: ">Indicates the support for passing DTMF through without re-encoding.
		The &lt;passthrough> element has no attributes.  The &lt;passthrough> element then has
		a further child element, &lt;dtmf-type>.  The &lt;dtmf-type>
		element has two attributes, 'name' and 'package.  The 'name' attribute provides the
		type of DTMF being used, and it can only be a case insensitive string containing
		either 'RFC4733' <xref target="RFC4733"/> or 'Media' (passing tones as signals through the audio stream).
		The 'package' attribute provides the name of the Media Control Channel
		Framework package, compliant with the specification in the related IANA registry
		(e.g., "msc-ivr/1.0"), for which the DTMF type applies.</t>
	
	</list>
	</t>

</section>
<!--dtmf-support -->

<section anchor="sec:mixing-modes" title="&lt;mixing-modes>">

	<t>The &lt;mixing-modes> element provides information about the support for audio
	and video mixing of a Media Server, specifically a list of supported algorithms
	to mix audio and a list of supported video presentation layouts. The element MAY be present.</t>

	<t>The &lt;mixing-modes> element has no attributes.</t>

	<t>The &lt;mixing-modes> element has zero or more of the following child elements:


	<list style="hanging">
	<t hangText="<audio-mixing-modes>: "> Describes the available algorithms for
	audio mixing. The &lt;audio-mixing-modes> element has no attributes. The
	&lt;audio-mixing-modes> element has one child element. The child element,
	&lt;audio-mixing-mode>, contains a specific available algorithm. Valid values
	for the &lt;audio-mixing-mode> element are algorithm names, e.g., 'nbest' and 'controller'
	as defined in <xref target="RFC6505"/>. The element has a single
	attribute, 'package'. The attribute 'package' provides the name of the Media
	Control Channel Framework package, compliant with the Section 13.1.1 of <xref target="RFC6230"/>, for which the algorithm support applies.</t>

	<t hangText="<video-mixing-modes>: "> Describes the available video
	presentation layouts and the supported functionality for what concerns video mixing.
	The &lt;video-mixing-modes> element has two attributes, 'vas' and 'activespeakermix'.
	The 'vas' attribute is of type boolean with a value of 'true' indicating the Media Server
	supports automatic Voice Activated Switching. The 'activespeakermix' is of type boolean
	with a value of 'true' indicating that the Media Server is able to prepare an
	additional video stream for the loudest speaker participant without its contribution.
	The &lt;video-mixing-modes> element has one child element.
	The child element, &lt;video-mixing-mode>, contains the name of a specific video presentation
	layout. The name may refer to one of predefined video layouts defined in the XCON
	conference information data model, or to non-XCON layouts as well, as long as they are properly prefixed
	according to the schema they belong to.
	The &lt;video-mixing-mode> element has a single attribute, 'package'. The attribute 'package' provides the
	name of the Media Control Channel Framework package, compliant with
	the specification in the related IANA registry (e.g., "msc-ivr/1.0"), for which the algorithm
	support applies.</t>

	</list>
	</t>

</section>
<!--mixing-modes -->

<section anchor="sec:supported-tones" title="&lt;supported-tones>">

	<t>The &lt;supported-tones> element provides information about which
	tones a media server supports. In particular, the support is reported
	referring to both country codes support (ISO 3166-1 <xref target="ISO.3166-1"/>) and supported
	functionality (ITU-T Recommendation Q.1950 <xref target="ITU-T.Q.1950"/>). The element MAY be present.</t>

	<t>The &lt;supported-tones> element has no attributes.</t>

	<t>The &lt;supported-tones> element has zero or more of the following child elements:


	<list style="hanging">
		<t hangText="<supported-country-codes>: "> Describes the supported
		country codes with respect to tones. The &lt;supported-country-codes>
		element has no attributes. The &lt;supported-country-codes> has one
		child element. The child element, &lt;country-code>, reports support
		for a specific country code, compliant with the ISO 3166-1 <xref target="ISO.3166-1"/>
		specification. The &lt;country-code> element has a single attribute,
		'package'. The attribute 'package' provides the name of the Media
		Control Channel Framework package, compliant with the Section 13.1.1 of <xref target="RFC6230"/>, in which the tones from the
		specified country code are supported.</t>

		<t hangText="<supported-h248-codes>: "> Describes the supported
		H.248 codes with respect to tones. The &lt;supported-h248-codes>
		element has no attributes. The &lt;supported-h248-codes> has one
		child element. The child element, &lt;h248-code>, reports support
		for a specific H.248 code, compliant with the ITU-T Recommendation Q.1950 <xref target="ITU-T.Q.1950"/>
		specification. The codes can be either specific (e.g., cg/dt to
		only report the Dial Tone from the Call Progress Tones package)
		or generic (e.g., cg/* to report all the tones from the Call Progress
		Tones package) using wild-cards. The &lt;h248-code> element has a
		single attribute, 'package'. The attribute 'package' provides
		the name of the Media Control Channel Framework package, compliant with the Section 13.1.1 of <xref target="RFC6230"/>, in which
		the specified codes are supported.</t>
	</list>
	</t>

</section>
<!--supported-tones -->

<section anchor="sec:file-transfer-modes" title="&lt;file-transfer-modes>">

	<t>The &lt;file-transfer-modes> element allows the Media Server to specify which scheme names are supported
	for transferring files to a Media Server for each Media Control Channel Framework package type. For example, whether the Media Server
	supports fetching resources via HTTP, HTTS, NFS, RTSP etc protocols.  The element MAY be present.</t>

	<t>The &lt;file-transfer-modes> element has no attributes.</t>

	<t>The &lt;file-transfer-modes> element has zero or more of the following child element:


	<list style="hanging">
		<t hangText="<file-transfer-mode>: ">has two attributes, 'name' and 'package'.  The 'name' attribute provides the
		scheme name of the protocol that can be used for file transfer (e.g., "HTTP", "RTSP", etc.): the value of the
		attribute is case insensitive. 	The 'package' attribute provides the name of the Media
		Control Channel Framework package, compliant with the specification in the related
		IANA registry (e.g., "msc-ivr/1.0"), for which the scheme name applies.</t>
	
	</list>
	</t>
	
	<t>It is important to point out that this element provides no information about whether or not the MS supports any
	flavour of live streaming: for instance, a value of "HTTP" for the IVR Package would only mean the 'http' scheme makes
	sense to the MS within the context of that package. Whether or not the MS can make use of HTTP to only fetch resources,
	or also to attach an HTTP live stream to a call, is to be considered implementation specific to the MS and unrelevant to the AS and/or MRB.
	Besides, the MS supporting a scheme does not imply it also supports the related secure versions: for instance, if the MS
	supports both "HTTP" and "HTTPS", both the schemes will appear in the element. A lack of the "HTTPS" value would need
	to be interpreted as a lack of support for the 'https' scheme.</t>

</section>
<!--file-transfer-modes -->

<section anchor="sec:asr-tts-support" title="&lt;asr-tts-support>">


	<t>The &lt;asr-tts-support> element provides information about the support for
	Automatic Speech Recognition (ASR) and Text-to-Speech (TTS) functionality
	in a media server. The functionality are reported by referring to the supported
	languages (using <xref target="ISO.639.1988">ISO-639-1</xref> codes) for what regards both ASR and TTS.
	The element MAY be present.</t>
	
	<t>The &lt;asr-tts-support> element has no attributes.</t>

	<t>The &lt;asr-tts-support> element has zero or more of the following child elements:
		
	<list style="hanging">	
		
	<t hangText="<asr-support>: "> Describes the available languages for ASR. The
	&lt;asr-support> element has no attributes. The &lt;asr-support> has one child element.
	The child element, &lt;language>, reports the MS supports ASR for a specific language.
	The &lt;language> element has a single attribute, 'xml:lang'. The attribute 'xml:lang'
	contains the <xref target="ISO.639.1988">ISO-639-1</xref> code of the supported language.</t>

	<t hangText="<tts-support>: "> Describes the available languages for TTS. The
	&lt;tts-support> element has no attributes. The &lt;tts-support> has one child element.
	The child element, &lt;language>, reports the MS supports tts for a specific language.
	The &lt;language> element has a single attribute, 'xml:lang'. The attribute 'xml:lang'
	contains the <xref target="ISO.639.1988">ISO-639-1</xref> code of the supported language.</t>

	</list>
	</t>

</section>
<!--asr-tts-support -->

<section anchor="sec:vxml-support" title="&lt;vxml-support>">

	<t>The &lt;vxml-support> element specifies if the Media Server supports VoiceXML and if it does which
	protocols the support is exposed through (e.g., via the control framework, RFC4240 <xref target="RFC4240"/>, or RFC5552 <xref target="RFC5552"/>). 
	The element MAY be present.</t>

	<t>The &lt;vxml-support> element has no attributes.</t>

	<t>The &lt;vxml-support> element has zero or more of the following child elements:


	<list style="hanging">
		<t hangText="<vxml-mode>: ">has two attributes, 'package' and 'support'.  The 'package' attribute
		provides the name of the Media Control Channel Framework package, compliant with the specification
		in the related IANA registry (e.g., "msc-ivr/1.0"), for which the VXML support
		applies.  The 'support' attribute provides the type of VXML support provided by the
		Media Server (e.g., RFC5552 <xref target="RFC5552"/>, RFC4240 <xref target="RFC4240"/> or IVR Package <xref target="RFC6231"/>),
		and valid values are case insensitive RFC references (e.g., "rfc6231" to specify the MS supports
		VoiceXML as provided by the IVR Package <xref target="RFC6231"/>).</t>
	
	</list>
	</t>
	
	<t>The presence of at least one &lt;vxml-mode> child element would indicate that the Media Server
	does support VXML as specified by the child element itself.  An empty &lt;vxml> element would otherwise indicate the Media Server does not support VXML at all.</t>

</section>
<!--vxml-support -->

<section anchor="sec:media-server-location" title="&lt;media-server-location>">

	<t>The &lt;media-server-location> element provides information about the civic
	location of a media server. Its description makes use of the Civic Address
	Schema standardized in <xref target="RFC5139">RFC 5139</xref>. The element MAY be present. More precisely,
	this section is entirely optional, and it's implementation specific to fill it with just the details each
	implementor deems necessary for any optimization that may be needed.</t>

	<t>The &lt;media-server-location> element has no attributes.</t>

	<t>The &lt;media-server-location> element has zero or more of the following child elements:

	<list style="hanging">
	<t hangText="<civicAddress>: "> Describes the civic
	address location of the media server, whose representation refers to the
	Section 4 of <xref target="RFC5139">RFC 5139</xref>.</t>
	
	</list>
	</t>

</section>
<!--media-server-location -->

<section anchor="sec:label" title="&lt;label>">

	<t>The &lt;label> element allows a Media Server to declare a piece of information that will be understood by the MRB. 
	For example, the Media Server can declare if it's a blue or green one.  It's a string to allow arbitrary values to be returned 
	to allow arbitrary classification.  The element MAY be present.</t>

	<t>The &lt;label> element has no attributes.</t>

	<t>The &lt;label> element has no child elements.</t>

</section>
<!--label -->

<section anchor="sec:media-server-address" title="&lt;media-server-address>">

	<t>The &lt;media-server-address> element allows a Media Server to provide
	a direct SIP URI address where it can be reached (e.g., the URI AS would
	call to in order to set-up a Control Channel and relay SIP media dialogs). 
	The element MAY be present.</t>

	<t>The &lt;media-server-address> element has a single attribute.</t>

	<t>The &lt;media-server-address> element has no child elements.</t>

</section>
<!--media-server-address -->

<section anchor="sec:encryption" title="&lt;encryption>">

	<t>The &lt;encryption> element allows a Media Server to declare support for encrypting RTP media streams
	using <xref target="RFC3711">RFC 3711</xref>.  The element MAY be present.</t>

	<t>The &lt;encryption> element has no attributes.</t>

	<t>The &lt;encryption> element has zero or more of the following child elements:

	<list style="hanging">
		<t hangText="<keying-mechanism>: ">has no attributes.  The element provides the name of
		a keying mechanism the MS supports for encrypting RTP media streams.</t>
	
	</list>
	</t>
	
	<t>The presence of at least one &lt;keying-mechanism> child element would indicate that the Media Server
	does support RTP media stream encryption as specified by the child element itself.
	An empty &lt;encryption> element would otherwise indicate the Media Server does not support RTP encryption at all.</t>


</section>
<!--encryption -->

</section>
<!-- mrbnotification -->

</section>

<!-- Media Server Publish Interface -->

	<section anchor="sec:Res_Cons" title="Media Service Resource Consumer Interface">		
     
		<t>The Media Server Consumer interface provides the ability for clients of an MRB, 
		such as Application Servers, to request an appropriate Media Server to satisfy
		specific criteria.  The interface allows a client to pass detailed meta-information 
		to the MRB to help select an appropriate Media Server.  The MRB is then able to make 
	       	an informed decision and provide the client with an appropriate media server 
		resource.  The MRB Consumer interface includes both 1) In-Line Aware MRB Mode
		(IAMM) that uses the Session Initiation Protocol (SIP) and 2) Query mode that uses
		the Hypertext Transfer Protocol (HTTP)
		<xref target="RFC2616"/>.  The MRB Consumer interface does not include In-Line Unaware Mode
	      	(IUMM) which is further explained in <xref target="sec:In_Line"/>.  The following subsections provide guidance on
		using the Consumer interface, which is represented by the 'application/mrb-consumer+xml media
		type in <xref target="sec:consumer_xml"/>, with HTTP and SIP.</t>

	<section anchor="sec:http_Consumer" title="Query Mode / HTTP Consumer Interface Usage">

		<t>An appropriate interface for such a 'query' style interface is
		in fact a HTTP usage.  Using HTTP and XML combined reduces complexity
		and encourages use of common tools that are widely available in the industry today.
		The following information explains the primary operations required to request and then
		receive information from an MRB, by making use of
		HTTP <xref target="RFC2616"/> and HTTPS <xref target="RFC2818"/> as
		transport for a query for media resource and the appropriate response.</t>

		<t>The media resource query, as defined by the &lt;mediaResourceRequest> element from
	       	<xref target="sec:consumer_xml"/>, MUST be carried in the body of an HTTP/HTTPS
		POST request.  The media type contained in the HTTP/HTTPS
		request/response MUST be 'application/mrb-consumer+xml'.  This value MUST
		be reflected in the appropriate HTTP headers like 'Content-Type' and
		'Accept'.  The body of the HTTP/HTTPS POST request MUST only contain a &lt;mrbconsumer> root element with only one child
		&lt;mediaResourceRequest> element as defined 
		in <xref target="sec:consumer_xml"/>.</t>

		<t>The media resource response to a query, as defined by the &lt;mediaResourceResponse> element from
	       	<xref target="sec:consumer_xml"/>, MUST be carried in the body of an HTTP/HTTPS
		200 response to the original HTTP/HTTPS POST request.  The media type contained in the HTTP/HTTPS
		request/response MUST be 'application/mrb-consumer+xml'.  This value MUST
		be reflected in the appropriate HTTP headers like 'Content-Type' and
		'Accept'.  The body of the HTTP/HTTPS 200 response MUST only contain
		 a &lt;mrbconsumer> root element with only one child
		&lt;mediaResourceResponse> element as defined 
		in <xref target="sec:consumer_xml"/>.</t>

		<t>When an application server wants to release previously awarded media resources granted through a
		prior request/response exchange with MRB, it will send a new request with an &lt;action> element with value
		'remove' as described in <xref target="sec:lease"/> about the use of the Consumer interface
		lease mechanism.</t>

		</section>

		<!-- HTTP Consumer Interface Usage -->
		
		<section anchor="sec:sip_Consumer" title="In-Line Aware Mode / SIP Consumer Interface Usage">
			

		<t>This document provides a complete tool-kit for MRB deployment which includes the ability
		to interact with an MRB using SIP for the Consumer interface.
		The following information explains the primary operations required to request and then
		receive information from an MRB, by making use of
		SIP <xref target="RFC3261"/> as transport for a request for media resources and the appropriate
		response when used with IAMM of operation (as discussed in <xref target="sec:IAMM_CFW"/>).</t>

		<t>Use of IAMM, besides having the MRB select appropriate media resources on behalf of a client
		application, includes setting up either a Control Framework control channel  between an application
		server and one of the media servers (<xref target="sec:IAMM_CFW"/>) or a media dialog session between an application
		server and one of the media servers (<xref target="sec:IAMM_CALL_LEG"/>). Note that in either case the SIP addresses of the selected
		media servers are made known to the requesting application server in the SIP 200 OK response by means of one
		or more &lt;media-server-address> child elements in the  &lt;response-session-info> element (<xref target="sec:Media_Response"/>).</t>


		<section anchor="sec:IAMM_CFW" title="IAMM and Setting up a Control Framework Control Channel">

		<t>The media resource request information, as defined by the &lt;mediaResourceRequest> element from
		<xref target="sec:consumer_xml"/>, is carried in a SIP INVITE request.  The INVITE
		request will be constructed as it would have been to connect to a media server, as
		defined by the Media Control
		Channel Framework <xref target="RFC6230"/>.  The following
		additional steps MUST be followed when using the Consumer interface:	

	
		<list style="symbols">
			<t>The Consumer Client will Include a payload in the SIP INVITE request of type
			'multipart/mixed' <xref target="RFC2046"/>.  One of the parts to be included
			in the 'multipart/mixed' payload MUST be the 'application/sdp' format which is constructed as
			specified in the Media Control Channel
			Framework <xref target="RFC6230"/>. </t>
			<t> Another part of the 'multipart/mixed' payload MUST be of type
			'application/mrb-consumer+xml', as specified in this document and defined in
			<xref target="sec:consumer_xml"/>.  The body part MUST be an XML document without prolog and whose
			root element is &lt;mediaResourceRequest>.</t>
			<t> The INVITE request will then be dispatched to the MRB, as defined
			by <xref target="RFC6230"/>.</t>
		</list>
	</t>

	<t>On receiving a SIP INVITE request containing the multipart/mixed payload as specified previously, the MRB
	will complete a number of steps to fulfill the request. It will:

		<list style="symbols">
			<t>Extract the multipart MIME payload from the SIP INVITE request. It will then use the contextual
			information provided by the client in the 'application/mrb-consumer+xml' part to determine which
			media server (or media servers, if more than one is deemed to be needed) should be selected to service the request.</t>

			<t>Extract the 'application/sdp' part from the payload and use it as the body of a new SIP INVITE
			request for connecting the client to one of the selected media servers, as defined in the Media Channel
			Control Framework <xref target="RFC6230"/>. The policy the MRB follows to pick a specific MS out
			of the MSs it selects is implementation specific, and out of scope to this document. It is important to 
			configure the SIP elements between the MRB and the MS in such a way that 
			that the INVITE will not fork.  In case of a failure in reaching
			the chosen MS, the MRB SHOULD proceed to the next one, if available.</t>
	</list>
	</t>

	<t>If none of the available MS can be reached, the MRB MUST reply with a SIP 503 error message including a
	Retry-After header with a non-zero value.  The AS MUST NOT attempt to setup a new session
	before the time the MRB asked it to wait has passed.</t>
	
	<t>In case at least one MS is reachable, the MRB acts as a Back-to-Back UA (B2BUA) that
	extracts the 'application/mrb-consumer+xml' information from the SIP INVITE request and then
	sends a corresponding SIP INVITE request to the MS it has selected, to negotiate a control channel
	as defined in the Media Channel Control Framework <xref target="RFC6230"/>.</t>

	<t>In case of a failure in negotiating the control channel with the MS, the MRB SHOULD proceed to the next one,
	if available, as explained above. If none of the available MS can be reached, or the negotiation of the control
	channel with all of them fails, the MRB MUST reply with a SIP 503 error message including a
	Retry-After header with a non-zero value. The AS MUST NOT attempt to setup a new session
	before the time the MRB asked it to wait has passed.</t>
	
	<t>Once the MRB receives the SIP response from the selected media resource (i.e., media server), it will in turn
	respond to the requesting client (i.e., application server).</t>

		<t>The media resource response by MRB to a request, as defined by the &lt;mediaResourceResponse> element from
	       	<xref target="sec:consumer_xml"/>, MUST be carried in the payload of a SIP
		200 response to the original SIP INVITE request.  The 200
		response will be constructed as it would have been to connect from a media server, as
		defined by the Media Control
		Channel Framework <xref target="RFC6230"/>.  The following
		additional steps MUST be followed when using the Consumer interface:

		<list style="symbols">
			<t>Include a payload in the SIP 200 response of type
			'multipart/mixed' as per <xref target="RFC2046">RFC 2046</xref>.  One of the parts to be included
			in the 'multipart/mixed' payload MUST be the 'application/sdp' format which is constructed as
			specified in the Media Control Channel
			Framework <xref target="RFC6230"/> and based on the incoming response from the selected Media Resource.</t>
			<t> Another part of the 'multipart/mixed' payload MUST be of type
			'application/mrb-consumer+xml', as specified in this document and defined in
			<xref target="sec:consumer_xml"/>.  Only the &lt;mediaResourceResponse> and its child
			elements can be included in the payload.</t>
			<t> The SIP 200 response will then be dispatched from the MRB.</t>
			<t>A SIP ACK to the 200 response will then be sent back to the MRB.</t>
		</list>
	</t>

	<t>Considering that the use of SIP as a transport for Consumer transactions may result in a packet loss,
	the IAMM relies on a successful INVITE transaction to address the seq increment mechanism. This means that,
	if the INVITE is unsuccessful for any reason, the AS MUST use the same seq value as before for the next
	Consumer request it may want to send to the MRB for the same session.</t>
	
	<t>An MRB implementation may be programmed to conclude that the requested resources are no longer needed when
	it receives a SIP BYE from the application server or media server that concludes the SIP dialog that initiated
	the request, or when the lease interval expires.</t>
</section>

	<section anchor="sec:IAMM_CALL_LEG" title="IAMM and Setting up a Media Dialog">
	
		<t>This scenario is identical to the description in the prior section for setting up a Control Framework
		control channel, except for the difference that the application/sdp payload conveys content appropriate
		for setting up the media dialog to the media resource, as per <xref target="RFC3261">RFC 3261</xref>, instead of application/sdp payload
		for setting up a control channel.</t>


	</section>
	<!-- HTTP Consumer Interface Usage -->

</section>

		<!-- SIP Consumer Interface Usage -->

		<section anchor="sec:lease" title="Consumer Interface Lease Mechanism">
			
			<t>The Consumer interface defined in <xref target="sec:Res_Cons"/>
			and <xref target="sec:consumer_xml"/> allows a client to request an appropriate
			media resource based on information included in the request (either a HTTP POST
			or SIP INVITE message).  In case of success, the response that is returned to the client MUST contain
			a &lt;response-session-info> element in either the SIP 200 or HTTP 200 response.
			The success response contains the description of certain
		   resources that have been reserved to a specific Consumer client in a (new
		   or revised) &quot;resource session&quot;, which is identified in the
		   &lt;response-session-info>.  The resource session is a &quot;lease&quot;, in
		   that the reservation is scheduled to expire at a particular time in
		   the future, releasing the resources to be assigned for other uses.
		   The lease may be extended or terminated earlier by future Consumer
		   client requests that identify and reference a specific resource session.</t>

			<t>Before delving into the details of such lease mechanism, though, it's worthwhile
			to first clarify its role within the context of the Consumer interface. As
			explained in <xref target="sec:MS_Pub"/>, the knowledge the MRB has of the resources
			of all the MSs it handles is imperfect. As such, how an MRB actually manages such
			resources depends on how it is implemented: one may choose to have the MRB keeping
			track and state of the allocated resources, or simply depend on the MSs themselves
			to provide the information by means of the publishing interface notifications.
			Further information may be inferred by the signalling, in case the MRB is in
			the path of media dialogs.</t>

			<t>That said, the &lt;mediaResourceResponse> element returned from the MRB contains a &lt;response-session-info>
			element if the request is successful.  The &lt;response-session-info> element has zero or more of
			the following child elements which provide the appropriate resource session information:

			<list style="symbols">

			<t>&lt;session-id> is a unique identifier that enables a Consumer client and MRB to
			correlate future media resource requests related to an initial media resource request. 
			The &lt;session-id> MUST be included in all future related requests (see &lt;session-id>
			use later in this section when constructing a subsequent request).</t>
		
			<t>&lt;seq> is a numeric value returned to the Consumer client.  On issuing any
			future requests related to the media resource session (as determined by the
			&lt;session-id> element) the consumer client MUST increment the value returned in the
			&lt;seq> element and include in the request (see &lt;seq>
			use later in this section when constructing a subsequent request).</t>
		
			<t>&lt;expires> provides a value which provides the number of seconds the
			request for media resources is deemed alive.  The Consumer client should issue a refresh
			of the request, as discussed later in this section, if the expires timer is due to fire
			and the media resources are still required.</t>
		
			<t>&lt;media-server-address> provides information representing an assigned MS. More instances
			of this element may appear, should the MRB assign more MSs to a Consumer request.
			</t>
	
			</list>

			</t>	
				
			<t>The &lt;mediaResourceRequest> element is used in subsequent Consumer interface
			requests if the client wishes to manipulate the session.  The Consumer client
			MUST include the  &lt;session-info> element which enables the receiving MRB
			to determine an existing media resource allocation session.  The &lt;session-info>
			element has the following child elements which provide the appropriate resource session
			information to the MRB:

			<list style="symbols">
			<t>&lt;session-id> is a unique identifier that allows a Consumer client to indicate the
			appropriate existing media resource session to be manipulated by the MRB for this request.  The
			value was provided by the MRB in the initial request for media resources, as discussed
			earlier in this section (&lt;session-id> element included as part of the &lt;session-info>
			element in the initial &lt;mediaResourceResponse>).</t>
			<t>&lt;seq> is a numeric value returned to Consumer client in the initial request for
			media resources, as discussed earlier in this section (&lt;seq> element included as
			part of the &lt;session-info> element in the initial &lt;mediaResourceResponse>).  On issuing any
			future requests related to the specific media resource session (as determined by the
			&lt;session-id> element) the consumer client MUST increment the value returned in the
			&lt;seq> element from the initial response (contained in the &lt;mediaResourceResponse>) for
			every new request.  The value of the &lt;seq> element in requests acts as a counter to
			and in conjunction with the unique &lt;session-id> allows for unique identification of a request.
			The first numeric value for the &lt;seq> element is not meant to be '1', but SHOULD be generated
			randomly by the MRB: this is to reduce the chances a malicious MRB disrupts the session created by this MRB,
			as explained in <xref target="sec:security"/>.
			</t>
			<t>&lt;action> element provides the operation to be carried out by the MRB on receiving the request:
				<list style="symbols">
				<t>The value of 'update' is a request by the Consumer client to update the existing session at the MRB
				with alternate requirements which are contained in the remainder of the request.  If the requested
				resource information is identical to the existing MRB session, the MRB will attempt a session refresh. 
				If the information has changed, the MRB
				will attempt to update the existing session with the new information.  If the operation is successful, the
				200 status code in the response is returned in the status attribute of the &lt;mediaResourceResponseType> element. 
				If the operation is not successful, a 409 status code in the response is
				returned in the status attribute of the &lt;mediaResourceResponseType> element.</t>
				<t>The value of 'remove' is a request by the Consumer client to remove
				the session at the MRB.  This provides a mechanism for Consumer clients to release unwanted
				resources before they expire.  If the operation is successful, a
				200 status code in the response is returned in the status attribute of the &lt;mediaResourceResponseType> element. 
				If the operation is not successful, a 410 status code in the response is returned in the status attribute of
				the &lt;mediaResourceResponseType> element.</t>
				</list>
			</t>
			</list>
			</t>
			
			<t>Omitting the 'action' attribute means requesting a new set of resources.</t>
				
			<t>
			When used with HTTP the &lt;session-info> element MUST be included in a HTTP POST
			message (as defined in <xref target="RFC2616"/>).
			When used with SIP, instead, the &lt;session-info> element MUST be included in either a SIP INVITE, or a
			SIP re-INVITE (as defined in <xref target="RFC3261"/>) or a SIP UPDATE (as defined in<xref target="RFC3311"/>) request:
			in fact, any SIP dialog, be it a new or an existing one, can be exploited to carry leasing information,
			and as such new SIP INVITE messages can update other leases as well as requesting a new one.
			</t>

			<t>With IAMM, the application server or media server will eventually
			send a SIP BYE to end the SIP session, whether it was for a
			control channel or a media dialog.  That BYE contains no Consumer
			interface lease information.</t>

		</section>

		<!-- Consumer Interface Lease Mechanism -->
	

	<section anchor="sec:mrbconsumer" title="<mrbconsumer>">

	<t>This section defines the XML elements for the Consumer interface.  The formal XML schema definition
	for the Consumer interface can be found in <xref target="sec:consumer_xml"/>.</t>

	<t>The root element is &lt;mrbconsumer>.  All other XML elements (requests, responses) are
	contained within it.  The MRB Consumer interface request element is detailed in <xref target="sec:mediaResourceRequest"/>. 
	MRB Consumer interface response element is contained in <xref target="sec:mediaResourceResponse"/>.</t>

	<t>The &lt;mrbconsumer> element has the following attributes:

	<list style="hanging">
	<t hangText="version: "> a token specifying the mrb-consumer package version.  The value
      	is fixed as '1.0' for this version of the package.  The attribute
      	MUST be present.</t>
	</list>
	</t>

	<t>The &lt;mrbconsumer> element may have zero or more children of one of
   the following child element types:

	<list style="hanging">
		<t>&lt;mediaResourceRequest> for sending a Consumer request.  See <xref target="sec:mediaResourceRequest"/>.</t>
		<t>&lt;mediaResourceResponse> for sending a Consumer response.  See <xref target="sec:mediaResourceResponse"/>.</t>
	</list>
	</t>
	
	</section>
	<section anchor="sec:Media_Request" title="Media Service Resource Request">

	<t>This section provides the element definitions for use in Consumer
   interface requests.  The requests are carried in the
   &lt;mediaResourceRequest> element.</t>
   
	<section anchor="sec:mediaResourceRequest" title="<mediaResourceRequest> element">

		<t>The &lt;mediaResourceRequest> element provides information for clients
		wishing to query an external MRB entity.  The &lt;mediaResourceRequest> element has
		a single mandatory attribute, 'id': this attribute contains a random identifier, generated
		by the client, which will be included in the response in order to map it to a specific
		request.  The &lt;mediaResourceRequest> element has
		&lt;generalInfo>, &lt;ivrInfo> and &lt;mixerInfo> as
		child elements.  These three elements are used to describe the requirements of a
		client requesting a Media Server and are covered in the following sub-sections.</t>


	<section anchor="sec:requestGeneral" title="<generalInfo> element">
		<t>The &lt;generalInfo> element provides a information for general Consumer request information
		that is neither IVR or Mixer specific.  This includes session information that can be used for
		subsequent requests as part of the leasing mechanism described in <xref target="sec:lease"/>. 
		The following sub-sections describe the elements of the &lt;generalInfo> element,
		&lt;session-info> and &lt;packages>.</t>


		<section anchor="sec:session-info" title="<session-info> element">

		<t>The &lt;session-info> element is included in Consumer requests when an update is being made
		to an existing media resource session.  The ability to change and remove an existing media resource
		session is described in more detail in <xref target="sec:lease"/>.  The element MAY be present.</t>

		<t>The &lt;session-info> element has no attributes.</t>

		<t>The &lt;session-info> element has zero or more of the following child elements:


		<list style="hanging">
		<t hangText="<session-id>: "> is a unique identifier that explicitly references an existing media
		resource session on the MRB.  The identifier is included to update the existing session and is
		described in more detail in <xref target="sec:lease"/>.</t>
		<t hangText="<seq>: "> is used in association with the &lt;session-id> element in a subsequent
		request to update an existing media resource session on an MRB.  The &lt;seq> number is incremented
		from its original value returned in response to the initial request for media resources.  More information
		about its use is provided in <xref target="sec:lease"/>.</t>
		<t hangText="<action>: "> provides the operation that should be carried out on an existing media
		resource session on an MRB:
		<list style="symbols">
		<t>The value of 'update' instructs the MRB to attempt to update the
		existing media resource session with the information contained in the &lt;ivrInfo> and &lt;mixerInfo>
		elements.</t>
		<t>The value of 'remove' instructs the MRB to attempt to remove the existing
		media resource session.  More information on its use is provided in <xref target="sec:lease"/>.</t>
		</list></t>
		</list>
		</t>
		</section>

		<section anchor="sec:packages" title="<packages> element">

		<t>The &lt;packages> element provides a list of Media Control Channel Framework compliant
		packages that are required by the Consumer client.  The element MAY be present.</t>

		<t>The &lt;packages> element has no attributes.</t>

		<t>The &lt;packages> element has zero or more of the following child element:


		<list style="hanging">
			<t hangText="<package>: "> child element contains a string representing the Media Control
			Channel Framework package required by the Consumer client.  The &lt;package> element
			can appear multiple times. A valid value is a Control Package name as specified
			in the related IANA registry (e.g., "msc-ivr/1.0")</t>
		</list>
		</t>
		</section>

	</section>
	
	<!-- generalInfo -->
	
	<section anchor="sec:requestivrInfo" title="<ivrInfo> element">

		<t>The &lt;ivrInfo> element provides information for general Consumer request information
		that is IVR specific.  The following sub-sections describe the elements of the &lt;ivrInfo>
		element, &lt;ivr-sessions>, &lt;file-formats>,
		&lt;dtmf>, &lt;tones>, &lt;asr-tts>, &lt;vxml>, &lt;location>, &lt;encryption>,
	       	&lt;application-data>, &lt;max-prepared-duration> and &lt;stream-mode>.</t>

	<section anchor="sec:ivr-sessions" title="<ivr-sessions> element">

		<t>The &lt;ivr-sessions> element indicates the number of IVR sessions a Consumer
		client requires from a media resource.  The element MAY be present.</t>

		<t>The &lt;ivr-sessions> element has no attributes.</t>

		<t>The &lt;ivr-sessions> element has zero or more of the following child element:


		<list style="hanging">

		<t hangText="<rtp-codec>: ">  Describes a required codec and the number of sessions using that codec. 
		The &lt;rtp-codec> element has one attribute.  The value of the attribute 'name' is a media type
     		(which can include parameters per <xref target="RFC6381"/>). The &lt;rtp-codec> element has two child
      		element.  The child element, &lt;decoding>, has as content the decimal number of
    		RTP sessions required for decoding using the specified codec.  The child element, &lt;encoding>, has as content
		the decimal number of RTP sessions required for encoding using the specified codec.</t>

		</list>
		</t>
	</section>

	<!--ivr-sessions -->

	<section anchor="sec:file-formats_consumer" title="<file-formats> element">

		<t>The &lt;file-formats> element provides a list of file formats required for the
		purpose of playing media.  It should be noted that this element describes media types, and might
		better have been named "media-format" but the name "file-format" is being used due to existing
		implementations  The element MAY be present.</t>

		<t>The &lt;file-formats> element has no attributes.</t>

		<t>The &lt;file-formats> element has zero or more of the following child element:


		<list style="hanging">
		<t hangText="<required-format>: "> has a single attribute, 'name', which provides the
		type of file format that is required.  A valid value is a media type
		which, depending on its definition, can include
      		additional parameters (e.g., <xref target="RFC6381"/>). The &lt;required-format> element then has
		a further child element, &lt;required-file-package>.  The &lt;required-file-package>
		element has a single attribute, 'required-file-package-name', which contains the name of the Media Control Channel
		Framework package, compliant with the Section 13.1.1 of <xref target="RFC6230"/>, for which the file format support applies.</t>
		</list>
		</t>
	</section>

	<!--file-formats -->


	<section anchor="sec:dtmf" title="<dtmf> element">

		<t>The &lt;dtmf> element specifies the required methods to detect DTMF tones and to generate them. 
		The element MAY be present.</t>

		<t>The &lt;dtmf> element has no attributes.</t>

		<t>The &lt;dtmf> element has zero or more of the following child elements:


		<list style="hanging">
		<t hangText="<detect>: ">Indicates the required support for DTMF detection.
		The &lt;detect> element has no attributes.  The &lt;detect> element then has
		a further child element, &lt;dtmf-type>.  The &lt;dtmf-type>
		element has two attributes, 'name' and 'package.  The 'name' attribute provides the
		type of DTMF being needed, and it can only be a case insensitive string containing
		 either 'RFC4733' <xref target="RFC4733"/> or 'Media' (detecting tones as signals from the audio stream).
		The 'package' attribute provides the name of the Media Control Channel
		Framework package, compliant with the specification in the related IANA registry
		(e.g., "msc-ivr/1.0"), for which the DTMF type applies.</t>

		<t hangText="<generate>: ">Indicates the required support for DTMF generation.
		The &lt;generate> element has no attributes.  The &lt;generate> element then has
		a further child element, &lt;dtmf-type>.  The &lt;dtmf-type>
		element has two attributes, 'name' and 'package.  The 'name' attribute provides the
		type of DTMF being needed, and it can only be a case insensitive string containing
		either 'RFC4733' <xref target="RFC4733"/> or 'Media' (generating tones as signals in the audio stream).
		The 'package' attribute provides the name of the Media Control Channel
		Framework package, compliant with the specification in the related IANA registry
		(e.g., "msc-ivr/1.0"), for which the DTMF type applies.</t>

		<t hangText="<passthrough>: ">Indicates the required support for passing DTMF through without re-encoding.
		The &lt;passthrough> element has no attributes.  The &lt;passthrough> element then has
		a further child element, &lt;dtmf-type>.  The &lt;dtmf-type>
		element has two attributes, 'name' and 'package.  The 'name' attribute provides the
		type of DTMF being needed, and it can only be a case insensitive string containing
		either 'RFC4733' <xref target="RFC4733"/> or 'Media' (passing tones as signals through the audio stream).
		The 'package' attribute provides the name of the Media Control Channel
		Framework package, compliant with the specification in the related IANA registry
		(e.g., "msc-ivr/1.0"), for which the DTMF type applies.</t>
	
		</list>
		</t>
	</section>

	<!--DTMF -->

	<section anchor="sec:tones" title="&lt;tones>">


	<t>The &lt;tones> element provides requested
	tones a media server must support for IVR. In particular, the request refers
	to both country codes support (ISO 3166-1 <xref target="ISO.3166-1"/>) and requested
	functionality (ITU-T Recommendation Q.1950 <xref target="ITU-T.Q.1950"/>). The element MAY be present.</t>

	<t>The &lt;tones> element has no attributes.</t>

	<t>The &lt;tones> element has zero or more of the following child elements:

	<list style="hanging">
		<t hangText="<country-codes>: "> Describes the requested
		country codes with respect to tones. The &lt;country-codes>
		element has no attributes. The &lt;country-codes> has one
		child element. The child element, &lt;country-code>, requests
		a specific country code, compliant with the ISO 3166-1 <xref target="ISO.3166-1"/>
		specification. The &lt;country-code> element has a single attribute,
		'package'. The attribute 'package' provides the name of the Media
		Control Channel Framework package, compliant with the specification in the related IANA
		registry (e.g., "msc-ivr/1.0"), in which the tones from the specified country code are
		requested.</t>

		<t hangText="<h248-codes>: "> Describes the requested
		H.248 codes with respect to tones. The &lt;h248-codes>
		element has no attributes. The &lt;h248-codes> has one
		child element. The child element, &lt;h248-code>, requests
		a specific H.248 code, compliant with the ITU-T Recommendation Q.1950 <xref target="ITU-T.Q.1950"/>
		specification. The codes can be either specific (e.g., cg/dt to
		only report the Dial Tone from the Call Progress Tones package)
		or generic (e.g., cg/* to report all the tones from the Call Progress
		Tones package) using wild-cards. The &lt;h248-code> element has a
		single attribute, 'package'. The attribute 'package' provides
		the name of the Media Control Channel Framework package, compliant with the specification
		in the related IANA registry (e.g., "msc-ivr/1.0"), in which the specified codes are
		requested.</t>
	</list>
	</t>

	</section>
	
	<!--tones -->

	<section anchor="sec:asr-tts" title="&lt;asr-tts>">

	<t>The &lt;asr-tts> element requests information about the support for
	Automatic Speech Recognition (ASR) and Text-to-Speech (TTS) functionality
	in a media server. The functionality is requested by referring to the supported
	languages (using <xref target="ISO.639.1988">ISO-639-1</xref> codes) for what regards both ASR and TTS.

	The &lt;asr-tts> element has no attributes.

	The &lt;asr-tts> element has zero or more of the following child elements:
		
		
	<list style="hanging">	
		
	<t hangText="<asr-support>: "> Describes the available languages for ASR. The
	&lt;asr-support> element has no attributes. The &lt;asr-support> has one child element.
	The child element, &lt;language>, requests the MS supports ASR for a specific language.
	The &lt;language> element has a single attribute, 'xml:lang'. The attribute 'xml:lang'
	contains the <xref target="ISO.639.1988">ISO-639-1</xref> code of the supported language.</t>

	<t hangText="<tts-support>: "> Describes the available languages for TTS. The
	&lt;tts-support> element has no attributes. The &lt;tts-support> has one child element.
	The child element, &lt;language>, requests the MS supports tts for a specific language.
	The &lt;language> element has a single attribute, 'xml:lang'. The attribute 'xml:lang'
	contains the <xref target="ISO.639.1988">ISO-639-1</xref> code of the supported language.</t>

	</list>
	</t>

	</section>
	
	<!--asr-tts -->


	<section anchor="sec:vxml" title="<vxml> element">

		<t>The &lt;vxml> element specifies if the Consumer client required VoiceXML and if it does which
		protocols the support is exposed through (e.g., via the control framework,
		RFC4240 <xref target="RFC4240"/>, or RFC5552 <xref target="RFC5552"/>). 
		The element MAY be present.</t>

		<t>The &lt;vxml> element has zero or more of the following child elements:


		<list style="hanging">
		<t hangText="<vxml-mode>: ">has two attributes, 'package' and 'require'.  The 'package' attribute
		provides the name of the Media Control Channel Framework package, compliant with the Section 13.1.1 of <xref target="RFC6230"/>, for which the VXML support
		applies.  The 'require' attribute specifies the type of VXML support required by the
		Consumer client (e.g., RFC5552 <xref target="RFC5552"/>, RFC4240 <xref target="RFC4240"/> or IVR Package <xref target="RFC6231"/>),
		and valid values are case insensitive RFC references (e.g., "rfc6231" to specify the Client requests support for
		VoiceXML as provided by the IVR Package <xref target="RFC6231"/>).</t>
	
		</list>
		</t>
		
		<t>The presence of at least one &lt;vxml> child element would indicate that the Consumer client requires VXML support
		as specified by the child element itself.  An empty &lt;vxml> element would otherwise indicate the Consumer client does not require VXML support.</t>

	</section>

	<!--vxml -->

	<section anchor="sec:location" title="&lt;location>">

	<t>The &lt;location> element requests a civic
	location for an IVR media server.  The request makes use of the Civic Address
	Schema standardized in <xref target="RFC5139">RFC 5139</xref>. The element MAY be present.  More precisely,
	this section is entirely optional, and it's implementation specific to fill it with just the details each
	implementor deems necessary for any optimization that may be needed.</t>

	<t>The &lt;location> element has no attributes.</t>

	<t>The &lt;location> element has a single child element:

	<list style="hanging">
	<t hangText="<civicAddress>: "> Describes the civic
	address location of the requested media server, whose representation refers to
	Section 4 of <xref target="RFC5139">RFC 5139</xref>.</t>
	
	</list>
	</t>
	</section>

	<!--location -->

	<section anchor="sec:encryption_consumer" title="&lt;encryption>">

	<t>The &lt;encryption> element allows a Consumer client to request support for encrypting RTP media streams
	using <xref target="RFC3711">RFC 3711</xref>.  The element MAY be present.</t>

	<t>The &lt;encryption> element has no attributes.</t>

	<t>The &lt;encryption> element has zero or more of the following child elements:

	<list style="hanging">
		<t hangText="<keying-mechanism>: ">has no attributes.  The element provides the name of
		a keying mechanism the Client requires for encrypting RTP media streams.</t>
	
	</list>
	</t>
	
	<t>The presence of at least one &lt;keying-mechanism> child element would indicate that the Consumer client
	does request RTP media stream encryption as specified by the child element itself.
	An empty &lt;encryption> element would otherwise indicate the Consumer client does not require RTP encryption at all.</t>


	</section>
	
	<!--encryption -->

	<section anchor="sec:application-data_consumer" title="&lt;application-data>">

	<t>The &lt;application-data> element provides an arbitrary string of
    characters as IVR application level data.  This data is meant to only
    have meaning at the application level logic and as such is not
    otherwise restricted by this specification.  The set of allowed
    characters are the same as those in XML (viz., tab, carriage
    return, line feed, and the legal characters of Unicode and ISO/IEC
    10646 [see http://www.w3.org/TR/xml/ section 2.2]).  The element MAY be present.</t>

	<t>The &lt;application-data> element has no attributes.</t>

	<t>The &lt;application-data> element has no child elements.</t>

	</section>

	<!--application-data -->

	<section anchor="sec:max-prepared-duration_consumer" title="&lt;max-prepared-duration>">

	<t>The &lt;max-prepared-duration> element provides the amount of time required by the Consumer client
	that a media dialog can be prepared in the system before it is executed.  The element MAY be present.</t>

	<t>The &lt;max-prepared-duration> element has no attributes.</t>

	<t>The &lt;max-prepared-duration> element has a single child element:


	<list style="hanging">
		<t hangText="<max-time>: "> has a single attribute, 'max-time-seconds', which provides the
		amount of time in seconds that a media dialog can be in the prepared state.  The &lt;max-time> element then has
		a further child element, &lt;max-time-package>.  The &lt;max-time-package>
		element provides the name of the Media Control Channel
		Framework package, compliant with the Section 13.1.1 of <xref target="RFC6230"/>, for which the time period applies.</t>
	</list>
	</t>

	</section>

	<!--max-prepared-duration -->

	<section anchor="sec:file-transfer-modes_consumer" title="&lt;file-transfer-modes>">

	<t>The &lt;file-transfer-modes> element allows the Consumer client to specify which scheme names are required
	for file transfer to a Media Server for each Media Control Channel Framework package type. For example does the Media Server
	supports fetching media resources via RTSP, HTTP, NFS, etc protocols.  The element MAY be present.</t>

	<t>The &lt;file-transfer-modes> element has no attributes.</t>

	<t>The &lt;file-transfer-modes> element has a single child element:


	<list style="hanging">
		<t hangText="<file-transfer-mode>: ">has two attributes, 'name' and 'package'.  The 'name' attribute provides the
		scheme name of the protocol required for fetching resources: valid values are case insensitive scheme names (e.g., RTSP, HTTP,
		HTTPS, NFS, etc.).  The 'package' attribute provides the name of the Media Control Channel Framework package,
		compliant with the Section 13.1.1 of <xref target="RFC6230"/>, for which the scheme name applies.</t>
	
	</list>
	</t>
	
	<t>The same considerations about file transfer and live streaming explained in <xref target="sec:file-transfer-modes"/>
	apply here as well.</t>

</section>
<!--file-transfer-modes -->


</section>
	
<!-- ivrInfo -->
	
	<section anchor="sec:requestMixerInfo" title="<mixerInfo> element">

		<t>The &lt;mixerInfo> element provides information for general Consumer request information
		that is Mixer specific.  The following sub-sections describe the elements of the &lt;mixerInfo>
		element, &lt;mixers>, &lt;file-formats>,
		&lt;dtmf-type>, &lt;tones>, &lt;mixing-mode>, &lt;application-data>, &lt;location> and &lt;encryption>.</t>


		<section anchor="sec:mixers" title="&lt;mixers>">

		<t>The &lt;mixers> element provides information detailing the required
		mixed RTP sessions.  The element MAY be present.</t>

		<t>The &lt;mixers> element has no attributes.</t>
		<t>The &lt;mixers> element has a single child element:


		<list style="hanging">
		<t hangText="<mix>: "> Describes required mixed RTP sessions. 
		The &lt;mix> element has one attribute.  The value of the attribute 'users' is the number of
		participants required in the mix.  The &lt;mix> element has one child element.  The child element,
		&lt;rtp-codec>, contains the same information relating to RTP sessions as defined in
	     	<xref target="sec:active-rtp-sessions"/>.  The element MAY be present.</t>
		</list>
		</t>

		</section>
		
		<!--active-mixer-sessions -->

		<section anchor="sec:file-formats_mixer" title="&lt;file-formats>">

		<t>The &lt;file-formats> element provides a list of file formats required by
		the Consumer client for the purpose of playing media to a mix.  The element MAY be present.</t>

		<t>The &lt;file-formats> element has no attributes.</t>

		<t>The &lt;file-formats> element has a single child element:


		<list style="hanging">
		<t hangText="<required-format>: "> has a single attribute, 'name', which provides the
		type of file format that is supported.  A valid value is a media type
		which, depending on its definition, can include
      additional parameters (e.g., <xref target="RFC6381"/>). The &lt;required-format> element then has
		a further child element, &lt;required-file-package>.  The &lt;required-file-package>
		element contains a single attribute, 'required-file-package-name', which contains the name of the Media Control Channel
		Framework package, compliant with the Section 13.1.1 of <xref target="RFC6230"/>, for which the file format support applies.</t>
		</list>
		</t>
		</section>
		
		<!--file-formats -->

		<section anchor="sec:dtmf_mixer" title="<dtmf> element">

		<t>The &lt;dtmf> element specifies the required methods to detect DTMF tones and to generate them in a mix. 
		The element MAY be present.</t>

		<t>The &lt;dtmf> element has no attributes.</t>

		<t>The &lt;dtmf> element has zero or more of the following child elements:

		<list style="hanging">
		<t hangText="<detect>: ">Indicates the required support for DTMF detection.
		The &lt;detect> element has no attributes.  The &lt;detect> element then has
		a further child element, &lt;dtmf-type>.  The &lt;dtmf-type>
		element has two attributes, 'name' and 'package.  The 'name' attribute provides the
		type of DTMF being used, and it can only be a case insensitive string containing
		either 'RFC4733' <xref target="RFC4733"/> or 'Media' (detecting tones as signals from the audio stream).
		The 'package' attribute provides the name of the Media Control Channel
		Framework package, compliant with the specification in the related IANA registry
		(e.g., "msc-ivr/1.0"), for which the DTMF type applies.</t>

		<t hangText="<generate>: ">Indicates the required support for DTMF generation.
		The &lt;generate> element has no attributes.  The &lt;generate> element then has
		a further child element, &lt;dtmf-type>.  The &lt;dtmf-type>
		element has two attributes, 'name' and 'package.  The 'name' attribute provides the
		type of DTMF being used, and it can only be a case insensitive string containing
		either 'RFC4733' <xref target="RFC4733"/> or 'Media' (generating tones as signals in the audio stream).
		The 'package' attribute provides the name of the Media Control Channel
		Framework package, compliant with the specification in the related IANA registry
		(e.g., "msc-ivr/1.0"), for which the DTMF type applies.</t>

		<t hangText="<passthrough>: ">Indicates the required support for passing DTMF through without re-encoding.
		The &lt;passthrough> element has no attributes.  The &lt;passthrough> element then has
		a further child element, &lt;dtmf-type>.  The &lt;dtmf-type>
		element has two attributes, 'name' and 'package.  The 'name' attribute provides the
		type of DTMF being used, and it can only be a case insensitive string containing
		either 'RFC4733' <xref target="RFC4733"/> or 'Media' (passing tones as signals through the audio stream).
		The 'package' attribute provides the name of the Media Control Channel
		Framework package, compliant with the specification in the related IANA registry
		(e.g., "msc-ivr/1.0"), for which the DTMF type applies.</t>
	
		</list>
		</t>
	</section>

	<!--DTMF -->

	<section anchor="sec:tones_mixer" title="&lt;tones>">


	<t>The &lt;tones> element provides requested
	tones a media server must support for a mix. In particular, the request refers
	to both country codes support (ISO 3166-1 <xref target="ISO.3166-1"/>) and requested
	functionality (ITU-T Recommendation Q.1950 <xref target="ITU-T.Q.1950"/>). The element MAY be present.</t>

	<t>The &lt;tones> element has no attributes.</t>

	<t>The &lt;tones> element has zero or more of the following child elements:

	<list style="hanging">
		<t hangText="<country-codes>: "> Describes the requested
		country codes with respect to tones. The &lt;country-codes>
		element has no attributes. The &lt;country-codes> has one
		child element. The child element, &lt;country-code>, requests
		a specific country code, compliant with the ISO 3166-1 <xref target="ISO.3166-1"/>
		specification. The &lt;country-code> element has a single attribute,
		'package'. The attribute 'package' provides the name of the Media
		Control Channel Framework package, compliant with the specification in the related
		IANA registry (e.g., "msc-ivr/1.0"), in which the tones from the specified country
		code are requested.</t>

		<t hangText="<h248-codes>: "> Describes the requested
		H.248 codes with respect to tones. The &lt;h248-codes>
		element has no attributes. The &lt;h248-codes> has one
		child element. The child element, &lt;h248-code>, requests
		a specific H.248 code, compliant with the ITU-T Recommendation Q.1950 <xref target="ITU-T.Q.1950"/>
		specification. The codes can be either specific (e.g., cg/dt to
		only report the Dial Tone from the Call Progress Tones package)
		or generic (e.g., cg/* to report all the tones from the Call Progress
		Tones package) using wild-cards. The &lt;h248-code> element has a
		single attribute, 'package'. The attribute 'package' provides
		the name of the Media Control Channel Framework package, compliant with the
		specification in the related IANA registry (e.g., "msc-ivr/1.0"), in which
		the specified codes are requested.</t>
	</list>
	</t>

	</section>
	
	<!--tones -->

	<section anchor="sec:mixing-modes_mixer" title="&lt;mixing-modes>">


	<t>The &lt;mixing-modes> element requests information about the support for audio
	and video mixing of a Media Server, specifically a list of supported algorithms
	to mix audio and a list of supported video presentation layouts. The element MAY be present.</t>

	<t>The &lt;mixing-modes> element has no attributes.</t>

	<t>The &lt;mixing-modes> element has zero or more of the following child elements:


	<list style="hanging">
	<t hangText="<audio-mixing-modes>: "> Describes the requested algorithms for
	audio mixing. The &lt;audio-mixing-modes> element has no attributes. The
	&lt;audio-mixing-modes> element has one child element. The child element,
	&lt;audio-mixing-mode>, contains a specific requested algorithm. Valid values
	for the &lt;audio-mixing-mode> element are are algorithm names, e.g., 'nbest' and 'controller'
	as defined in <xref target="RFC6505"/>. The element has a single
	attribute, 'package'. The attribute 'package' provides the name of the Media
	Control Channel Framework package, compliant with the specification in the related IANA
	registry (e.g., "msc-ivr/1.0"), for which the algorithm support is requested.</t>

	<t hangText="<video-mixing-modes>: "> Describes the requested video
	presentation layouts for video mixing. The &lt;video-mixing-modes> element
	has two attributes, 'vas' and 'activespeakermix'. The 'vas' attribute is of
	type boolean with a value of 'true' indicating that the Consumer Client requires
	automatic Voice Activated Switching. The 'activespeakermix' attribute is of
	type boolean with a value of 'true' indicating that the Consumer Client requires
	an additional video stream for the loudest speaker participant without its contribution.
	The &lt;video-mixing-modes> element has one child element.
	The child element, &lt;video-mixing-mode>, contains the name of a specific video presentation
	layout. The name may refer to one of predefined video layouts defined in the XCON
	conference information data model, or to non-XCON layouts as well, as long as they are properly prefixed.
	The &lt;video-mixing-mode> element has a single attribute, 'package'. The attribute 'package' provides the
	name of the Media Control Channel Framework package, compliant with the specification
	in the related IANA registry (e.g., "msc-ivr/1.0"), for which the algorithm
	support is requested.</t>

	</list>
	</t>


	</section>
	
	<!--mixing-modes -->


	<section anchor="sec:application-data_mixer" title="&lt;application-data>">

	<t>The &lt;application-data> element provides an arbitrary string of
    characters as Mixer application level data.  This data is meant to only
    have meaning at the application level logic and as such is not
    otherwise restricted by this specification.  The set of allowed
    characters are the same as those in XML (viz., tab, carriage
    return, line feed, and the legal characters of Unicode and ISO/IEC
    10646 [see http://www.w3.org/TR/xml/ section 2.2]).  The element MAY be present.</t>

	<t>The &lt;application-data> element has no attributes.</t>

	<t>The &lt;application-data> element has no child elements.</t>

	</section>

	<!--application-data -->


	<section anchor="sec:location_mixer" title="&lt;location>">

	<t>The &lt;location> element requests a civic
	location for a mixer media server.  The request makes use of the Civic Address
	Schema standardized in <xref target="RFC5139">RFC 5139</xref>. The element MAY be present.  More precisely,
	this section is entirely optional, and it's implementation specific to fill it with just the details each
	implementor deems necessary for any optimization that may be needed.</t>

	<t>The contents of a &lt;location> element has no attributes.</t>

	<t>The contents of a &lt;location> element has a single child element:

	<list style="hanging">
	<t hangText="<civicAddress>: "> Describes the civic
	address location of the requested media server, whose representation refers to
	Section 4 of <xref target="RFC5139">RFC 5139</xref>.</t>
	
	</list>
	</t>

	</section>

	<!--location -->

	<section anchor="sec:encryption_mixer" title="&lt;encryption>">

	<t>The &lt;encryption> element allows a Consumer client to request support for encrypting mixed RTP media streams
	using <xref target="RFC3711">RFC 3711</xref>.  The element MAY be present.</t>

	<t>The &lt;encryption> element has no attributes.</t>

	<t>The &lt;encryption> element has zero or more of the following child elements:

	<list style="hanging">
		<t hangText="<keying-mechanism>: ">has no attributes.  The element provides the name of
		a keying mechanism the Cosumer client requires for encrypting mixed RTP media streams.</t>
	
	</list>
	</t>
	
	<t>The presence of at least one &lt;keying-mechanism> child element would indicate that the Consumer client
	does require mixed RTP media stream encryption as specified by the child element itself.
	An empty &lt;encryption> element would otherwise indicate the client does not require RTP encryption at all.</t>


	</section>
	
	<!--encryption -->


	</section>
	
	<!-- MixerInfo -->

        </section>

	<!-- MediaResourceRequest -->

</section>

<!-- Consumer -->

	<section anchor="sec:Media_Response" title="Media Service Resource Response">

		<t>This section provides the element definitions for use in Consumer interface
		responses.  The responses are carried in the &lt;mediaResourceResponse>
		element.</t>

	<section anchor="sec:mediaResourceResponse" title="<mediaResourceResponse> element">

	<t>The &lt;mediaResourceResponse> element provides a information for clients
		receiving response information from an external MRB entity.</t>

		<t>The &lt;mediaResourceResponse> element has two mandatory attributes, 'id' and 'status'.
		The 'id' attribute must contain the same value the client provided
		in the 'id' attribute in the &lt;mediaResourceRequest> the response is for. The 'status' attribute
		indicates the status code of the operation.  The following status codes are defined for 'status': </t>


       <texttable anchor="defn.response.statuscodes.consumer"
                title="&lt;response> status codes" >
                <ttcol align="left" width="15%">code</ttcol>
                <ttcol align="left" width="85%">description</ttcol>
				<c>200</c>
					<c>OK</c>
				<c>400</c>
					<c>Syntax error</c>
				<c>405</c>
					<c>Wrong sequence number</c>
				<c>408</c>
					<c>Unable to find Resource</c>
				<c>409</c>
					<c>Unable to update Resource</c>
				<c>410</c>
					<c>Unable to remove Resource</c>
				<c>420</c>
					<c>Unsupported attribute or element</c>
       </texttable>

<t>
		In case a new media resource request made by an AS has been accepted,
		the MRB MUST reply with a &lt;mediaResourceResponse> with status code 200. The same rule applies
		whenever a request to update (action='update') or remove (action='remove') an
		existing transaction can be fulfilled by the MRB.
</t>
<t>
		A media resource request, nevertheless, may fail for several reasons. In such
		a case, the status codes defined in <xref target="defn.response.statuscodes.consumer"/>
		must be used instead. Specifically, if the MRB fails to handle a request
		due to a syntax error in the request itself (e.g., incorrect XML,
		violation of the schema constraints or invalid values in any of the
		attributes/elements) the MRB MUST reply with a &lt;mediaResourceResponse> with status code 400.
		If a syntactically correct request fails because the request also includes any
		attribute/element the MRB doesn't understand, the MRB MUST reply with a &lt;mediaResourceResponse> with status code 420.
		If a syntactically correct request fails because it contains a wrong sequence number,
		that is, a 'seq' value not consistent with the increment the MRB expects according to <xref target="sec:lease"/>,
		the MRB MUST reply with a &lt;mediaResourceResponse> with status code 405.
		If a syntactically correct request fails because the MRB couldn't find any MS able to
		fulfil the requirements presented by the AS in its request, the MRB MUST reply
		with a &lt;mediaResourceResponse> with status code 408.
		If a syntactically correct request fails because the MRB couldn't update an
		existing request according to the new requirements presented by the AS in
		its request, the MRB MUST reply with a &lt;mediaResourceResponse> with status code 409.
		If a syntactically correct request fails because the MRB couldn't remove an
		existing request and release the related resources as requested by the AS,
		the MRB MUST reply with a &lt;mediaResourceResponse> with status code 410.
</t>
<t>
		Further details on status codes 409 and 410 are presented in <xref target="sec:lease"/>,
		where the leasing mechanism, together with its related scenarios, is described.
</t>


	
     		<t>The &lt;mediaResourceResponse>
		element only has &lt;response-session-info> as a
		child element.  This element is used to describe the response of a Consumer interface
		query and is covered in the following sub-section.</t>


		<section anchor="sec:response-session-info" title="<response-session-info> element">

		<t>The &lt;response-session-info> element is included in Consumer responses. This applies to responses
		to both requests for new resources and requests to update an existing media resource session.
		The ability to change and remove an existing media resource
		session is described in more detail in <xref target="sec:lease"/>.
		If the request was successful, the &lt;mediaResourceResponse> MUST
	   have one &lt;response-session-info> child, which describes the media
	   resource session which was addressed by the request.  If the
	   request was not successful, the &lt;mediaResourceResponse> MUST NOT
	   have a &lt;response-session-info> child.
		</t>

		<t>The contents of a &lt;response-session-info> element has no attributes.</t>

		<t>The contents of a &lt;response-session-info> element has zero or more of the following child elements:


		<list style="hanging">
		<t hangText="<session-id>: "> is a unique identifier that explicitly references an existing media
		resource session on the MRB.  The identifier is included to update the existing session and is
		described in more detail in <xref target="sec:lease"/>.</t>
		<t hangText="<seq>: "> is used in association with the &lt;session-id> element in a subsequent
		request to update an existing media resource session on an MRB.  The &lt;seq> number is incremented
		from its original value returned in response to the initial request for media resources.  More information
		its use is provided in <xref target="sec:lease"/>.</t>
		<t hangText="<expires>: "> includes the number of seconds that the media resources are reserved as part of this
		interaction.  If the lease is not refreshed before expiry, the MRB will re-claim the resources and they will
		no longer be guaranteed.  It is RECOMMENDED that a minimum value of 300 seconds be used for the value 
		of the 'expires' attribute.  It is also RECOMMENDED that a Consumer client refresh the lease at an
		interval that is not too close to the expiry time.  A value of 80% of the time-out period could be used.
   		For example, if the time-out period is 300 seconds, the Consumer Client would
   		refresh the transaction at 240 seconds.  More information on its use is provided in <xref target="sec:lease"/>.</t>
		<t hangText="<media-server-address>: "> provides information to reach the MS handling the requested media resource.  One or
		more instances of these element may appear.  The &lt;media-server-address> element has a single attribute named
		'uri' which supplies a SIP URI that reaches the specified media server.  It also has three optional elements
		&lt;connection-id>, &lt;ivr-sessions>, and &lt;mixers>.  The &lt;ivr-sessions> and &lt;mixers> are defined in <xref target="sec:ivr-sessions"/> and
	       	<xref target="sec:mixers"/> and have the same meaning but are applied to individual media server instances as a
		subset of the overall resources reported in the &lt;connection-id>
		element.  If multiple MSs are assigned in an IAMM operation, exactly one &lt;media-server-address>
			element, the one describing the one that provided the media dialog or CFW response, will have a
			&lt;connection-id> element. For more information on the use of the &lt;connection-id> element
			for media dialogs, instead, see <xref target="sec:b2bua"/>.</t>
		</list>
		</t>
		</section>


	</section>

	
	</section>


	</section>
	<!-- Media Server Consumer Interface -->

	<section anchor="sec:In_Line" title="In-Line Unaware MRB Interface">
		<t>An entity acting as an In-Line MRB can act in one of two roles for a request, as introduced
		in <xref target="sec:Inline"/>.  In-Line Unaware
		MRB Mode (IUMM) of operation and In-Line Aware MRB Mode (IAMM) of operation.  This section
		further describes IUMM.</t>

		<t>It should be noted that the introduction of an MRB entity into the network, as specified in this document, 
		requires interfaces to be implemented by those requesting media server resources (for example an application 
		server).  This applies when using the Consumer interface as discussed in
		<xref target="sec:http_Consumer"/>(Query mode) and <xref target="sec:sip_Consumer"/>(IAMM). Nevertheless, an
		MRB is conceived to also
		be able to act in a client unaware mode when it is deployed into the network. 
		This allows any SIP compliant client entity, as defined by <xref target="RFC3261">RFC 3261</xref> and its
		extensions, to send requests to an MRB which in turn will select an appropriate media server based on
		knowledge of media server resources it currently has available transparently to the client entity.
		Using an MRB in this mode allows for
		easy migration of current applications and services that are unaware of the MRB concept and would simply require
		a configuration change resulting in the MRB being set as a SIP outbound proxy for clients requiring media
		services.</t>

		<t>With IUMM, the MRB may conclude that an assigned media resource is no longer needed when it receives a SIP
		BYE from the application server or media server that ends that SIP dialog that initiated the request.</t>

		<t>As with IAMM, in IUMM the SIP INVITE from the application server could convey application/sdp payload to either
		set up a media dialog or a Control Framework control channel.  In either case, in order to permit the AS to associate a media dialog
	   with a control channel to the same media server using the
	   procedures of <xref target="RFC6230"/> section 6, the MRB should be acting as a SIP
	   proxy (and not a B2BUA) so that the SIP address of the targeted
	   media server can be transparently passed back to the application
	   server in the SIP response and so that the SIP dialog is between
	   the application server and the media server.</t>

		<t>While IUMM has the least impact on legacy application servers, it also provides the least versatility.
		See <xref target="sec:merits"/>.</t>

	</section>
	<!-- IUMM -->	

</section>
<!-- MRB Interface Definitions -->

<section anchor="sec:b2bua" title="MRB acting as a B2BUA">

	<t>An MRB entity can potentially act as a SIP Back-2-Back-User-Agent (B2BUA) or a SIP Proxy Server as defined in
	<xref target="RFC3261">RFC 3261</xref>.  When acting as a B2BUA issues can arise when using Media Control Channel
	packages such as the IVR<xref target="RFC6231"/> and Mixer<xref target="RFC6505"/>
	 Packages.  Specifically the Framework attribute 'connectionid' provided in
	the appendix titled 'Appendix: Common Package Components' of Media Control Channel
	Framework<xref target="RFC6230"/> uses a concatenation of the SIP dialog identifiers to be
	used for referencing SIP dialogs within the media control channel.  When a request traverses an MRB acting as a
	B2BUA, the SIP dialog identifiers change and so the 'connectionid' can not be used as intended due to the SIP dialog
	identifiers changing.  For this reason when a MRB wishes to act as a SIP B2BUA when handling a request from an AS to set
	up a media dialog to a MS it MUST include the optional
	&lt;connection-id> element in a Consumer interface response with a value that provides the equivalent  for the 'connectionid'
	('Local Dialog Tag' + 'Remote Dialog Tag') for the far side of the B2BUA.  If present, this value MUST be used
	as the value for the 'connectionid' in packages where the Common Package Components are used.  The &lt;connection-id>
	element MUST NOT be included in a HTTP Consumer interface response.</t>
	<t>It is important to point out that, although more MSs instances may be returned in a Consumer response (i.e., the
	MRB has assigned more than one MS to a Consumer request to fulfill the AS requirements), in IAMM the MRB will
	only act as a B2BUA with a single MS: in this case, exactly one &lt;media-server-address> element, the one
	describing the one that provided the media dialog or CFW response, will have a &lt;connection-id> element, which will
	instead be missing in the other &lt;media-server-address> elements.</t>

</section>
<!-- MRB Acting as a B2BUA -->

<section anchor="sec:multi" title="Multi-modal MRB Implementations">

	<t>An MRB implementation may operate multi-modally with a collection of application server clients all sharing the same
	pool of media resources. I.e., an MRB may be simultaneously operating in Query mode, IAMM and IUMM. It knows in which
	mode to act on any particular request from a client depending on the nature of the request:

	<list style="symbols">

	<t>If the received quest is HTTP Post with application/mrb-consumer+xml content, then MRB processes it in Query mode.</t>
	<t>If the received request is a SIP INVITE with application/mrb-consumer+xml content and application/sdp content, then
	MRB processes it in IAMM.</t>
	<t>If the received request is a SIP INVITE without application/mrb-consumer+xml content but with application/sdp content
		then MRB processes it in IUMM.</t>
	</list>
	</t>
</section>
<!-- Multi-modal MRB Implementations -->

<section anchor="sec:merits" title="Relative Merits of Query Mode, IAMM, and IUMM">

	<t>At a high level, the possible application server MRB interactions can be distinguished among the following basic
	types:

	<list style="letters">

		<t>Query mode, in which the client is requesting the assignment by MRB of suitable MSs resources;</t>
		<t>IAMM in which the client is requesting the assignment by MRB of suitable MSs resources and the
		establishment of a media dialog to one of the MSs;</t>
		<t>IAMM in which the client is requesting the assignment by MRB of suitable MSs resources and the establishment
		of a CFW control channel to one of the MSs;</t>
		<t>IUMM where the client is requesting the establishment of a media dialog to MS resources;</t>
		<t>IUMM where the client is requesting the establishment of a CFW control channel to MS resources.</t>

	</list>
	Each type of interaction has advantages and disadvantages compared to the others, where such considerations may have to
	do with the versatility of what MRB can provide, technical aspects such as efficiency in different application scenarios,
	complexity, delay, use with legacy application servers, or use with the Media Control Channel Framework. Depending on
	the characteristics of a particular setting that an MRB is intended to support, some of the above interaction types may
	be more appropriate than others.  This section makes a few observations on relative merits, but is not intended to be
	exhaustive. Some constraints of a given interaction type may be subtle.
	

	<list style="symbols">
		
		<t>About operation with other types of media control: Any of the types of interactions work with the use
		<xref target="RFC4240">RFC 4240</xref> and <xref target="RFC5552">RFC 5552</xref> where initial control
		instructions are conveyed in the SIP INVITE from the application
		server for the media dialog to the media server and subsequent instructions may be fetched using HTTP. Query mode
		(a), IAMM/media dialog (b) and IUMM/media dialog (d) work with MSML as per <xref target="RFC5707">RFC 5707</xref> or
		MSCML as per <xref target="RFC5022">RFC 5022</xref>.</t>

		<t>As stated previously, IUMM has no interface impacts on an application server. On the other hand, with IUMM
		the application server does not specify the characteristics of the type of media resource it needs because
		the &lt;mediaResourceRequest> element is not passed to the MRB. For IUMM media dialog (d) the best the MRB can do to
		deduce an appropriate media resource gleaned from examining other information in the SIP INVITE, such as the
		SDP information for the media dialog, or initial control information in the SIP Request URI as per
		<xref target="RFC4240">RFC 4240</xref>. With
		IUMM/control channel (e) there is even less information for the MRB to use. </t>

		<t>If using IUMM/control channel (e), the subsequent sending of the media dialog to the media server should not
		be done using IUMM/media dialog. I.e., the SIP signaling to send the media dialog to the selected media server must be
		directly between the application server and that media server, and not through the MRB. Otherwise, MRB might
		send the media dialog to a different media server. Likewise, if using IUMM/media dialog (d), the subsequent
		establishment of a control channel should not be done with IUMM/control channel (e).</t>

		<t>Query mode (a) and IAMM/control channel (c) lend themselves to requesting a pool of media
		resources (e.g., a number of IVR or conferencing ports) in advance of use and retaining their use over a
		period of time, independent of whether there are media dialogs to those resources at any given moment, whereas
		the other types of interactions do not. Likewise for making a subsequent request to increase or decrease
		the amount of resources previously awarded.</t>

	<t>While Query mode (a) and IAMM/control channel (c) are the most versatile interaction types, the former
	is completely decoupled from the use or not of a control channel, whereas  the latter requires the use of a control
	channel.</t>

	<t>When Media Control Channel Framework control channels are to be used in conjunction with the use of MRB, Query
	mode (a) would typically result in fewer such channels being established over time as compared to IAMM/control channel
	(c). That is because the latter would involve setting up an additional control channel every time an AS has a new
	request for MBR for media resources.</t>

	</list>
	</t>
</section>
<!-- Relative Merits of Query Mode, IAMM, and IUMM -->

<section anchor="sec:Examples" title="Examples">

	<t>This section provides examples of both the Publish and Consumer interfaces. For what concerns the
	Consumer interface, both Query and Inline modes are addressed.</t>
	
	<t>
		Note that due to RFC formatting conventions, this section often splits
		HTTP, SIP/SDP and CFW across lines whose content would exceed 72 characters.
		A backslash character marks where this line folding has taken place.  This
		backslash and its trailing CRLF and whitespace would not appear in the actual
		protocol contents.  Besides, also note that the indentation of the XML
		content is only provided for readability: actual messages will follow strict
		XML syntax, which allows for, but does not require, indentation.
	</t>

	<section anchor="sec:ExPub" title="Publish Example">
	
	   <t>
		   The following example assumes a control channel has been established
		   and synced as described in the Media Control Channel Framework
		   (<xref target="RFC6230"/>).
	   </t>
	   <t>
			<xref target="fig-expub"/> shows the subscription/notification mechanism
			the Publish interface is based on, as defined in <xref target="sec:MS_Pub"/>.
			The MRB subscribes for information at the MS (message A1.), and the MS accepts the subscription (A2).
			Notifications are triggered by the MS (A3.) and acknowledged by the MRB (A4.).
	   </t>
			<t>
				<figure anchor="fig-expub" title="Publish Example: Sequence Diagram">
					<artwork>
						<![CDATA[
        MRB                                            MS
         |                                              |
         | A1. CONTROL (MRB subscription)               |
         |--------------------------------------------->|
         |                                   A2. 200 OK |
         |<---------------------------------------------|
         |                                              |
         .                                              .
         .                                              .
         |                                              |
         |                                              |--+ collect
         |                                              |  | up-to-date
         |                                              |<-+ info
         |               B1. CONTROL (MRB notification) |
         |<---------------------------------------------|
         | B2. 200 OK                                   |
         |--------------------------------------------->|
         |                                              |
         .                                              .
         .                                              .
							]]>
					</artwork>
				</figure>
			</t>

			<t>
				The rest of this section includes a full dump of the messages
				associated with the previous sequence diagram, specifically:
			</t>
			<t>
			<list style="numbers">
				<t>the subscription (A1), in an &lt;mrbrequest&gt; (CFW CONTROL);</t>
				<t>the MS accepting the subscription (A2), in an &lt;mrbresponse&gt; (CFW 200);</t>
				<t>a notification (A3), in a &lt;mrbnotification&gt; (CFW CONTROL event);</t>
				<t>the ack to the notification (A4), in a framework level 200 message (CFW 200);</t>
			</list>
			</t>

			<t>
				<figure>
					<artwork>
						<![CDATA[
A1. MRB -> MS (CONTROL, publish request)
----------------------------------------
CFW lidc30BZObiC CONTROL
Control-Package: mrb-publish/1.0
Content-Type: application/mrb-publish+xml
Content-Length: 337

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<mrbpublish version="1.0" xmlns="urn:ietf:params:xml:ns:mrb-publish">
    <mrbrequest>
        <subscription action="create" seqnumber="1" id="p0T65U">
            <expires>600</expires>
	    <minfrequency>20</minfrequency>
	    <maxfrequency>20</maxfrequency>
        </subscription>
    </mrbrequest>
</mrbpublish>



A2. MRB <- MS (200 to CONTROL, request accepted)
------------------------------------------------
CFW lidc30BZObiC 200
Timeout: 10
Content-Type: application/mrb-publish+xml
Content-Length: 139

<mrbpublish version="1.0" xmlns="urn:ietf:params:xml:ns:mrb-publish">
	<mrbresponse status="200" reason="OK: Request accepted"/>
</mrbpublish>



B1. MRB <- MS (CONTROL, event notification from MS)
---------------------------------------------------
CFW 03fff52e7b7a CONTROL
Control-Package: mrb-publish/1.0
Content-Type: application/mrb-publish+xml
Content-Length: 4234

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <mrbpublish version="1.0"
             xmlns="urn:ietf:params:xml:ns:mrb-publish">
    <mrbnotification seqnumber="1" id="QQ6J3c">
        <media-server-id>a1b2c3d4</media-server-id>
        <supported-packages>
            <package name="msc-ivr/1.0"/>
            <package name="msc-mixer/1.0"/>
            <package name="mrb-publish/1.0"/>
            <package name="msc-example-pkg/1.0"/>
        </supported-packages>
        <active-rtp-sessions>
            <rtp-codec name="audio/basic">
                <decoding>10</decoding>
                <encoding>20</encoding>
            </rtp-codec>
        </active-rtp-sessions>
        <active-mixer-sessions>
            <active-mix conferenceid="7cfgs43">
                <rtp-codec name="audio/basic">
                    <decoding>3</decoding>
                    <encoding>3</encoding>
                </rtp-codec>
            </active-mix>
        </active-mixer-sessions>
        <non-active-rtp-sessions>
            <rtp-codec name="audio/basic">
                <decoding>50</decoding>
                <encoding>40</encoding>
            </rtp-codec>
        </non-active-rtp-sessions>
        <non-active-mixer-sessions>
            <non-active-mix available="15">
                <rtp-codec name="audio/basic">
                    <decoding>15</decoding>
                    <encoding>15</encoding>
                </rtp-codec>
            </non-active-mix>
        </non-active-mixer-sessions>
        <media-server-status>active</media-server-status>
        <supported-codecs>
            <supported-codec name="audio/basic">
                <supported-codec-package name="msc-ivr/1.0">
                    <supported-action>encoding</supported-action>
                    <supported-action>decoding</supported-action>
                </supported-codec-package>
                <supported-codec-package name="msc-mixer/1.0">
                    <supported-action>encoding</supported-action>
                    <supported-action>decoding</supported-action>
                </supported-codec-package>
            </supported-codec>
        </supported-codecs>
        <application-data>TestbedPrototype</application-data>
        <file-formats>
            <supported-format name="audio/x-wav">
                <supported-file-package>
                    msc-ivr/1.0
                </supported-file-package>
            </supported-format>
        </file-formats>
        <max-prepared-duration>
            <max-time max-time-seconds="3600">
                <max-time-package>msc-ivr/1.0</max-time-package>
            </max-time>
        </max-prepared-duration>
        <dtmf-support>
            <detect>
                <dtmf-type package="msc-ivr/1.0" name="RFC4733"/>
                <dtmf-type package="msc-mixer/1.0" name="RFC4733"/>
            </detect>
            <generate>
                <dtmf-type package="msc-ivr/1.0" name="RFC4733"/>
                <dtmf-type package="msc-mixer/1.0" name="RFC4733"/>
            </generate>
            <passthrough>
                <dtmf-type package="msc-ivr/1.0" name="RFC4733"/>
                <dtmf-type package="msc-mixer/1.0" name="RFC4733"/>
            </passthrough>
        </dtmf-support>
        <mixing-modes>
            <audio-mixing-modes>
                <audio-mixing-mode package="msc-ivr/1.0">
                     nbest
                </audio-mixing-mode>
            </audio-mixing-modes>
            <video-mixing-modes activespeakermix="true" vas="true">
                <video-mixing-mode package="msc-mixer/1.0">
                     single-view
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     dual-view
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     dual-view-crop
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     dual-view-2x1
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     dual-view-2x1-crop
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     quad-view
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     multiple-5x1
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     multiple-3x3
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     multiple-4x4
                </video-mixing-mode>
            </video-mixing-modes>
        </mixing-modes>
        <supported-tones>
            <supported-country-codes>
                <country-code package="msc-ivr/1.0">GB</country-code>
                <country-code package="msc-ivr/1.0">IT</country-code>
                <country-code package="msc-ivr/1.0">US</country-code>
            </supported-country-codes>
            <supported-h248-codes>
                <h248-code package="msc-ivr/1.0">cg/*</h248-code>
                <h248-code package="msc-ivr/1.0">biztn/ofque</h248-code>
                <h248-code package="msc-ivr/1.0">biztn/erwt</h248-code>
                <h248-code package="msc-mixer/1.0">conftn/*</h248-code>
            </supported-h248-codes>
        </supported-tones>
        <file-transfer-modes>
            <file-transfer-mode package="msc-ivr/1.0" name="HTTP"/>
        </file-transfer-modes>
        <asr-tts-support>
            <asr-support>
                <language xml:lang="en"/>
            </asr-support>
            <tts-support>
                <language xml:lang="en"/>
            </tts-support>
        </asr-tts-support>
        <vxml-support>
            <vxml-mode package="msc-ivr/1.0" support="RFC6231"/>
        </vxml-support>
        <media-server-location>
            <civicAddress xml:lang="it">
                <country>IT</country>
                <A1>Campania</A1>
                <A3>Napoli</A3>
                <A6>Via Claudio</A6>
                <HNO>21</HNO>
                <LMK>University of Napoli Federico II</LMK>
                <NAM>Dipartimento di Informatica e Sistemistica</NAM>
                <PC>80210</PC>
            </civicAddress>
        </media-server-location>
        <label>TestbedPrototype-01</label>
        <media-server-address>
            sip:MediaServer@ms.example.net
        </media-server-address>
        <encryption>
            <keying-mechanism>SDES-SRTP</keying-mechanism>
        </encryption>
    </mrbnotification>
   </mrbpublish>



B2. MRB -> MS (200 to CONTROL)
------------------------------
CFW 03fff52e7b7a 200
					]]>
					</artwork>
				</figure>
			</t>

	</section>

	<!-- Publish Example -->

	<section anchor="sec:ExCons" title="Consumer Example">

		<t>
		As specified in <xref target="sec:Res_Cons"/>, the Consumer interface
		can be involved in two different modes: Query and Inline-aware. When in Query mode,
		Consumer messages are transported in HTTP messages: an example of such an
		approach is presented in <xref target="sec:ExConsQuery"/>. When in
		Inline-aware mode, instead, messages are transported as part of SIP negotiations:
		considering that SIP negotiations may be related to either the creation of a
		control channel or to a UAC media dialog, two separate examples of such an approach are
		presented in <xref target="sec:ExConsIAMM"/>.
		</t>
		
		<section anchor="sec:ExConsQuery" title="Query Example">

	   <t>
		   The following example assumes the interested AS already knows the
		   HTTP URL where an MRB is listening for Consumer messages.
	   </t>
	   <t>
			<xref target="fig-excons"/> shows the HTTP-based transaction between the AS and
			the MRB. The AS sends a consumer request as payload of an HTTP POST message (1.),
			and the MRB provides an answer in an HTTP 200 OK message (2.). Specifically,
			as it will be shown in the dumps, the AS is interested in 100 IVR ports: the MRB
			finds two MSs that can satisfy the request (one providing 60 ports, the other 40 ports)
			and reports them to the AS.
	   </t>

			<t>
				<figure anchor="fig-excons" title="Consumer Example (Query): Sequence Diagram">
					<artwork>
						<![CDATA[
    AS                                             MRB
     |                                              |
     | 1. HTTP POST (Consumer request)              |
     |--------------------------------------------->|
     |                                              |
     |                                              |
     |                                              |--+ Parse request
     |                                              |  | and see if any
     |                                              |<-+ MS applies
     |                                              |
     |                2. 200 OK (Consumer response) |
     |<---------------------------------------------|
     |                                              |
     |--+ Parse response and                        |
     |  | start session (SIP/COMEDIA/CFW)           |
     |<-+ with first MS reported by MRB             |
     |                                              |
     .                                              .
     .                                              .
							]]>
					</artwork>
				</figure>
			</t>

			<t>
				The rest of this section includes a full dump of the messages
				associated with the previous sequence diagram, specifically:
			</t>
			<t>
			<list style="numbers">
				<t>the Consumer request (1), in a &lt;mediaResourceRequest&gt; (HTTP POST, Content-Type 'application/mrb-consumer+xml');</t>
				<t>the Consumer response (2), in an &lt;mediaResourceResponse&gt; (HTTP 200 OK, Content-Type 'application/mrb-consumer+xml').</t>
			</list>
			</t>

			<t>
				<figure>
					<artwork>
						<![CDATA[
1. AS -> MRB (HTTP POST, Consumer request)
------------------------------------------
POST /Mrb/Consumer HTTP/1.1
Content-Length: 893
Content-Type: application/mrb-consumer+xml
Host: mrb.example.net:8080
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.0.1 (java 1.5)

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<mrbconsumer version="1.0" xmlns="urn:ietf:params:xml:ns:mrb-consumer">
    <mediaResourceRequest id="gh11x23v">
        <generalInfo>
            <packages>
                <package>msc-ivr/1.0</package>
                <package>msc-mixer/1.0</package>
            </packages>
        </generalInfo>
        <ivrInfo>
            <ivr-sessions>
                <rtp-codec name="audio/basic">
                    <decoding>100</decoding>
                    <encoding>100</encoding>
                </rtp-codec>
            </ivr-sessions>
            <file-formats>
                <required-format name="audio/x-wav"/>
            </file-formats>
            <file-transfer-modes>
                <file-transfer-mode package="msc-ivr/1.0" name="HTTP"/>
            </file-transfer-modes>
        </ivrInfo>
    </mediaResourceRequest>
</mrbconsumer>


2. AS <- MRB (200 to POST, Consumer response)
---------------------------------------------
HTTP/1.1 200 OK
X-Powered-By: Servlet/2.5
Server: Sun GlassFish Communications Server 1.5
Content-Type: application/mrb-consumer+xml;charset=ISO-8859-1
Content-Length: 1133
Date: Mon, 12 Apr 2011 14:59:26 GMT

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<mrbconsumer version="1.0" xmlns="urn:ietf:params:xml:ns:mrb-consumer" >
    <mediaResourceResponse reason="Resource found" status="200"
                           id="gh11x23v">
        <response-session-info>
            <session-id>5t3Y4IQ84gY1</session-id>
            <seq>9</seq>
            <expires>3600</expires>
            <media-server-address
                              uri="sip:MediaServer@ms.example.com:5080">
                <ivr-sessions>
                    <rtp-codec name="audio/basic">
                        <decoding>60</decoding>
                        <encoding>60</encoding>
                    </rtp-codec>
                </ivr-sessions>
            </media-server-address>
            <media-server-address
                       uri="sip:OtherMediaServer@pool.example.net:5080">
                <ivr-sessions>
                    <rtp-codec name="audio/basic">
                        <decoding>40</decoding>
                        <encoding>40</encoding>
                    </rtp-codec>
                </ivr-sessions>
            </media-server-address>
        </response-session-info>
    </mediaResourceResponse>
</mrbconsumer>
					]]>
					</artwork>
				</figure>
			</t>

			<t>As the dumps evince, the request and response are associated by means of the
			'id' attribute (id=&quot;gh11x23v&quot;). Besides, the MRB has picked '9' as the
			random sequence number that needs to be incremented by the AS for the following
			request associated with the same session.</t>
			<t>
				The rest of the scenario is omitted for brevity. After having received
				the 'mediaResourceResponse', the AS has the address of two MSs able to
				fulfil its media requirements, and can start a Control Dialog with one
				or both of them.
			</t>

		</section>

		<!-- Query Example -->

		<section anchor="sec:ExConsIAMM" title="IAMM Example">

		<t>
			As anticipated, two separate examples are presented for the IAMM case: in fact,
			IAMM-mode can take advantage of two different approaches with respect to the
			SIP dialogs to be exploited to carry consumer messages, i.e.: i) a SIP control
			dialog to create a control channel, and, ii) a UAC media dialog to attach to a MS.
			To make things clearer for the reader, the same consumer request as the one
			presented in the Query mode will be sent, in order to clarify how the
			behaviour of the involved parties may differ.
		</t>

		<section anchor="sec:ExConsIAMMCFW" title="IAMM Example: CFW-based approach">

	   <t>
		   The following example assumes the interested AS already knows the
		   SIP URI where an MRB is listening as an UAS.
	   </t>
	   <t>
			<xref target="fig-exiamm"/> shows the first approach, i.e. SIP-based transactions
			between the AS, the MRB and one MS that the MRB chooses from the two that are
			allocated to fulfill the request. The diagram is more complex than before.
			This is basically a scenario envisaging the MRB as a B2BUA. The AS sends a SIP
			INVITE (1.), containing both a CFW-related SDP and a Consumer request (multipart body).
			The MRB sends a provisional response to the AS (2.) and starts working on the request.
			First of all, it makes use of the Consumer request from the AS to determine which MSs
			should be exploited. Once the right MSs have been chosen (MS1 and MS2 in the example),
			the MRB sends a new SIP INVITE to one of the MSs (MS1 in the example)
			by just including the SDP part of the original request (3.). That MS
			negotiates this INVITE as specified in <xref target="RFC6230"/>
			(4., 5., 6.), providing the MRB with its own CFW-related SDP. The MRB replies to the
			original AS INVITE preparing a SIP 200 OK with another multipart body (7.): this
			multipart body includes the Consumer response used by the MRB to determine the right MSs
			and the SDP returned by the MS (MS1) in 5. The AS finally acknowledges the 200 OK (8.), and
			can start a CFW connection towards that MS (MS1). Since the MRB provided the AS with two
			MSs instances to fulfill its requirements, the AS can use the URI in the &lt;media-server-address>
			element in the &lt;mediaResourceResponse> that describes the other MS to establish a CFW
			channel with that MS (MS2) as well.
	   </t>
	   <t>
			Please note that, to ease the reading of the protocol contents, a simple '=_Part' is
			used whenever a boundary for a 'multipart/mixed' payload is provided, instead of
			the actual boundary that would be inserted in the SIP messages.
	   </t>

			<t>
				<figure anchor="fig-exiamm" title="Consumer Example (IAMM-CFW): Sequence Diagram">
					<artwork>
						<![CDATA[
 AS                     MRB                        MS1              MS2
 |                       |                           |                |
 | 1. INVITE             |                           |                |
 | (multipart/mixed)     |                           |                |
 |---------------------->|                           |                |
 |       2. 100 (Trying) |                           |                |
 |<----------------------|                           |                |
 |                       |--+ Extract SDP and        |                |
 |                       |  | MRB payloads; handle   |                |
 |                       |<-+ Consumer request to    |                |
 |                       |    pick MSs (MS1 and MS2) |                |
 |                       |                           |                |
 |                       | 3. INVITE                 |                |
 |                       | (only copy SDP from 1.)   |                |
 |                       |-------------------------->|                |
 |                       |           4. 100 (Trying) |                |
 |                       |<--------------------------|                |
 |                       |                           |--+ Negotiate   |
 |                       |                           |  | CFW Control |
 |                       |                           |<-+ Channel     |
 |                       |                 5. 200 OK |                |
 |                       |<--------------------------|                |
 |                       | 6. ACK                    |                |
 |                       |-------------------------->|                |
 |        Prepare new +--|                           |                |
 |       payload with |  |                           |                |
 |    SDP from MS and +->|                           |                |
 |     Consumer reply    |                           |                |
 |                       |                           |                |
 |             7. 200 OK |                           |                |
 |     (multipart/mixed) |                           |                |
 |<----------------------|                           |                |
 | 8. ACK                |                           |                |
 |---------------------->|                           |                |
 |                       |                           |                |
 |--+ Read Cons. reply   |                           |                |
 |  | and use SDP to     |                           |                |
 |<-+ create CFW Chn.    |                           |                |
 |                       |                           |                |
 |                                                   |                |
 |   Create TCP CFW channel towards MS1 (if needed)  |                |
 |-------------------------------------------------->|                |
 |                                                   |                |
 |<<############## TCP CONNECTION #################>>|                |
 |                                                   |                |
 | CFW SYNC                                          |                |
 |++++++++++++++++++++++++++++++++++++++++++++++++++>|                |
 |                                                   |                |
 .                       .                           .                .
 .                       .                           .                .
 |                                                   |                |
 |   Negotiate SIP Control Dialog with MS2                            |
 |<------------------------------------------------------------------>|
 |   Create TCP CFW channel towards MS2 as well (if needed)           |
 |------------------------------------------------------------------->|
 |                                                                    |
 |<<######################## TCP CONNECTION ########################>>|
 |                                                                    |
 | CFW SYNC                                                           |
 |+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++>|
 |                                                                    |
 |                       |                           |                |
 .                       .                           .                .
 .                       .                           .                .
							]]>
					</artwork>
				</figure>
			</t>

			<t>
				The rest of this section includes an almost full dump of the messages
				associated with the previous sequence diagram. Only the relevant SIP messages
				are shown (both the INVITEs and the 200 OKs), and only the relevant headers
				are preserved for brevity (Content-Type and multipart-related information).
				Specifically:
			</t>
			<t>
			<list style="numbers">
				<t>the original INVITE (1), containing both a CFW-related SDP (COMEDIA information
				to negotiate a new Control Channel) and a Consumer &lt;mediaResourceRequest&gt;;</t>
				<t>the INVITE sent by the MRB to the MS as a B2BUA (3.), containing only the
				CFW-related SDP from the original INVITE;.</t>
				<t>the 200 OK sent by the MS back to the MRB (5.), to complete the CFW-related negotiation (SDP only);</t>
				<t>the 200 OK sent by the MRB back to the AS in response to the original INVITE (7.),
				containing both the CFW-related information sent by the MS and a Consumer
				&lt;mediaResourceRequest&gt; documenting the MRB's decision to use that MS.</t>
			</list>
			</t>

			<t>
				<figure>
					<artwork>
						<![CDATA[
1. AS -> MRB (INVITE multipart/mixed)
-------------------------------------
   [..]
   Content-Type: multipart/mixed;boundary="=_Part"

   =_Part
   Content-Type: application/sdp

   v=0
   o=- 2890844526 2890842807 IN IP4 as.example.com
   s=MediaCtrl
   c=IN IP4 as.example.com
   t=0 0
   m=application 48035 TCP cfw
   a=connection:new
   a=setup:active
   a=cfw-id:vF0zD4xzUAW9
   a=ctrl-package:msc-mixer/1.0
   a=ctrl-package:msc-ivr/1.0

   =_Part
   Content-Type: application/mrb-consumer+xml

   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <mrbconsumer version="1.0"
                xmlns="urn:ietf:params:xml:ns:mrb-consumer">
    <mediaResourceRequest id="pz78hnq1">
        <generalInfo>
            <packages>
                <package>msc-ivr/1.0</package>
                <package>msc-mixer/1.0</package>
            </packages>
        </generalInfo>
        <ivrInfo>
            <ivr-sessions>
                <rtp-codec name="audio/basic">
                    <decoding>100</decoding>
                    <encoding>100</encoding>
                </rtp-codec>
            </ivr-sessions>
            <file-formats>
                <required-format name="audio/x-wav"/>
            </file-formats>
            <file-transfer-modes>
                <file-transfer-mode package="msc-ivr/1.0" name="HTTP"/>
            </file-transfer-modes>
        </ivrInfo>
    </mediaResourceRequest>
   </mrbconsumer>

   =_Part



3. MRB -> MS (INVITE sdp only)
------------------------------
   [..]
   Content-Type: application/sdp

   v=0
   o=- 2890844526 2890842807 IN IP4 as.example.com
   s=MediaCtrl
   c=IN IP4 as.example.com
   t=0 0
   m=application 48035 TCP cfw
   a=connection:new
   a=setup:active
   a=cfw-id:vF0zD4xzUAW9
   a=ctrl-package:msc-mixer/1.0
   a=ctrl-package:msc-ivr/1.0



5. MRB <- MS (200 OK sdp)
-------------------------
   [..]
   Content-Type: application/sdp

   v=0
   o=lminiero 2890844526 2890842808 IN IP4 ms.example.net
   s=MediaCtrl
   c=IN IP4 ms.example.net
   t=0 0
   m=application 7575 TCP cfw
   a=connection:new
   a=setup:passive
   a=cfw-id:vF0zD4xzUAW9
   a=ctrl-package:msc-mixer/1.0
   a=ctrl-package:msc-ivr/1.0
   a=ctrl-package:mrb-publish/1.0
   a=ctrl-package:msc-example-pkg/1.0



7. AS <- MRB (200 OK multipart/mixed)
-------------------------------------
   [..]
   Content-Type: multipart/mixed;boundary="=_Part"

   =_Part
   Content-Type: application/sdp

   v=0
   o=lminiero 2890844526 2890842808 IN IP4 ms.example.net
   s=MediaCtrl
   c=IN IP4 ms.example.net
   t=0 0
   m=application 7575 TCP cfw
   a=connection:new
   a=setup:passive
   a=cfw-id:vF0zD4xzUAW9
   a=ctrl-package:msc-mixer/1.0
   a=ctrl-package:msc-ivr/1.0
   a=ctrl-package:mrb-publish/1.0
   a=ctrl-package:msc-example-pkg/1.0

   =_Part
   Content-Type: application/mrb-consumer+xml

   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <mrbconsumer version="1.0"
                xmlns="urn:ietf:params:xml:ns:mrb-consumer" >
    <mediaResourceResponse reason="Resource found" status="200"
                           id="pz78hnq1">
        <response-session-info>
            <session-id>z1skKYZQ3eFu</session-id>
            <seq>9</seq>
            <expires>3600</expires>
            <media-server-address
                              uri="sip:MediaServer@ms.example.com:5080">
                <connection-id>32pbdxZ8:KQw677BF</connection-id>
                <ivr-sessions>
                    <rtp-codec name="audio/basic">
                        <decoding>60</decoding>
                        <encoding>60</encoding>
                    </rtp-codec>
                </ivr-sessions>
            </media-server-address>
            <media-server-address
                       uri="sip:OtherMediaServer@pool.example.net:5080">
                <ivr-sessions>
                    <rtp-codec name="audio/basic">
                        <decoding>40</decoding>
                        <encoding>40</encoding>
                    </rtp-codec>
                </ivr-sessions>
            </media-server-address>
        </response-session-info>
    </mediaResourceResponse>
   </mrbconsumer>

   =_Part
					]]>
					</artwork>
				</figure>
			</t>

			<t>
				As the dumps evince, the only difference in the response
				the MRB provides the AS with is in the 'connection-id' attribute that
				is added to the first allocated MS instance: this allows the AS to
				understand the MRB has sent the CFW channel negotiation to that
				specific MS, and that the connection-id to be used (should the SIP
				control dialog also include media-related SDP later on) is the
				one provided. This will be more carefully described in the next section,
				for the media dialog-based approach.
			</t>
			<t>
				The continuation of the scenario (the AS connecting to MS1 to start the Control Channel and
				the related SYNC message, the AS connecting to MS2 as well later on, all the media dialogs
				being attached to either MS) are omitted for brevity.
			</t>
		</section>

		<!-- IAMM Example CFW -->

		<section anchor="sec:ExConsIAMMCallLeg" title="IAMM Example: Media dialog-based approach">

	   <t>
		   The following example assumes the interested AS already knows the
		   SIP URI where an MRB is listening as an UAS.
	   </t>
	   <t>
			<xref target="fig-exiamm2"/> shows the second approach, i.e. SIP-based transactions
			between a SIP client, the AS, the MRB and the MS that the MRB chooses. The interaction is basically the
			same as before (e.g. for what concerns the multipart body) but considering a new
			party is involved in the communication, the diagram is slightly more complex than before.
			As before, the MRB acts as a B2BUA. A UAC sends a SIP INVITE to a SIP URI handled by the AS,
			since it is interested to its services (1.). The AS sends a provisional response (2.) and,
			since it doesn't have the resources yet, sends to the MRB a new SIP
			INVITE (3.), containing both the UAC media-related SDP and a Consumer request (multipart body).
			The MRB sends a provisional response to the AS (4.) and starts working on the request.
			First of all, it makes use of the Consumer request from the AS to determine which MSs
			should be chosen. Once the right MSs have been chosen, the MRB sends a new SIP INVITE
			to one of the MSs by just including the SDP part of the original request (5.). The MS
			negotiates this INVITE as specified in <xref target="RFC6230"/>
			(6., 7., 8.) to allocate the needed media resources to handle the new media dialog,
			eventually providing the MRB with its own media-related SDP. The MRB replies to the
			original AS INVITE preparing a SIP 200 OK with another multipart body (9.): this
			multipart body includes the Consumer response from the MRB indicating the chosen MSs
			and the SDP returned by the MS in 7. The AS finally acknowledges the 200 OK (10.), and
			ends the scenario by eventually providing the UAC with the SDP it needs to set-up
			the RTP channels with the chosen MS: a separate direct SIP control dialog may be initiated
			by the AS to the same MS in order to set up a control channel to manipulate the media dialog media.
		</t>
		<t>
			As with the IAMM - CFW example in the prior section, this example has
			the MRB selecting MS resources across two MS instances. And here again
			the convention can be that the MRB sent the SIP INVITE to the first MS
			in the list provided to the AS in the Consumer response information. For the sake
			of brevity, the considerations about connecting to the other MS as well are omitted,
			since they have already been addressed in the previous section.
		</t>
	   	<t>
			Please note that, to ease the reading of the protocol contents, a simple '=_Part' is
			used whenever a boundary for a 'multipart/mixed' payload is provided, instead of
			the actual boundary that would be inserted in the SIP messages.
	   </t>

			<t>
				<figure anchor="fig-exiamm2" title="Consumer Example (IAMM-MediaDialog): Sequence Diagram">
					<artwork>
						<![CDATA[
UAC              AS                     MRB                          MS
 |               |                       |                           |
 | 1. INVITE     |                       |                           |
 | (media SDP)   |                       |                           |
 |-------------->|                       |                           |
 | 2. 100 Trying |                       |                           |
 |<--------------|                       |                           |
 |               | 3. INVITE             |                           |
 |               | (multipart/mixed)     |                           |
 |               |---------------------->|                           |
 |               |       4. 100 (Trying) |                           |
 |               |<----------------------|                           |
 |               |                       |--+ Extract SDP and        |
 |               |                       |  | MRB payloads; handle   |
 |               |                       |<-+ Consumer request to    |
 |               |                       |    pick Media Servers     |
 |               |                       |                           |
 |               |                       | 5. INVITE                 |
 |               |                       | (only copy SDP from 3.)   |
 |               |                       |-------------------------->|
 |               |                       |           6. 100 (Trying) |
 |               |                       |<--------------------------|
 |               |                       |                        +--|
 |               |                       |    Handle media dialog |  |
 |               |                       |        (connection-id) +->|
 |               |                       |                           |
 |               |                       |                 7. 200 OK |
 |               |                       |<--------------------------|
 |               |                       | 8. ACK                    |
 |               |                       |-------------------------->|
 |               |        Prepare new +--|                           |
 |               |       payload with |  |                           |
 |               |    SDP from MS and +->|                           |
 |               |     Consumer reply    |                           |
 |               |                       |                           |
 |               |             9. 200 OK |                           |
 |               |     (multipart/mixed) |                           |
 |               |<----------------------|                           |
 |               | 10. ACK               |                           |
 |               |---------------------->|                           |
 |               |                       |                           |
 |               |--+ Read Cons. reply   |                           |
 |               |  | and send SDP       |                           |
 |               |<-+ back to UAC        |                           |
 |    11. 200 OK |                       |                           |
 |<--------------|                       |                           |
 | 12. ACK       |                       |                           |
 |-------------->|                       |                           |
 |               |                       |                           |
 |<<*************************** RTP *******************************>>|
 |               |                       |                           |
 |               |--+ Negotiate          |                           |
 |               |  | CFW channel        |                           |
 |               |<-+ towards MS         |                           |
 |               |    (if needed)        |                           |
 .               .                       .                           .
 .               .                       .                           .
 |               |                       |                           |
 |               |                                                   |
 |               |    Create TCP CFW channel towards MS (if needed)  |
 |               |-------------------------------------------------->|
 |               |                                                   |
 |               |<<############## TCP CONNECTION #################>>|
 |               |                                                   |
 |               | CFW SYNC                                          |
 |               |++++++++++++++++++++++++++++++++++++++++++++++++++>|
 |               |                                                   |
 .               .                       .                           .
 .               .                       .                           .

							]]>
					</artwork>
				</figure>
			</t>

			<t>
				The rest of this section includes an almost full dump of the messages
				associated with the previous sequence diagram. Only the relevant SIP messages
				are shown (both the INVITEs and the 200 OKs), and only the relevant headers
				are preserved for brevity (Content-Type, From/To and multipart-related information).
				Specifically:
			</t>
			<t>
			<list style="numbers">
				<t>the original INVITE (1), containing the media-related SDP sent by a UAC;</t>
				<t>the original INVITE (3), containing both the media-related SDP and a
				Consumer &lt;mediaResourceRequest&gt;;</t>
				<t>the INVITE sent by the MRB to the MS as a B2BUA (5.), containing only the
				media-related SDP from the original INVITE;</t>
				<t>the 200 OK sent by the MS back to the MRB (7.), to complete the media-related negotiation (SDP only);</t>
				<t>the 200 OK sent by the MRB back to the AS in response to the original INVITE (9.),
				containing both the media-related information sent by the MS and a Consumer
				&lt;mediaResourceRequest&gt; documenting the MRB's decision to use that MS;</t>
				<t>the 200 OK sent by the AS back to the UAC to have it set-up the RTP channel(s) with the MS (11.).</t>
			</list>
			</t>

			<t>
				<figure>
					<artwork>
						<![CDATA[
1. UAC -> AS (INVITE with media SDP)
------------------------------------
   [..]
   From: <sip:lminiero@users.example.com>;tag=1153573888
   To: <sip:mediactrlDemo@as.example.com>
   [..]
   Content-Type: application/sdp

   v=0
   o=lminiero 123456 654321 IN IP4 203.0.113.2
   s=A conversation
   c=IN IP4 203.0.113.2
   t=0 0
   m=audio 7078 RTP/AVP 0 3 8 101
   a=rtpmap:0 PCMU/8000/1
   a=rtpmap:3 GSM/8000/1
   a=rtpmap:8 PCMA/8000/1
   a=rtpmap:101 telephone-event/8000
   a=fmtp:101 0-11
   m=video 9078 RTP/AVP 98
   
   

3. AS -> MRB (INVITE multipart/mixed)
-------------------------------------
   [..]
   From: <sip:ApplicationServer@as.example.com>;tag=fd4fush5
   To: <sip:Mrb@mrb.example.org>
   [..]
   Content-Type: multipart/mixed;boundary="=_Part"

   =_Part
   Content-Type: application/sdp

   v=0
   o=lminiero 123456 654321 IN IP4 203.0.113.2
   s=A conversation
   c=IN IP4 203.0.113.2
   t=0 0
   m=audio 7078 RTP/AVP 0 3 8 101
   a=rtpmap:0 PCMU/8000/1
   a=rtpmap:3 GSM/8000/1
   a=rtpmap:8 PCMA/8000/1
   a=rtpmap:101 telephone-event/8000
   a=fmtp:101 0-11
   m=video 9078 RTP/AVP 98

   =_Part
   Content-Type: application/mrb-consumer+xml

   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <mrbconsumer version="1.0"
                xmlns="urn:ietf:params:xml:ns:mrb-consumer">
    <mediaResourceRequest id="ns56g1x0">
        <generalInfo>
            <packages>
                <package>msc-ivr/1.0</package>
                <package>msc-mixer/1.0</package>
            </packages>
        </generalInfo>
        <ivrInfo>
            <ivr-sessions>
                <rtp-codec name="audio/basic">
                    <decoding>100</decoding>
                    <encoding>100</encoding>
                </rtp-codec>
            </ivr-sessions>
            <file-formats>
                <required-format name="audio/x-wav"/>
            </file-formats>
            <file-transfer-modes>
                <file-transfer-mode package="msc-ivr/1.0" name="HTTP"/>
            </file-transfer-modes>
        </ivrInfo>
    </mediaResourceRequest>
   </mrbconsumer>

   =_Part



5. MRB -> MS (INVITE sdp only)
------------------------------
   [..]
   From: <sip:Mrb@mrb.example.org:5060>;tag=32pbdxZ8
   To: <sip:MediaServer@ms.example.com:5080>
   [..]
   Content-Type: application/sdp

   v=0
   o=lminiero 123456 654321 IN IP4 203.0.113.2
   s=A conversation
   c=IN IP4 203.0.113.2
   t=0 0
   m=audio 7078 RTP/AVP 0 3 8 101
   a=rtpmap:0 PCMU/8000/1
   a=rtpmap:3 GSM/8000/1
   a=rtpmap:8 PCMA/8000/1
   a=rtpmap:101 telephone-event/8000
   a=fmtp:101 0-11
   m=video 9078 RTP/AVP 98



7. MRB <- MS (200 OK sdp)
-------------------------
   [..]
   From: <sip:Mrb@mrb.example.org:5060>;tag=32pbdxZ8
   To: <sip:MediaServer@ms.example.com:5080>;tag=KQw677BF
   [..]
   Content-Type: application/sdp

   v=0
   o=lminiero 123456 654322 IN IP4 203.0.113.1
   s=MediaCtrl
   c=IN IP4 203.0.113.1
   t=0 0
   m=audio 63442 RTP/AVP 0 3 8 101
   a=rtpmap:0 PCMU/8000
   a=rtpmap:3 GSM/8000
   a=rtpmap:8 PCMA/8000
   a=rtpmap:101 telephone-event/8000
   a=fmtp:101 0-15
   a=ptime:20
   a=label:7eda834
   m=video 33468 RTP/AVP 98
   a=rtpmap:98 H263-1998/90000
   a=fmtp:98 CIF=2
   a=label:0132ca2



9. AS <- MRB (200 OK multipart/mixed)
-------------------------------------
   [..]
   From: <sip:ApplicationServer@as.example.com>;tag=fd4fush5
   To: <sip:Mrb@mrb.example.org>;tag=117652221
   [..]
   Content-Type: multipart/mixed;boundary="=_Part"

   =_Part
   Content-Type: application/sdp

   v=0
   o=lminiero 123456 654322 IN IP4 203.0.113.1
   s=MediaCtrl
   c=IN IP4 203.0.113.1
   t=0 0
   m=audio 63442 RTP/AVP 0 3 8 101
   a=rtpmap:0 PCMU/8000
   a=rtpmap:3 GSM/8000
   a=rtpmap:8 PCMA/8000
   a=rtpmap:101 telephone-event/8000
   a=fmtp:101 0-15
   a=ptime:20
   a=label:7eda834
   m=video 33468 RTP/AVP 98
   a=rtpmap:98 H263-1998/90000
   a=fmtp:98 CIF=2
   a=label:0132ca2

   =_Part
   Content-Type: application/mrb-consumer+xml

   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <mrbconsumer version="1.0"
                xmlns="urn:ietf:params:xml:ns:mrb-consumer" >
    <mediaResourceResponse reason="Resource found" status="200"
                           id="ns56g1x0">
        <response-session-info>
            <session-id>z1skKYZQ3eFu</session-id>
            <seq>9</seq>
            <expires>3600</expires>
            <media-server-address
                              uri="sip:MediaServer@ms.example.com:5080">
                <connection-id>32pbdxZ8:KQw677BF</connection-id>
                <ivr-sessions>
                    <rtp-codec name="audio/basic">
                        <decoding>60</decoding>
                        <encoding>60</encoding>
                    </rtp-codec>
                </ivr-sessions>
            </media-server-address>
            <media-server-address
                       uri="sip:OtherMediaServer@pool.example.net:5080">
                <ivr-sessions>
                    <rtp-codec name="audio/basic">
                        <decoding>40</decoding>
                        <encoding>40</encoding>
                    </rtp-codec>
                </ivr-sessions>
            </media-server-address>
        </response-session-info>
    </mediaResourceResponse>
   </mrbconsumer>

   =_Part



11. UAC <- AS (200 OK sdp)
--------------------------
   [..]
   From: <sip:lminiero@users.example.com>;tag=1153573888
   To: <sip:mediactrlDemo@as.example.com>;tag=bcd47c32
   [..]
   Content-Type: application/sdp

   v=0
   o=lminiero 123456 654322 IN IP4 203.0.113.1
   s=MediaCtrl
   c=IN IP4 203.0.113.1
   t=0 0
   m=audio 63442 RTP/AVP 0 3 8 101
   a=rtpmap:0 PCMU/8000
   a=rtpmap:3 GSM/8000
   a=rtpmap:8 PCMA/8000
   a=rtpmap:101 telephone-event/8000
   a=fmtp:101 0-15
   a=ptime:20
   a=label:7eda834
   m=video 33468 RTP/AVP 98
   a=rtpmap:98 H263-1998/90000
   a=fmtp:98 CIF=2
   a=label:0132ca2
					]]>
					</artwork>
				</figure>
			</t>

			<t>
				As the dumps evinced, as in the IAMM-CFW example, the MRB provides
			   the AS with a 'media-server-address' element in the consumer
			   response: the 'uri' attribute identifies the specific MS to which
			   the MRB has sent the SDP media negotiation, and the 'connection-id'
			   enables the AS to identify to the MS the dialog between the MRB and
			   MS.  This attribute is needed, since, according to the framework
			   specification, the connection-id is built out of the From/To tags
			   of the dialog between the MRB and MS; since the MRB acts as a B2BUA
			   in this scenario, without that attribute the AS does not know the
			   relevant tags, thus preventing the CFW protocol to work as expected.
			</t>

			<t>
				The continuation of the scenario (the AS connecting to the MS to start the Control Channel, the SYNC message, etc.)
				are omitted for brevity.
			</t>
		</section>

		<!-- IAMM Example media dialog -->

		</section>

		<!-- IAMM Example -->

	</section>

	<!-- Consumer Example -->

</section>

<!-- Examples -->


<section anchor="sec:publisher_xml" title="Media Service Resource Publisher Interface XML Schema">

	<t>This section gives the XML Schema Definition
   [W3C.REC-xmlschema-1-20041028], [W3C.REC-xmlschema-2-20041028] of the
   "application/mrb-publish+xml" format.</t>

<figure anchor="fig:publisher_xml">
	<artwork><![CDATA[

<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema targetNamespace="urn:ietf:params:xml:ns:mrb-publish"
 elementFormDefault="qualified" blockDefault="#all"
 xmlns="urn:ietf:params:xml:ns:mrb-publish"
 xmlns:fw="urn:ietf:params:xml:ns:control:framework-attributes"
 xmlns:ca="urn:ietf:params:xml:ns:pidf:geopriv10:civicAddr"
 xmlns:xsd="http://www.w3.org/2001/XMLSchema">

 <xsd:annotation>
  <xsd:documentation>
   IETF MediaCtrl MRB 1.0

   This is the schema of the IETF MediaCtrl MRB package.

   The schema namespace is urn:ietf:params:xml:ns:mrb-publish

  </xsd:documentation>
 </xsd:annotation>


 <!--
  #############################################################

  SCHEMA IMPORTS

  #############################################################
 -->

 <xsd:import namespace="http://www.w3.org/XML/1998/namespace"
  schemaLocation="http://www.w3.org/2001/xml.xsd">
  <xsd:annotation>
   <xsd:documentation>
    This import brings in the XML attributes for
    xml:base, xml:lang, etc
   </xsd:documentation>
  </xsd:annotation>
 </xsd:import>

<xsd:import 
  namespace="urn:ietf:params:xml:ns:control:framework-attributes" 
  schemaLocation="framework.xsd">
  <xsd:annotation>
   <xsd:documentation>
    This import brings in the framework attributes for
    conferenceid and connectionid.
   </xsd:documentation>
  </xsd:annotation>
</xsd:import>

<xsd:import 
  namespace="urn:ietf:params:xml:ns:pidf:geopriv10:civicAddr" 
  schemaLocation="civicAddress.xsd">
  <xsd:annotation>
   <xsd:documentation>
    This import brings in the civicAddress specification
    from RFC5139.
   </xsd:documentation>
  </xsd:annotation>
</xsd:import>

<!--
  #####################################################

  Extensible core type

  #####################################################
 -->


 <xsd:complexType name="Tcore">
  <xsd:annotation>
   <xsd:documentation>
    This type is extended by other (non-mixed) component types to
    allow attributes from other namespaces.
   </xsd:documentation>
  </xsd:annotation>
  <xsd:sequence/>
  <xsd:anyAttribute namespace="##other" processContents="lax" />
 </xsd:complexType>


<!--
  #####################################################

  TOP LEVEL ELEMENT: mrbpublish

  #####################################################
 -->

<xsd:complexType name="mrbpublishType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:choice>
      <xsd:element ref="mrbrequest" />
      <xsd:element ref="mrbresponse" />
      <xsd:element ref="mrbnotification" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
     </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="version" type="version.datatype"
      use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="mrbpublish" type="mrbpublishType" />

<!--
  #####################################################

  mrbrequest TYPE

  #####################################################
 -->

<!--  mrbrequest -->

 <xsd:complexType name="mrbrequestType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="subscription" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="mrbrequest" type="mrbrequestType" />

<!--  subscription -->

<xsd:complexType name="subscriptionType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element name="expires" type="xsd:nonNegativeInteger"
      minOccurs="0" maxOccurs="1" />
     <xsd:element name="minfrequency" type="xsd:nonNegativeInteger"
      minOccurs="0" maxOccurs="1" />
     <xsd:element name="maxfrequency" type="xsd:nonNegativeInteger"
      minOccurs="0" maxOccurs="1" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="id" type="id.datatype" use="required" />
    <xsd:attribute name="seqnumber" type="xsd:nonNegativeInteger"
      use="required" />
    <xsd:attribute name="action" type="action.datatype"
      use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="subscription" type="subscriptionType" />


<!--
  #####################################################

  mrbresponse TYPE

  #####################################################
 -->

<!--  mrbresponse -->

 <xsd:complexType name="mrbresponseType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="subscription" minOccurs="0" maxOccurs="1" />
     <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="status" type="status.datatype"
     use="required" />
    <xsd:attribute name="reason" type="xsd:string" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>


 <xsd:element name="mrbresponse" type="mrbresponseType" />

<!--
  #####################################################

  mrbnotification TYPE

  #####################################################
 -->

<!--  mrbnotification -->

<xsd:complexType name="mrbnotificationType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element name="media-server-id" 
        type="subscriptionid.datatype"/>
     <xsd:element ref="supported-packages" minOccurs="0" />
     <xsd:element ref="active-rtp-sessions" minOccurs="0" />
     <xsd:element ref="active-mixer-sessions" minOccurs="0" />
     <xsd:element ref="non-active-rtp-sessions" minOccurs="0" />
     <xsd:element ref="non-active-mixer-sessions" minOccurs="0" />
     <xsd:element ref="media-server-status" minOccurs="0" />
     <xsd:element ref="supported-codecs" minOccurs="0" />
     <xsd:element ref="application-data" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:element ref="file-formats" minOccurs="0" />
     <xsd:element ref="max-prepared-duration" minOccurs="0" />
     <xsd:element ref="dtmf-support" minOccurs="0" />
     <xsd:element ref="mixing-modes" minOccurs="0" />
     <xsd:element ref="supported-tones" minOccurs="0" />
     <xsd:element ref="file-transfer-modes" minOccurs="0" />
     <xsd:element ref="asr-tts-support" minOccurs="0" />
     <xsd:element ref="vxml-support" minOccurs="0" />
     <xsd:element ref="media-server-location" minOccurs="0" />
     <xsd:element ref="label" minOccurs="0" />
     <xsd:element ref="media-server-address" minOccurs="0" />
     <xsd:element ref="encryption" minOccurs="0" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
     <xsd:attribute name="id" type="subscriptionid.datatype"
      use="required" />
     <xsd:attribute name="seqnumber" type="xsd:nonNegativeInteger"
      use="required" />
     <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="mrbnotification" type="mrbnotificationType" />


<!--  supported-packages -->

 <xsd:complexType name="supported-packagesType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="package" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="supported-packages" type="supported-packagesType"/>


 <xsd:complexType name="packageType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="package" type="packageType" />


<!--  active-rtp-sessions -->

 <xsd:complexType name="active-rtp-sessionsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="rtp-codec" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="active-rtp-sessions" type="active-rtp-sessionsType"/>


 <xsd:complexType name="rtp-codecType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element name="decoding" type="xsd:nonNegativeInteger" />
      <xsd:element name="encoding" type="xsd:nonNegativeInteger" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="rtp-codec" type="rtp-codecType" />


<!--  active-mixer-sessions -->

<xsd:complexType name="active-mixer-sessionsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="active-mix" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="active-mixer-sessions"
  type="active-mixer-sessionsType" />


<xsd:complexType name="active-mixType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="rtp-codec" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attributeGroup ref="fw:framework-attributes" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="active-mix" type="active-mixType" />


<!--  non-active-rtp-sessions -->

<xsd:complexType name="non-active-rtp-sessionsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="rtp-codec" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="non-active-rtp-sessions"
  type="non-active-rtp-sessionsType" />

<!--  non-active-mixer-sessions -->

<xsd:complexType name="non-active-mixer-sessionsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="non-active-mix" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="non-active-mixer-sessions"
  type="non-active-mixer-sessionsType" />

 <xsd:complexType name="non-active-mixType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="rtp-codec" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="available" type="xsd:nonNegativeInteger"
      use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="non-active-mix" type="non-active-mixType" />

<!--  media-server-status -->

 <xsd:element name="media-server-status" type="msstatus.datatype" />

<!--  supported-codecs -->

<xsd:complexType name="supported-codecsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="supported-codec"
         minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
         maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="supported-codecs" type="supported-codecsType" />

 <xsd:complexType name="supported-codecType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="supported-codec-package"
         minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="supported-codec" type="supported-codecType" />

 <xsd:complexType name="supported-codec-packageType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element name="supported-action" type="actions.datatype"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="supported-codec-package"
  type="supported-codec-packageType" />


<!--  application-data -->

<xsd:element name="application-data" type="appdata.datatype" />

<!--  file-formats -->

<xsd:complexType name="file-formatsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="supported-format"
         minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
         maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="file-formats" type="file-formatsType" />

 <xsd:complexType name="supported-formatType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="supported-file-package"
         minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="supported-format" type="supported-formatType" />

 <xsd:element name="supported-file-package"
  type="xsd:string" />

<!--  max-prepared-duration -->

<xsd:complexType name="max-prepared-durationType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="max-time" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="max-prepared-duration"
  type="max-prepared-durationType" />


 <xsd:complexType name="max-timeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element name="max-time-package" type="xsd:string" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="max-time-seconds" type="xsd:nonNegativeInteger"
     use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="max-time" type="max-timeType" />

<!--  dtmf-support -->

<xsd:complexType name="dtmf-supportType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="detect" />
       <xsd:element ref="generate" />
       <xsd:element ref="passthrough" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="dtmf-support" type="dtmf-supportType" />

 <xsd:complexType name="detectType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="dtmf-type"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="detect" type="detectType" />

 <xsd:complexType name="generateType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="dtmf-type"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="generate" type="generateType" />

 <xsd:complexType name="passthroughType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="dtmf-type"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="passthrough" type="passthroughType" />


 <xsd:complexType name="dtmf-typeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="dtmf.datatype" use="required" />
    <xsd:attribute name="package" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="dtmf-type" type="dtmf-typeType" />


<!--  mixing-modes -->

<xsd:complexType name="mixing-modesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:element ref="audio-mixing-modes"
        minOccurs="0" maxOccurs="1" />
      <xsd:element ref="video-mixing-modes"
        minOccurs="0" maxOccurs="1" />
      <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="mixing-modes" type="mixing-modesType" />

<xsd:complexType name="audio-mixing-modesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="audio-mixing-mode"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="audio-mixing-modes" type="audio-mixing-modesType" />

<xsd:complexType name="audio-mixing-modeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="audio-mixing-mode" type="audio-mixing-modeType" />

<xsd:complexType name="video-mixing-modesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="video-mixing-mode"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:attribute name="vas" type="boolean.datatype"
     default="false" />
   <xsd:attribute name="activespeakermix" type="boolean.datatype"
     default="false" />
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="video-mixing-modes" type="video-mixing-modesType" />

<xsd:complexType name="video-mixing-modeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="video-mixing-mode" type="video-mixing-modeType" />


<!--  supported-tones -->

<xsd:complexType name="supported-tonesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:element ref="supported-country-codes"
        minOccurs="0" maxOccurs="1" />
      <xsd:element ref="supported-h248-codes"
        minOccurs="0" maxOccurs="1" />
      <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="supported-tones" type="supported-tonesType" />

<xsd:complexType name="supported-country-codesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="country-code"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="supported-country-codes" 
  type="supported-country-codesType" />

<xsd:complexType name="country-codeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="country-code" type="country-codeType" />

<xsd:complexType name="supported-h248-codesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="h248-code"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="supported-h248-codes" 
  type="supported-h248-codesType" />

<xsd:complexType name="h248-codeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="h248-code" type="h248-codeType" />


<!--  file-transfer-modes -->

 <xsd:complexType name="file-transfer-modesType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="file-transfer-mode"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="file-transfer-modes"
              type="file-transfer-modesType" />

 <xsd:complexType name="file-transfer-modeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="transfermode.datatype"
     use="required" />
    <xsd:attribute name="package" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>
 <xsd:element name="file-transfer-mode" type="file-transfer-modeType" />


<!--  asr-tts-support -->

<xsd:complexType name="asr-tts-supportType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:element ref="asr-support"
        minOccurs="0" maxOccurs="1" />
      <xsd:element ref="tts-support"
        minOccurs="0" maxOccurs="1" />
      <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="asr-tts-support" type="asr-tts-supportType" />

<xsd:complexType name="asr-supportType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="language"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="asr-support" type="asr-supportType" />

<xsd:complexType name="tts-supportType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="language"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="tts-support" type="tts-supportType" />

<xsd:complexType name="languageType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:attribute ref="xml:lang" />
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="language" type="languageType" />


<!--  media-server-location -->

<xsd:complexType name="media-server-locationType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element name="civicAddress" type="ca:civicAddress"
                        minOccurs="1" maxOccurs="1" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="media-server-location" 
  type="media-server-locationType" />


<!--  vxml-support -->

 <xsd:complexType name="vxml-supportType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="vxml-mode"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="vxml-support" type="vxml-supportType" />

 <xsd:complexType name="vxml-modeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="package" type="xsd:string" use="required" />
    <xsd:attribute name="support" type="vxml.datatype" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="vxml-mode" type="vxml-modeType" />


<!--  label -->

 <xsd:element name="label" type="label.datatype" />


<!-- media-server-address -->

 <xsd:element name="media-server-address" type="xsd:anyURI" />

<!--  encryption -->

 <xsd:complexType name="encryptionType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="keying-mechanism"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="encryption" type="encryptionType" />

 <xsd:element name="keying-mechanism" type="keying.datatype" />

 
<!--
  ####################################################

  DATATYPES

  ####################################################
 -->


 <xsd:simpleType name="version.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="1.0" />
  </xsd:restriction>
 </xsd:simpleType>

<xsd:simpleType name="id.datatype">
  <xsd:restriction base="xsd:NMTOKEN" />
 </xsd:simpleType>

 <xsd:simpleType name="status.datatype">
  <xsd:restriction base="xsd:positiveInteger">
   <xsd:pattern value="[0-9][0-9][0-9]" />
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:simpleType name="msstatus.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="active" />
   <xsd:enumeration value="deactivated" />
   <xsd:enumeration value="unavailable" />
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:simpleType name="action.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="create" />
   <xsd:enumeration value="update" />
   <xsd:enumeration value="remove" />
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:simpleType name="actions.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="encoding" />
   <xsd:enumeration value="decoding" />
   <xsd:enumeration value="passthrough" />
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:simpleType name="appdata.datatype">
  <xsd:restriction base="xsd:string" />
 </xsd:simpleType>

 <xsd:simpleType name="dtmf.datatype">
  <xsd:restriction base="xsd:NMTOKEN"/>
 </xsd:simpleType>

 <xsd:simpleType name="transfermode.datatype">
  <xsd:restriction base="xsd:NMTOKEN" />
 </xsd:simpleType>

 <xsd:simpleType name="boolean.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="true" />
   <xsd:enumeration value="false" />
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:simpleType name="vxml.datatype">
  <xsd:restriction base="xsd:NMTOKEN"/>
 </xsd:simpleType>

 <xsd:simpleType name="label.datatype">
  <xsd:restriction base="xsd:NMTOKEN" />
 </xsd:simpleType>

 <xsd:simpleType name="subscriptionid.datatype">
  <xsd:restriction base="xsd:NMTOKEN" />
 </xsd:simpleType>

 <xsd:simpleType name="keying.datatype">
  <xsd:restriction base="xsd:NMTOKEN" />
 </xsd:simpleType>

</xsd:schema>
	]]></artwork>
		</figure>


</section>

<!-- publisher_xml -->


<section anchor="sec:consumer_xml" title="Media Service Resource Consumer Interface XML Schema">

	<t>This section gives the XML Schema Definition
   [W3C.REC-xmlschema-1-20041028], [W3C.REC-xmlschema-2-20041028] of the
   "application/mrb-consumer+xml" format.</t>	

<figure anchor="fig:xml_schema">
			<artwork><![CDATA[

<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema targetNamespace="urn:ietf:params:xml:ns:mrb-consumer"
 elementFormDefault="qualified" blockDefault="#all"
 xmlns="urn:ietf:params:xml:ns:mrb-consumer"
 xmlns:ca="urn:ietf:params:xml:ns:pidf:geopriv10:civicAddr"
 xmlns:xsd="http://www.w3.org/2001/XMLSchema">

 <xsd:annotation>
  <xsd:documentation>
   IETF MediaCtrl MRB 1.0 

   This is the schema of the IETF MediaCtrl MRB Consumer interface.

   The schema namespace is urn:ietf:params:xml:ns:mrb-consumer

  </xsd:documentation>
 </xsd:annotation>


 <!--
  #############################################################

  SCHEMA IMPORTS

  #############################################################
 -->

 <xsd:import namespace="http://www.w3.org/XML/1998/namespace"
  schemaLocation="http://www.w3.org/2001/xml.xsd">
  <xsd:annotation>
   <xsd:documentation>
    This import brings in the XML attributes for
    xml:base, xml:lang, etc
   </xsd:documentation>
  </xsd:annotation>
 </xsd:import>

<xsd:import 
  namespace="urn:ietf:params:xml:ns:pidf:geopriv10:civicAddr" 
  schemaLocation="civicAddress.xsd">
  <xsd:annotation>
   <xsd:documentation>
    This import brings in the civicAddress specification
    from RFC5139.
   </xsd:documentation>
  </xsd:annotation>
</xsd:import>

<!--
  #####################################################

  Extensible core type

  #####################################################
 -->


 <xsd:complexType name="Tcore">
  <xsd:annotation>
   <xsd:documentation>
    This type is extended by other (non-mixed) component types to
    allow attributes from other namespaces.
   </xsd:documentation>
  </xsd:annotation>
  <xsd:sequence/>
  <xsd:anyAttribute namespace="##other" processContents="lax" />
 </xsd:complexType>


<!--
  #####################################################

  TOP LEVEL ELEMENT: mrbconsumer

  #####################################################
 -->

<xsd:complexType name="mrbconsumerType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:choice>
      <xsd:element ref="mediaResourceRequest" />
      <xsd:element ref="mediaResourceResponse" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
     </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="version" type="version.datatype"
      use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

 <xsd:element name="mrbconsumer" type="mrbconsumerType" />

<!--
  #####################################################

  mediaResourceRequest TYPE

  #####################################################
 -->

<!--  mediaResourceRequst -->

 <xsd:complexType name="mediaResourceRequestType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="generalInfo" minOccurs="0" />
      <xsd:element ref="ivrInfo" minOccurs="0" />
      <xsd:element ref="mixerInfo" minOccurs="0" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:string"
      use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="mediaResourceRequest" 
	 type="mediaResourceRequestType" />

<!--
  #####################################################

  generalInfo TYPE

  #####################################################
-->

<!--  generalInfo -->

<xsd:complexType name="generalInfoType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="session-info" minOccurs="0" />
      <xsd:element ref="packages" minOccurs="0" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="generalInfo" type="generalInfoType" />


<!--  session-info -->

<xsd:complexType name="session-infoType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element name="session-id" type="id.datatype"/>
       <xsd:element name="seq" type="xsd:nonNegativeInteger"/>
       <xsd:element name="action" type="action.datatype"/>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="session-info" type="session-infoType" />

<!--  packages -->

<xsd:complexType name="packagesType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element name="package" type="xsd:string" minOccurs="0"
        maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="packages" type="packagesType"/>


<!--
  #####################################################

  ivrInfo TYPE

  #####################################################
-->

<!--  ivrInfo -->

<xsd:complexType name="ivrInfoType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="ivr-sessions" minOccurs="0" />
      <xsd:element ref="file-formats" minOccurs="0" />
      <xsd:element ref="dtmf-type" minOccurs="0" />
      <xsd:element ref="tones" minOccurs="0" />
      <xsd:element ref="asr-tts" minOccurs="0" />
      <xsd:element ref="vxml" minOccurs="0" />
      <xsd:element ref="location" minOccurs="0" />
      <xsd:element ref="encryption" minOccurs="0" />
      <xsd:element ref="application-data" minOccurs="0" />
      <xsd:element ref="max-prepared-duration" minOccurs="0" />
      <xsd:element ref="file-transfer-modes" minOccurs="0" />
      <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence> 
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="ivrInfo" type="ivrInfoType" />


<!--
  #####################################################

  mixerInfo TYPE

  #####################################################
--> 
 
<!--  mixerInfo -->

<xsd:complexType name="mixerInfoType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="mixers" minOccurs="0"/>
      <xsd:element ref="file-formats" minOccurs="0"/>
      <xsd:element ref="dtmf-type" minOccurs="0"/>
      <xsd:element ref="tones" minOccurs="0"/>
      <xsd:element ref="mixing-modes" minOccurs="0"/>
      <xsd:element ref="application-data" minOccurs="0"/>
      <xsd:element ref="location" minOccurs="0"/>
      <xsd:element ref="encryption" minOccurs="0"/>
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence> 
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="mixerInfo" type="mixerInfoType" />


<!--
  #####################################################

  mediaResourceResponse TYPE

  #####################################################
 -->

<!--  mediaResourceResponse -->

 <xsd:complexType name="mediaResourceResponseType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="response-session-info" minOccurs="0" />
       <xsd:any namespace="##other" minOccurs="0"
          maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:string"
     use="required" />
    <xsd:attribute name="status" type="status.datatype"
     use="required" />
    <xsd:attribute name="reason" type="xsd:string" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>
 

 <xsd:element name="mediaResourceResponse" 
	 type="mediaResourceResponseType" />
 

<!--
  ####################################################

  ELEMENTS

  ####################################################
 -->

<!--  response-session-info -->

<xsd:complexType name="response-session-infoType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element name="session-id" type="id.datatype"/>
       <xsd:element name="seq" type="xsd:nonNegativeInteger"/>
       <xsd:element name="expires" type="xsd:nonNegativeInteger"/>
       <xsd:element ref="media-server-address" 
	  minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
         maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="response-session-info" 
   type="response-session-infoType" />

<!-- media-server-address -->

<xsd:complexType name="media-server-addressTYPE">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element name="connection-id" type="xsd:string"
	 minOccurs="0" maxOccurs="unbounded" />
     <xsd:element ref="ivr-sessions" minOccurs="0"/>
     <xsd:element ref="mixers" minOccurs="0"/>
     <xsd:any namespace="##other" minOccurs="0"
         maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="uri" type="xsd:anyURI" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="media-server-address" 
    type="media-server-addressTYPE" />

<!--  ivr-sessions -->

<xsd:complexType name="ivr-sessionsType">
 <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="rtp-codec" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="ivr-sessions" type="ivr-sessionsType" />

<xsd:complexType name="rtp-codecType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element name="decoding" type="xsd:nonNegativeInteger" />
      <xsd:element name="encoding" type="xsd:nonNegativeInteger" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="rtp-codec" type="rtp-codecType" />


<!-- file-formats -->

<xsd:complexType name="file-formatsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="required-format"
         minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
         maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="file-formats" type="file-formatsType" />

<xsd:complexType name="required-formatType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="required-file-package"
         minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="required-format" type="required-formatType" />

<xsd:complexType name="required-file-packageType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element name="required-file-package-name" type="xsd:string"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="required-file-package"
  type="required-file-packageType" />

<!--  dtmf-type -->

<xsd:complexType name="dtmfType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="detect" />
       <xsd:element ref="generate" />
       <xsd:element ref="passthrough" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="dtmf" type="dtmfType" />

<xsd:complexType name="detectType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="dtmf-type"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="detect" type="detectType" />

<xsd:complexType name="generateType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="dtmf-type"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="generate" type="generateType" />

<xsd:complexType name="passthroughType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="dtmf-type"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="passthrough" type="passthroughType" />

<xsd:complexType name="dtmf-typeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="dtmf.datatype" use="required" />
    <xsd:attribute name="package" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="dtmf-type" type="dtmf-typeType" />

<!--  tones -->

<xsd:complexType name="required-tonesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:element ref="country-codes"
        minOccurs="0" maxOccurs="1" />
      <xsd:element ref="h248-codes"
        minOccurs="0" maxOccurs="1" />
      <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="tones" type="required-tonesType" />

<xsd:complexType name="required-country-codesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="country-code"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="country-codes" 
   type="required-country-codesType" />

<xsd:complexType name="country-codeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="country-code" type="country-codeType" />

<xsd:complexType name="required-h248-codesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="h248-code"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="h248-codes" 
   type="required-h248-codesType" />

<xsd:complexType name="h248-codeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="h248-code" type="h248-codeType" />

<!--  asr-tts -->

<xsd:complexType name="asr-ttsType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:element ref="asr-support"
        minOccurs="0" maxOccurs="1" />
      <xsd:element ref="tts-support"
        minOccurs="0" maxOccurs="1" />
      <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="asr-tts" type="asr-ttsType" />

<xsd:complexType name="asr-supportType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="language"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="asr-support" type="asr-supportType" />

<xsd:complexType name="tts-supportType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="language"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="tts-support" type="tts-supportType" />

<xsd:complexType name="languageType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:attribute ref="xml:lang" />
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="language" type="languageType" /> 


<!--  vxml -->

<xsd:complexType name="vxmlType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="vxml-mode"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="vxml" type="vxmlType" />

<xsd:complexType name="vxml-modeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="package" type="xsd:string" use="required" />
    <xsd:attribute name="require" type="vxml.datatype" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="vxml-mode" type="vxml-modeType" />

<!--  location -->

<xsd:complexType name="locationType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="ca:civicAddress"
                        minOccurs="1" maxOccurs="1" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="location" type="locationType" /> 


<!--  encryption -->

 <xsd:complexType name="encryptionType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="keying-mechanism"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="encryption" type="encryptionType" />

 <xsd:element name="keying-mechanism" type="keying.datatype" />

<!--  application-data -->

<xsd:element name="application-data" type="appdata.datatype" />

<!--  max-prepared-duration -->

<xsd:complexType name="max-prepared-durationType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="max-time" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="max-prepared-duration"
  type="max-prepared-durationType" />


<xsd:complexType name="max-timeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element name="max-time-package" type="xsd:string" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="max-time-seconds" type="xsd:nonNegativeInteger"
     use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="max-time" type="max-timeType" />


<!--  stream-mode -->

<xsd:complexType name="file-transfer-modesType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="file-transfer-mode"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="file-transfer-modes"
             type="file-transfer-modesType" />

<xsd:complexType name="file-transfer-modeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="transfermode.datatype"
     use="required" />
    <xsd:attribute name="package" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="file-transfer-mode" type="file-transfer-modeType" />

<!--  mixers -->

<xsd:complexType name="mixerssessionsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="mix" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="mixers" type="mixerssessionsType" />

<xsd:complexType name="mixType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="rtp-codec" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="users" type="xsd:nonNegativeInteger" 
     use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="mix" type="mixType" />


<!--  mixing-modes -->

<xsd:complexType name="mixing-modesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:element ref="audio-mixing-modes"
        minOccurs="0" maxOccurs="1" />
      <xsd:element ref="video-mixing-modes"
        minOccurs="0" maxOccurs="1" />
      <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="mixing-modes" type="mixing-modesType" />

<xsd:complexType name="audio-mixing-modesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="audio-mixing-mode"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="audio-mixing-modes" type="audio-mixing-modesType" />

<xsd:complexType name="audio-mixing-modeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="audio-mixing-mode" type="audio-mixing-modeType" />

<xsd:complexType name="video-mixing-modesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="video-mixing-mode"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:attribute name="vas" type="boolean.datatype"
     default="false" />
   <xsd:attribute name="activespeakermix" type="boolean.datatype"
     default="false" />
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="video-mixing-modes" type="video-mixing-modesType" />

<xsd:complexType name="video-mixing-modeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="video-mixing-mode" type="video-mixing-modeType" /> 


<!--
  ####################################################

  DATATYPES

  ####################################################
 -->

<xsd:simpleType name="version.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="1.0" />
  </xsd:restriction>
</xsd:simpleType>

<xsd:simpleType name="id.datatype">
  <xsd:restriction base="xsd:NMTOKEN" />
</xsd:simpleType>

<xsd:simpleType name="status.datatype">
  <xsd:restriction base="xsd:positiveInteger">
   <xsd:pattern value="[0-9][0-9][0-9]" />
  </xsd:restriction>
</xsd:simpleType>

<xsd:simpleType name="transfermode.datatype">
  <xsd:restriction base="xsd:NMTOKEN"/>
</xsd:simpleType>

<xsd:simpleType name="action.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="remove" />
   <xsd:enumeration value="update" />
  </xsd:restriction>
</xsd:simpleType> 

<xsd:simpleType name="dtmf.datatype">
  <xsd:restriction base="xsd:NMTOKEN"/>
</xsd:simpleType>

<xsd:simpleType name="boolean.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="true" />
   <xsd:enumeration value="false" />
  </xsd:restriction>
</xsd:simpleType>

<xsd:simpleType name="vxml.datatype">
  <xsd:restriction base="xsd:NMTOKEN"/>
</xsd:simpleType>

<xsd:simpleType name="appdata.datatype">
  <xsd:restriction base="xsd:string" />
 </xsd:simpleType>
 
 <xsd:simpleType name="keying.datatype">
  <xsd:restriction base="xsd:NMTOKEN" />
 </xsd:simpleType>

</xsd:schema>
	]]></artwork>
		</figure>


</section>

<!-- XML Schema -->


<section anchor="sec:security" title="Security Considerations">
			
	<t>The MRB network entity has two primary interfaces, Publish and Consumer,
	that carry sensitive information and must therefore be appropriately protected
	and secured.</t>

	<t>The Publish interface, as defined in and described in <xref target="sec:MS_Pub"/>,
	uses the Media Control Channel Framework <xref target="RFC6230"/>
	as a mechanism to connect an MRB to a media server. It is very important that the 
	communication between the MRB and the MS is secured: a malicious entity, in fact,
	may change or even delete subscriptions to a MS, thus affecting the view the MRB
	has of the resources actually available on a MS, leading it to wrong choices when
	media resources are being requested by an AS. A malicious entity may even lie about
	the resources being available on a MS, for instance to make the MRB think no resources
	are available at all. Considering the Publish interface is a CFW Control Package, the same Security
	Considerations included in the Media Control Channel Framework specification apply
	here to protect interactions between an MRB and a media server.</t>

	<t>The Consumer interface, as defined in and described in <xref target="sec:Res_Cons"/>,
	conceives transactions based on a session ID. These transactions may be transported either
	by means of HTTP messages, or SIP dialogs. This means that malicious users could
	be able to disrupt or manipulate a MRB session should they have access to the above mentioned
	session ID or replicate it somehow: for instance, a malicious entity could modify an
	existing session between an AS and the MRB, e.g., requesting less resources than originally
	requested to cause media dialogs to be rejected by the AS, or requesting many more resources
	instead to try and lock as many of (if not all) the resources a MRB can provide, thus making
	them unavailable to other legitimate AS in subsequent requests. In order to prevent this,
	it is strongly adviced for MRB implementations to generate very hard to replicate session identifiers,
	in order to minimize the chances malicious users could gain access to valid ones just guessing or by means of
	brute force attacks. It is very important, of course, to also secure the way these identifiers are transported
	by the involved parties, both in requests and responses, in order to prevent network attackers from
	intercepting Consumer messages and have access to session IDs.  The Consumer interface uses either the Hypertext
	Transfer Protocol (HTTP) or Session Initiation Protocol (SIP) as the mechanism
	for clients to connect to an MRB to request media resources.  In the case of the HTTP use, any binding using the Consumer
	interface MUST be capable of being transacted over TLS, as described in
	<xref target="RFC2818">RFC 2818</xref>. 
	In the case of the SIP use, the same security considerations included in the Media Control
	Channel Framework specification apply here to protect interactions between a client
	requesting media resources and an MRB.</t>
	
	<t>Should a valid session ID be compromised somehow (that is, intercepted or just guessed by a
	malicious user), as a further means to prevent disruption, the Consumer interface also envisages the use
	of a sequence number in its transactions.  This sequence number is to be increased
	after each successful transaction, starting from a first value randomly generated by the MRB
	when the session is first created, and must match in every request/response.  While this adds
	complexity to the protocol (implementations must pay attention to those sequence numbers, since
	wrong values will cause "Wrong sequence number" errors and the failure of the related requests),
	it is an important added value for security. In fact, considering different transaction related to the same
	session could be transported in different, unrelated HTTP messages (or SIP INVITEs
	in case the Inline mode is being used), this sequence number
	protection prevents the chances of session replication or disruption, especially in
	cases where the session ID has been compromised: that is, it should make it harder to malicious
	users to manipulate or remove a session they guessed the ID of.  As such, it is strongly
	adviced that MRB don't choose 1 as the first sequence number for a new session, but rather
	pick a random value to start from. The reaction to out of sequence transactions is left to
	MRB implementations: a related error code is available, but implementations may decide to
	enforce further limitations or actions upon the receival of too many failed attempts in a row, or
	of what looks like blatant attempts to guess what the current, valid sequence number is.</t>
	
	<t>It is also worth noting that in In-line mode (both IAMM and IUMM) the MRB
	may act as a Back-to-Back User Agent (B2BUA). This means that, as a B2BUA, the
	MRB may happen to modify SIP bodies: it is the case, for instance, of the IAMM
	handling multipart/mixed payloads. This impacts the ability to use any SIP
	security feature that protects the body (e.g., RFC4474, s/mime, etc.) unless
	the MRB intermediates the security association. This should be taken into
	account when implementing an MRB compliant with this specification.</t>
	
	<t>Both the Publishing and Consumer interface may address the location of a MS: the
	Publishing interface may be used to make the MRB know where a MS is located
	(approximately or precisely), and the Consumer interface to ask for a MS
	located somewhere in particular (e.g., a conference bridge close to San Francisco).
	ThisAs such, both MS and MRB implementors need to take this into account
	when deciding whether or not make this location information available, and if so
	how much bits of information really need to be made available for brokering purposes.</t>
	
	<t>Finally, it is worthwhile to also discuss authorization issues related
	to the specification. Neither the Publishing nor the Consumer interface
	provide an explicit means for implementing authentication, i.e., they
	do not envisage protocol messages to make sure, for instance, that
	only authorized Application Servers can make use of the services provided
	by a MRB. Nevertheless, considering both the interfaces are transported
	in well-established protocols (HTTP, SIP, CFW), support for such an
	functionality can be expressed by means of the authentication mechanisms
	provided by the protocol themselves. Therefore, any
	MRB-aware entity (Application Servers, Media Servers, Media Resource
	Brokers themselves) MUST support the HTTP and SIP Digest access
	authentication. That said, the usage of such Digest access authentications
	is recommended and not mandatory, which means MRB-aware entities MAY
	exploit it in deployment.</t>
		
	<t>A MRB may want to enforce further constraints on the interactions between an AS/MS and a MRB.
	For instance, it may choose to only accept requests associated with a specific session ID
	from the IP address that originated the first request, or just make use of pre-shared certificates
	to assess the identity of legitimate AS and/or MS.</t>
	
</section>

<!-- Security Consideration -->

<section anchor="sec:IANA_Considerations" title="IANA Considerations">

	<t>There are several IANA considerations associated with this specification.</t>

	<section anchor="sec:IANA_Package" title="Media Control Channel Framework Package Registration">

   <t>This section registers a new Media Control Channel Framework package,
   per the instructions in Section 13.1 of
   <xref target="RFC6230"/>.</t>

	<t>
	<list style="hanging">

      <t hangText="Package Name: ">mrb-publish/1.0</t>
      <t hangText="Published Specification(s): ">RFCXXXX</t>
      <t hangText="Person and email address to contact for further information: ">
      IETF, MEDIACTRL working group, (mediactrl@ietf.org),
      Chris Boulton (chris@ns-technologies.com).
        [NOTE TO IANA/RFC-EDITOR: Please replace XXXX
        with the RFC number for this specification.]</t>
	</list>
	</t>

	</section>

	<section anchor="sec:IANA_Publish" title="application/mrb-publish+xml Media Type">

	<t>
	<list style="hanging">

		<t hangText="To: ">application</t>
		<t hangText="Subject: ">Registration of media type application/mrb-publish+xml</t>
		
		<t hangText="Type name: ">application</t>

 		<t hangText="Subtype name: ">mrb-publish+xml</t>

 		<t hangText="Required parameters: ">none</t>

 		<t hangText="Optional parameters: ">Same as charset parameter of application/xml as
 specified in RFC 3023 <xref target="RFC3023"/>.</t>

 		<t hangText="Encoding considerations: ">Same as encoding considerations of
 application/xml as specified in RFC 3023 <xref target="RFC3023"/>.</t>

 		<t hangText="Security considerations: ">See Section 10 of RFC 3023 <xref target="RFC3023"/> and
 <xref target="sec:security"/> of RFCXXXX [[NOTE TO RFC-EDITOR/IANA: Please replace
 XXXX with the RFC number of this specification.]].</t>

 		<t hangText="Interoperability considerations: ">none.</t>

 		<t hangText="Published specification: "><xref target="sec:publisher_xml"/> of
			RFCXXXX [[NOTE TO RFC-EDITOR/IANA: Please replace XXXX with the RFC
			number of this specification.]].</t>

 		<t hangText="Applications which use this media type: ">This document type has
 been used to support a Media Resource Broker (MRB) entity.</t>

 		<t hangText="Additional Information:"></t>

 		<t hangText="Magic Number: ">None</t>

 		<t hangText="File Extension: ">.xdf</t>

 		<t hangText="Macintosh file type code: ">&quot;TEXT&quot;</t>

 		<t hangText="Personal and email address for further information: ">Chris Boulton &lt;chris at ns-technologies.com&gt;</t>

 		<t hangText="Intended usage: COMMON"></t>

 		<t hangText="Author/Change controller: ">The IETF.</t>

	</list>
	</t>

	</section>

	<!-- IANA Publish -->

	<section anchor="sec:IANA_Consumer" title="application/mrb-consumer+xml MIME Type">


	<t>
	<list style="hanging">

		<t hangText="To: ">application</t>
		<t hangText="Subject: ">Registration of media type application/mrb-consumer+xml</t>
		
		<t hangText="Type name: ">application</t>

 		<t hangText="Subtype name: ">mrb-consumer+xml</t>

 		<t hangText="Mandatory parameters: ">none</t>

 		<t hangText="Optional parameters: ">Same as charset parameter of application/xml as
 specified in RFC 3023 <xref target="RFC3023"/>.</t>

 		<t hangText="Encoding considerations: ">Same as encoding considerations of
 application/xml as specified in RFC 3023 <xref target="RFC3023"/>.</t>

 		<t hangText="Security considerations: ">See Section 10 of RFC 3023 <xref target="RFC3023"/> and
 <xref target="sec:security"/> of RFCXXXX [[NOTE TO RFC-EDITOR/IANA: Please replace
 XXXX with the RFC number of this specification.]].</t>

 		<t hangText="Interoperability considerations: ">none.</t>

 		<t hangText="Published specification: "><xref target="sec:consumer_xml"/> of
			RFCXXXX [[NOTE TO RFC-EDITOR/IANA: Please replace XXXX with the RFC
			number of this specification.]].</t>

 		<t hangText="Applications which use this media type: ">This document type has
 been used to support a Media Resource Broker (MRB) entity.</t>

 		<t hangText="Additional Information:"></t>

 		<t hangText="Magic Number: ">None</t>

 		<t hangText="File Extension: ">.xdf</t>

 		<t hangText="Macintosh file type code: ">&quot;TEXT&quot;</t>

 		<t hangText="Personal and email address for further information: ">Chris Boulton &lt;chris at ns-technologies.com&gt;</t>

 		<t hangText="Intended usage: COMMON"></t>

 		<t hangText="Author/Change controller: ">The IETF.</t>

	</list>
	</t>

	</section>

	<!-- IANA Consumer -->

	<section anchor="sec:IANA_mrbpub" title="URN Sub-Namespace Registration for mrb-publish">
<t>
   Please register the URN name space "urn:ietf:params:xml:ns:mrb-publish", with the ID of "mrb-publish".  The schema of the XML namespace named
urn:ietf:params:xml:ns:mrb-publish" is <xref target="sec:publisher_xml"/>.
</t>
	</section>

	<!-- IANA MrbPub -->

	<section anchor="sec:IANA_mrbcons" title="URN Sub-Namespace Registration for mrb-consumer">
<t>
   Please register the URN name space "urn:ietf:params:xml:ns:mrb-consumer", with the ID of "mrb-consumer".  The schema of the XML namespace named
urn:ietf:params:xml:ns:mrb-consumer" is in <xref target="sec:consumer_xml"/>.
</t>
	</section>

	<!-- IANA MrbCons -->

	<section anchor="sec:IANA_PubSchema" title="XML Schema Registration for mrb-publish">

	<t>Please register the schema for mrb-publish:</t>

	<t>
	<list style="hanging">

		<t hangText="URI: ">urn:ietf:params:xml:schema:mrb-publish</t>
		<t hangText="ID: ">mrb-publish</t>
		<t hangText="Filename: ">mrb-publish</t>
		<t hangText="Registrant Contact: ">IETF, MEDIACTRL working group (mediactrl@ietf.org)</t>
		<t hangText="Schema: ">The XML for the schema is in <xref target="sec:publisher_xml"/> of this document.</t>

	</list>
	</t>
	
	</section>

	<!-- IANA Publisher Schema -->

	<section anchor="sec:IANA_ConsSchema" title="XML Schema Registration for mrb-consumer">

	<t>Please register the schema for mrb-consumer:</t>
	
	<t>
	<list style="hanging">

		<t hangText="URI: ">urn:ietf:params:xml:schema:mrb-consumer</t>
		<t hangText="ID: ">mrb-consumer</t>
		<t hangText="Filename: ">mrb-consumer</t>
		<t hangText="Registrant Contact: ">IETF, MEDIACTRL working group (mediactrl@ietf.org)</t>
		<t hangText="Schema: ">The XML for the schema is in <xref target="sec:consumer_xml"/> of this document.</t>

	</list>
	</t>
	
	</section>

	<!-- IANA Publisher Schema -->

</section>

<!-- IANA Considerations -->

<section title="Changes">


<t>Note to RFC Editor:  Please remove this whole section.</t>

<section title="Changes from 12 Version">

  <t>
	<list style="symbols">
		<t>Several changes and clarifications according to the AD review by Robert Sparks.</t>
		<t>Updated reference for mixer draft (RFC6505).</t>
	</list>
  </t>
  </section>
<section title="Changes from 11 Version">

  <t>
	<list style="symbols">
		<t>Fixed a wrong reference to RFC5707 (because of a typo this was RFC5705).</t>
		<t>Changed the registration in 13.1 to match the template required by RFC6230.</t>
		<t>Fixed the incorrect URIs for registering the schemas in Sections 13.6 and 13.7.</t>
		<t>Removed enumeration types for 'dtmf-type', 'vxml-mode' and 'stream-mode' from both the schemas
		to allow for better extensibility, and clarified values are case insensitive where needed.</t>
		<t>Clarified that the use of the civic location of a media server is entirely optional, and it's
		implementation specific to fill it with just the details each implementor deems necessary for
		any optimization that may be needed.</t>
	</list>
  </t>
  </section>
<section title="Changes from 10 Version">

  <t>
	<list style="symbols">
		<t>Editorial changes as a result of Shepherd review.</t>
		<t>Added new attribute 'id' to both &lt;mediaResourceRequest> and &lt;mediaResourceResponse> elements in the consumer schema, in order to map a response to a specific request.</t>
		<t>Renamed 'supported-actions' to 'supported-action' in the Publisher schema.</t>
		<t>Removed 'support' attribute from both the &lt;vxml-support> element (Publisher schema) and the &lt;vxml> element (Consumer schema): now an empty element means no VXML support is provided/requested.</t>
		<t>Clarified the scope of the 'application-data' element, and changed its type from xsd:NMTOKEN to xsd:string in the schema.</t>
		<t>Clarified the use of the &lt;subscription> element in an &lt;mrbresponse.</t>
		<t>Clarified the meaning of TCP CONNECTION in sequence diagrams.</t>
		<t>Removed useless backslashes from XML examples.</t>
		<t>Updated references for Framework and IVR drafts (RFC6230, RFC6231).</t>
	</list>
  </t>
  </section>

<section title="Changes from 09 Version">

  <t>
	<list style="symbols">
		<t>Language changes as a result of Shepherd review.</t>
	</list>
  </t>
  </section>

<section title="Changes from 08 Version">

  <t>
	<list style="symbols">
		<t>Fixed Nits.</t>
		<t>Added range for reporting period - as per mailing list.</t>
	</list>
  </t>
  </section>


<section title="Changes from 07 Version">

  <t>
	<list style="symbols">
		<t>Corrected some errors in the Consumer schema: a few elements were not declared
		optional as they should have been, and some were incorrectly defined as
		choices instead of sequences;</t>
		<t>Corrected examples after validation tests;</t>
		<t>Fixed a few typos in the text.</t>
		<t>Clarified language in various places.</t>
		<t>Added 'Multi-modal MRB Implementations' section.</t>
		<t>Added 'Relative Merits of Query Mode, IAMM, and IUMM' section.</t>
		<t>Clarifying text related to IAMM and IUMM.</t>
		<t>Expanded media-server-address for extra information and to allow multiples.</t>
		<t>New B2BUA section.</t>
		<t>Updated Examples.</t>
	</list>
  </t>
  </section>

<section title="Changes from 06 Version">

  <t>
	<list style="symbols">
		<t>Added the missing &lt;encoding&gt; and &lt;decoding&gt; elements to the &lt;rtp-codec&gt; instances, where needed.</t>
		<t>Fixed a few typos in the text.</t>
	</list>
  </t>
  </section>

<section title="Changes from 05 Version">

  <t>
	<list style="symbols">
		<t>Clarifier that video layouts may refer to either XCON-defined layouts or others.</t>
		<t>Added RFC4240 as an option for VXML support.</t>
		<t>Fixed a few typos in the text and in the schemas.</t>
	</list>
  </t>
  </section>

<section title="Changes from 04 Version">

  <t>
	<list style="symbols">
		<t>Corrected some typos and leftovers in both 'session-info' and
		'response-session-info' definitions.</t>
		<t>Clarified that 'response-session-info' is not only included
		in reply to updates, but also to new requests; besides, clarified
		that it is an optional element, in the sense that it is mandatory
		in successful responses (200), while not needed otherwise (any
		error).</t>
		<t>Corrected the Query example flow which included a 'session'info'
		in a new request.</t>
	</list>
  </t>
  </section>

<section title="Changes from 03 Version">

  <t>
	<list style="symbols">
		<t>Addressed comments per the Expert RAI Review by Ben Campbell.</t>
		<t>Several editorial changes (fixes, typos, nits).</t>
		<t>Removed the 3xx class responses for the IAMM, per discussion in Anaheim (feature had been added in the -02 version).</t>
		<t>Clarified that backslashes and XML indentation in the Examples are only provided for readability.</t>
		<t>Clarified the distinction between 'deactivated' and 'unavailable'.</t>
		<t>Added text to the status codes in both Publish and Consumer responses, in order to clarify when they are involved.</t>
		<t>Added some text to better clarify the role of leasing in the Consumer interface.</t>
		<t>Added additional IANA considerations, that were missing in the previous versions of the document.</t>
		<t>Added text to the security considerations.</t>
	</list>
  </t>
  </section>

<section title="Changes from 02 Version">

  <t>
	<list style="symbols">
		<t>Added examples in <xref target="sec:Examples"/>.</t>	
		<t>Fixed some nits in the schemas (encryption and required mixed=true elements).</t>
		<t>Completed review nit review comments from Gary Munson.</t>	
	</list>
  </t>
  </section>

<section title="Changes from 01 Version">

  <t>
	<list style="symbols">
		<t>Added description of lease mechanism.</t>	
		<t>Added specific HTTP and SIP usage of Consumer interface.</t>	
		<t>Completed Publish interface schema + associated text.</t>
		<t>Included Consumer interface schema + associated text.</t>
		<t>Included supported-packages element.</t>
		<t>Removed announce-var element from doc.</t>
		<t>Expanded Abstract.</t>
		<t>General scrub of text - input from Simon Romano.</t>
		<t>Added IANA Considerations section.</t>
		<t>Added Security Considerations section.</t>
	  </list>
  </t>
  </section>

<section title="Changes from 00 Version">

	<t>
	<list style="symbols">
		<t>Included In-line text based on strawman proposal.</t>
		<t>Included first attempt at publish interface based on design team work.</t>
	  </list>
  </t>
  </section>

</section>

<!-- Changes -->


<section title="Acknowledgements">

	<t>The authors would like to thank the members of the Publish Interface design team who provided valuable
	input into this document.  The design team consisted of Adnan Saleem, Michael Trank,
	Victor Paulsamy, Martin Dolly, and Scott McGlashan.  The authors would also like to thank John Dally,
	Bob Epley, Simon Romano, Henry Lum, Christian Groves and Jonathan Lennox for input into this specification.</t>
	
	<t>Ben Campbell carried out the RAI expert review on the -03 specification
	and provided a great deal of invaluable input.</t>

</section>

<!-- Acknowledgements -->

	</middle>

	<!-- Middle -->

	<back>
		
	  <references title="Normative References">
     		<?rfc include="reference.RFC.2119"?>
     		<?rfc include="reference.RFC.2616"?>
     		<?rfc include="reference.RFC.2046"?>
     		<?rfc include="reference.RFC.3023"?>
     		<?rfc include="reference.RFC.3261"?>
     		<?rfc include="reference.RFC.3311"?>
		<?rfc include="reference.RFC.3711"?>
		<?rfc include="reference.RFC.5139"?>
     		<?rfc include="reference.ISO.639.1988"?>
			  <reference anchor="ITU-T.Q.1950">
				<front>
				  <title>Call Bearer Control (CBC) Protocol</title>
				  <author>
					<organization>International Telecommunication Union - Telecommunication Standardization Bureau</organization>
				  </author>
				</front>
				<seriesInfo name="ITU-T" value="Recommendation Q.1950"/>
			  </reference>

			  <reference anchor="ISO.3166-1">
				<front>
				  <title>Codes for the representation of names of countries and their subdivisions - Part 1: Country codes</title>
				  <author>
					<organization>International Organization for Standardization</organization>
				  </author>
				  <date year="1997"/>
				</front>
				<seriesInfo name="ISO" value="Standard 3166-1:1997"/>
			  </reference>
    		<?rfc include="reference.W3C.CR-wsdl20-20051215"?>
      		<?rfc include="reference.W3C.REC-soap12-part1-20030624"?>
       		<?rfc include="reference.W3C.REC-soap12-part2-20030624"?>
	  </references>

	  <references title="Informative References">
     		<?rfc include="reference.RFC.2818"?>
			<?rfc include="reference.RFC.5022"?>
       		<?rfc include="reference.RFC.4240"?>
       		<?rfc include="reference.RFC.6381"?>
       		<?rfc include="reference.RFC.4733"?>
       		<?rfc include="reference.RFC.5167"?>
			<?rfc include="reference.RFC.5707"?>
       		<?rfc include="reference.RFC.5552"?>
       		<?rfc include="reference.RFC.5567"?>
       		<?rfc include="reference.RFC.6230"?>
		<?rfc include="reference.RFC.6231"?>
		<?rfc include="reference.RFC.6505"?>
    	  </references>

  	</back>

	<!-- Back -->

</rfc>
