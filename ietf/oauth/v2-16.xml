<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<rfc category='std' ipr='trust200902' obsoletes='5849' docName='draft-ietf-oauth-v2-16'>
  <?rfc strict='yes' ?>
  <?rfc toc='yes' ?>
  <?rfc tocdepth='2' ?>
  <?rfc symrefs='yes' ?>
  <?rfc sortrefs='yes' ?>
  <?rfc compact='yes' ?>
  <?rfc subcompact='yes' ?>

  <front>
    <title abbrev='OAuth 2.0'>The OAuth 2.0 Authorization Protocol</title>

    <author fullname='Eran Hammer-Lahav' surname='Hammer-Lahav' initials='E' role='editor'>
      <organization>Yahoo!</organization>
      <address>
        <email>eran@hueniverse.com</email>
        <uri>http://hueniverse.com</uri>
      </address>
    </author>
    <author fullname='David Recordon' surname='Recordon' initials='D'>
      <organization>Facebook</organization>
      <address>
        <email>dr@fb.com</email>
        <uri>http://www.davidrecordon.com/</uri>
      </address>
    </author>
    <author fullname='Dick Hardt' surname='Hardt' initials='D'>
      <organization>Microsoft</organization>
      <address>
        <email>dick.hardt@gmail.com</email>
        <uri>http://dickhardt.org/</uri>
      </address>
    </author>

    <date year='2011' />

    <abstract>
      <t>
        The OAuth 2.0 authorization protocol enables a third-party application to obtain limited
        access to an HTTP service, either on behalf of an end-user by orchestrating an approval
        interaction between the end-user and the HTTP service, or by allowing the third-party
        application to obtain access on its own behalf.
      </t>
    </abstract>
  </front>

  <middle>

    <section title='Introduction'>
      <t>
        In the traditional client-server authentication model, the client accesses a protected
        resource on the server by authenticating with the server using the resource owner's
        credentials. In order to provide third-party applications access to protected resources,
        the resource owner shares its credentials with the third-party. This creates several
        problems and limitations:
      </t>
      <t>
        <list style='symbols'>
          <t>
            Third-party applications are required to store the resource-owner's credentials
            for future use, typically a password in clear-text.
          </t>
          <t>
            Servers are required to support password authentication, despite the security
            weaknesses created by passwords.
          </t>
          <t>
            Third-party applications gain overly broad access to the resource-owner's protected
            resources, leaving resource owners without any ability to restrict duration or access
            to a limited subset of resources.
          </t>
          <t>
            Resource owners cannot revoke access to an individual third-party without revoking
            access to all third-parties, and must do so by changing their password.
          </t>
        </list>
      </t>
      <t>
        OAuth addresses these issues by introducing an authorization layer and separating the role
        of the client from that of the resource owner. In OAuth, the client requests access to
        resources controlled by the resource owner and hosted by the resource server, and is issued
        a different set of credentials than those of the resource owner.
      </t>
      <t>
        Instead of using the resource owner's credentials to access protected resources, the client
        obtains an access token - a string denoting a specific scope, duration, and other access
        attributes. Access tokens are issued to third-party clients by an authorization server with
        the approval of the resource owner. The client uses the access token to access the
        protected resources hosted by the resource server.
      </t>
      <t>
        For example, a web end-user (resource owner) can grant a printing service (client) access
        to her protected photos stored at a photo sharing service (resource server), without
        sharing her username and password with the printing service. Instead, she authenticates
        directly with a server trusted by the photo sharing service (authorization server) which
        issues the printing service delegation-specific credentials (access token).
      </t>
      <t>
        This specification is designed for use with HTTP <xref target='RFC2616' />. The use of
        OAuth with any transport protocol other than HTTP is undefined.
      </t>

      <section title='Roles'>
        <t>
          OAuth includes four roles working together to grant and provide access to protected
          resources - access restricted resources which require authentication to access:
        </t>
        <t>
          <list style='hanging'>
            <t hangText='resource owner'>
              <vspace />
              An entity capable of granting access to a protected resource. When the resource owner
              is a person, it is referred to as an end-user.
            </t>
            <t hangText='resource server'>
              <vspace />
              The server hosting the protected resources, capable of accepting and responding to
              protected resource requests using access tokens.
            </t>
            <t hangText='client'>
              <vspace />
              An application making protected resource requests on behalf of the resource owner and
              with its authorization.
            </t>
            <t hangText='authorization server'>
              <vspace />
              The server issuing access tokens to the client after successfully authenticating the
              resource owner and obtaining authorization.
            </t>
          </list>
        </t>
        <t>
          The interaction between the authorization server and resource server is beyond the scope
          of this specification. The authorization server may be the same server as the resource
          server or a separate entity. A single authorization server may issue access tokens
          accepted by multiple resource servers.
        </t>
      </section>

      <section title='Protocol Flow'>
        <t>
          When interacting with the authorization server, the client identifies itself using a set
          of client credentials which include a client identifier and other authentication
          attributes. The means through which the client obtains its credentials are beyond the
          scope of this specification, but typically involve registration with the authorization
          server.
        </t>
        <figure title='Abstract Protocol Flow' anchor='Figure-1'>
          <artwork>
            <![CDATA[
  +--------+                               +---------------+
  |        |--(A)- Authorization Request ->|   Resource    |
  |        |                               |     Owner     |
  |        |<-(B)-- Authorization Grant ---|               |
  |        |                               +---------------+
  |        |
  |        |        Authorization Grant &  +---------------+
  |        |--(C)--- Client Credentials -->| Authorization |
  | Client |                               |     Server    |
  |        |<-(D)----- Access Token -------|               |
  |        |                               +---------------+
  |        |
  |        |                               +---------------+
  |        |--(E)----- Access Token ------>|    Resource   |
  |        |                               |     Server    |
  |        |<-(F)--- Protected Resource ---|               |
  +--------+                               +---------------+
]]>
          </artwork>
        </figure>
        <t>
          The abstract flow illustrated in <xref target='Figure-1' /> describes the interaction
          between the four roles and includes the following steps:
        </t>
        <t>
          <list style='format (%C)'>
            <t>
              The client requests authorization from the resource owner. The authorization request
              can be made directly to the resource owner (as shown), or preferably indirectly via
              an intermediary such as an authorization server.
            </t>
            <t>
              The client receives an authorization grant which represents the authorization
              provided by the resource owner. The authorization grant type depends on the method used by
              the client and supported by the authorization server to obtain it.
            </t>
            <t>
              The client requests an access token by authenticating with the authorization server
              using its client credentials (prearranged between the client and authorization
              server) and presenting the authorization grant.
            </t>
            <t>
              The authorization server validates the client credentials and the authorization grant, and
              if valid issues an access token.
            </t>
            <t>
              The client requests the protected resource from the resource server and authenticates
              by presenting the access token.
            </t>
            <t>
              The resource server validates the access token, and if valid, serves the request.
            </t>
          </list>
        </t>
      </section>

      <section title='Access Token'>
        <t>
          An access token is a string representing an authorization issued to the client. The
          string is usually opaque to the client. Tokens represent specific scopes and durations of
          access, granted by the resource owner, and enforced by the resource server and
          authorization server.
        </t>
        <t>
          The token may denote an identifier used to retrieve the authorization information, or
          self-contain the authorization information in a verifiable manner (i.e. a token string
          consisting of some data and a signature). Additional authentication credentials may be
          required in order for the client to use a token.
        </t>
        <t>
          The access token provides an abstraction layer, replacing different authorization
          constructs (e.g. username and password) with a single token understood by the resource
          server. This abstraction enables issuing access tokens more restrictive than the
          authorization grant used to obtain them, as well as removing the resource server's need to
          understand a wide range of authentication methods.
        </t>
        <t>
          Access tokens can have different formats, structures, and methods of utilization (e.g.
          cryptographic properties) based on the resource server security requirements. Access token
          attributes and the methods used to access protected resources are beyond the scope of this
          specification and are defined by companion specifications.
        </t>
      </section>

      <section title='Authorization Grant'>
        <t>
          An authorization grant is a general term used to describe the intermediate credentials
          representing the resource owner authorization (to access its protected resources), and
          serves as an abstraction layer. An authorization grant is used by the client to obtain
          an access token.
        </t>
        <t>
          This specification defines four grant types: authorization code, implicit, resource owner
          password credentials, and client credentials, as well as an extensibility mechanism for
          defining additional types.
        </t>

        <section title='Authorization Code'>
          <t>
            The authorization code is obtained by using an authorization server as an intermediary
            between the client and resource owner. Instead of requesting authorization directly
            from the resource owner, the client directs the resource owner to an authorization
            server (via its user-agent as defined in <xref target='RFC2616' />), which in turn
            directs the resource owner back to the client with the authorization code.
          </t>
          <t>
            Before directing the resource owner back to the client with the authorization code, the
            authorization server authenticates the resource owner and obtains authorization.
            Because the resource owner only authenticates with the authorization server, the
            resource owner's credentials are never shared with the client.
          </t>
          <t>
            The authorization code provides a few important security benefits such as the ability to
            authenticate the client and issuing the access token directly to the client without
            potentially exposing it to others, including the resource owner.
          </t>
        </section>

        <section title='Implicit'>
          <t>
            When an access token is issued to the client directly as the result of the resource
            owner authorization, without an intermediary authorization grant (such as an
            authorization code), the grant is considered implicit.
          </t>
          <t>
            When issuing an implicit grant, the authorization server cannot verify the identity of
            the client, and the access token may be exposed to the resource owner or other
            applications with access to the resource owner's user-agent.
          </t>
          <t>
            Implicit grants improve the responsiveness and efficiency of some clients (such as a
            client implemented as an in-browser application) since it reduces the number of round
            trips required to obtain an access token.
          </t>
        </section>

        <section title="Resource Owner Password Credentials">
          <t>
            The resource owner password credentials (e.g. a username and password) can be used
            directly as an authorization grant to obtain an access token. The credentials should
            only be used when there is a high degree of trust between the resource owner and the
            client (e.g. its computer operating system or a highly privileged application), and
            when other authorization grant types are not available (such as an authorization code).
          </t>
          <t>
            Even though this grant type requires direct client access to the resource owner
            credentials, the resource owner credentials are used for a single request and are
            exchanged for an access token. Unlike the HTTP Basic authentication scheme defined in
            <xref target='RFC2617' />, this grant type (when combined with a refresh token)
            eliminates the need for the client to store the resource-owner credentials for future
            use.
          </t>
        </section>

        <section title='Client Credentials'>
          <t>
            The client credentials can be used as an authorization grant when the authorization
            scope is limited to the protected resources under the control of the client, or to
            protected resources previously arranged with the authorization server. Client
            credentials are used as an authorization grant typically when the client is acting on
            its own behalf (the client is also the resource owner).
          </t>
        </section>

        <section title='Extensions'>
          <t>
            Additional grant types may be defined to provide a bridge between OAuth and other
            protocols. For example, <xref target='I-D.ietf-oauth-saml2-bearer' /> defines a
            <xref target='OASIS.saml-core-2.0-os'>SAML 2.0</xref> bearer assertion grant type,
            which can be used to obtain an access token.
          </t>
        </section>

      </section>

      <section title='Refresh Token'>
        <t>
          A refresh token is optionally issued by the authorization server to the client together
          with an access token. The client can use the refresh token to request another access
          token based on the same authorization, without having to involve the resource owner
          again, or having to retain the original authorization grant used to obtain the initial
          access token.
        </t>
        <t>
          A refresh token is a string representing the authorization granted to the client by the
          resource owner. The string is usually opaque to the client. The token may denote an
          identifier used to retrieve the authorization information, or self-contain the
          authorization information in a verifiable manner. The refresh token is bound to the
          client it was issued to, and its usage requires client authentication.
        </t>
        <t>
          The refresh token can be used to obtain a new access token when the current access token
          expires (access tokens may have a shorter lifetime than authorized by the resource
          owner), no longer valid, or to obtain additional access tokens with identical or narrower
          scope.
        </t>
        <figure title='Refreshing an Expired Access Token' anchor='Figure-2'>
          <artwork>
            <![CDATA[
  +--------+            Authorization Grant &          +---------------+
  |        |--(A)-------- Client Credentials --------->|               |
  |        |                                           |               |
  |        |<-(B)----------- Access Token -------------|               |
  |        |               & Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |                Refresh Token &            |               |
  |        |--(G)-------- Client Credentials --------->|               |
  |        |                                           |               |
  |        |<-(H)----------- Access Token -------------|               |
  +--------+           & Optional Refresh Token        +---------------+
]]>
          </artwork>
        </figure>
        <t>
          The flow illustrated in <xref target='Figure-2' /> includes the following steps:
        </t>
        <t>
          <list style='format (%C)'>
            <t>
              The client requests an access token by authenticating with the authorization server
              using its client credentials, and presenting an authorization grant.
            </t>
            <t>
              The authorization server validates the client credentials and the authorization
              grant, and if valid issues an access token and a refresh token.
            </t>
            <t>
              The client makes a protected resource requests to the resource server by presenting
              the access token.
            </t>
            <t>
              The resource server validates the access token, and if valid, serves the request.
            </t>
            <t>
              Steps (C) and (D) repeat until the access token expires. If the client knows the
              access token expired, it skips to step (G), otherwise it makes another protected
              resource request.
            </t>
            <t>
              Since the access token is invalid, the resource server returns an invalid token
              error.
            </t>
            <t>
              The client requests a new access token by authenticating with the authorization
              server using its client credentials, and presenting the refresh token.
            </t>
            <t>
              The authorization server validates the client credentials and the refresh token,
              and if valid issues a new access token (and optionally, a new refresh token).
            </t>
          </list>
        </t>
      </section>

      <section title='Document Structure'>
        <t>
          This specification is organized into the following sections:
        </t>
        <t>
          <list style='symbols'>
            <t>
              Section 2 - describes the two endpoints used to obtain and utilize the various
              authorization grant types.
            </t>
            <t>
              Section 3 - describes client identification and authentication in general, and
              provides one such method for client authentication using password credentials.
            </t>
            <t>
              Section 4 - describes the complete flow for each authorization grant type, including
              requesting authorization, authorization response, and requesting an access token.
            </t>
            <t>
              Section 5 - describes the common access token response used for all non-implicit
              authorization grant types.
            </t>
            <t>
              Section 6 - describes the use of a refresh token to obtain additional access tokens
              using the same resource owner authorization.
            </t>
            <t>
              Section 7 - describes how access tokens are used to access protected resources.
            </t>
            <t>
              Section 8 - describes how to extend certain elements of the protocol.
            </t>
            <t>
              Section 9 - provides a security analysis of the protocol.
            </t>
          </list>
        </t>
      </section>

      <section title='Notational Conventions'>
        <t>
          The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL NOT', 'SHOULD', 'SHOULD
          NOT', 'RECOMMENDED', 'MAY', and 'OPTIONAL' in this specification are to be interpreted as
          described in <xref target='RFC2119' />.
        </t>
        <t>
          This specification uses the Augmented Backus-Naur Form (ABNF) notation of
          <xref target='RFC5234' />.
        </t>
        <t>
          Unless otherwise noted, all the protocol parameter names and values are case sensitive.
        </t>
      </section>

    </section>

    <section title='Protocol Endpoints'>
      <t>
        The authorization process utilizes two endpoints (HTTP resources):
      </t>
      <t>
        <list style='symbols'>
          <t>
            Authorization endpoint - used to obtain authorization from the resource owner via
            user-agent redirection.
          </t>
          <t>
            Token endpoint - used to exchange an authorization grant for an access token, typically
            with client authentication.
          </t>
        </list>
      </t>
      <t>
        Not every authorization grant type utilizes both endpoints. Extension grant types MAY
        define additional endpoints as needed.
      </t>

      <section title='Authorization Endpoint'>
        <t>
          The authorization endpoint is used to interact with the resource owner and obtain
          authorization which is expressed explicitly as an authorization code (exchanged for an
          access token), or implicitly by direct issuance of an access token.
        </t>
        <t>
          The authorization server MUST first verify the identity of the resource owner. The way in
          which the authorization server authenticates the resource owner (e.g. username and
          password login, session cookies) is beyond the scope of this specification.
        </t>
        <t>
          The means through which the client obtains the location of the authorization endpoint are
          beyond the scope of this specification but is typically provided in the service
          documentation. The endpoint URI MAY include a query component as defined by
          <xref target='RFC3986' /> section 3, which MUST be retained when adding additional query
          parameters.
        </t>
        <t>
          Since requests to the authorization endpoint result in user authentication and the
          transmission of clear-text credentials (in the HTTP response), the authorization server
          MUST require the use of a transport-layer security mechanism when sending requests to the
          authorization endpoint. The authorization server MUST support TLS 1.2 as defined in
          <xref target='RFC5246' />, and MAY support additional transport-layer mechanisms meeting
          its security requirements.
        </t>
        <t>
          The authorization server MUST support the use of the HTTP <spanx style='verb'>GET</spanx>
          method <xref target='RFC2616' /> for the authorization endpoint, and MAY support the use
          of the <spanx style='verb'>POST</spanx> method as well.
        </t>
        <t>
          The REQUIRED <spanx style='verb'>response_type</spanx> request parameter is used to
          identify which grant type the client is requesting: authorization code or implicit,
          described in <xref target='code-authz-req' /> and <xref target='implicit-authz-req' />
          respectively. If the request is missing the <spanx style='verb'>response_type</spanx>
          parameter, the authorization server SHOULD return an error response as described in
          <xref target='code-authz-error' />.
        </t>
        <t>
          Parameters sent without a value MUST be treated as if they were omitted from the
          request. The authorization server SHOULD ignore unrecognized request parameters.
        </t>
        <t>
          Request and response parameters MUST NOT repeat more than once, unless noted otherwise.
        </t>

        <section title='Redirection URI' anchor='redirect-uri'>
          <t>
            The client directs the resource owner's user-agent to the authorization endpoint and
            includes a redirection URI to which the authorization server will redirect the
            user-agent back once authorization has been obtained (or denied). The client MAY omit
            the redirection URI if one has been established between the client and authorization
            server via other means, such as during the client registration process.
          </t>
          <t>
            The redirection URI MUST be an absolute URI and MAY include a query component, which
            MUST be retained by the authorization server when adding additional query parameters.
          </t>
          <t>
            The authorization server SHOULD require the client to pre-register their redirection
            URI or at least certain components such as the scheme, host, port and path. If a
            redirection URI was registered, the authorization server MUST compare any redirection
            URI received at the authorization endpoint with the registered URI.
          </t>
          <t>
            The authorization server SHOULD NOT redirect the user-agent to unregistered or
            untrusted URIs to prevent the endpoint from being used as an open redirector. If no
            valid redirection URI is available, the authorization server SHOULD inform the
            resource owner directly of the error.
          </t>
        </section>

      </section>

      <section title='Token Endpoint'>
        <t>
          The token endpoint is used by the client to obtain an access token by authenticating with
          the authorization server and presenting its authorization grant or refresh token. The
          token endpoint is used with every authorization grant except for the implicit grant type
          (since an access token is issued directly).
        </t>
        <t>
          The means through which the client obtains the location of the token endpoint are
          beyond the scope of this specification but is typically provided in the service
          documentation. The endpoint URI MAY include a query component, which MUST be retained
          when adding additional query parameters.
        </t>
        <t>
          Since requests to the token endpoint result in the transmission of clear-text credentials
          (in the HTTP request and response), the authorization server MUST require the use of a
          transport-layer security mechanism when sending requests to the token endpoint. The
          authorization server MUST support TLS 1.2 as defined in <xref target='RFC5246' />, and
          MAY support additional transport-layer mechanisms meeting its security requirements.
        </t>
        <t>
          The token endpoint requires client authentication as described in
          <xref target='client-authentication' />. The authorization server MAY accept any form of
          client authentication meeting its security requirements. The client MUST NOT use more
          than one authentication method in each request.
        </t>
        <t>
          The client MUST use the HTTP <spanx style='verb'>POST</spanx> method when making access
          token requests.
        </t>
        <t>
          Parameters sent without a value MUST be treated as if they were omitted from the
          request. The authorization server SHOULD ignore unrecognized request parameters.
        </t>
        <t>
          Request and response parameters MUST NOT repeat more than once, unless noted otherwise.
        </t>
      </section>

    </section>

    <section title='Client Authentication' anchor='client-authentication'>
      <t>
        Client credentials are used to identify and authenticate the client. The client
        credentials include a client identifier - a unique string issued to the client to
        identify itself to the authorization server. The client identifier is not a secret, it is
        exposed to the resource owner, and MUST NOT be used alone for client authentication. Client
        authentication is accomplished via additional means such as a matching client password.
      </t>
      <t>
        The methods through which the client obtains its client credentials are beyond the scope of
        this specification. However, the client registration process typically includes gathering
        relevant information which is used to educate the resource owner about the client when
        requesting authorization.
      </t>
      <t>
        Due to the nature of some clients, the authorization server should not make assumptions
        about the confidentiality of client credentials without establishing trust with the
        client. The authorization server SHOULD NOT issue client credentials to clients incapable
        of keeping their credentials confidential (typically determined during the client
        registration process).
      </t>
      <t>
        In addition, the authorization server MAY allow unauthenticated access token requests
        when the client identity does not matter (e.g. anonymous client) or when the client
        identity is established via other means. For readability purposes only, this specification
        is written under the assumption that the authorization server requires some form of client
        authentication. However, such language does not affect the authorization server's discretion
        in allowing unauthenticated client requests.
      </t>

      <section title='Client Password Authentication'>
        <t>
          [[ Pending Consensus ]]
        </t>
        <t>
          Clients in possession of client password credentials (the client identifier together with
          a shared symmetric secret) MAY use the HTTP Basic authentication scheme as defined in
          <xref target='RFC2617' /> to authenticate with the authorization server. The client
          identifier is used as the username, and the secret is used as the password.
        </t>
        <t>
          When using the HTTP Basic authentication scheme, the client identifier is included twice
          in the request (in the <spanx style='verb'>Authorization</spanx> header and in the
          <spanx style='verb'>client_id</spanx> parameter). The authorization server MUST ensure
          the two identifiers belong to the same client.
        </t>
        <figure>
          <preamble>
            For example (extra line breaks are for display purposes only):
          </preamble>
          <artwork>
            <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
  Content-Type: application/x-www-form-urlencoded

  grant_type=authorization_code&client_id=s6BhdRkqt3&
  code=i1WsRn1uB1&
  redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
]]>
          </artwork>
        </figure>
        <t>
          Alternatively, the authorization server MAY allow including the client secret in the
          request body using the following parameter:
        </t>
        <t>
          <list style='hanging' hangIndent='6'>
            <t hangText='client_secret'>
              <vspace />
              REQUIRED. The client secret.
            </t>
          </list>
        </t>
        <t>
          The use of the <spanx style='verb'>client_secret</spanx> parameter is NOT RECOMMENDED,
          and should be limited to clients unable to directly utilize the HTTP Basic authentication
          scheme.
        </t>
        <figure>
          <preamble>
            For example (extra line breaks are for display purposes only):
          </preamble>
          <artwork>
            <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded

  grant_type=authorization_code&client_id=s6BhdRkqt3&
  client_secret=gX1fBat3bV&code=i1WsRn1uB1&
  redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
]]>
          </artwork>
        </figure>
        <t>
          Since requests using this authentication method result in the transmission of clear-text
          credentials, the authorization server MUST require the use of a transport-layer security
          mechanism when sending requests to the token endpoint.
        </t>
      </section>

      <section title='Other Client Authentication Methods'>
        <t>
          The authorization server MAY support any suitable HTTP authentication scheme matching its
          security requirements. When using other authentication methods, the authorization server
          MUST define a mapping between the client identifier and the credentials used to
          authenticate.
        </t>
      </section>

    </section>

    <section title='Obtaining Authorization'>
      <t>
        To request an access token, the client obtains authorization from the resource owner. The
        authorization is expressed in the form of an authorization grant which the client uses to
        request the access token. OAuth defines four grant types: authorization code, implicit,
        resource owner password credentials, and client credentials. It also provides an extension
        mechanism for defining additional grant types.
      </t>

      <section title='Authorization Code' anchor='grant-code'>
        <t>
          The authorization code grant type is suitable for clients capable of maintaining their
          client credentials confidential (for authenticating with the authorization server) such
          as a client implemented on a secure server. As a redirection-based flow, the client
          must be capable of interacting with the resource owner's user-agent (typically a web
          browser) and capable of receiving incoming requests (via redirection) from the
          authorization server.
        </t>
        <figure title='Authorization Code Flow' anchor='Figure-3'>
          <artwork>
            <![CDATA[
  +----------+
  | resource |
  |   owner  |
  |          |
  +----------+
       ^
       |
      (B)      
  +----|-----+          Client Identifier      +---------------+
  |         -+----(A)--- & Redirect URI ------>|               |
  |  User-   |                                 | Authorization |
  |  Agent  -+----(B)-- User authenticates --->|     Server    |
  |          |                                 |               |
  |         -+----(C)-- Authorization Code ---<|               |
  +-|----|---+                                 +---------------+
    |    |                                         ^      v
   (A)  (C)                                        |      |
    |    |                                         |      |
    ^    v                                         |      |
  +---------+                                      |      |
  |         |>---(D)-- Client Credentials, --------'      |
  |         |          Authorization Code,                |
  | Client  |            & Redirect URI                   |
  |         |                                             |
  |         |<---(E)----- Access Token -------------------'
  +---------+       (w/ Optional Refresh Token)
]]>
          </artwork>
        </figure>
        <t>
          The flow illustrated in <xref target='Figure-3' /> includes the following steps:
        </t>
        <t>
          <list style='format (%C)'>
            <t>
              The client initiates the flow by directing the resource owner's user-agent to the
              authorization endpoint. The client includes its client identifier, requested
              scope, local state, and a redirection URI to which the authorization server will send
              the user-agent back once access is granted (or denied).
            </t>
            <t>
              The authorization server authenticates the resource owner (via the user-agent) and
              establishes whether the resource owner grants or denies the client's access request.
            </t>
            <t>
              Assuming the resource owner grants access, the authorization server redirects the
              user-agent back to the client using the redirection URI provided earlier. The
              redirection URI includes an authorization code and any local state provided by the
              client earlier.
            </t>
            <t>
              The client requests an access token from the authorization server's token endpoint
              by authenticating using its client credentials, and includes the authorization code
              received in the previous step. The client includes the redirection URI used to obtain
              the authorization code for verification.
            </t>
            <t>
              The authorization server validates the client credentials, the authorization code,
              and ensures the redirection URI received matches the URI used to redirect the client
              in step (C). If valid, responds back with an access token.
            </t>
          </list>
        </t>

        <section title='Authorization Request' anchor='code-authz-req'>
          <t>
            The client constructs the request URI by adding the following parameters to the
            query component of the authorization endpoint URI using the
            <spanx style='verb'>application/x-www-form-urlencoded</spanx> format as defined by
            <xref target='W3C.REC-html401-19991224' />:
          </t>
          <t>
            <list style='hanging' hangIndent='6'>
              <t hangText='response_type'>
                <vspace />
                REQUIRED. Value MUST be set to <spanx style='verb'>code</spanx>.
              </t>
              <t hangText='client_id'>
                <vspace />
                REQUIRED. The client identifier as described in
                <xref target='client-authentication' />.
              </t>
              <t hangText='redirect_uri'>
                <vspace />
                REQUIRED, unless a redirection URI has been established between the client and
                authorization server via other means. Described in <xref target='redirect-uri' />.
              </t>
              <t hangText='scope'>
                <vspace />
                OPTIONAL. The scope of the access request expressed as a list of space-delimited,
                case sensitive strings. The value is defined by the authorization server. If the
                value contains multiple space-delimited strings, their order does not matter, and
                each string adds an additional access range to the requested scope.
              </t>
              <t hangText='state'>
                <vspace />
                OPTIONAL. An opaque value used by the client to maintain state between the request
                and callback. The authorization server includes this value when redirecting the
                user-agent back to the client.
              </t>
            </list>
          </t>
          <t>
            The client directs the resource owner to the constructed URI using an HTTP redirection
            response, or by other means available to it via the user-agent.
          </t>
          <figure>
            <preamble>
              For example, the client directs the user-agent to make the following HTTP request
              using transport-layer security (extra line breaks are for display purposes only):
            </preamble>
            <artwork>
              <![CDATA[
  GET /authorize?response_type=code&client_id=s6BhdRkqt3&
      redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
  Host: server.example.com
]]>
            </artwork>
          </figure>
          <t>
            The authorization server validates the request to ensure all required parameters are
            present and valid. If the request is valid, the authorization server authenticates the
            resource owner and obtains an authorization decision (by asking the resource owner or
            by establishing approval via other means).
          </t>
          <t>
            When a decision is established, the authorization server directs the user-agent to the
            provided client redirection URI using an HTTP redirection response, or by other means
            available to it via the user-agent.
          </t>
        </section>

        <section title='Authorization Response'>
          <t>
            If the resource owner grants the access request, the authorization server issues an
            authorization code and delivers it to the client by adding the following parameters to
            the query component of the redirection URI using the
            <spanx style='verb'>application/x-www-form-urlencoded</spanx> format:
          </t>
          <t>
            <list style='hanging' hangIndent='6'>
              <t hangText='code'>
                <vspace />
                REQUIRED. The authorization code generated by the authorization server. The
                authorization code SHOULD expire shortly after it is issued to minimize the risk of
                leaks. The client MUST NOT reuse the authorization code. If an authorization code
                is used more than once, the authorization server MAY revoke all tokens previously
                issued based on that authorization code. The authorization code is bound to the
                client identifier and redirection URI.
              </t>
              <t hangText='state'>
                <vspace />
                REQUIRED if the <spanx style='verb'>state</spanx> parameter was present in the
                client authorization request. Set to the exact value received from the client.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example, the authorization server redirects the user-agent by sending the
              following HTTP response:
            </preamble>
            <artwork>
              <![CDATA[
  HTTP/1.1 302 Found
  Location: https://client.example.com/cb?code=i1WsRn1uB1
]]>
            </artwork>
          </figure>
          <t>
            The client SHOULD ignore unrecognized response parameters. The authorization code
            string size is left undefined by this specification. The client should avoid making
            assumptions about code value sizes. The authorization server should document the size
            of any value it issues.
          </t>

          <section title='Error Response' anchor='code-authz-error'>
            <t>
              If the request fails due to a missing, invalid, or mismatching redirection URI, or if
              the client identifier provided is invalid, the authorization server SHOULD inform the
              resource owner of the error, and MUST NOT redirect the user-agent to the invalid
              redirection URI.
            </t>
            <t>
              If the resource owner denies the access request or if the request fails for reasons
              other than a missing or invalid redirection URI, the authorization server informs the
              client by adding the following parameters to the query component of the redirection
              URI using the <spanx style='verb'>application/x-www-form-urlencoded</spanx> format:
            </t>
            <t>
              <list style='hanging' hangIndent='6'>
                <t hangText='error'>
                  <vspace />
                  REQUIRED. A single error code from the following:

                  <list style='hanging' hangIndent='6'>
                    <t hangText='invalid_request'>
                      <vspace />
                      The request is missing a required parameter, includes an unsupported
                      parameter or parameter value, or is otherwise malformed.
                    </t>
                    <t hangText='unauthorized_client'>
                      <vspace />
                      The client is not authorized to request an authorization code using this
                      method.
                    </t>
                    <t hangText='access_denied'>
                      <vspace />
                      The resource owner or authorization server denied the request.
                    </t>
                    <t hangText='unsupported_response_type'>
                      <vspace />
                      The authorization server does not support obtaining an authorization code
                      using this method.
                    </t>
                    <t hangText='invalid_scope'>
                      <vspace />
                      The requested scope is invalid, unknown, or malformed.
                    </t>
                    <t hangText='a 4xx or 5xx HTTP status code (except for 400 and 401)'>
                      <vspace />
                      The authorization server MAY set the <spanx style='verb'>error</spanx>
                      parameter value to a numerical HTTP status code from the 4xx or 5xx range, with
                      the exception of the 400 (Bad Request) and 401 (Unauthorized) status codes.
                      For example, if the service is temporarily unavailable, the authorization
                      server MAY return an error response with <spanx style='verb'>error</spanx>
                      set to <spanx style='verb'>503</spanx>.
                    </t>
                  </list>
                </t>
                <t hangText='error_description'>
                  <vspace />
                  OPTIONAL. A human-readable text providing additional information, used to assist
                  in the understanding and resolution of the error occurred. [[ add language and
                  encoding information ]]
                </t>
                <t hangText='error_uri'>
                  <vspace />
                  OPTIONAL. A URI identifying a human-readable web page with information about the
                  error, used to provide the resource owner with additional information about the
                  error.
                </t>
                <t hangText='state'>
                  <vspace />
                  REQUIRED if a valid <spanx style='verb'>state</spanx> parameter was present in the
                  client authorization request. Set to the exact value received from the client.
                </t>
              </list>
            </t>
            <figure>
              <preamble>
                For example, the authorization server redirects the user-agent by sending the
                following HTTP response:
              </preamble>
              <artwork>
                <![CDATA[
  HTTP/1.1 302 Found
  Location: https://client.example.com/cb?error=access_denied
]]>
              </artwork>
            </figure>
          </section>

        </section>

        <section title='Access Token Request'>
          <t>
            The client makes a request to the token endpoint by adding the following parameters
            using the <spanx style='verb'>application/x-www-form-urlencoded</spanx> format in the
            HTTP request entity-body:
          </t>
          <t>
            <list style='hanging' hangIndent='6'>
              <t hangText='grant_type'>
                <vspace />
                REQUIRED. Value MUST be set to <spanx style='verb'>authorization_code</spanx>.
              </t>
              <t hangText='client_id'>
                <vspace />
                REQUIRED. The client identifier as described in
                <xref target='client-authentication' />.
              </t>
              <t hangText='code'>
                <vspace />
                REQUIRED. The authorization code received from the authorization server.
              </t>
              <t hangText='redirect_uri'>
                <vspace />
                REQUIRED. The redirection URI used by the authorization server to return the
                authorization response in the previous step.
              </t>
            </list>
          </t>
          <t>
            The client includes its authentication credentials as described in
            <xref target='client-authentication' />
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTP using transport-layer security
              (extra line breaks are for display purposes only):
            </preamble>
            <artwork>
              <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
  Content-Type: application/x-www-form-urlencoded

  grant_type=authorization_code&client_id=s6BhdRkqt3&
  code=i1WsRn1uB1&
  redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
]]>
            </artwork>
          </figure>
          <t>
            The authorization server MUST:
          </t>
          <t>
            <list style='symbols'>
              <t>
                Validate the client credentials and ensure that the authorization code was issued
                to that client.
              </t>
              <t>
                Verify that the authorization code is valid, and that the redirection URI matches
                the redirection URI used by the authorization server to deliver the authorization
                code.
              </t>
            </list>
          </t>
        </section>

        <section title='Access Token Response'>
          <t>
            If the access token request is valid and authorized, the authorization server issues an
            access token and optional refresh token as described in <xref target='token-response' />.
            If the request client authentication failed or is invalid, the authorization server returns
            an error response as described in <xref target='token-errors' />.
          </t>
          <figure>
            <preamble>
              An example successful response:
            </preamble>
            <artwork>
              <![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/json
  Cache-Control: no-store

  {
    "access_token":"SlAV32hkKG",
    "token_type":"example",
    "expires_in":3600,
    "refresh_token":"8xLOxBtZp8",
    "example_parameter":"example_value"
  }
]]>
            </artwork>
          </figure>
        </section>

      </section>

      <section title='Implicit Grant' anchor='grant-implicit'>
        <t>
          The implicit grant type is suitable for clients incapable of maintaining their
          client credentials confidential (for authenticating with the authorization server) such
          as client applications residing in a user-agent, typically implemented in a browser using
          a scripting language such as JavaScript.
        </t>
        <t>
          As a redirection-based flow, the client must be capable of interacting with the
          resource owner's user-agent (typically a web browser) and capable of receiving incoming
          requests (via redirection) from the authorization server.
        </t>
        <t>
          Unlike the authorization code grant type in which the client makes separate requests for
          authorization and access token, the client receives the access token as the result of the
          authorization request.
        </t>
        <t>
          Using the implicit grant type does not include client authentication since the client is
          unable to maintain their credential confidentiality (the client resides on the resource
          owner's computer or device which makes the client credentials accessible and
          exploitable). Because the access token is encoded into the redirection URI, it may be
          exposed to the resource owner and other applications residing on its computer or device.
        </t>
        <figure title='Implicit Grant Flow' anchor='Figure-4'>
          <artwork>
            <![CDATA[
  +----------+
  | Resource |
  |  Owner   |
  |          |
  +----------+
       ^
       |
      (B)      
  +----|-----+          Client Identifier     +---------------+
  |         -+----(A)--- & Redirect URI ----->|               |
  |  User-   |                                | Authorization |
  |  Agent  -|----(B)-- User authenticates -->|     Server    |
  |          |                                |               |
  |          |<---(C)---- Redirect URI ------<|               |
  |          |          with Access Token     +---------------+
  |          |            in Fragment
  |          |                                +---------------+
  |          |----(D)---- Redirect URI ------>|   Web Server  |
  |          |          without Fragment      |  with Client  |
  |          |                                |   Resource    |
  |     (F)  |<---(E)------- Script ---------<|               |
  |          |                                +---------------+
  +-|--------+
    |    |    
   (A)  (G) Access Token
    |    |
    ^    v
  +---------+
  |         |
  |  Client |
  |         |
  +---------+
]]>
          </artwork>
        </figure>
        <t>
          The flow illustrated in <xref target='Figure-4' /> includes the following steps:
        </t>
        <t>
          <list style='format (%C)'>
            <t>
              The client initiates the flow by directing the resource owner's user-agent to the
              authorization endpoint. The client includes its client identifier, requested
              scope, local state, and a redirection URI to which the authorization server will send
              the user-agent back once access is granted (or denied).
            </t>
            <t>
              The authorization server authenticates the resource owner (via the user-agent) and
              establishes whether the resource owner grants or denies the client's access request.
            </t>
            <t>
              Assuming the resource owner grants access, the authorization server redirects the
              user-agent back to the client using the redirection URI provided earlier. The
              redirection URI includes the access token in the URI fragment.
            </t>
            <t>
              The user-agent follows the redirection instructions by making a request to the web
              server (does not include the fragment). The user-agent retains the fragment
              information locally.
            </t>
            <t>
              The web server returns a web page (typically an HTML document with an embedded
              script) capable of accessing the full redirection URI including the fragment retained
              by the user-agent, and extracting the access token (and other parameters) contained
              in the fragment.
            </t>
            <t>
              The user-agent executes the script provided by the web server locally, which
              extracts the access token and passes it to the client.
            </t>
          </list>
        </t>

        <section title='Authorization Request' anchor='implicit-authz-req'>
          <t>
            The client constructs the request URI by adding the following parameters to the
            query component of the authorization endpoint URI using the
            <spanx style='verb'>application/x-www-form-urlencoded</spanx> format:
          </t>
          <t>
            <list style='hanging' hangIndent='6'>
              <t hangText='response_type'>
                <vspace />
                REQUIRED. Value MUST be set to <spanx style='verb'>token</spanx>.
              </t>
              <t hangText='client_id'>
                <vspace />
                REQUIRED. The client identifier as described in
                <xref target='client-authentication' />.
              </t>
              <t hangText='redirect_uri'>
                <vspace />
                REQUIRED, unless a redirection URI has been established between the client and
                authorization server via other means. Described in <xref target='redirect-uri' />.
              </t>
              <t hangText='scope'>
                <vspace />
                OPTIONAL. The scope of the access request expressed as a list of space-delimited,
                case sensitive strings. The value is defined by the authorization server. If the
                value contains multiple space-delimited strings, their order does not matter, and
                each string adds an additional access range to the requested scope.
              </t>
              <t hangText='state'>
                <vspace />
                OPTIONAL. An opaque value used by the client to maintain state between the request
                and callback. The authorization server includes this value when redirecting the
                user-agent back to the client.
              </t>
            </list>
          </t>
          <t>
            The client directs the resource owner to the constructed URI using an HTTP redirection
            response, or by other means available to it via the user-agent.
          </t>
          <figure>
            <preamble>
              For example, the client directs the user-agent to make the following HTTP request
              using transport-layer security (extra line breaks are for display purposes only):
            </preamble>
            <artwork>
              <![CDATA[
  GET /authorize?response_type=token&client_id=s6BhdRkqt3&
      redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
  Host: server.example.com
]]>
            </artwork>
          </figure>
          <t>
            The authorization server validates the request to ensure all required parameters are
            present and valid. If the request is valid, the authorization server authenticates the
            resource owner and obtains an authorization decision (by asking the resource owner or
            by establishing approval via other means).
          </t>
          <t>
            When a decision is established, the authorization server directs the user-agent to the
            provided client redirection URI using an HTTP redirection response, or by other means
            available to it via the user-agent.
          </t>
        </section>

        <section title='Access Token Response'>
          <t>
            If the resource owner grants the access request, the authorization server issues an
            access token and delivers it to the client by adding the following parameters to
            the fragment component of the redirection URI using the
            <spanx style='verb'>application/x-www-form-urlencoded</spanx> format:
          </t>
          <t>
            <list style='hanging' hangIndent='6'>
              <t hangText='access_token'>
                <vspace />
                REQUIRED. The access token issued by the authorization server.
              </t>
              <t hangText='token_type'>
                <vspace />
                REQUIRED. The type of the token issued as described in
                <xref target='token-types' />. Value is case insensitive.
              </t>
              <t hangText='expires_in'>
                <vspace />
                OPTIONAL. The duration in seconds of the access token lifetime. For example, the
                value <spanx style='verb'>3600</spanx> denotes that the access token will expire in
                one hour from the time the response was generated.
              </t>
              <t hangText='scope'>
                <vspace />
                OPTIONAL. The scope of the access request expressed as a list of space-delimited,
                case sensitive strings. The value is defined by the authorization server. If the
                value contains multiple space-delimited strings, their order does not matter, and
                each string adds an additional access range to the requested scope. The
                authorization server SHOULD include the parameter if the requested scope is
                different from the one requested by the client.
              </t>
              <t hangText='state'>
                <vspace />
                REQUIRED if the <spanx style='verb'>state</spanx> parameter was present in the
                client authorization request. Set to the exact value received from the client.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example, the authorization server redirects the user-agent by sending the
              following HTTP response (URI extra line breaks are for display purposes only):
            </preamble>
            <artwork>
              <![CDATA[
  HTTP/1.1 302 Found
  Location: http://example.com/rd#access_token=FJQbwq9&
            token_type=example&expires_in=3600
]]>
            </artwork>
          </figure>
          <t>
            The client SHOULD ignore unrecognized response parameters. The access token string size
            is left undefined by this specification. The client should avoid making assumptions
            about value sizes. The authorization server should document the size of any value it
            issues.
          </t>

          <section title='Error Response' anchor='implicit-authz-error'>
            <t>
              If the request fails due to a missing, invalid, or mismatching redirection URI, or if
              the client identifier provided is invalid, the authorization server SHOULD inform the
              resource owner of the error, and MUST NOT redirect the user-agent to the invalid
              redirection URI.
            </t>
            <t>
              If the resource owner denies the access request or if the request fails for reasons
              other than a missing or invalid redirection URI, the authorization server informs the
              client by adding the following parameters to the fragment component of the
              redirection URI using the
              <spanx style='verb'>application/x-www-form-urlencoded</spanx> format:
            </t>
            <t>
              <list style='hanging' hangIndent='6'>
                <t hangText='error'>
                  <vspace />
                  REQUIRED. A single error code from the following:

                  <list style='hanging' hangIndent='6'>
                    <t hangText='invalid_request'>
                      <vspace />
                      The request is missing a required parameter, includes an unsupported
                      parameter or parameter value, or is otherwise malformed.
                    </t>
                    <t hangText='unauthorized_client'>
                      <vspace />
                      The client is not authorized to request an access token using this method.
                    </t>
                    <t hangText='access_denied'>
                      <vspace />
                      The resource owner or authorization server denied the request.
                    </t>
                    <t hangText='unsupported_response_type'>
                      <vspace />
                      The authorization server does not support obtaining an access token using
                      this method.
                    </t>
                    <t hangText='invalid_scope'>
                      <vspace />
                      The requested scope is invalid, unknown, or malformed.
                    </t>
                    <t hangText='a 4xx or 5xx HTTP status code (except for 400 and 401)'>
                      <vspace />
                      The authorization server MAY set the <spanx style='verb'>error</spanx>
                      parameter value to a numerical HTTP status code from the 4xx or 5xx range, with
                      the exception of the 400 (Bad Request) and 401 (Unauthorized) status codes.
                      For example, if the service is temporarily unavailable, the authorization
                      server MAY return an error response with <spanx style='verb'>error</spanx>
                      set to <spanx style='verb'>503</spanx>.
                    </t>
                  </list>
                </t>
                <t hangText='error_description'>
                  <vspace />
                  OPTIONAL. A human-readable text providing additional information, used to assist
                  in the understanding and resolution of the error occurred. [[ add language and
                  encoding information ]]
                </t>
                <t hangText='error_uri'>
                  <vspace />
                  OPTIONAL. A URI identifying a human-readable web page with information about the
                  error, used to provide the resource owner with additional information about the
                  error.
                </t>
                <t hangText='state'>
                  <vspace />
                  REQUIRED if a valid <spanx style='verb'>state</spanx> parameter was present in the
                  client authorization request. Set to the exact value received from the client.
                </t>
              </list>
            </t>
            <figure>
              <preamble>
                For example, the authorization server redirects the user-agent by sending the
                following HTTP response:
              </preamble>
              <artwork>
                <![CDATA[
  HTTP/1.1 302 Found
  Location: https://client.example.com/cb#error=access_denied
]]>
              </artwork>
            </figure>
          </section>

        </section>

      </section>

      <section title='Resource Owner Password Credentials' anchor='grant-password'>
        <t>
          The resource owner password credentials grant type is suitable in cases where the
          resource owner has a trust relationship with the client, such as its computer operating
          system or a highly privileged application. The authorization server should take special
          care when enabling the grant type, and only when other flows are not viable.
        </t>
        <t>
          The grant type is suitable for clients capable of obtaining the resource owner credentials
          (username and password, typically using an interactive form). It is also used to migrate
          existing clients using direct authentication schemes such as HTTP Basic or Digest
          authentication to OAuth by converting the stored credentials with an access token.
        </t>
        <figure title='Resource Owner Password Credentials Flow' anchor='Figure-5'>
          <artwork>
            <![CDATA[
  +----------+
  | Resource |
  |  Owner   |
  |          |
  +----------+
       v
       |
      (A) Password Credentials
       |
       v
  +---------+                                  +---------------+
  |         |          Client Credentials      |               |
  |         |>--(B)---- & Resource Owner ----->|               |
  | Client  |         Password Credentials     | Authorization |
  |         |                                  |     Server    |
  |         |<--(C)---- Access Token ---------<|               |
  |         |    (w/ Optional Refresh Token)   |               |
  +---------+                                  +---------------+
]]>
          </artwork>
        </figure>
        <t>
          The flow illustrated in <xref target='Figure-5' /> includes the following steps:
        </t>
        <t>
          <list style='format (%C)'>
            <t>
              The resource owner provides the client with its username and password.
            </t>
            <t>
              The client requests an access token from the authorization server's token endpoint by
              authenticating using its client credentials, and includes the credentials received
              from the resource owner.
            </t>
            <t>
              The authorization server validates the resource owner credentials and the client
              credentials and issues an access token.
            </t>
          </list>
        </t>

        <section title='Authorization Request and Response'>
          <t>
            The method through which the client obtains the resource owner credentials is beyond
            the scope of this specification. The client MUST discard the credentials once an access
            token has been obtained.
          </t>
        </section>

        <section title='Access Token Request'>
          <t>
            The client makes a request to the token endpoint by adding the following parameters
            using the <spanx style='verb'>application/x-www-form-urlencoded</spanx> format in the
            HTTP request entity-body:
          </t>
          <t>
            <list style='hanging' hangIndent='6'>
              <t hangText='grant_type'>
                <vspace />
                REQUIRED. Value MUST be set to <spanx style='verb'>password</spanx>.
              </t>
              <t hangText='client_id'>
                <vspace />
                REQUIRED. The client identifier as described in
                <xref target='client-authentication' />.
              </t>
              <t hangText='username'>
                <vspace />
                REQUIRED. The resource owner username, encoded as UTF-8.
              </t>
              <t hangText='password'>
                <vspace />
                REQUIRED. The resource owner password, encoded as UTF-8.
              </t>
              <t hangText='scope'>
                <vspace />
                OPTIONAL. The scope of the access request expressed as a list of space-delimited,
                case sensitive strings. The value is defined by the authorization server. If the
                value contains multiple space-delimited strings, their order does not matter, and
                each string adds an additional access range to the requested scope.
              </t>
            </list>
          </t>
          <t>
            The client includes its authentication credentials as described in
            <xref target='client-authentication' />
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTP request using transport-layer
              security (extra line breaks are for display purposes only):
            </preamble>
            <artwork>
              <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
  Content-Type: application/x-www-form-urlencoded
  
  grant_type=password&client_id=s6BhdRkqt3&
  username=johndoe&password=A3ddj3w
]]>
            </artwork>
          </figure>
          <t>
            The authorization server MUST:
          </t>
          <t>
            <list style='symbols'>
              <t>
                Validate the client credentials.
              </t>
              <t>
                Validate the resource owner password credentials.
              </t>
            </list>
          </t>
        </section>

        <section title='Access Token Response'>
          <t>
            If the access token request is valid and authorized, the authorization server issues an
            access token and optional refresh token as described in <xref target='token-response' />.
            If the request failed client authentication or is invalid, the authorization server returns
            an error response as described in <xref target='token-errors' />.
          </t>
          <figure>
            <preamble>
              An example successful response:
            </preamble>
            <artwork>
              <![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/json
  Cache-Control: no-store

  {
    "access_token":"SlAV32hkKG",
    "token_type":"example",
    "expires_in":3600,
    "refresh_token":"8xLOxBtZp8",
    "example_parameter":"example_value"
  }
]]>
            </artwork>
          </figure>
        </section>

      </section>

      <section title='Client Credentials' anchor='grant-client'>
        <t>
          The client can request an access token using only its client credentials when the client
          is requesting access to the protected resources under its control, or those of another
          resource owner which has been previously arranged with the authorization server (the
          method of which is beyond the scope of this specification).
        </t>
        <figure title='Client Credentials Flow' anchor='Figure-6'>
          <artwork>
            <![CDATA[
  +---------+                                  +---------------+
  |         |                                  |               |
  |         |>--(A)--- Client Credentials ---->| Authorization |
  | Client  |                                  |     Server    |
  |         |<--(B)---- Access Token ---------<|               |
  |         |    (w/ Optional Refresh Token)   |               |
  +---------+                                  +---------------+
]]>
          </artwork>
        </figure>
        <t>
          The flow illustrated in <xref target='Figure-6' /> includes the following steps:
        </t>
        <t>
          <list style='format (%C)'>
            <t>
              The client requests an access token from the token endpoint by authenticating using
              its client credentials.
            </t>
            <t>
              The authorization server validates the client credentials and issues an access token.
            </t>
          </list>
        </t>

        <section title='Authorization Request and Response'>
          <t>
            Since the client credentials are used as the authorization grant, no additional
            authorization request is needed as the client is already in the possession of its
            client credentials.
          </t>
        </section>

        <section title='Access Token Request'>
          <t>
            The client makes a request to the token endpoint by adding the following parameters
            using the <spanx style='verb'>application/x-www-form-urlencoded</spanx> format in the
            HTTP request entity-body:
          </t>
          <t>
            <list style='hanging' hangIndent='6'>
              <t hangText='grant_type'>
                <vspace />
                REQUIRED. Value MUST be set to <spanx style='verb'>client_credentials</spanx>.
              </t>
              <t hangText='client_id'>
                <vspace />
                REQUIRED. The client identifier as described in
                <xref target='client-authentication' />.
              </t>
              <t hangText='scope'>
                <vspace />
                OPTIONAL. The scope of the access request expressed as a list of space-delimited,
                case sensitive strings. The value is defined by the authorization server. If the
                value contains multiple space-delimited strings, their order does not matter, and
                each string adds an additional access range to the requested scope.
              </t>
            </list>
          </t>
          <t>
            The client includes its authentication credentials as described in
            <xref target='client-authentication' />
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTP request using transport-layer
              security (extra line breaks are for display purposes only):
            </preamble>
            <artwork>
              <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
  Content-Type: application/x-www-form-urlencoded
  
  grant_type=client_credentials&client_id=s6BhdRkqt3
]]>
            </artwork>
          </figure>
          <t>
            The authorization server MUST validate the client credentials.
          </t>
        </section>

        <section title='Access Token Response'>
          <t>
            If the access token request is valid and authorized, the authorization server issues an
            access token and optional refresh token as described in <xref target='token-response' />.
            If the request failed client authentication or is invalid, the authorization server returns
            an error response as described in <xref target='token-errors' />.
          </t>
          <figure>
            <preamble>
              An example successful response:
            </preamble>
            <artwork>
              <![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/json
  Cache-Control: no-store

  {
    "access_token":"SlAV32hkKG",
    "token_type":"example",
    "expires_in":3600,
    "refresh_token":"8xLOxBtZp8",
    "example_parameter":"example_value"
  }
]]>
            </artwork>
          </figure>
        </section>

      </section>

      <section title='Extensions'>
        <t>
          The client uses an extension grant type by specifying the grant type using an
          absolute URI (defined by the authorization server) as the value of the
          <spanx style='verb'>grant_type</spanx> parameter of the token endpoint, and by
          adding any additional parameters necessary.
        </t>
        <figure>
          <preamble>
            For example, to request an access token using a SAML 2.0 assertion grant type as
            defined by <xref target='I-D.ietf-oauth-saml2-bearer' />, the client makes the
            following HTTP request using transport-layer security (line breaks are for display
            purposes only):
          </preamble>
          <artwork>
            <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded

  grant_type=http%3A%2F%2Foauth.net%2Fgrant_type%2Fassertion%2F
  saml%2F2.0%2Fbearer&assertion=PEFzc2VydGlvbiBJc3N1ZUluc3RhbnQ
  [...omitted for brevity...]V0aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-
]]>
          </artwork>
        </figure>
        <t>
          If the access token request is valid and authorized, the authorization server issues an
          access token and optional refresh token as described in <xref target='token-response' />.
          If the request failed client authentication or is invalid, the authorization server returns
          an error response as described in <xref target='token-errors' />.
        </t>
      </section>

    </section>

    <section title='Issuing an Access Token' anchor='token-issue'>
      <t>
        If the access token request is valid and authorized, the authorization server issues an
        access token and optional refresh token as described in <xref target='token-response' />.
        If the request failed client authentication or is invalid, the authorization server returns
        an error response as described in <xref target='token-errors' />.
      </t>

      <section title='Successful Response' anchor='token-response'>
        <t>
          The authorization server issues an access token and optional refresh token, and
          constructs the response by adding the following parameters to the entity body of the HTTP
          response with a 200 (OK) status code:
        </t>
        <t>
          <list style='hanging' hangIndent='6'>
            <t hangText='access_token'>
              <vspace />
              REQUIRED. The access token issued by the authorization server.
            </t>
            <t hangText='token_type'>
              <vspace />
              REQUIRED. The type of the token issued as described in <xref target='token-types' />.
              Value is case insensitive.
            </t>
            <t hangText='expires_in'>
              <vspace />
              OPTIONAL. The duration in seconds of the access token lifetime. For example, the
              value <spanx style='verb'>3600</spanx> denotes that the access token will expire in
              one hour from the time the response was generated.
            </t>
            <t hangText='refresh_token'>
              <vspace />
              OPTIONAL. The refresh token which can be used to obtain new access tokens using the
              same authorization grant as described in <xref target='token-refresh' />.
            </t>
            <t hangText='scope'>
              <vspace />
              OPTIONAL. The scope of the access request expressed as a list of space-delimited,
              case sensitive strings. The value is defined by the authorization server. If the
              value contains multiple space-delimited strings, their order does not matter, and
              each string adds an additional access range to the requested scope. The authorization
              server SHOULD include the parameter if the requested scope is different from the one
              requested by the client.
            </t>
          </list>
        </t>
        <t>
          The parameters are included in the entity body of the HTTP response using the
          <spanx style='verb'>application/json</spanx> media type as defined by
          <xref target='RFC4627' />. The parameters are serialized into a JSON structure by
          adding each parameter at the highest structure level. Parameter names and string values
          are included as JSON strings. Numerical values are included as JSON numbers.
        </t>
        <t>
          The authorization server MUST include the HTTP
          <spanx style='verb'>Cache-Control</spanx> response header field <xref target='RFC2616' />
          with a value of <spanx style='verb'>no-store</spanx> in any response containing tokens,
          secrets, or other sensitive information.
        </t>
        <figure>
          <preamble>
            For example:
          </preamble>
          <artwork>
            <![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/json
  Cache-Control: no-store

  {
    "access_token":"SlAV32hkKG",
    "token_type":"example",
    "expires_in":3600,
    "refresh_token":"8xLOxBtZp8",
    "example_parameter":"example_value"
  }
]]>
          </artwork>
        </figure>
        <t>
          The client SHOULD ignore unrecognized response parameters. The sizes of tokens and other
          values received from the authorization server are left undefined. The client should
          avoid making assumptions about value sizes. The authorization server should document the
          size of any value it issues.
        </t>
      </section>

      <section title='Error Response' anchor='token-errors'>
        <t>
          The authorization server responds with an HTTP 400 (Bad Request) status code and includes
          the following parameters with the response:
        </t>
        <t>
          <list style='hanging' hangIndent='6'>
            <t hangText='error'>
              <vspace />
              REQUIRED. A single error code from the following:

              <list style='hanging' hangIndent='6'>
                <t hangText='invalid_request'>
                  <vspace />
                  The request is missing a required parameter, includes an unsupported
                  parameter or parameter value, repeats a parameter, includes multiple
                  credentials, utilizes more than one mechanism for authenticating the client,
                  or is otherwise malformed.
                </t>
                <t hangText='invalid_client'>
                  <vspace />
                  Client authentication failed (e.g. unknown client, no client credentials
                  included, multiple client credentials included, or unsupported credentials
                  type). The authorization server MAY return an HTTP 401 (Unauthorized) status code
                  to indicate which HTTP authentication schemes are supported. If the client
                  attempted to authenticate via the <spanx style='verb'>Authorization</spanx>
                  request header field, the authorization server MUST respond with an HTTP 401
                  (Unauthorized) status code, and include the
                  <spanx style='verb'>WWW-Authenticate</spanx> response header field matching the
                  authentication scheme used by the client.
                </t>
                <t hangText='invalid_grant'>
                  <vspace />
                  The provided authorization grant is invalid, expired, revoked, does not match the
                  redirection URI used in the authorization request, or was issued to another client.
                </t>
                <t hangText='unauthorized_client'>
                  <vspace />
                  The authenticated client is not authorized to use this authorization grant type.
                </t>
                <t hangText='unsupported_grant_type'>
                  <vspace />
                  The authorization grant type is not supported by the authorization server.
                </t>
                <t hangText='invalid_scope'>
                  <vspace />
                  The requested scope is invalid, unknown, malformed, or exceeds the scope granted
                  by the resource owner.
                </t>
              </list>
            </t>
            <t hangText='error_description'>
              <vspace />
              OPTIONAL. A human-readable text providing additional information, used to assist
              in the understanding and resolution of the error occurred. [[ add language and
              encoding information ]]
            </t>
            <t hangText='error_uri'>
              <vspace />
              OPTIONAL. A URI identifying a human-readable web page with information about the
              error, used to provide the resource owner with additional information about the
              error.
            </t>
          </list>
        </t>
        <t>
          The parameters are included in the entity body of the HTTP response using the
          <spanx style='verb'>application/json</spanx> media type as defined by
          <xref target='RFC4627' />. The parameters are serialized into a JSON structure by
          adding each parameter at the highest structure level. Parameter names and string values
          are included as JSON strings. Numerical values are included as JSON numbers.
        </t>
        <figure>
          <preamble>
            For example:
          </preamble>
          <artwork>
            <![CDATA[
  HTTP/1.1 400 Bad Request
  Content-Type: application/json
  Cache-Control: no-store

  {
    "error":"invalid_request"
  }
]]>
          </artwork>
        </figure>
        <t>
          If the authorization server encounters an error condition other than the 400 (Bad
          Request) and 401 (Unauthorized) responses described above (e.g. the service is
          temporarily unavailable), the authorization server SHOULD include an error response in
          the entity body, and set the <spanx style='verb'>error</spanx> parameter value to the
          numerical HTTP status code returned.
        </t>
        <figure>
          <preamble>
            For example:
          </preamble>
          <artwork>
            <![CDATA[
  HTTP/1.1 503 Service Unavailable
  Content-Type: application/json

  {
    "error":"503"
  }
]]>
          </artwork>
        </figure>
      </section>

    </section>

    <section title='Refreshing an Access Token' anchor='token-refresh'>
      <t>
        If the authorization server issued a refresh token to the client, the client makes a
        refresh request to the token endpoint by adding the following parameters using the
        <spanx style='verb'>application/x-www-form-urlencoded</spanx> format in the HTTP request
        entity-body:
      </t>
      <t>
        <list style='hanging' hangIndent='6'>
          <t hangText='grant_type'>
            <vspace />
            REQUIRED. Value MUST be set to <spanx style='verb'>refresh_token</spanx>.
          </t>
          <t hangText='client_id'>
            <vspace />
            REQUIRED. The client identifier as described in
            <xref target='client-authentication' />.
          </t>
          <t hangText='refresh_token'>
            <vspace />
            REQUIRED. The refresh token issued to the client.
          </t>
          <t hangText='scope'>
            <vspace />
            OPTIONAL. The scope of the access request expressed as a list of space-delimited,
            case sensitive strings. The value is defined by the authorization server. If the
            value contains multiple space-delimited strings, their order does not matter, and
            each string adds an additional access range to the requested scope. The requested
            scope MUST be equal or lesser than the scope originally granted by the resource
            owner, and if omitted is treated as equal to the scope originally granted by the
            resource owner.
          </t>
        </list>
      </t>
      <t>
        The client includes its authentication credentials as described in
        <xref target='client-authentication' />.
      </t>
      <figure>
        <preamble>
          For example, the client makes the following HTTP request using transport-layer
          security (extra line breaks are for display purposes only):
        </preamble>
        <artwork>
          <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
  Content-Type: application/x-www-form-urlencoded
  
  grant_type=refresh_token&client_id=s6BhdRkqt3&
  refresh_token=n4E9O119d
]]>
        </artwork>
      </figure>
      <t>
        The authorization server MUST validate the client credentials, ensure that the refresh
        token was issued to the authenticated client, validate the refresh token, and
        verify that the resource owner's authorization is still valid. If valid and authorized, the
        authorization server issues an access token as described in
        <xref target='token-response' />. If the request failed verification or is invalid, the
        authorization server returns an error response as described in
        <xref target='token-errors' />.
      </t>
      <t>
        The authorization server MAY issue a new refresh token, in which case, the client MUST
        discard the old refresh token and replace it with the new refresh token.
      </t>
    </section>

    <section title='Accessing Protected Resources' anchor='access-resource'>
      <t>
        The client accesses protected resources by presenting the access token to the resource
        server. The resource server MUST validate the access token and ensure it has not expired
        and that its scope covers the requested resource. The methods used by the resource server
        to validate the access token (as well as any error responses) are beyond the scope of this
        specification, but generally involve an interaction or coordination between the resource
        server and the authorization server.
      </t>
      <t>
        The method in which the client utilized the access token to authenticate with the resource
        server depends on the type of access token issued by the authorization server. Typically,
        it involves using the HTTP <spanx style='verb'>Authorization</spanx> request header field
        <xref target='RFC2617' /> with an authentication scheme defined by the access token type
        specification.
      </t>

      <section title='Access Token Types' anchor='token-types'>
        <t>
          The access token type provides the client with the information required to successfully
          utilize the access token to make a protected resource request (along with type-specific
          attributes). The client MUST NOT use an access token if it does not understand the token
          type.
        </t>
        <figure>
          <preamble>
            For example, the <spanx style='verb'>bearer</spanx> token type defined in
            <xref target='I-D.ietf-oauth-v2-bearer' /> is utilized by simply including the access
            token string in the request:
          </preamble>
          <artwork>
            <![CDATA[
  GET /resource/1 HTTP/1.1
  Host: example.com
  Authorization: Bearer 7Fjfp0ZBr1KtDRbnfVdmIw
]]>
          </artwork>
        </figure>
        <figure>
          <preamble>
            while the <spanx style='verb'>mac</spanx> token type defined in
            <xref target='I-D.ietf-oauth-v2-http-mac' /> is utilized by issuing a MAC key
            together with the access token which is used to sign certain components of the HTTP
            requests:
          </preamble>
          <artwork>
            <![CDATA[
  GET /resource/1 HTTP/1.1
  Host: example.com
  Authorization: MAC id="h480djs93hd8",
                     nonce="274312:dj83hs9s",
                     mac="kDZvddkndxvhGRXZhvuDjEWhGeE="
]]>
          </artwork>
        </figure>
        <t>
          The above examples are provided for illustration purposes only. Developers are advised to
          consult the <xref target='I-D.ietf-oauth-v2-bearer' /> and
          <xref target='I-D.ietf-oauth-v2-http-mac' /> specifications before use.
        </t>
        <t>
          Each access token type definition specifies the additional attributes (if any) sent to
          the client together with the <spanx style='verb'>access_token</spanx> response parameter.
          It also defines the HTTP authentication method used to include the access token when
          making a protected resource request.
        </t>
      </section>

    </section>

    <section title='Extensibility' anchor='extensions'>

      <section title='Defining Access Token Types' anchor='new-types'>
        <t>
          Access token types can be defined in one of two ways: registered in the access token type
          registry (following the procedures in <xref target='type-registry' />), or use a unique
          absolute URI as its name.
        </t>
        <t>
          Types utilizing a URI name SHOULD be limited to vendor-specific implementations that are
          not commonly applicable, and are specific to the implementation details of the resource
          server where they are used.
        </t>
        <t>
          All other types MUST be registered. Type names MUST conform to the type-name ABNF. If the
          type definition includes a new HTTP authentication scheme, the type name SHOULD be
          identical to the HTTP authentication scheme name (as defined by <xref target='RFC2617' />).
        </t>
        <figure>
          <artwork>
            <![CDATA[
  type-name  = 1*name-char
  name-char   = "-" / "." / "_" / DIGIT / ALPHA
]]>
          </artwork>
        </figure>
      </section>

      <section title='Defining New Endpoint Parameters'>
        <t>
          New request or response parameters for use with the authorization endpoint or the token
          endpoint are defined and registered in the parameters registry following the procedure in
          <xref target='parameters-registry' />.
        </t>
        <t>
          Parameter names MUST conform to the param-name ABNF and parameter values syntax MUST be
          well-defined (e.g., using ABNF, or a reference to the syntax of an existing parameter).
        </t>
        <figure>
          <artwork>
            <![CDATA[
  param-name  = 1*name-char
  name-char   = "-" / "." / "_" / DIGIT / ALPHA
]]>
          </artwork>
        </figure>
        <t>
          Unregistered vendor-specific parameter extensions that are not commonly applicable, and
          are specific to the implementation details of the authorization server where they are
          used SHOULD utilize a vendor-specific prefix that is not likely to conflict with other
          registered values (e.g. begin with 'companyname_').
        </t>
      </section>

      <section title='Defining New Authorization Grant Types'>
        <t>
          New authorization grant types can be defined by assigning them a unique absolute URI for
          use with the <spanx style='verb'>grant_type</spanx> parameter. If the extension grant
          type requires additional token endpoint parameters, they MUST be registered in the OAuth
          parameters registry as described by <xref target='parameters-registry' />.
        </t>
      </section>

      <section title='Defining Additional Error Codes' anchor='new-errors'>
        <t>
          In cases where protocol extensions (i.e. access token types, extension parameters, or
          extension grant types) require additional error codes to be used with the authorization
          code grant error response (<xref target='code-authz-error' />), the implicit grant error
          response (<xref target='implicit-authz-error' />), or the token error response
          (<xref target='token-errors' />), such error codes MAY be defined.
        </t>
        <t>
          Extension error codes MUST be registered (following the procedures in
          <xref target='error-registry' />) if the extension they are used in conjunction with is
          a registered access token type, a registered endpoint parameter, or an extension grant
          type. Error codes used with unregistered extensions MAY be registered.
        </t>
        <t>
          Error codes MUST conform to the error-code ABNF, and SHOULD be prefixed by an identifying
          name when possible. For example, an error identifying an invalid value set to the
          extension parameter <spanx style='verb'>example</spanx> should be named
          <spanx style='verb'>example_invalid</spanx>.
        </t>
        <figure>
          <artwork>
            <![CDATA[
  error-code   = ALPHA *error-char
  error-char   = "-" / "." / "_" / DIGIT / ALPHA
]]>
          </artwork>
        </figure>
      </section>

    </section>

    <section title='Native Applications'>
      <t>
        [[ Pending consensus ]]
      </t>
      <t>
        A native application is a client which is installed and executes on the end-user's device
        (i.e. desktop application, native mobile application). Native applications are often
        capable of interacting with (or embedding) a user-agent but are limited in how such
        interactions affects their overall end-user experience. In many cases, native applications
        are incapable of receiving redirection requests from the authorization server (e.g. due to
        firewall rules, operating system restrictions).
      </t>
      <t>
        Native applications can utilize OAuth in different ways, based on their requirements and
        desired end-user experience:
      </t>
      <t>
        <list style='symbols'>
          <t>
            Use the authorization code grant type flow described in <xref target='grant-code' /> by
            launching an external user-agent. The native application can capture the response by
            providing a redirection URI identifying a local (non-network) resource (registered
            with the operating system to invoke the native application as handler), or by providing
            a redirection URI identifying a server-hosted resource under the native application's
            control, which in turn makes the response available to the native application (e.g.
            using the user-agent window title or other locations accessible from outside the
            user-agent).
          </t>
          <t>
            Use the authorization code grant type flow described in <xref target='grant-code' /> by
            embedding a user-agent. The native application obtains the response by directly
            communicating with the embedded user-agent. Embedded user-agents are discouraged as
            they typically provide a less consistent user experience and do not enable the end-user
            to verify the authorization server's authenticity.
          </t>
        </list>
      </t>
      <t>
        Native applications SHOULD use the authorization code grant type flow without client
        password credentials (due to their inability to keep the credentials confidential) to
        obtain short-lived access tokens, and use refresh tokens to maintain access.
      </t>
      <t>
        When choosing between launching an external user-agent and an embedding a user-agent,
        native application developers should consider the following:
      </t>
      <t>
        <list style='symbols'>
          <t>
            External user-agents may improve completion rate as the end-user may already have
            an active session with the authorization server removing the need to re-authenticate,
            and provide a familiar user-agent user experience. The end-user may also rely on
            extensions or add-ons to assist with authentication (e.g. password managers or 2-factor
            device reader).
          </t>
          <t>
            Embedded user-agents often offer a better end-user flow, as they remove the need to
            switch context and open new windows but also may provide less familiar features than
            the external user-agent.
          </t>
          <t>
            Embedded user-agents pose a security challenge because end-users are authenticating in
            an unidentified window without access to the visual protections offered by many
            user-agents. Embedded user-agents educate end-user to trust unidentified requests for
            authentication (making phishing attacks easier to execute).
          </t>
        </list>
      </t>
    </section>

    <section title='Security Considerations'>
      <t>
        As a flexible and extensible framework, OAuth's security considerations depend on many
        factors. The following sections provide implementers with security guidelines focused on
        three common client types:
      </t>
      <t>
        <list style='hanging'>
          <t hangText='Web Application'>
            <vspace />
            A web application is a client running on a web server. End-users access the client via
            an HTML user interface rendered in a user-agent on the end-user's device. The client
            credentials as well as any access token issued to the client are stored on the web
            server and are not exposed to or accessible by the end-user.
          </t>
          <t hangText='User-Agent-based Application'>
            <vspace />
            A user-agent-based application is a client in which the client code is downloaded from
            a web server and executes within a user-agent on the end-user's device. The OAuth
            protocol data and credentials are accessible to the end-user. Since such applications
            directly reside within the user-agent, they can make seamless use of the user-agent
            capabilities in the end-user authorization process.
          </t>
          <t hangText='Native Application'>
            <vspace />
            A native application is a client which is installed and executes on the end-user's
            device. The OAuth protocol data and credentials are accessible to the end-user. It is
            assumed that such an application can protect dynamically issued credentials, such as
            refresh tokens, from eavesdropping by other applications residing on the same device.
          </t>
        </list>
      </t>
      <t>
        A comprehensive OAuth security model and analysis, as well as background for the protocol
        design is provided in <xref target='I-D.lodderstedt-oauth-security' />.
      </t>

      <section title='Client Authentication'>
        <t>
          The authorization server issues client credentials to web applications for the purpose of
          authenticating them. The authorization server is encouraged to consider using stronger
          client authentication means than a client password. Application developers MUST ensure
          confidentiality of client passwords and other credentials.
        </t>
        <t>
          The authorization server MUST NOT issue client passwords or other credentials to native
          or user-agent-based applications for the purpose of client authentication. The
          authorization server MAY issue a client password or other credentials for a specific
          installation of a native application on a specific device.
        </t>
      </section>

      <section title='Client Impersonation'>
        <t>
          Given the inability of some clients to keep their client credentials confidential, a
          malicious client can impersonate another client and obtain access to protected resources.
          The authorization server MUST authenticate the client whenever possible. If the
          authorization server cannot authenticate the a client due to the client's limitations,
          the authorization server should utilize other means to protect resource owners from such
          malicious clients, including but not limited to engaging the end-user to assist in
          identifying the client and its source.
        </t>
        <t>
          The authorization server SHOULD enforce explicit end-user authentication, or prompt the
          end-user to authorize access again, providing the end-user with information about the
          client, scope, and duration of the authorization. It is up to the end-user to review the
          information in the context of the current client, and authorize the request.
        </t>
        <t>
          The authorization server SHOULD NOT automatically, without active end-user interaction,
          process repeated authorization requests without authenticating the client or relying on
          other measures to ensure the repeated request comes from a valid client and not an
          impersonator.
        </t>
        <t>
          The authorization server SHOULD require the client to pre-register its redirection URI
          and validate the value of the <spanx style='verb'>redirect_uri</spanx> against the
          pre-registered value. The client MUST NOT serve an open redirector resource which can be
          used by an attacker to construct an URI that will pass the authorization server's
          redirection URI matching rules, and will redirect the end-user's user-agent to the
          attacker's server.
        </t>
        <t>
          The authorization server SHOULD issue access tokens with limited scope and duration to
          clients incapable of authenticating.
        </t>
      </section>

      <section title='Access Token Credentials'>
        <t>
          Access token credentials MUST be kept confidential in transit and storage, and shared
          only among the authorization server, the resource servers the credentials are valid for,
          and the client to whom the credentials were issued.
        </t>
        <t>
          When using the implicit grant type, the access token credentials are transmitted in the
          URI fragment, which can expose the credentials to unauthorized parties.
        </t>
        <t>
          The authorization server MUST ensure that access token credentials cannot be generated,
          modified, or guessed to produce valid access token credentials.
        </t>
        <t>
          The client SHOULD request access token credentials with the minimal scope and duration
          necessary. The authorization server SHOULD take the client identity into account when
          choosing to honor the requested scope, and MAY issue credentials with a lesser scope than
          requested.
        </t>
      </section>

      <section title='Refresh Tokens'>
        <t>
          Authorization servers MAY issue refresh tokens to web and native applications.
        </t>
        <t>
          Refresh tokens MUST be kept confidential in transit and storage, and shared only among
          the authorization server and the client to whom the refresh tokens were issued.
          The authorization server MUST maintain the link between a refresh token and the client to
          whom it was issued.
        </t>
        <t>
          The authorization server MUST verify the link between the refresh token and client
          identity whenever the client's identity can be authenticated. When client authentication is
          not possible, the authorization server SHOULD deploy other means to detect refresh token
          abuse.
        </t>
        <t>
          The authorization server MUST ensure that refresh tokens cannot be generated, modified,
          or guessed to produce valid refresh tokens.
        </t>
      </section>

      <section title='Request Confidentiality'>
        <t>
          Access token credentials, refresh tokens, resource owner passwords, and client secrets
          MUST NOT be transmitted in the clear. Authorization codes SHOULD NOT be transmitted in
          the clear.
        </t>
      </section>

      <section title='Endpoints Authenticity'>
        <t>
          In order to prevent man-in-the-middle and phishing attacks, the authorization server
          MUST implement and require TLS with server-side authentication in all exchanges. The
          client MUST verify the authorization server's TLS certificate, as well as the respective
          certificate chain.
        </t>
      </section>

      <section title='Credentials Guessing Attacks'>
        <t>
          The authorization server MUST prevent attackers from guessing access tokens,
          authorization codes, refresh tokens, resource owner passwords, and client secrets.
        </t>
        <t>
          When generating tokens and other secrets not intended for direct human utilization, the
          authorization server MUST use a reasonable level of entropy in order to mitigate the risk
          of guessing attacks. When creating secrets intended for human usage, the authorization
          server MUST utilize other means to protect those secrets.
        </t>
      </section>

      <section title='Phishing Attacks'>
        <t>
          Native applications SHOULD use external browsers instead of embedding browsers within the
          application when requesting end-user authorization. External browsers offer a familiar
          user experience and a trusted environment in which end-users can confirm the
          authenticity of the authorization server.
        </t>
        <t>
          To reduce the risk of phishing attacks, the authorization servers MUST utilize TLS to
          allow user-agents to validate the authorization server's identity. Service providers
          should educate their end-users about the risks of phishing attacks and how they can
          verify the authorization server's identity.
        </t>
      </section>

      <section title='Authorization Codes'>
        <t>
          The transmission of authorization codes SHOULD be made over a secure channel, and the
          client SHOULD implement TLS for use with its redirection URI if the URI identifies a
          network resource. Authorization codes MUST be kept confidential. Since authorization
          codes are transmitted via user-agent redirections, they could potentially be disclosed
          through user-agent history and HTTP referrer headers.
        </t>
        <t>
          Authorization codes operate as plaintext bearer credentials, used to verify that the
          end-user who granted authorization at the authorization server, is the same end-user
          returning to the client to complete the process. Therefore, if the client relies on the
          authorization code for its own end-user authentication, the client redirection endpoint
          MUST require TLS.
        </t>
        <t>
          Authorization codes SHOULD be short lived and MUST be single use. If the authorization
          server observes multiple attempts to exchange an authorization code for an access token,
          the authorization server SHOULD revoke all access tokens already granted based on the
          compromised authorization code.
        </t>
        <t>
          If the client can be authenticated, the authorization servers MUST authenticate the
          client and ensure that the authorization code was issued to the same client.
        </t>
      </section>

      <section title='Session Fixation'>
        <t>
          Session fixation attacks leverage the authorization code grant type, by tricking an
          end-user to authorize access to a legitimate client, but to a client account under the
          control of the attacker. The only difference between a valid flow and the attack flow is
          in how the victim reached the authorization server to grant access. Once at the
          authorization server, the victim is prompted with a normal, valid request on behalf of a
          legitimate and familiar client. The attacker then uses the victim's authorization to gain
          access to the information authorized by the victim.
        </t>
        <t>
          In order to prevent such an attack, authorization servers MUST ensure that the
          redirection URI used to obtain the authorization code, is the same as the redirection URI
          provided when exchanging the authorization code for an access token. The authorization
          server SHOULD require the client to pre-register their redirection URI and if provided,
          MUST validate the redirection URI received in the authorization request against the
          pre-registered value.
        </t>
      </section>

      <section title='Redirection URI Validation'>
        <t>
          [[ Add specific recommendations about redirection validation and matching ]]
        </t>
      </section>

      <section title='Resource Owner Password Credentials'>
        <t>
          The resource owner password credentials grant type is often used for legacy or migration
          reasons. It reduces the overall risk of storing username and password in the client, but
          does not eliminate the need to expose highly privileged credentials to the client.
        </t>
        <t>
          This grant type carries a higher risk than the other grant types because it maintains the
          password anti-pattern OAuth seeks to avoid. The client could abuse the password or the
          password could unintentionally be disclosed to an attacker (e.g. via log files or other
          records kept by the client).
        </t>
        <t>
          Additionally, because the resource owner does not have control over the authorization
          process (the resource owner involvement ends when it hands over its credentials to the
          client), the client can obtain access tokens with a broader scope and longer duration
          than desired by the resource owner. The authorization server SHOULD restrict the scope
          and duration of access tokens issued via this grant type.
        </t>
        <t>
          The authorization server and client SHOULD minimize use of this grant type and utilize
          other grant types whenever possible.
        </t>
      </section>

      <section title='XSRF/CSRF Prevention'>
        <t>
          [[ Add text with reference to the 'state' parameter ]]
        </t>
      </section>

    </section>

    <section title='IANA Considerations'>

      <section title='The OAuth Access Token Type Registry' anchor='type-registry'>
        <t>
          This specification establishes the OAuth access token type registry.
        </t>
        <t>
          Access token types are registered on the advice of one or more Designated Experts
          (appointed by the IESG or their delegate), with a Specification Required (using
          terminology from <xref target='RFC5226' />). However, to allow for the allocation of
          values prior to publication, the Designated Expert(s) may approve registration once they
          are satisfied that such a specification will be published.
        </t>
        <t>
          Registration requests should be sent to the [TBD]@ietf.org mailing list for review and
          comment, with an appropriate subject (e.g., "Request for access toke type: example").
          [[ Note to RFC-EDITOR: The name of the mailing list should be determined in consultation
          with the IESG and IANA. Suggested name: oauth-ext-review. ]]
        </t>
        <t>
          Within at most 14 days of the request, the Designated Expert(s) will either approve or
          deny the registration request, communicating this decision to the review list and IANA.
          Denials should include an explanation and, if applicable, suggestions as to how to make
          the request successful.
        </t>
        <t>
          Decisions (or lack thereof) made by the Designated Expert can be first appealed to
          Application Area Directors (contactable using app-ads@tools.ietf.org email address or
          directly by looking up their email addresses on http://www.iesg.org/ website) and, if the
          appellant is not satisfied with the response, to the full IESG (using the iesg@iesg.org
          mailing list).
        </t>
        <t>
          IANA should only accept registry updates from the Designated Expert(s), and should direct
          all requests for registration to the review mailing list.
        </t>

        <section title='Registration Template'>
          <t>
            <list style='hanging'>
              <t hangText='Type name:'>
                <vspace />
                The name requested (e.g., "example").
              </t>
              <t hangText='Additional Token Endpoint Response Parameters:'>
                <vspace />
                Additional response parameters returned together with the
                <spanx style='verb'>access_token</spanx> parameter. New parameters MUST be
                separately registered in the OAuth parameters registry as described by
                <xref target='parameters-registry' />.
              </t>
              <t hangText='HTTP Authentication Scheme(s):'>
                <vspace />
                The HTTP authentication scheme name(s), if any, used to authenticate protected
                resources requests using access token of this type.
              </t>
              <t hangText='Change controller:'>
                <vspace />
                For standards-track RFCs, state "IETF". For others, give the name of the
                responsible party. Other details (e.g., postal address, e-mail address, home page
                URI) may also be included.
              </t>
              <t hangText='Specification document(s):'>
                <vspace />
                Reference to document that specifies the parameter, preferably including a URI that
                can be used to retrieve a copy of the document. An indication of the relevant
                sections may also be included, but is not required.
              </t>
            </list>
          </t>
        </section>

      </section>

      <section title='The OAuth Parameters Registry' anchor='parameters-registry'>
        <t>
          This specification establishes the OAuth parameters registry.
        </t>
        <t>
          Additional parameters for inclusion in the authorization endpoint request, the
          authorization endpoint response, the token endpoint request, or the token endpoint
          response, are registered on the advice of one or more Designated Experts (appointed by
          the IESG or their delegate), with a Specification Required (using terminology from
          <xref target='RFC5226' />). However, to allow for the allocation of values prior to
          publication, the Designated Expert(s) may approve registration once they are satisfied
          that such a specification will be published.
        </t>
        <t>
          Registration requests should be sent to the [TBD]@ietf.org mailing list for review and
          comment, with an appropriate subject (e.g., "Request for parameter: example").
          [[ Note to RFC-EDITOR: The name of the mailing list should be determined in consultation
          with the IESG and IANA. Suggested name: oauth-ext-review. ]]
        </t>
        <t>
          Within at most 14 days of the request, the Designated Expert(s) will either approve or
          deny the registration request, communicating this decision to the review list and IANA.
          Denials should include an explanation and, if applicable, suggestions as to how to make
          the request successful.
        </t>
        <t>
          Decisions (or lack thereof) made by the Designated Expert can be first appealed to
          Application Area Directors (contactable using app-ads@tools.ietf.org email address or
          directly by looking up their email addresses on http://www.iesg.org/ website) and, if the
          appellant is not satisfied with the response, to the full IESG (using the iesg@iesg.org
          mailing list).
        </t>
        <t>
          IANA should only accept registry updates from the Designated Expert(s), and should direct
          all requests for registration to the review mailing list.
        </t>

        <section title='Registration Template'>
          <t>
            <list style='hanging'>
              <t hangText='Parameter name:'>
                <vspace />
                The name requested (e.g., "example").
              </t>
              <t hangText='Parameter usage location:'>
                <vspace />
                The location(s) where parameter can be used. The possible locations are:
                authorization request, authorization response, token request, or token response.
              </t>
              <t hangText='Change controller:'>
                <vspace />
                For standards-track RFCs, state "IETF". For others, give the name of the
                responsible party. Other details (e.g., postal address, e-mail address, home page
                URI) may also be included.
              </t>
              <t hangText='Specification document(s):'>
                <vspace />
                Reference to document that specifies the parameter, preferably including a URI that
                can be used to retrieve a copy of the document. An indication of the relevant
                sections may also be included, but is not required.
              </t>
            </list>
          </t>
        </section>

        <section title='Initial Registry Contents'>
          <t>
            The OAuth Parameters Registry's initial contents are:
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: client_id
              </t>
              <t>
                Parameter usage location: authorization request, token request
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: client_secret
              </t>
              <t>
                Parameter usage location: token request
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: response_type
              </t>
              <t>
                Parameter usage location: authorization request
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: redirect_uri
              </t>
              <t>
                Parameter usage location: authorization request, token request
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: scope
              </t>
              <t>
                Parameter usage location: authorization request, authorization response, token
                request, token response
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: state
              </t>
              <t>
                Parameter usage location: authorization request, authorization response
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: code
              </t>
              <t>
                Parameter usage location: authorization response, token request
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: error_description
              </t>
              <t>
                Parameter usage location: authorization response, token response
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: error_uri
              </t>
              <t>
                Parameter usage location: authorization response, token response
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: grant_type
              </t>
              <t>
                Parameter usage location: token request
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: access_token
              </t>
              <t>
                Parameter usage location: authorization response, token response
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: token_type
              </t>
              <t>
                Parameter usage location: authorization response, token response
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: expires_in
              </t>
              <t>
                Parameter usage location: authorization response, token response
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: username
              </t>
              <t>
                Parameter usage location: token request
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: password
              </t>
              <t>
                Parameter usage location: token request
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Parameter name: refresh_token
              </t>
              <t>
                Parameter usage location: token request, token response
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
        </section>

      </section>

      <section title='The OAuth Extensions Error Registry' anchor='error-registry'>
        <t>
          This specification establishes the OAuth extensions error registry.
        </t>
        <t>
          Additional error codes used together with other protocol extensions (i.e. extension grant
          types, access token types, or extension parameters) are registered on the advice of one
          or more Designated Experts (appointed by the IESG or their delegate), with a
          Specification Required (using terminology from <xref target='RFC5226' />). However, to
          allow for the allocation of values prior to publication, the Designated Expert(s) may
          approve registration once they are satisfied that such a specification will be published.
        </t>
        <t>
          Registration requests should be sent to the [TBD]@ietf.org mailing list for review and
          comment, with an appropriate subject (e.g., "Request for error code: example").
          [[ Note to RFC-EDITOR: The name of the mailing list should be determined in consultation
          with the IESG and IANA. Suggested name: oauth-ext-review. ]]
        </t>
        <t>
          Within at most 14 days of the request, the Designated Expert(s) will either approve or
          deny the registration request, communicating this decision to the review list and IANA.
          Denials should include an explanation and, if applicable, suggestions as to how to make
          the request successful.
        </t>
        <t>
          Decisions (or lack thereof) made by the Designated Expert can be first appealed to
          Application Area Directors (contactable using app-ads@tools.ietf.org email address or
          directly by looking up their email addresses on http://www.iesg.org/ website) and, if the
          appellant is not satisfied with the response, to the full IESG (using the iesg@iesg.org
          mailing list).
        </t>
        <t>
          IANA should only accept registry updates from the Designated Expert(s), and should direct
          all requests for registration to the review mailing list.
        </t>

        <section title='Registration Template'>
          <t>
            <list style='hanging'>
              <t hangText='Error name:'>
                <vspace />
                The name requested (e.g., "example").
              </t>
              <t hangText='Error usage location:'>
                <vspace />
                The location(s) where the error can be used. The possible locations are:
                authorization code grant error response (<xref target='code-authz-error' />),
                implicit grant error response (<xref target='implicit-authz-error' />), or token
                error response (<xref target='token-errors' />).
              </t>
              <t hangText='Related protocol extension:'>
                <vspace />
                The name of the extension grant type, access token type, or extension parameter,
                the error code is used in conjunction with.
              </t>
              <t hangText='Change controller:'>
                <vspace />
                For standards-track RFCs, state "IETF". For others, give the name of the
                responsible party. Other details (e.g., postal address, e-mail address, home page
                URI) may also be included.
              </t>
              <t hangText='Specification document(s):'>
                <vspace />
                Reference to document that specifies the error code, preferably including a URI
                that can be used to retrieve a copy of the document. An indication of the relevant
                sections may also be included, but is not required.
              </t>
            </list>
          </t>
        </section>

      </section>

    </section>

    <section title='Acknowledgements'>
      <t>
        The initial OAuth 2.0 protocol specification was edited by David Recordon, based on two
        previous publications: the OAuth 1.0 community specification <xref target='RFC5849' />, and
        OAuth WRAP (OAuth Web Resource Authorization Profiles)
        <xref target='I-D.draft-hardt-oauth-01' />. The Security Considerations section was drafted
        by Torsten Lodderstedt, Mark McGloin, Phil Hunt, and Anthony Nadalin.
      </t>
      <t>
        The OAuth 1.0 community specification was edited by Eran Hammer-Lahav and authored by
        Mark Atwood, Dirk Balfanz, Darren Bounds, Richard M. Conlan, Blaine Cook, Leah Culver,
        Breno de Medeiros, Brian Eaton, Kellan Elliott-McCrea, Larry Halff, Eran Hammer-Lahav,
        Ben Laurie, Chris Messina, John Panzer, Sam Quigley, David Recordon, Eran Sandler,
        Jonathan Sergent, Todd Sieling, Brian Slesinsky, and Andy Smith.
      </t>
      <t>
        The OAuth WRAP specification was edited by Dick Hardt and authored by Brian Eaton,
        Yaron Goland, Dick Hardt, and Allen Tom.
      </t>
      <t>
        This specification is the work of the OAuth Working Group which includes dozens of active
        and dedicated participants. In particular, the following individuals contributed ideas,
        feedback, and wording which shaped and formed the final specification:
      </t>
      <t>
        Michael Adams, Andrew Arnott, Dirk Balfanz, Scott Cantor, Blaine Cook, Brian Campbell,
        Leah Culver, Bill de hra, Brian Eaton, Brian Ellin, Igor Faynberg, George Fletcher,
        Tim Freeman, Evan Gilbert, Yaron Goland, Brent Goldman, Kristoffer Gronowski, Justin Hart,
        Craig Heath, Phil Hunt, Michael B. Jones, John Kemp, Mark Kent, Raffi Krikorian,
        Chasen Le Hara, Rasmus Lerdorf, Torsten Lodderstedt, Hui-Lan Lu, Paul Madsen,
        Alastair Mair, Eve Maler, James Manger, Mark McGloin, Laurence Miao, Chuck Mortimore,
        Justin Richer, Peter Saint-Andre, Nat Sakimura, Rob Sayre, Marius Scurtescu, Naitik Shah,
        Luke Shepard, Vlad Skvortsov, Justin Smith, Jeremy Suriel, Christian Stbner, Paul Tarjan,
        Allen Tom, Franklin Tse, Nick Walker, Skylar Woodward.
      </t>
    </section>

    <appendix title="Editor's Notes">
      <t>
        While many people contributed to this specification throughout its long journey, the editor
        would like to acknowledge and thank a few individuals for their outstanding and invaluable
        efforts leading up to the publication of this specification. It is these individuals without
        whom this work would not have existed, or reached its successful conclusion.
      </t>
      <t>
        David Recordon for continuously being one of OAuths most valuable assets, bringing
        pragmatism and urgency to the work, and helping shape it from its very beginning, as well
        as being one of the best collaborators I had the pleasure of working with.
      </t>
      <t>
        Mark Nottingham for introducing OAuth to the IETF and setting the community on this course.
        Lisa Dusseault for her support and guidance as the Application area director. Blaine Cook,
        Peter Saint-Andre, and Hannes Tschofenig for their work as working group chairs.
      </t>
      <t>
        James Manger for his creative ideas and always insightful feedback. Brian Campbell,
        Torsten Lodderstedt, Chuck Mortimore, Justin Richer, Marius Scurtescu, and Luke Shepard for
        their continued participation and valuable feedback.
      </t>
      <t>
        Special thanks goes to Mike Curtis and Yahoo! for their unconditional support of this work
        for over three years.
      </t>
    </appendix>

  </middle>

  <back>

    <references title='Normative References'>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-html401-19991224.xml' ?>

    </references>

    <references title='Informative References'>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5849.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-oauth-v2-bearer-04.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-oauth-saml2-bearer-03.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-oauth-v2-http-mac-00.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-lodderstedt-oauth-security-01.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml2/reference.OASIS.saml-core-2.0-os.xml' ?>

      <reference anchor="I-D.draft-hardt-oauth-01">
        <front>
          <title>OAuth Web Resource Authorization Profiles</title>
          <author initials="D" surname="Hardt" fullname="Dick Hardt" role="editor" />
          <author initials="A" surname="Tom" fullname="Allen Tom" />
          <author initials="B" surname="Eaton" fullname="Brian Eaton" />
          <author initials="Y" surname="Goland" fullname="Yaron Goland" />
          <date month="January" day="15" year="2010" />
        </front>
        <format type="TXT" target="http://www.ietf.org/internet-drafts/draft-hardt-oauth-01.txt" />
      </reference>

    </references>

  </back>

</rfc>
