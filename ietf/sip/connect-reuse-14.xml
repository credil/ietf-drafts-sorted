<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
 
<?rfc toc="yes" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="no" ?>

<rfc  docName="DOCNAME"
      category= "std"
      ipr="trust200902"> 

<front>
    <title abbrev="SIP Connection Reuse">
       Connection Reuse in the Session Initiation Protocol (SIP)
    </title>
    <author initials="V." surname="Gurbani" fullname="Vijay K. Gurbani"
            role="editor">
      <organization>Bell Laboratories, Alcatel-Lucent</organization>
      <address>
        <postal/>
        <email>vkg@alcatel-lucent.com</email>
      </address>
    </author>
    <author initials="R." surname="Mahy" fullname="Rohan Mahy">
      <organization>Unaffiliated</organization>
      <address>
	<postal/>
	<email>rohan@ekabal.com</email>
      </address>
    </author>
    <author initials="B." surname="Tate" fullname="Brett Tate">
      <organization>BroadSoft</organization>
      <address>
        <postal/>
        <email>brett@broadsoft.com</email>
      </address>
    </author>
    <date month="MONTH" year="YEAR" />
    <area>Transport</area>
    <workgroup>SIP WG</workgroup>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>connection reuse</keyword>

<abstract>

<t>This document enables a pair of communicating proxies to reuse a 
congestion-controlled connection between themselves for sending requests 
in the forward and backwards direction.  Because the connection is 
essentially aliased for requests going in the backwards direction, reuse 
is predicated upon both the communicating endpoints authenticating 
themselves using X.509 certificates through TLS.  For this reason, we 
only consider connection reuse for TLS over TCP and TLS over SCTP.  
This document also provides guidelines on connection reuse and 
virtual SIP servers and the interaction of connection reuse and 
DNS SRV lookups in SIP.</t>

</abstract>
</front>
<middle>

<section title="Terminology" anchor="terminology">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document 
are to be interpreted as described in 
<xref target="RFC2119">RFC 2119</xref>.</t>

<t>Additional terminology used in this document:</t>
<t>
 <list style="hanging">
  <t hangText="Advertised address:">The address that occurs in the 
  Via header field's sent-by production rule, including the port number 
  and transport.</t>

  <t hangText="Alias:">Re-using an existing connection for sending 
  requests in the backwards direction; i.e., A opens a connection to B 
  to send a request, and B uses that connection to send requests in 
  the backwards direction to A.</t>

  <t hangText="Connection reuse:">See "Alias".</t>

  <t hangText="Persistent connection:">The process of sending multiple,
  possibly unrelated requests on the same connection, and receiving 
  responses on that connection as well.  More succinctly, A opens 
  a connection to B to send a request, and later reuses the same 
  connection to send other requests, possibly unrelated to the dialog 
  established by the first request.  Responses will arrive over 
  the same connection.  Persistent connection behavior is specified 
  in Section 18 of RFC3261 <xref target="RFC3261"/>.  Persistent 
  connections do not imply connection reuse.</t>

  <t hangText="Resolved address:"> The network identifiers (IP address, 
  port, transport) associated with a user agent as a result of 
  executing RFC3263 <xref target="RFC3263"/> on a Uniform Resource 
  Identifier (URI).</t>

  <t hangText="Shared connection:">See "Persistent connection."</t>

 </list>
</t>

</section>

<section title="Applicability Statement">

<t>The applicability of the mechanism described in this document is for
two adjacent SIP entities to reuse connections when they are agnostic about
the direction of the connection, i.e., either end can initiate the connection.
SIP entities that can only open a connection in a specific direction -- perhaps
because of Network Address Translation (NAT) and firewalls -- reuse
their connections using the mechanism described in the outbound
document <xref target="I-D.ietf-sip-outbound"></xref>.</t>

<t>This memo concerns connection reuse, not persistent connections
(see definitions of these in <xref target="terminology"/>).  Behavior 
for persistent connections is specified in Section 18 of RFC3261 
<xref target="RFC3261"/> and is not altered by this memo.</t>

<t>This memo documents that it is good practice to only reuse those
connections where the identity of the sender can be verified by the 
receiver.  Thus, TLS (<xref target="RFC5246">RFC 5246</xref>)
connections (over any connection-oriented transport) formed by 
exchanging X.509 certificates can be reused because they authoritatively 
establish identities of the communicating parties (see 
<xref target="overview"/>).</t>

<!--
For reasons discussed in 
<xref target="auth-tcp"/>, connection reuse over other connection-oriented 
transport -- e.g., TCP, SCTP (<xref target="RFC4960">RFC4960</xref>) --
is not advisable. -->

</section>

<section title="Introduction">

<t>SIP entities can communicate using either 
unreliable/connectionless (e.g., UDP) or reliable/connection-oriented 
(e.g., TCP, SCTP) transport protocols. When SIP entities use a 
connection-oriented protocol (such as TCP or SCTP) to send a request, 
they typically originate their connections from an ephemeral port.</t>

<t>In the following example, A listens for SIP requests over 
TLS on TCP port 5061 (the default port for 
SIP over TLS over TCP), but uses an ephemeral port (port 49160) for a 
new connection to B.  These entities could be SIP user agents or 
SIP proxy servers.</t>

<figure title="Uni-directional connection for requests from A to B"
        anchor="uni-dir">
<artwork><![CDATA[
       +-----------+ 49160 (UAC)     5061 (UAS) +-----------+
       |           |--------------------------->|           |
       |  Entity   |                            |  Entity   |
       |     A     |                            |     B     |
       |           | 5061 (UAS)                 |           |
       +-----------+                            +-----------+

]]></artwork></figure>

<t>The SIP protocol includes the notion of a persistent connection,
which is a mechanisms to insure that responses to a request reuse the 
existing connection that is typically still available, as well as
reusing the existing connections for other requests sent by the originator 
of the connection.  However, new requests sent in the backwards 
direction -- in the example above, requests from B destined to A -- are 
unlikely to reuse the existing connection.  This frequently causes a pair 
of SIP entities to use one connection for requests sent in each direction, 
as shown below.</t>

<figure title="Two connections for requests between A and B."
        anchor="two-conns">
<artwork><![CDATA[
       +-----------+ 49160             5061 +-----------+
       |           |.......................>|           |
       |  Entity   |                        |  Entity   |
       |     A     | 5061             49170 |     B     |
       |           |<-----------------------|           |
       +-----------+                        +-----------+

]]></artwork></figure>

<t>Unlike TCP, TLS connections can be reused to send requests in 
the backwards direction since each end can be authenticated when the 
connection is initially set up.  Once the authentication step 
has been performed, the situation can thought to resemble the picture 
in <xref target="uni-dir"/> except that A and B both use a single
shared connection, for example, between port 49160 on A and
port 5061 on B.  When A wants to send a request to B, it will reuse 
this connection, and when B wants to send a request to A, it will 
reuse the same connection.</t>

</section>

<section title="Benefits of TLS Connection Reuse">

<t>Opening an extra connection where an existing one is sufficient can 
result in potential scaling and performance problems.  Each new connection 
using TLS requires a TCP three-way handshake, a handful of round-trips to 
establish TLS, typically expensive asymmetric authentication and key 
generation algorithms, and certificate verification.  This can lead to 
a build up of considerable queues as the server CPU saturates by the 
TLS handshakes it is already performing (Section 6.19 of Rescorla
<xref target="Book-Rescorla-TLS"/>).</t>

<t>Consider the call flow shown below where Proxy A and Proxy B use the 
Record-Route mechanism to stay involved in a dialog.  Proxy B will 
establish a new TLS connection just to send a BYE request.</t>

<figure title="Multiple connections for requests"
        anchor="fig-mult-conns">
<artwork><![CDATA[

                   Proxy A    Proxy B
                      |          |
  Create connection 1 +---INV--->|
                      |          |
                      |<---200---+ Response over connection 1
                      |          |
  Re-use connection 1 +---ACK--->|
                      |          |
                      =          =
                      |          |
                      |<---BYE---+ Create connection 2
                      |          |
       Response over  +---200--->|
       connection 2

]]></artwork></figure>

<t>Setting up a second connection (from B to A above) for subsequent 
requests, even requests in the context of an existing dialog (e.g., 
re-INVITE request or BYE request after an initial INVITE request, or 
a NOTIFY request after a SUBSCRIBE request or a REFER request), can also 
cause excessive delay (especially in networks with long round-trip times).  
Thus, it is advantageous to reuse connections whenever possible.</t>

<t>From the user expectation point of view, it is advantageous if the
re-INVITE requests or UPDATE requests are handled 
automatically and rapidly in order to avoid media and session state from 
being out of step.  If a re-INVITE request requires a new TLS connection, 
the re-INVITE request could be delayed by several extra round-trip times.  
Depending on the round-trip time, this combined delay could be perceptible 
or even annoying to a human user.  This is especially problematic for some 
common SIP call flows (for example, the recommended example flow in 
figure number 4 in <xref target="RFC3725">RFC3725</xref> use many 
reINVITE requests).</t>

<t>The mechanism described in this document can mitigate the delays 
associated with subsequent requests.</t>

</section>

<section title="Overview of Operation" anchor="overview">

<t>This section is tutorial in nature, and does not specify any normative
behavior.</t>

<t>We now explain this working in more detail in the context of 
communication between two adjacent proxies.  Without any loss of generality, 
the same technique can be used for connection reuse between a UAC and an 
edge proxy, or between an edge proxy and a UAS, or between an UAC and 
an UAS.</t>

<t>P1 and P2 are proxies responsible for routing SIP requests to
user agents that use them as edge proxies 
(see <xref target="fig-proxy-setup"/>).</t>

<figure title="Proxy setup"
        anchor="fig-proxy-setup">
<artwork><![CDATA[
                P1 <===================> P2
           p1.example.com          p2.example.net
            (192.0.2.1)              (192.0.2.128)

     +---+                                    +---+
     |   |   0---0                   0---0    |   |
     |___|    /-\                     /-\     |___|
    /    /   +---+                   +---+   /    /
   +----+                                   +----+
   User Agents                       User Agents
   example.com domain                example.net domain

]]></artwork></figure>
         
<t>For illustration purpose the discussion below uses TCP as a transport 
for TLS operations.  Another streaming transport -- such as SCTP 
-- can be used as well.</t>

<t>The act of reusing a connection is initiated by P1 when it adds 
an "alias" header field parameter (defined later) to the Via header field.  
When P2 receives the request, it examines the topmost Via header field.  
If the Via header contained an "alias" header field parameter, P2 
establishes a binding such that subsequent requests going to P1 will 
reuse the connection; i.e., requests are sent over the established 
connection.</t>

<t>With reference to <xref target="fig-proxy-setup"/>, in order for 
P2 to reuse a connection for requests in the backwards direction, it is 
important that the validation model for requests sent in 
this direction (i.e., P2 to P1) is equivalent to the normal 
"connection in each direction" model, wherein P2 acting as client would 
open up a new connection in the backwards direction and validate the 
connection by examining the X.509 certificate presented.  The act of 
reusing a connection needs the desired property that requests get 
delivered in the backwards direction only if they would have been 
delivered to the same destination had connection reuse not been 
employed.  To guarantee this property, the X.509 certificate presented 
by P1 to P2 when a TLS connection is first authenticated are     
cached for later use.</t>

<t>To aid the discussion of connection reuse, this document defines
a data structure called the connection alias table (or simply, alias table),
which is used to store aliased addresses and is used by user agents to
search for an existing connection before a new one is opened up to a
destination.  It is not the intent of this memo to standardize the 
implementation of an alias table; rather we use it as a convenience to 
aid subsequent discussions.</t>

<t>P1 gets a request from one of its upstream user agents, and after 
performing RFC3263 <xref target="RFC3263"/> server selection, arrives 
at a resolved address of P2.  P1 maintains an alias table, and it 
populates the alias table with the IP address, port number, and transport 
of P2 as determined through RFC3263 server selection.  P1 adds an 
"alias" header field parameter to the topmost Via header field (inserted 
by it) before sending the request to P2.  The value in the sent-by 
production rule of the Via header field (including the port number), and 
the transport over which the request was sent becomes the advertised address 
of P1:</t>

<t>Via: SIP/2.0/TLS p1.example.com;branch=z9hG4bKa7c8dze;alias</t>

<t>Assuming that P1 does not already have an existing aliased connection 
with P2, P1 now opens a connection with P2. P2 presents its X.509 
certificate to P1 for validation (see <xref target="auth-tls-client"/>).  
Upon connection authentication and acceptance, P1 adds P2 to its 
alias table.  P1's alias table now looks like:</t>

<artwork><![CDATA[
Destination  Destination  Destination  Destination      Alias 
IP Address   Port         Transport    Identity         Descriptor
...
192.0.2.128  5061         TLS          sip:example.net     25
                                       sip:p2.example.net

]]></artwork>

<t>Subsequent requests that traverse from P1 to P2 will reuse this 
connection; i.e., the requests will be sent over the descriptor 25.</t>

<t>The following columns in the alias table created at the client
warrant an explanation:</t>

<list style="numbers">
 <t>The IP address, port and transport are a result of executing
 RFC3263 server resolution process on a next hop URI.</t>
 <t>The entries in the fourth column consists of the identities of
 the server as asserted in the X.509 certificate presented by the
 server.  These identities are cached by the client after the
 server has been duly authenticated 
 (see <xref target="auth-tls-client"/>).</t>
 <t>The entry in the last column is the socket descriptor over which
 P1, acting as a client, actively opened a TLS connection.  At some
 later time, when P1 gets a request from one of the user agents in its
 domain, it will reuse the aliased connection accessible through
 socket descriptor 25 if and only if all of the following conditions 
 hold:</t>
 <list style="letters">
  <t>P1 determines through the RFC3263 server resolution process that the
  {transport, IP-address, port} tuple of P2 to be {TLS, 192.0.2.128, 5061},
  and </t>
  <t>The URI used for the RFC3263 server resolution matches one of the
  identities stored in the cached certificate (fourth column).</t>
 </list>
</list>

<t>When P2 receives the request it examines the topmost Via header field
to determine whether P1 is willing to use this connection as an aliased
connection (i.e., accept requests from P2 towards P1.)  The Via header
field at P2 now looks like the following (the "received" header field 
parameter is added by P2):</t>

<artwork><![CDATA[
Via: SIP/2.0/TLS p1.example.com;branch=z9hG4bKa7c8dze;alias;
  received=192.0.2.1
]]></artwork>

<t>The presence of the "alias" Via header field parameter indicates that 
P1 supports aliasing on this connection.  P2 now authenticates the 
connection (see <xref target="auth-tls-server"/>) and if the authentication 
was successful, P2 creates an alias to P1 using the advertised address in 
the topmost Via header field.  P2's alias table looks like the 
following:</t>

<artwork><![CDATA[
Destination  Destination  Destination  Destination     Alias
IP Address   Port         Transport    Identity        Descriptor
...
192.0.2.1    5061             TLS      sip:example.com     18
                                       sip:p1.example.com
]]></artwork>

<t>There are a few items of interest here:</t>
<list style="numbers">
 <t>The IP address field is populated with the source address of
 the client.</t>
 <t>The port field is populated from the advertised address (topmost
 Via header field), if a port is present in it, or 5061 if it is not.</t>
 <t>The transport field is populated from the advertised address (topmost
 Via header field).</t>
 <t>The entries in the fourth column consist of the identities of
 the client as asserted in the X.509 certificate presented by the
 client.  These identities are cached by the server after the client
 has been duly authenticated (see <xref target="auth-tls-server"/>).</t>
 <t>The entry in the last column is the socket descriptor over which
 the connection was passively accepted.  At some later time, when
 P2 gets a request from one of the user agents in its domain, it will
 reuse the aliased connection accessible through socket descriptor
 18 if and only if all of the following conditions hold:</t>
 <list style="letters">
  <t>P2 determines through RFC3263 server resolution process that the
  {transport, IP-address, port} tuple of P1 to be {TLS, 192.0.2.1, 5061},
  and </t>
  <t>The URI used for RFC3263 server resolution matches one of the
  identities stored in the cached certificate (fourth column).</t>
 </list>
 <t>The network address inserted in the "Destination IP Address" column 
 is the source address as seen by P2 (i.e., the "received" header field
 parameter).  It could be the case that the host name of P1 resolves 
 to different IP addresses due to round-robin DNS.  However, the 
 aliased connection is to be established with the original sender of 
 the request.</t>
</list>

</section> <!-- overview -->

<section title="Requirements">

<t>The following are the requirements that motivated this specification:</t>

<t><list style="numbers">

<t>A connection sharing mechanism should allow SIP entities to reuse existing
connections for requests and responses originated from either peer in the
connection.</t>

<t>A connection sharing mechanism must not require clients to send 
all traffic from well-know SIP ports.</t>

<t>A connection sharing mechanism must not require configuring ephemeral port 
numbers in DNS.</t>

<t>A connection sharing mechanism must prevent unauthorized hijacking of 
other connections.</t>

<t>Connection sharing should persist across SIP transactions and dialogs.</t>

<t>Connection sharing must work across name-based virtual SIP servers.</t>

<t>There is no requirement to share a complete path for ordinary connection 
reuse.  Hop-by-hop connection sharing is more appropriate.</t>

</list>
</t>
</section>

<section title="Formal Syntax">

<t>The following syntax specification uses the augmented Backus-Naur Form (BNF)
as described in <xref target="RFC5234">RFC 5234</xref>.  This document 
extends the via-params to include a new via-alias defined below.</t>

<artwork>
   via-params =/ via-alias
   via-alias  =  "alias"
</artwork>

</section>

<section title="Normative Behavior">

<!--
<t>When this document is followed to specify connection reuse, an alias 
is formed at the receiver of a request when it gets a request
with the "alias" parameter in the topmost Via header.  If the receiver 
decides to accept the alias, then the alias corresponds to the source IP
address, transport, port (if one exists in the Via sent-by, or the default 
port if it does not), and the identities of the sender as asserted in
the certificate of the sender of the request.  Whenever the RFC3263
server selection mechanism executed at the receiver results in the 
choice of this IP address, port, transport, and identity tuple, the 
alias SHOULD be used instead.</t>

<t><list>
 <t>Note that at the receiver, the responses are sent over the same 
 connection as specified by RFC3261.  The aliasing mechanism at the 
 receiver allows subsequent requests going from the receiver to the original 
 sender of the request to reuse the same connection.</t>
</list></t>

<t>An alias is formed at the sender of the request when it executes the
RFC3263 server selection mechanism to arrive at an IP address, port, 
and transport tuple to send a request to.  Subsequent requests going to 
the same resolved address SHOULD use the alias instead.</t>
-->

<section title="Client Behavior">

<t>Clients SHOULD keep connections up as long as they are needed.  
Connection reuse works best when the client and the server maintain 
their connections for long periods of time.  Clients, therefore, SHOULD 
NOT automatically drop connections on completion of a transaction or 
termination of a dialog.</t>

<t>The mechanism for connection reuse uses a new Via header 
field parameter.  The "alias" header field parameter is included in 
a Via header field value to indicate that the client wants to create 
a transport layer alias.  The client places its advertised address in 
the Via header field value (in the "sent-by" production).</t>

<t>If the client places an "alias" header field parameter in the topmost 
Via header of the request, the client SHOULD keep the connection open for 
as long as the resources on the host operating system allow it to, and 
that the client MUST accept requests over this connection -- in addition 
to the default listening port -- from its downstream peer.  And furthermore, 
the client SHOULD reuse the connection when subsequent requests in the 
same or different transactions are destined to the same resolved address.</t>

<t><list>
 <t>Note that RFC3261 states that a response arrives over the same 
 connection that was opened for a request.</t>
</list></t>

<t>Whether or not to allow an aliased connection ultimately depends on
the recipient of the request; i.e., the client does not get any confirmation
that its downstream peer created the alias, or indeed that it even supports
this specification.  Thus, clients MUST NOT assume that the acceptance of 
a request by a server automatically enables connection aliasing.  Clients 
MUST continue receiving requests on their default port.</t>

<t>Clients MUST authenticate the connection before 
forming an alias; <xref target="auth-tls-client"/> discusses the 
authentication steps in more detail.  Once the server has been 
authenticated, the client MUST cache, in the alias table, the identity 
(or identities) of the server as determined in Section 7.1 of
RFC YYYY <xref target="I-D.domain-certs"/> (Note to RFC Editor: Please 
replace RFC YYYY with the RFC number assigned to the this reference.)
The client MUST also populate the destination IP address, port, 
and transport of the server in the alias table; these fields are 
retrieved from executing RFC3263 server resolution process on the 
next hop URI.  And finally, the client MUST populate the alias 
descriptor field with the connection handle (or identifier) used to 
connect to the server.</t>

<t>Once the alias table has been updated with a resolved address,
and the client wants to send a new request in the direction of the server, 
the client reuses the connection only if all of the following conditions
hold:</t>

<list style="numbers">
 <t>The client uses the RFC3263 resolution on a URI and arrives at a
 resolved address contained in the alias table, and</t>
 <t>The URI used for RFC3263 server resolution matches one of the
 identities stored in the alias table row corresponding to that resolved
 address.</t>
</list>

<t>Clients MUST be prepared for the case that the connection no longer 
exists when they are ready to send a subsequent request over it.  In 
such a case, a new connection MUST be opened to the resolved address and 
the alias table updated accordingly.</t>

<t>This behavior has an adverse side effect when a CANCEL
request or an ACK request for a non-2xx response is sent downstream.
Normally, these would be sent over the same connection that the 
INVITE request was sent over.  However, if between the sending of
the INVITE request and subsequent sending of the CANCEL request or 
ACK request to a non-2xx response, the connection was closed, then 
the client SHOULD open a new connection to the resolved address and 
send the CANCEL request or ACK request there instead.  The client
MAY insert the newly opened connection into the alias table.</t>

</section>

<section title="Server Behavior">

<t>Servers SHOULD keep connections up unless they need to reclaim 
resources.  Connection reuse works best when the client and the 
server maintain their connections for long periods of time.  Servers, 
therefore, SHOULD NOT automatically drop connections on completion of a
transaction or termination of a dialog.</t>

<!--
<t>The server SHOULD NOT use any TCP connection or SCTP association, 
which has been accepted at the server, to send requests.

<t>For TCP and SCTP transports, the server SHOULD NOT accord any
semantics to the "alias" header field parameter, if present, in the 
topmost Via header field unless conditions mentioned in 
<xref target="auth-tcp"/> are duly considered.</t>

<t>The rest of the discussion below applies to only the TLS transport.</t>
-->

<t>When a server receives a request over TLS whose topmost Via header field
contains an "alias" header field parameter, it signifies that the upstream 
client will leave the connection open beyond the transaction and dialog 
lifetime, and that subsequent transactions and dialogs that are destined 
to a resolved address that matches the identifiers in the advertised 
address in the topmost Via header field can reuse this connection. </t>

<t>Whether or not to use in the reverse direction a connection marked with
the "alias" Via header field parameter ultimately depends on the policies 
of the server.  It can choose to honor it, and thereby send subsequent 
requests over the aliased connection.  If the server chooses not to honor 
an aliased connection, the server MUST allow the request to proceed as 
though the "alias" header field parameter was not present in the topmost 
Via header.</t>

<t><list>
 <t>This assures interoperability with RFC3261 server behavior.  Clients
 can include the "alias" header field parameter without fear that the 
 server will reject the SIP request because of its presence.</t>
</list></t>

<t>Servers MUST be prepared to deal with the case that the aliased 
connection no longer exist when they are ready to send a subsequent
request over it.  This can happen if the peer ran out of operating system
resources and had to close the connection.  In such a case, the server
MUST open a new connection to the resolved address and the alias table 
updated accordingly.</t>

<t>If the sent-by production of the Via header field contains a port, the 
server MUST use it as a destination port.  Otherwise the default port is 
the destination port.</t>

<t>Servers MUST follow the authentication steps outlined in
<xref target="auth-tls-server"/> to authenticate the connection 
before forming an alias.</t>

<t>The server, if it decides to reuse the connection, MUST cache
in the alias table the identity (or identities) of the client as they
appear in the X.509 certificate subjectAlternativeName extension field.  
The server also populates the destination IP address, port and 
transport in the alias table from the topmost Via header field (using the 
";received" parameter for the destination IP address).  If the port 
number is omitted, a default port number of 5061 is to be used.  And 
finally, the server populates the alias descriptor field with the 
connection handle (or identifier) used to accept the connection from 
the client (see <xref target="overview"/> for the contents of 
the alias table.)</t>

<t>Once the alias table has been updated, and the server wants to
send a request in the direction of the client, it reuses the
connection only if all of the following conditions hold:</t>

<list style="numbers">
  <t>The server, which acts as a client for this transaction, 
  uses the RFC3263 resolution process on a URI and arrives at a 
  resolved address contained in the alias table, and</t>
  <t>The URI used for RFC3263 server resolution matches one of the
  identities stored in the alias table row corresponding to that
  resolved address.</t>
</list>

</section>

<section title="Closing a TLS connection"
         anchor="tls-close">

<t>Either the client or the server may terminate a TLS session by
sending a TLS closure alert.  Before closing a TLS connection, 
the initiator of the closure MUST either wait for any outstanding 
SIP transactions to complete, or explicitly abandon them.</t>

<t>After the initiator of the close has sent a closure alert, it
MUST discard any TLS messages until it has received a similar
alert from its peer.  The receiver of the closure alert MUST NOT
start any new SIP transactions after the receipt of the closure
alert.</t>

</section>

</section> <!-- Normative Behavior -->

<section anchor="auth" title="Security Considerations">

<t>This document presents requirements and a mechanism for reusing existing 
connections easily.  Unauthenticated connection reuse would present many 
opportunities for rampant abuse and hijacking.  Authenticating connection 
aliases is essential to prevent connection hijacking.  For example, a program 
run by a malicious user of a multiuser system could attempt to hijack 
SIP requests destined for the well-known SIP port from a large relay 
proxy.</t>

<section title="Authenticating TLS Connections: Client View" 
         anchor="auth-tls-client">

<t>When a TLS client establishes a connection with a server, it is
presented with the server's X.509 certificate.  Authentication proceeds
as described in Section 7.3 ("Client behavior") of RFC 
YYYY <xref target="I-D.domain-certs"/>.
 <list style="empty">
  <t>Note to RFC Editor: Please replace RFC YYYY with the RFC number
  assigned to the above reference.</t>
 </list>
</t>

</section>

<section title="Authenticating TLS Connections: Server View"
         anchor="auth-tls-server">

<t>A TLS server conformant to this specification MUST ask for a client
certificate; if the client possesses a certificate, it will be presented
to the server for mutual authentication, and authentication proceeds
as described in Section 7.4 ("Server behavior") of RFC YYYY 
<xref target="I-D.domain-certs"/>.
 <list style="empty">
  <t>Note to RFC Editor: Please replace RFC YYYY with the RFC number
  assigned to the above reference.</t>
 </list>
</t>

<t>If the client does not present a certificate, the server MUST
proceed as if the "alias" header field parameter was not present in 
the topmost Via header.  In this case, the server MUST NOT update the 
alias table.</t>

</section>

<!-- Commented this due to AD review.

<section title="Security Considerations for TCP and SCTP Transports" 
         anchor="auth-tcp">

<t>Clients SHOULD NOT reuse TCP connections or SCTP associations 
using the same mechanism to reuse TLS connections because there isn't 
any way to perform the authentication step.</t>

<t>Connection reuse over TCP or SCTP is inherently insecure.  Without
the X.509 certificate-based proof of identity when using TLS between
communicating peers, the mechanisms defined in this document can enable
a rogue host to represent a legitimate domain's proxy simply by populating 
the topmost Via header field sent-by production rule with a legitimate 
domain name.  As an example, consider a proxy that receives a request 
with the following topmost Via header field (the "received" header field
parameter is added by the proxy after getting the request):</t>

<artwork>
Via: SIP/2.0/TCP p1.example.com;branch=z9hG4bKa7c8dze;alias;
   received=192.0.2.100
</artwork>

<t>The proxy has no authoritative means of asserting that the sender of 
this request can indeed be trusted to belong to the example.com
domain; all it has is the information in the advertised address.  If it 
attempts to reuse this connection, requests that would normally go to 
the example.com domain would now instead be destined to 192.0.2.100, 
which can in fact be a rogue host that has no affiliation with the 
example.com domain.</t>

<t>For this reason, connection reuse over TCP and SCTP is NOT RECOMMENDED 
unless the server-end of the connection has some way of verifying the 
identity of the client-end of the connection to the same level of 
assurance as it would have by doing a DNS lookup and establishing 
a connection in the backwards direction.  For example, if a DNS lookup 
resolved to the same address and port as the source address and 
source port of the inbound connection, then this level of assurance can
be acceptable.</t>

<t>If the server-end of the connection does not have any manner of
verifying the identity of the client-end, then it actively
opens up a connection in the direction of its peer using RFC3263
server selection process.  This connection can be used as a 
persistent connection for requests going in the backwards direction.
Thus the two peers will open and maintain a connection in the direction
of the other (as depicted in <xref target="two-conns"/>).  This manner 
of opening connections, while still not secure, is at least more secure 
than using the connection reuse mechanism over TCP or SCTP in an 
unauthenticated fashion.</t>

</section>
-->

<!-- </section> -->

<section title="Connection reuse and Virtual servers" anchor="virt-server">

<t>Virtual servers present special considerations for connection 
reuse.  Under the name-based virtual server scheme, one SIP proxy 
can host many virtual domains using one IP address and port number.  
If adequate defenses are not put in place, a connection opened to 
a downstream server on behalf of one domain can be reused to send
requests in the backwards direction to a different domain.  The 
Destination Identity column in the alias table has been added to 
aid in such defenses.</t>

<t>Virtual servers MUST only perform connection reuse for TLS
connections; virtual servers MUST NOT perform connection reuse
for other connection-oriented transports.  To understand why this is 
the case, note that the alias table caches not only which connections 
go to which destination addresses, but also which connections have 
authenticated themselves as responsible for which domains.  If a 
message is to be sent in the backwards direction to a new SIP domain 
that resolves to an address with a cached connection, the cached 
connection cannot be used because it is not authenticated for the 
new domain.</t>

<t>As an example, consider a proxy P1 that hosts two virtual 
domains -- example.com and example.net -- on the same IP address
and port.  RFC3263 server resolution is set up such that a DNS lookup
of example.com and example.net both resolve to an  {IP-address, port,
transport} tuple of {192.0.2.1, 5061, TLS}.  A user agent in the 
example.com domain sends a request to P1 causing it to make a 
downstream connection to its peering proxy, P2, and authenticating itself
as a proxy in the example.com domain by sending it a X.509 certificate
asserting such an identity.  P2's alias table now looks like the
following:</t>

<artwork><![CDATA[
Destination  Destination  Destination  Destination     Alias
IP Address   Port         Transport    Identity        Descriptor
...
192.0.2.1    5061             TLS      sip:example.com     18
]]></artwork>

<t>At some later point in time, a user agent in P2's domain wants to
send a request to a user agent in the example.net domain.  P2 performs 
a RFC3263 server resolution process on sips:example.net to derive a
resolved address tuple {192.0.2.1, 5061, TLS}.  It appears that a 
connection to this network address is already cached in the alias table, 
however, P2 cannot reuse this connection because the destination 
identity (sip:example.com) does not match the server identity used for 
RFC3261 resolution (sips:example.net).  Hence, P2 will open up a new 
connection to the example.net virtual domain hosted on P1.  P2's alias 
table will now look like:</t>

<artwork><![CDATA[
Destination  Destination  Destination  Destination     Alias
IP Address   Port         Transport    Identity        Descriptor
...
192.0.2.1    5061             TLS      sip:example.com     18
192.0.2.1    5061             TLS      sip:example.net     54

]]></artwork>

<t>The identities conveyed in an X.509 certificate are associated with
a specific TLS connection.  Absent such a guarantee of an identity tied
to a specific connection, a normal TCP or SCTP connection cannot be 
used to send requests in the backwards direction without a significant 
risk of inadvertent (or otherwise) connection hijacking.</t>

<t>The above discussion details the impact on P2 when connection
reuse is desired for virtual servers.  There is a subtle, but
important impact on P1 as well.</t>

<t>P1 should keep separate alias tables for the requests served
from the UAs in the example.com domain from those served by
the UAs in the example.net domain.  This is so that the
boundary between the two domains is preserved; P1 MUST NOT 
open a connection on behalf of one domain and reuse it to send a 
new request on behalf of another domain.</t>

</section> <!-- virt-server -->
</section>

<section title="Connection Reuse and SRV Interaction">

<t>Connection reuse has an interaction with the DNS SRV load balancing
mechanism.  To understand the interaction, consider the following figure:</t>

<figure title="Load balancing"
        anchor="fig-load-balancing">
<artwork>

          /+---- S1
+-------+/
| Proxy |------- S2
+-------+\
          \+---- S3

</artwork></figure>

<t>Here, the proxy uses DNS SRV to load balance across the three servers,
S1, S2, and S3.  Using the connect reuse mechanism specified in this
document, over time the proxy will maintain a distinct aliased connection to 
each of the servers.  However, once this is done, subsequent traffic is load 
balanced across the three downstream servers in the normal manner.</t>

</section>

<section title="IANA Considerations">
<t>This specification defines a new Via header field parameter called
"alias" in the "Header Field Parameters and Parameter Values"
sub-registry as per the registry created by RFC 3968 <xref target="RFC3968"/>.
The required information is:</t>

<artwork>
Header Field  Parameter Name  Predefined Values  Reference
___________________________________________________________________
Via           alias                 No           RFCXXXX

RFC XXXX [NOTE TO RFC-EDITOR: Please replace with final RFC number of 
this specification.]
</artwork>

</section>

<section title= "Acknowledgments" >

<t>Thanks to Jon Peterson for helpful answers about certificate behavior with 
SIP, Jonathan Rosenberg for his initial support of this concept, and 
Cullen Jennings for providing a sounding board for this idea.  Other
members of the SIP WG that contributed to this document include
Jeroen van Bemmel, Keith Drage, Matthew Gardiner, Rajnish Jain, Benny
Prijono, and Rocky Wang.</t>

<t>Dale Worley and Hadriel Kaplan graciously performed a WGLC review of
the draft.  The resulting revision has benefited tremendously from
their feedback.</t>

</section>


  </middle>

  <back>
    <references title="Normative References">

<reference anchor="RFC3261">
 <front>
  <title>SIP: Session Initiation Protocol</title>
  <author initials="J." surname="Rosenberg"/>
  <author initials="H." surname="Schulzrinne"/>
  <author initials='G.' surname='Camarillo'/>
  <author initials='A.' surname='Johnston'/>
  <author initials='J.' surname='Peterson'/>
  <author initials='R.' surname='Sparks'/>
  <author initials='M.' surname='Handley'/>
  <author initials='E.' surname='Schooler'/>
  <date month="June"  year="2002"/>
 </front>
 <seriesInfo name="RFC" value="3261"/>
 <format type="TXT" target="http://www.ietf.org/rfc/rfc3261.txt"/>
</reference>

<reference anchor="RFC2119">
 <front>
  <title>Key words for use in RFCs to Indicate Requirement Levels</title>
  <author initials="S." surname="Bradner">
    <organization></organization>
  </author>
  <date month="March" year="1997"/>
 </front>
 <seriesInfo name="RFC" value="2119"/>
 <format type="TXT" target="http://www.ietf.org/rfc/rfc2119.txt"/>
</reference>

<reference anchor="RFC5246">
 <front>
  <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
  <author initials="T." surname="Dierks"/>
  <author initials="E." surname="Rescorla"/>
  <date month="August" year="2008"/>
 </front>
 <seriesInfo name="RFC" value="5246"/>
 <format type="TXT" target="http://www.ietf.org/rfc/rfc5246.txt"/>
</reference>

<reference anchor="RFC3263">
 <front>
  <title>Session Initiation Protocol (SIP): Locating SIP Servers</title>
  <author initials="J." surname="Rosenberg"/>
  <author initials="H." surname="Schulzrinne"/>
  <date month="June" year="2002"/>
 </front>
 <seriesInfo name="RFC" value="3263"/>
 <format type="TXT" target="http://www.ietf.org/rfc/rfc3263.txt"/>
</reference>

<reference anchor='RFC5234'>
 <front>
  <title>Augmented BNF for Syntax Specifications: ABNF</title>
  <author initials='D.H.' surname='Crocker'></author>
  <author initials='P.' surname='Overell'></author>
  <date month='January' year='2008' />
 </front>
  <seriesInfo name='RFC' value='5234' />
  <format type="TXT" target="http://www.ietf.org/rfc/rfc5234.txt"/>
</reference>

<reference anchor="I-D.domain-certs">
 <front>
  <title>Domain Certificates in the Session Initiation Protocol (SIP)</title>
  <author initials="V.K" surname="Gurbani"></author>
  <author initials="S." surname="Lawrence"></author>
  <author initials="A." surname="Jeffrey"></author>
  <date month="May" year="2009" />
 </front>
  <seriesInfo name="Internet-Draft" 
              value="draft-ietf-sip-domain-certs-04"/>
  <format type="TXT" 
          target="http://www.ietf.org/internet-drafts/draft-ietf-sip-domain-certs-04.txt"/>
</reference>

</references>

<references title="Informational References">

<reference anchor='RFC3968'>
 <front>
  <title>The Internet Assigned Numbers Authority (IANA) Header 
   Field Parameter Registry for the Session Initiation Protocol (SIP)
  </title>
  <author initials="G." surname="Camarillo"></author>
  <date month="December" year="2004" />
 </front>
  <seriesInfo name="BCP" value="98"/>
  <seriesInfo name="RFC" value="3968" />
  <format type="TXT" target="http://www.ietf.org/rfc/rfc3968.txt"/>
</reference>

<reference anchor="I-D.ietf-sip-outbound">
 <front>
  <title>Managing Client Initiated Connections in the Session Initiation 
         Protocol (SIP)</title>
  <author initials="C." surname="Jennings"/>
  <author initials="R." surname="Mahy"/>
  <date month="June" year="2009"/>
 </front>
 <seriesInfo name="Internet-Draft" 
  value="draft-ietf-sip-outbound-20"/>
 <format type="TXT"
  target="http://www.ietf.org/internet-drafts/draft-ietf-sip-outbound-20.txt"/>
</reference>

<reference anchor="Book-Rescorla-TLS">
 <front>
  <title>SSL and TLS: Designing and Building Secure Systems</title>
  <author initials="E." surname="Rescorla"></author>
  <date year="2001"/>
 </front>
 <seriesInfo name="Addison-Wesley Publishing" value=""/>
</reference>

<reference anchor="RFC3725">
 <front>
  <title>Best Current Practices for Third Party Call Control (3pcc) in the
         Session Initiation Protocol (SIP)</title>
  <author initials="J." surname="Rosenberg"></author>
  <author initials="J." surname="Peterson"></author>
  <author initials="H." surname="Schulzrinne"></author>
  <author initials="H." surname="Camarillo"></author>
  <date month="April" year="2004" />
 </front>
  <seriesInfo name="RFC" value="3725" />
  <format type="TXT" target="http://www.ietf.org/rfc/rfc3725.txt"/>
</reference>

<reference anchor="RFC4960">
 <front>
  <title>Stream Control Transmission Protocol</title>
  <author initials="R." surname="Stewart"></author>
  <date month="September" year="2007" />
 </front>
 <seriesInfo name="RFC" value="4960" />
 <format type="TXT" target="http://www.ietf.org/rfc/rfc4960.txt"/>
</reference>

</references>
</back>
</rfc>

<!--
<section title="Authorizing a cluster of proxies">

<t><list>
 <t>NOTE NOTE NOTE NOTE NOTE NOTE: Section maintained for historical 
 reasons only.  Disregard any normative behavior specified in this section.</t>
 <t>Editor's note: I am leaving the rest of this section as-is for right now 
 until we decide what to do with it.  The information here addresses a
 requirement in the -04 version, which stated that "A connection sharing
 mechanism SHOULD allow SIP entities to reuse existing connections with
 closely coupled nodes which act as a single SIP entity (for example a
 cluster of nodes acting as a proxy server)."  That particular requirement
 has been removed from the current version since it interacted in a 
 sub-optimal way with the DNS and SRV load balancing mechanism.  However, the
 information in this section is helpful and I want to preserve it for 
 possible use later in a different context.  It has the nasty side-effect
 that the private key has to be shared across a cluster of proxies...</t>
</list></t>

<t>When clusters or farms of cooperating SIP servers (for example proxy 
servers) are configured together, this mechanism allows a SIP entity to select 
a server with an existing connection.  With this mechanism, Proxy B sends 
requests for Proxy cluster A to node A2 with whom it already shares an 
existing connection.</t>

<figure><artwork><![CDATA[
      +------------+
      |   Proxy    |
      |     A1     |
      |            |                        +-----------+
      | 10.54.32.1 |                        |           |
      +------------+                        |   Proxy   |
      +------------+ 49160             5061 |     B     |
      |   Proxy    |<======================>|           |
      |     A2     |                        +-----------+
      |            |
      | 10.54.32.2 |
      +------------+
]]></artwork></figure>
<t>
For example, on receipt of a message with the topmost Via header shown below, the transport layer in Proxy B creates an alias such that requests going to the advertised address (proxy-farm-a.example.com) are sent over the target connection (from 10.54.32.2:49160). 
</t>
<figure><artwork>
Via: SIP/2.0/TLS proxy-farm-a.example.com;branch=z9hG4bK7c8ze;alias
 ;received=10.54.32.2
</artwork></figure>
<t>
As a result, this has an important interaction with the DNS resolution mechanisms for SIP described in <xref target="RFC3263">RFC3263</xref>.  When new requests arrive for proxy-farm-a.example.com, proxy B still needs to perform a DNS NAPTR lookup to select the transport. Once the transport is selected, an SRV lookup would ordinarily occur to find the appropriate port number. In this case, the transport layer uses a connection reuse alias instead of performing the SRV query. 
</t><t>
Below is a partial DNS zone file for atlanta.com.
</t>
<figure><artwork>
; NAPTR queries for the current domain (example.com)
;
; order pref flags service regexp replacement
proxy-farm-a IN NAPTR 50 50 "s" "SIPS+D2T" "" _sips._tcp.proxy-farm-a
 
; SRV records for the proxy use 5060/5061
;
;; Priority Weight Port Target
_sips._tcp.proxy-farm-a  IN SRV 0 1 5061 host-a1
_sips._tcp.proxy-farm-a  IN SRV 0 1 5061 host-a2

host-a1  IN A 10.54.32.1
host-a2  IN A 10.54.32.2
</artwork></figure>
<t>
The existence of an alias parameter in a Via header in a request is treated as a request to the transport layer to create an alias (named by the sent-by parameter) that points to the alias target (the current connection) 
</t><t>
This mechanism is fully backwards compatible with existing implementations.  If the new Via parameter is not understood by the recipient, it will be ignored and the two implementations will revert to current behavior (two connections).
</t>

<t>The authorization mechanism for this mechanism requires TLS mutual 
authentication, such that the subjectAltName of the originator certificate 
corresponds to both the current connection and the target address of 
the alias.   The Via sent-by address needs to be within the scope protected 
by the certificate presented by the originator during TLS mutual 
authentication and the received IP address needs be a valid IP address for 
the sent-by host or hosts.  In other words, the sent-by address MUST be 
resolvable from the subjectAltName of the originator certificate, and the 
received IP address MUST be resolvable from the sent-by address.  This is in 
addition to other requirements for TLS authentication and authorization 
discussed in <xref target="RFC3261">SIP</xref> and 
<xref target="RFC3263">Locating SIP Servers</xref>.
</t><t>
Following this logic step-by-step: 
</t>
<list style="numbers"><t>
Verify that the certificate presented is not expired and is rooted in a trusted certificate chain.
</t><t>
Verify that the subjectAltName in the certificate covers the "advertised address" (the address in the Via sent-by production).   If the advertised address and the subjectAltName match exactly then the certificate covers the address.  
</t><t>
Use DNS to resolve if the advertised name is resolvable from the subjectAltName (start by resolving the subjectAltName as if it where a target URI according to the rules in RFC3263.  That is, if no port number is present perform an SRV lookup, then finally resolve relevant address records).  If any of the resolved addresses (port numbers can be ignored in this case) matches the advertised address, then the certificate covers the address.
</t><t>
Finally, verify that the advertised address can resolve to the IP address over which the connection was received.
</t></list>
<t>
For example, take the example in the previous section of proxy B receiving an alias request from host-a2.example.com.  Proxy B verifies that the presented certificate is valid and trusted. Proxy B checks that proxy-farm-a.example.com is both the advertised name and the subjectAltName in the certificate.  Finally, proxy B verifies that this connection is coming from 10.54.32.2, which is one of the addresses in DNS for host-a2.example.com, which in turn is mentioned in an SRV record for _sips._tcp.proxy-farm-a.example.com.
</t>

</section>
-->

<!--  LocalWords:  xml DOCTYPE rfc dtd stylesheet xsl href xslt toc sortrefs WG
 -->
<!--  LocalWords:  docName DOCNAME std ipr abbrev Mahy fullname Rohan Gurbani
 -->
<!--  LocalWords:  Plantronics Vijay Alcatel vkg acm org BroadSoft workgroup IP
 -->
<!--  LocalWords:  TLS SCTP DNS SRV xref hangText firewalls ietf outbound auth
 -->
<!--  LocalWords:  tcp connectionless UDP Uni uni dir CDATA UAS conns initially
 -->
<!--  LocalWords:  Rescorla mult INV ACK INVITEs reINVITE reINVITEs com hG bKa
 -->
<!--  LocalWords:  dze tls Backus Naur BNF params subjectAlternativeName certs
 -->
<!--  LocalWords:  interoperability conformant SCP inbound virt IANA RFCXXXX
 -->
<!--  LocalWords:  XXXX Cullen Jeroen Bemmel Drage Gardiner Rajnish Jain Worley
 -->
<!--  LocalWords:  Prijono Hadriel WGLC Schulzrinne Camarillo Handley
 -->
<!--  LocalWords:  seriesInfo
 -->
