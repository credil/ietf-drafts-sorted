<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="std" ipr="trust200902" docName="draft-ietf-jose-json-web-encryption-15">

  <front>
    <title abbrev="JWE">JSON Web Encryption (JWE)</title>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization>Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>

    <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
      <organization abbrev="RTFM">RTFM, Inc.</organization>
      <address>
        <email>ekr@rtfm.com</email>
      </address>
    </author>

    <author fullname="Joe Hildebrand" initials="J." surname="Hildebrand">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <email>jhildebr@cisco.com</email>
      </address>
    </author>

    <date day="3" month="September" year="2013" />

    <area>Security</area>
    <workgroup>JOSE Working Group</workgroup>

    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>JavaScript Object Notation</keyword>
    <keyword>JSON</keyword>
    <keyword>JSON Object Signing and Encryption</keyword>
    <keyword>JOSE</keyword>
    <keyword>JSON Web Signature</keyword>
    <keyword>JWS</keyword>
    <keyword>JSON Web Encryption</keyword>
    <keyword>JWE</keyword>
    <keyword>JSON Web Key</keyword>
    <keyword>JWK</keyword>
    <keyword>JSON Web Algorithms</keyword>
    <keyword>JWA</keyword>

    <abstract>
      <t>
	JSON Web Encryption (JWE) represents encrypted content
	using JavaScript Object Notation (JSON) based data structures.
	Cryptographic algorithms and identifiers for use with this
	specification are described in the separate
	JSON Web Algorithms (JWA) specification
	and IANA registries defined by that specification.
	Related digital signature and MAC capabilities are described
	in the separate JSON Web Signature (JWS) specification.
      </t>
    </abstract>

  </front>

  <middle>
    <section title="Introduction" anchor="Introduction">
      <t>
	JSON Web Encryption (JWE) represents encrypted content
	using JavaScript Object Notation (JSON) <xref target="RFC4627"/>
	based data structures.
	The JWE cryptographic mechanisms encrypt and provide integrity protection for
	an arbitrary sequence of octets.
      </t>
      <t>
	Two closely related serializations for JWE objects are defined.
	The JWE Compact Serialization is a compact, URL-safe representation
	intended for space constrained environments such as HTTP
	Authorization headers and URI query parameters.
	The JWE JSON Serialization represents JWE objects as JSON objects and
	enables the same content to be encrypted to multiple parties.
	Both share the same cryptographic underpinnings.
      </t>
      <t>
	Cryptographic algorithms and identifiers for use with this
	specification are described in the separate
	JSON Web Algorithms (JWA) <xref target="JWA" /> specification
	and IANA registries defined by that specification.
	Related digital signature and MAC capabilities are described
	in the separate JSON Web Signature (JWS) <xref target="JWS" />
	specification.
      </t>
      <t>
	Names defined by this specification are short because a core goal is
	for the resulting representations to be compact.
      </t>

      <section title="Notational Conventions" anchor="NotationalConventions">
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
          and "OPTIONAL" in this document are to be interpreted as
          described in
	  Key words for use in RFCs to Indicate Requirement Levels <xref target='RFC2119' />.
        </t>
      </section>

    </section>

    <section title="Terminology" anchor="Terminology">
      <t>
	<list style="hanging">

          <t hangText="JSON Web Encryption (JWE)">
	    A data structure representing an encrypted message.
	    The structure represents five values:
	    the JWE Header, the JWE Encrypted Key,
	    the JWE Initialization Vector, the JWE Ciphertext, and
	    the JWE Authentication Tag.
	  </t>

	  <t hangText="Authenticated Encryption with Associated Data (AEAD)">
	    An AEAD algorithm is one that encrypts the Plaintext,
	    allows Additional Authenticated Data to be specified,
	    and provides an integrated content integrity check
	    over the Ciphertext and Additional Authenticated Data.
	    AEAD algorithms accept two inputs, the Plaintext and the
	    Additional Authenticated Data value, and produce two outputs,
	    the Ciphertext and the Authentication Tag value.
	    AES Galois/Counter Mode (GCM) is one such algorithm.
	  </t>

	  <t hangText="Plaintext">
	    The sequence of octets to be encrypted -- a.k.a., the message.
	    The plaintext can contain an arbitrary sequence of octets.
	  </t>
	  <t hangText="Ciphertext">
	    An encrypted representation of the Plaintext.
	  </t>
	  <t hangText="Additional Authenticated Data (AAD)">
	    An input to an AEAD operation that
	    is integrity protected but not encrypted.
	  </t>
	  <t hangText="Authentication Tag">
	    An output of an AEAD operation that
	    ensures the integrity of
	    the Ciphertext
	    and the Additional Authenticated Data.
	    Note that some algorithms may not use an Authentication Tag,
	    in which case this value is the empty octet sequence.
	  </t>

	  <t hangText="Content Encryption Key (CEK)">
	    A symmetric key for the AEAD algorithm
	    used to encrypt the Plaintext for the
	    recipient to produce the Ciphertext and the Authentication Tag.
	  </t>

 	  <t hangText="JSON Text Object">
	    A UTF-8 <xref target="RFC3629"/>
	    encoded text string representing a JSON object;
	    the syntax of JSON objects is defined in
	    Section 2.2 of <xref target="RFC4627"/>.
	  </t>

          <t hangText="JWE Header">
	    A JSON Text Object
	    (or JSON Text Objects, when using the JWE JSON Serialization)
	    that describes the
	    encryption operations applied to create the JWE Encrypted
	    Key, the JWE Ciphertext, and the JWE Authentication Tag.
	    The members of the JWE Header object(s) are Header Parameters.
	  </t>
          <t hangText="JWE Encrypted Key">
	    The result of encrypting the Content Encryption Key (CEK) with the
	    intended recipient's key using the specified algorithm.
	    Note that for some algorithms, the JWE Encrypted Key
	    value is specified as being the empty octet sequence.
	  </t>
          <t hangText="JWE Initialization Vector">
	    A sequence of octets containing the Initialization Vector used
	    when encrypting the Plaintext.
	    Note that some algorithms may not use an Initialization Vector,
	    in which case this value is the empty octet sequence.
	  </t>
          <t hangText="JWE Ciphertext">
	    A sequence of octets containing the Ciphertext for a JWE.
	  </t>
	  <t hangText="JWE Authentication Tag">
	    A sequence of octets containing the Authentication Tag for a JWE.
	  </t>

          <t hangText="JWE Protected Header">
	    A JSON Text Object that contains the portion of the
	    JWE Header that is integrity protected.
	    For the JWE Compact Serialization, this comprises the entire JWE Header.
	    For the JWE JSON Serialization, this is one component of the JWE Header.
	  </t>

	  <t hangText="Header Parameter">
	    A name/value pair that is member of the JWE Header.
	  </t>
	  <t hangText="Header Parameter Name">
	    The name of a member of the JWE Header.
	  </t>
	  <t hangText="Header Parameter Value">
	    The value of a member of the JWE Header.
	  </t>

          <t hangText="Base64url Encoding">
	    Base64 encoding using the URL- and filename-safe
	    character set defined in Section 5 of <xref target="RFC4648">RFC 4648</xref>,
	    with all trailing '=' characters omitted (as permitted by Section 3.2).
	    (See Appendix C of <xref target="JWS" /> for notes on
	    implementing base64url encoding without padding.)
	  </t>

          <t hangText="Encoded JWE Header">
	    Base64url encoding of the JWE Protected Header.
	  </t>
          <t hangText="Encoded JWE Encrypted Key">
	    Base64url encoding of the JWE Encrypted Key.
	  </t>
          <t hangText="Encoded JWE Initialization Vector">
	    Base64url encoding of the JWE Initialization Vector.
	  </t>
          <t hangText="Encoded JWE Ciphertext">
	    Base64url encoding of the JWE Ciphertext.
	  </t>
	  <t hangText="Encoded JWE Authentication Tag">
	    Base64url encoding of the JWE Authentication Tag.
	  </t>

	  <t hangText="JWE Compact Serialization">
	    A representation of the JWE as the concatenation of
	    the Encoded JWE Header,
	    the Encoded JWE Encrypted Key,
	    the Encoded JWE Initialization Vector,
	    the Encoded JWE Ciphertext, and
	    the Encoded JWE Authentication Tag
	    in that order, with the five strings being separated
	    by four period ('.') characters.
	    This representation is compact and URL-safe.
	  </t>

	  <t hangText="JWE JSON Serialization">
	    A representation of the JWE as a JSON structure containing
	    JWE Header,
	    Encoded JWE Encrypted Key,
	    Encoded JWE Initialization Vector,
	    Encoded JWE Ciphertext, and
	    Encoded JWE Authentication Tag values.
	    Unlike the JWE Compact Serialization,
	    the JWE JSON Serialization
	    enables the same content to be encrypted to multiple parties.
	    This representation is neither compact nor URL-safe.
	  </t>

	  <t hangText="Collision Resistant Namespace">
	    A namespace that allows names to be allocated in a manner
	    such that they are highly unlikely to collide with other names.
	    Examples of Collision Resistant Namespaces include:
	    Domain Names,
	    Object Identifiers (OIDs) as defined in the ITU-T X.660
	    and X.670 Recommendation series, and
	    Universally Unique IDentifiers (UUIDs)
	    <xref target="RFC4122"/>.
	    When using an administratively delegated namespace,
	    the definer of a name needs to take
	    reasonable precautions to ensure they are in control of
	    the portion of the namespace they use to define the name.
	  </t>

	  <t hangText="StringOrURI">
	    A JSON string value, with the additional requirement that
	    while arbitrary string values MAY be used, any value
	    containing a ":" character MUST be a URI
	    <xref target="RFC3986"/>.
	    StringOrURI values are compared as case-sensitive strings
	    with no transformations or canonicalizations applied.
	  </t>

	  <t hangText="Key Management Mode">
	    A method of determining the Content Encryption Key (CEK) value to use.
	    Each algorithm used for determining the CEK value uses a specific Key Management Mode.
	    Key Management Modes employed by this specification are
	    Key Encryption,
	    Key Wrapping,
	    Direct Key Agreement,
	    Key Agreement with Key Wrapping, and
	    Direct Encryption.
	  </t>

	  <t hangText="Key Encryption">
	    A Key Management Mode in which the Content Encryption Key (CEK) value
	    is encrypted to the intended recipient using an asymmetric encryption algorithm.
	  </t>

	  <t hangText="Key Wrapping">
	    A Key Management Mode in which the Content Encryption Key (CEK) value
	    is encrypted to the intended recipient using a symmetric key wrapping algorithm.
	  </t>

	  <t hangText="Direct Key Agreement">
	    A Key Management Mode in which a key agreement algorithm is used to agree upon
	    the Content Encryption Key (CEK) value.
	  </t>

	  <t hangText="Key Agreement with Key Wrapping">
	    A Key Management Mode in which a key agreement algorithm is used to agree upon
	    a symmetric key used to encrypt the Content Encryption Key (CEK) value
	    to the intended recipient using a symmetric key wrapping algorithm.
	  </t>

	  <t hangText="Direct Encryption">
	    A Key Management Mode in which the Content Encryption Key (CEK) value
	    used is the secret symmetric key value shared between the parties.
	  </t>

        </list>
      </t>
    </section>

    <section title="JSON Web Encryption (JWE) Overview" anchor="Overview">

      <t>
	JWE represents encrypted content using JSON data
	structures and base64url encoding.
	Five values are represented in a JWE:
	the JWE Header,
	the JWE Encrypted Key,
	the JWE Initialization Vector,
	the JWE Ciphertext, and
	the JWE Authentication Tag.
	In the Compact Serialization, the five values are
	base64url-encoded for transmission, and represented
	as the concatenation of the encoded strings in that order,
	with the five strings being separated by four period ('.') characters.
	A JSON Serialization for this information is also defined in
	<xref target="JSONSerialization"/>.
      </t>
      <t>
	JWE utilizes authenticated encryption to ensure the confidentiality
	and integrity of the Plaintext and the integrity of the JWE Protected Header.
      </t>

      <section title="Example JWE" anchor="OAEPGCMIntro">
	<t>
	  This example encrypts the plaintext
	  "The true sign of intelligence is not knowledge but imagination."
	  to the recipient using RSAES OAEP for key encryption
	  and AES GCM for content encryption.
	</t>
	<t>
	  The following example JWE Header declares that:
	  <list style="symbols">
	    <t>
	      the Content Encryption Key is encrypted to the recipient
	      using the RSAES OAEP algorithm to produce
	      the JWE Encrypted Key and
	    </t>
	    <t>
	      the Plaintext is encrypted using the AES GCM
	      algorithm with a 256 bit key to produce the Ciphertext.
	    </t>
	  </list>
	</t>

	<figure><artwork><![CDATA[
  {"alg":"RSA-OAEP","enc":"A256GCM"}
]]></artwork></figure>

	<t>
	  Base64url encoding the octets of the UTF-8 representation of
	  the JWE Header yields this Encoded JWE Header value:
	</t>

	<figure><artwork><![CDATA[
  eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ
]]></artwork></figure>
	
	<t>
	  The remaining steps to finish creating this JWE are:
	  <list style="symbols">
	    <t>
	      Generate a random Content Encryption Key (CEK).
	    </t>
	    <t>
	      Encrypt the CEK with the recipient's public key using the RSAES OAEP
	      algorithm to produce the JWE Encrypted Key.
	    </t>
	    <t>
	      Base64url encode the JWE Encrypted Key to produce
	      the Encoded JWE Encrypted Key.
	    </t>
	    <t>
	      Generate a random JWE Initialization Vector.
	    </t>
	    <t>
	      Base64url encode the JWE Initialization Vector to produce the Encoded JWE Initialization Vector.
	    </t>
	    <t>
	      Let the Additional Authenticated Data encryption parameter be
	      the octets of the ASCII representation of
	      the Encoded JWE Header value.
	    </t>
	    <t>
	      Encrypt the Plaintext with AES GCM
	      using the CEK as the encryption key,
	      the JWE Initialization Vector,
	      and the Additional Authenticated Data value,
	      requesting a 128 bit Authentication Tag output.
	    </t>
	    <t>
	      Base64url encode the Ciphertext to create the Encoded JWE Ciphertext.
	    </t>
	    <t>
	      Base64url encode the Authentication Tag to create
	      the Encoded JWE Authentication Tag.
	    </t>
	    <t>
	      Assemble the final representation:
	      The Compact Serialization of this result is the
	      concatenation of
	      the Encoded JWE Header,
	      the Encoded JWE Encrypted Key,
	      the Encoded JWE Initialization Vector,
	      the Encoded JWE Ciphertext, and
	      the Encoded JWE Authentication Tag
	      in that order, with the five strings
	      being separated by four period ('.') characters.
	    </t>
	  </list>

	  The final result in this example
	  (with line breaks for display purposes only) is:
	</t>
	<figure><artwork><![CDATA[
  eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.
  OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe
  ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb
  Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV
  mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8
  1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi
  6UklfCpIMfIjf7iGdXKHzg.
  48V1_ALb6US04U3b.
  5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji
  SdiwkIr3ajwQzaBtQD_A.
  XFBoMYUZodetZdvTiFvSkQ
]]></artwork></figure>

	<t>
	  See <xref target="OAEPGCMExample"/> for the complete details of computing this JWE.
	  See <xref target="JWEExamples"/> for additional examples.
	</t>
      </section>

    </section>

    <section title="JWE Header" anchor="Header">

      <t>
	The members of the JSON object(s) representing the JWE Header
	describe the encryption applied to the Plaintext and optionally
	additional properties of the JWE.
	The Header Parameter Names within the JWE Header MUST be unique;
	recipients MUST either reject JWEs with duplicate Header Parameter Names
	or use a JSON parser that returns only the lexically last duplicate member name,
	as specified in Section 15.12 (The JSON Object) of
	ECMAScript 5.1 <xref target="ECMAScript"/>.
      </t>
      <t>
	Implementations are required to understand
	the specific header parameters defined by this specification 
	that are designated as "MUST be understood"
	and process them in the manner defined in this specification.
	All other header parameters defined by this specification that
	are not so designated MUST be ignored when not understood.
	Unless listed as a critical header parameter, per <xref target="critDef"/>,
	all header parameters not defined by this specification
	MUST be ignored when not understood.
      </t>
      <t>
        There are three classes of Header Parameter Names:
	Reserved Header Parameter Names, Public Header Parameter Names,
	and Private Header Parameter Names.
      </t>

      <section title="Reserved Header Parameter Names" anchor="ReservedHeaderParameterName">
	<t>
	  The following Header Parameter Names are reserved
	  with meanings as defined below.
	</t>
	<t>
	  Additional reserved Header Parameter Names can be defined
	  via the IANA
	  JSON Web Signature and Encryption Header Parameters registry
	  <xref target="JWS" />.
	  As indicated by the common registry, JWSs and JWEs share a
	  common header parameter space; when a parameter is used by
	  both specifications, its usage must be compatible
	  between the specifications.
	</t>

	<section title='"alg" (Algorithm) Header Parameter' anchor="algDef">
	  <t>
	    The <spanx style="verb">alg</spanx> (algorithm) header
	    parameter identifies the cryptographic algorithm used to
	    encrypt or determine the value of the Content Encryption Key (CEK).
	    The encrypted content is not usable if the <spanx style="verb">alg</spanx>
	    value does not represent a supported algorithm, or if the recipient does
	    not have a key that can be used with that algorithm.
	    <spanx style="verb">alg</spanx> values SHOULD either be
	    registered in the IANA
	    JSON Web Signature and Encryption Algorithms registry
	    <xref target="JWA" /> or be
	    a value that contains a Collision Resistant Namespace.
	    The <spanx style="verb">alg</spanx> value is a case sensitive string
	    containing a StringOrURI value.
	    Use of this header parameter is REQUIRED.
	    This header parameter MUST be understood by implementations.
	  </t>
	  <t>
	    A list of defined <spanx style="verb">alg</spanx> values can be found
	    in the IANA JSON Web Signature and Encryption Algorithms registry
	    <xref target="JWA" />;
	    the initial contents of this registry are the values defined in
	    Section 4.1 of the
	    JSON Web Algorithms (JWA) <xref target="JWA" /> specification.
	  </t>
	</section>

	<section title='"enc" (Encryption Method) Header Parameter' anchor="encDef">
	  <t>
	    The <spanx style="verb">enc</spanx> (encryption method)
	    header parameter identifies the content encryption algorithm
	    used to encrypt the Plaintext to produce the Ciphertext.
	    This algorithm MUST be an AEAD algorithm with a specified key length.
	    The recipient MUST reject the JWE if the <spanx style="verb">enc</spanx>
	    value does not represent a supported algorithm.
	    <spanx style="verb">enc</spanx> values SHOULD either be
	    registered in the IANA
	    JSON Web Signature and Encryption Algorithms registry
	    <xref target="JWA" /> or be
	    a value that contains a Collision Resistant Namespace.
	    The <spanx style="verb">enc</spanx> value is a case sensitive string
	    containing a StringOrURI value.
	    Use of this header parameter is REQUIRED.
	    This header parameter MUST be understood by implementations.
	  </t>
	  <t>
	    A list of defined <spanx style="verb">enc</spanx> values can be found
	    in the IANA JSON Web Signature and Encryption Algorithms registry
	    <xref target="JWA" />;
	    the initial contents of this registry are the values defined in
	    Section 4.2 of the
	    JSON Web Algorithms (JWA) <xref target="JWA" /> specification.
	  </t>
	</section>

	<section title='"zip" (Compression Algorithm) Header Parameter' anchor="zipDef">
	  <t>
	    The <spanx style="verb">zip</spanx> (compression algorithm)
	    applied to the Plaintext before encryption, if any.
	    If present, the value of the <spanx style="verb">zip</spanx>
	    header parameter MUST be the case sensitive string "DEF".
	    Compression is performed with the
	    DEFLATE <xref target="RFC1951" /> algorithm.
	    If no <spanx style="verb">zip</spanx> parameter is present,
	    no compression is applied to the Plaintext before encryption.
	    This header parameter MUST be integrity protected, and therefore
	    MUST occur only with the JWE Protected Header, when used.
	    Use of this header parameter is OPTIONAL.
	    This header parameter MUST be understood by implementations.
	  </t>
	</section>

	<section title='"jku" (JWK Set URL) Header Parameter' anchor="jkuDef">
	  <t>
	    The <spanx style="verb">jku</spanx> (JWK Set URL)
	    header parameter is a URI <xref target="RFC3986"/> that refers to a
	    resource for a set of JSON-encoded public keys, one of which
	    is the key
	    to which the JWE was encrypted;
	    this can be used to determine the private key needed to decrypt the JWE.
	    The keys MUST be encoded as a JSON Web Key Set (JWK Set) <xref target="JWK" />.
	    The protocol used to acquire the resource MUST provide
	    integrity protection; an HTTP GET request to retrieve the
	    JWK Set MUST use TLS <xref target="RFC2818"/> <xref target="RFC5246"/>;
	    the identity of the server MUST be validated, as per
	    Section 3.1 of HTTP Over TLS <xref target='RFC2818'/>.
	    Use of this header parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"jwk" (JSON Web Key) Header Parameter' anchor="jwkDef">
	  <t>
	    The <spanx style="verb">jwk</spanx> (JSON Web Key)
	    header parameter is the public key
	    to which the JWE was encrypted;
	    this can be used to determine the private key needed to decrypt the JWE.
	    This key is represented as a JSON Web Key <xref target="JWK" />.
	    Use of this header parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"x5u" (X.509 URL) Header Parameter' anchor="x5uDef">
	  <t>
	    The <spanx style="verb">x5u</spanx> (X.509 URL) header
	    parameter is a URI <xref target="RFC3986"/> that refers to a resource for
	    the X.509 public key certificate or certificate chain <xref target="RFC5280"/>
	    containing the key
	    to which the JWE was encrypted;
	    this can be used to determine the private key needed to decrypt the JWE.
	    The identified resource MUST provide a representation of
	    the certificate or certificate chain that conforms to
	    <xref target="RFC5280">RFC 5280</xref> in PEM encoded form
	    <xref target="RFC1421"/>.
	    The certificate containing the public key
	    to which the JWE was encrypted
	    MUST be the first certificate.
	    This MAY be followed by additional certificates, with each
	    subsequent certificate being the one used to certify the
	    previous one.
	    The protocol used to acquire the resource MUST provide
	    integrity protection; an HTTP GET request to retrieve the
	    certificate MUST use TLS <xref target="RFC2818"/> <xref target="RFC5246"/>;
	    the identity of the server MUST be validated, as per
	    Section 3.1 of HTTP Over TLS <xref target='RFC2818'/>.
	    Use of this header parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"x5t" (X.509 Certificate Thumbprint) Header Parameter' anchor="x5tDef">
	  <t>
	    The <spanx style="verb">x5t</spanx> (X.509 Certificate Thumbprint)
	    header parameter is a base64url encoded
	    SHA-1 thumbprint (a.k.a. digest) of the DER encoding of
	    the X.509 certificate <xref target="RFC5280"/>
	    containing the key
	    to which the JWE was encrypted;
	    this can be used to determine the private key needed to decrypt the JWE.
	    Use of this header parameter is OPTIONAL.
	  </t>
	  <t>
	    If, in the future, certificate thumbprints need to be
	    computed using hash functions other than SHA-1, it is
	    suggested that additional related header parameters be
	    defined for that purpose.  For example, it is suggested
	    that a new <spanx style="verb">x5t#S256</spanx> (X.509
	    Certificate Thumbprint using SHA-256) header parameter
	    could be defined by registering it in the IANA
	    JSON Web Signature and Encryption Header Parameters
	    registry <xref target="JWS" />.
	  </t>
	</section>

	<section title='"x5c" (X.509 Certificate Chain) Header Parameter' anchor="x5cDef">
	  <t>
	    The <spanx style="verb">x5c</spanx> (X.509 Certificate Chain)
	    header parameter contains the X.509 public key
	    certificate or certificate chain <xref target="RFC5280"/>
	    containing the key
	    to which the JWE was encrypted;
	    this can be used to determine the private key needed to decrypt the JWE.
	    The certificate or certificate chain is represented as
	    a JSON array of certificate value strings.
	    Each string in the array is a base64 encoded
	    (<xref target="RFC4648"/> Section 4 -- not base64url encoded)
	    DER <xref target="ITU.X690.1994"/> PKIX certificate value.
	    The certificate containing the public key
	    to which the JWE was encrypted
	    MUST be the first certificate.
	    This MAY be followed by additional certificates, with each
	    subsequent certificate being the one used to certify the
	    previous one.
	    Use of this header parameter is OPTIONAL.
	  </t>
	  <t>
	    See Appendix B of <xref target="JWS"/> for an example
	    <spanx style="verb">x5c</spanx> value.
	  </t>
	</section>

	<section title='"kid" (Key ID) Header Parameter' anchor="kidDef">
	  <t>
	    The <spanx style="verb">kid</spanx> (key ID) header
	    parameter is a hint indicating which key
	    to which the JWE was encrypted;
	    this can be used to determine the private key needed to decrypt the JWE.
	    This parameter allows originators to explicitly signal a change of
	    key to recipients.
	    Should the recipient be unable to locate a key
	    corresponding to the <spanx style="verb">kid</spanx>
	    value, they SHOULD treat that condition as an error.
	    The interpretation of the
	    <spanx style="verb">kid</spanx> value is unspecified.
	    Its value MUST be a string.
	    Use of this header parameter is OPTIONAL.
	  </t>
	  <t>
	    When used with a JWK, the <spanx style="verb">kid</spanx>
	    value can be used to match a JWK <spanx style="verb">kid</spanx>
	    parameter value.
	  </t>
	</section>

	<section title='"typ" (Type) Header Parameter' anchor="typDef">
	  <t>
	    The <spanx style="verb">typ</spanx> (type) header
	    parameter MAY be used to declare the type of
	    this complete JWE object
	    in an application-specific manner
	    in contexts where this is useful to the application.
	    This parameter has no effect upon the JWE processing.
	    The type value <spanx style="verb">JOSE</spanx> MAY be used
	    by applications
	    to indicate that this object is a JWS or JWE using
	    the JWS Compact Serialization or the JWE Compact Serialization.
	    The type value <spanx style="verb">JOSE+JSON</spanx> MAY be used
	    by applications
	    to indicate that this object is a JWS or JWE using
	    the JWS JSON Serialization or the JWE JSON Serialization.
	    Other type values MAY be used, and if not understood, SHOULD be ignored.
	    The <spanx style="verb">typ</spanx> value is a case sensitive string.
	    Use of this header parameter is OPTIONAL.
	  </t>
	  <t>
	    MIME Media Type <xref target="RFC2046"/>
	    values MAY be used as <spanx style="verb">typ</spanx> values.
	  </t>
	  <t>
	    <spanx style="verb">typ</spanx> values SHOULD either be
	    registered in the IANA
	    JSON Web Signature and Encryption Type Values registry
	    <xref target="JWS" /> or be
	    a value that contains a Collision Resistant Namespace.
	  </t>
	</section>

	<section title='"cty" (Content Type) Header Parameter' anchor="ctyDef">
	  <t>
	    The <spanx style="verb">cty</spanx> (content type) header
	    parameter MAY be used to declare the type of
	    the encrypted content (the Plaintext)
	    in an application-specific manner
	    in contexts where this is useful to the application.
	    This parameter has no effect upon the JWE processing.
	    Content type values that are not understood SHOULD be ignored.
	    The <spanx style="verb">cty</spanx> value is a case sensitive string.
	    Use of this header parameter is OPTIONAL.
	  </t>
	  <t>
	    The values used for the <spanx style="verb">cty</spanx>
	    header parameter come from the same value space as the
	    <spanx style="verb">typ</spanx> header parameter,
	    with the same rules applying.
	  </t>
	</section>

	<section title='"crit" (Critical) Header Parameter' anchor="critDef">
	  <t>
	    The <spanx style="verb">crit</spanx> (critical) header parameter
	    indicates that extensions to [[ this specification ]] are being used
	    that MUST be understood and processed.
	    Its value is an array listing the header parameter names defined
	    by those extensions that are used in the JWE Header.
	    If any of the listed extension header parameters are not
	    understood and supported by the receiver, it MUST reject the JWE.
	    Senders MUST NOT include header parameter names defined by
	    [[ this specification ]] or by <xref target="JWA" /> for use with JWE,
	    duplicate names, or
	    names that do not occur as header parameter names within the JWE Header
	    in the <spanx style="verb">crit</spanx> list.
	    Senders MUST not use the empty list <spanx style="verb">[]</spanx>
	    as the <spanx style="verb">crit</spanx> value.
	    Recipients MAY reject the JWE if the critical list
	    contains any header parameter names defined by [[ this specification ]]
	    or by <xref target="JWA" /> for use with JWE,
	    or any other constraints on its use are violated.
	    This header parameter MUST be integrity protected, and therefore
	    MUST occur only with the JWE Protected Header, when used.
	    Use of this header parameter is OPTIONAL.
	    This header parameter MUST be understood by implementations.
	  </t>
	  <t>
	    <figure>
	      <preamble>
		An example use, along with a hypothetical
		<spanx style="verb">exp</spanx> (expiration-time) field is:
	      </preamble>
	      <artwork><![CDATA[
  {"alg":"RSA-OAEP",
   "enc":"A256GCM",
   "crit":["exp"],
   "exp":1363284000
  }
]]></artwork>
	    </figure>
	  </t>
	</section>

      </section>

      <section title="Public Header Parameter Names" anchor="PublicHeaderParameterName">

        <t>
	  Additional Header Parameter Names can be defined by those
	  using JWEs. However, in order to prevent collisions, any new
	  Header Parameter Name SHOULD either be registered in the IANA
	  JSON Web Signature and Encryption Header Parameters registry
	  <xref target="JWS" /> or be a Public Name:
	  a value that contains a Collision Resistant Namespace.
	  In each case, the definer of the name
	  or value needs to take reasonable precautions to make sure they
	  are in control of the part of the namespace they use to
	  define the Header Parameter Name.
	</t>
	<t>
	  New header parameters should be introduced sparingly, as
	  they can result in non-interoperable JWEs.
	</t>
      </section>

      <section title="Private Header Parameter Names" anchor="PrivateHeaderParameterName">

	<t>
	  A producer and consumer of a JWE may agree to use Header Parameter Names
	  that are Private Names:  names that are
	  not Reserved Names <xref target="ReservedHeaderParameterName"></xref>
	  or Public Names <xref target="PublicHeaderParameterName"></xref>.
	  Unlike Public Names, Private Names are subject to collision and
	  should be used with caution.
	</t>

      </section>
    </section>

    <section title="Producing and Consuming JWEs" anchor="JWERules">

      <section title="Message Encryption" anchor="Encryption">
	<t>
	  The message encryption process is as follows.
	  The order of the steps is not significant in cases where
	  there are no dependencies between the inputs and outputs of the steps.
	</t>

	<t>
	  <list style="numbers">
	    <t>
	      Determine the Key Management Mode employed by the algorithm
	      used to determine the Content Encryption Key (CEK) value.
	      (This is the algorithm recorded in the
	      <spanx style="verb">alg</spanx> (algorithm)
	      header parameter of the resulting JWE.)
	    </t>
	    <t>
	      When Key Wrapping, Key Encryption,
	      or Key Agreement with Key Wrapping are employed,
	      generate a random Content Encryption Key (CEK) value.
	      See <xref target="RFC4086">RFC 4086</xref> for
	      considerations on generating random values.
	      The CEK MUST have a length equal to that
	      required for the content encryption algorithm.
	    </t>
	    <t>
	      When Direct Key Agreement or Key Agreement with Key Wrapping
	      are employed, use the key agreement algorithm
	      to compute the value of the agreed upon key.
	      When Direct Key Agreement is employed,
	      let the Content Encryption Key (CEK) be the agreed upon key.
	      When Key Agreement with Key Wrapping is employed,
	      the agreed upon key will be used to wrap the CEK.
	    </t>
	    <t>
	      When Key Wrapping, Key Encryption,
	      or Key Agreement with Key Wrapping are employed,
	      encrypt the CEK to the recipient and let the result be the
	      JWE Encrypted Key.
	    </t>
	    <t>
	      Otherwise, when Direct Key Agreement or Direct Encryption are employed,
	      let the JWE Encrypted Key be the empty octet sequence.
	    </t>
	    <t>
	      When Direct Encryption is employed,
	      let the Content Encryption Key (CEK) be the shared symmetric key.
	    </t>
	    <t>
	      Base64url encode the JWE Encrypted Key to create the
	      Encoded JWE Encrypted Key.
	    </t>
	    <t>
	      If the JWE JSON Serialization is being used, repeat this process
	      for each recipient.
	    </t>
	    <t>
	      Generate a random JWE Initialization Vector of the correct size
	      for the content encryption algorithm (if required for the algorithm);
	      otherwise, let the JWE Initialization Vector be the empty octet sequence.
	    </t>
	    <t>
	      Base64url encode the JWE Initialization Vector to create the
	      Encoded JWE Initialization Vector.
	    </t>
	    <t>
	      Compress the Plaintext if a <spanx
	      style="verb">zip</spanx> parameter was included.
	    </t>
	    <t>
	      Serialize the (compressed) Plaintext into an octet sequence M.
	    </t>
	    <t>
	      Create a JWE Header containing the encryption
	      parameters used.
	      Note that white space is explicitly allowed
	      in the representation and no canonicalization need be performed
	      before encoding.
	    </t>
	    <t>
	      Base64url encode the octets of the UTF-8 representation of
	      the JWE Protected Header to create the Encoded JWE Header.
	      If the JWE Protected Header is not present
	      (which can only happen when using the JWE JSON Serialization
	      and no <spanx style="verb">protected</spanx> member is present),
	      let the Encoded JWE Header be the empty string.
	    </t>
	    <t>
	      Let the Additional Authenticated Data encryption parameter be
	      the octets of the ASCII representation of
	      the Encoded JWE Header value.
	    </t>
	    <t>
	      Encrypt M using the CEK, the JWE Initialization Vector, and
	      the Additional Authenticated Data value
	      using the specified content encryption algorithm
	      to create the JWE Ciphertext value and the JWE Authentication Tag
	      (which is the Authentication Tag output from the encryption operation).
	    </t>
	    <t>
	      Base64url encode the JWE Ciphertext to create the Encoded JWE Ciphertext.
	    </t>
	    <t>
	      Base64url encode the JWE Authentication Tag to create the
	      Encoded JWE Authentication Tag.
	    </t>
	    <t>
	      The five encoded parts are result values used in both the
	      JWE Compact Serialization and the JWE JSON Serialization representations.
	    </t>
	    <t>
	      Create the desired serialized output.
	      The JWE Compact Serialization of this result is the
	      concatenation of
	      the Encoded JWE Header,
	      the Encoded JWE Encrypted Key,
	      the Encoded JWE Initialization Vector,
	      the Encoded JWE Ciphertext, and
	      the Encoded JWE Authentication Tag
	      in that order, with the five strings
	      being separated by four period ('.') characters.
	      The JWE JSON Serialization is described in <xref target="JSONSerialization"/>.
	    </t>
	  </list>
	</t>
      </section>

      <section title="Message Decryption" anchor="Decryption">
	<t>
	  The message decryption process is the reverse of the
	  encryption process.
	  The order of the steps is not significant in cases where
	  there are no dependencies between the inputs and outputs of the steps.
	  If any of these steps fails, the encrypted content cannot be validated.
	</t>
	<t>
	  It is an application decision which recipients' encrypted content
	  must successfully validate for the JWE to be accepted.
	  In some cases, encrypted content for all recipients must successfully validate
	  or the JWE will be rejected.
	  In other cases, only the encrypted content for a single recipient
	  needs to be successfully validated.
	  However, in all cases, the encrypted content for at least one recipient
	  MUST successfully validate or the JWE MUST be rejected.
	</t>
	<t>
	  <list style="numbers">
	    <t>
	      Parse the serialized input to determine the values of
	      the JWE Header,
	      the Encoded JWE Encrypted Key,
	      the Encoded JWE Initialization Vector,
	      the Encoded JWE Ciphertext, and
	      the Encoded JWE Authentication Tag.
	      When using the JWE Compact Serialization,
	      the Encoded JWE Header,
	      the Encoded JWE Encrypted Key,
	      the Encoded JWE Initialization Vector,
	      the Encoded JWE Ciphertext, and
	      the Encoded JWE Authentication Tag
	      are represented as text strings in that order,
	      separated by four period ('.') characters.
	      The JWE JSON Serialization
	      is described in <xref target="JSONSerialization"/>.
	    </t>
	    <t>
	      The Encoded JWE Header,
	      the Encoded JWE Encrypted Key,
	      the Encoded JWE Initialization Vector,
	      the Encoded JWE Ciphertext, and
	      the Encoded JWE Authentication Tag
	      MUST be successfully base64url decoded following the
	      restriction that no padding characters have been used.
	    </t>
	    <t>
	      The resulting JWE Protected Header MUST be a completely valid
	      JSON object conforming to <xref target="RFC4627">RFC 4627</xref>.
	    </t>
	    <t>
	      If using the JWE Compact Serialization, let the JWE Header be the
	      JWE Protected Header;
	      otherwise, when using the JWE JSON Serialization,
	      let the JWE Header be the union of the members of the JWE Protected Header,
	      the members of the <spanx style="verb">unprotected</spanx> value, and
	      the members of the corresponding <spanx style="verb">header</spanx> value,
	      all of which must be completely valid JSON objects.
	    </t>
	    <t>
	      The resulting JWE Header MUST NOT contain duplicate
	      Header Parameter Names.
	      When using the JWE JSON Serialization, this restriction includes
	      that the same Header Parameter Name also MUST NOT occur in
	      distinct JSON Text Object values that together comprise the JWE Header.
	    </t>
	    <t>
	      The resulting JWE Header MUST be validated to only include
	      parameters and values whose syntax and semantics are both
	      understood and supported
	      or that are specified as being ignored when not understood.
	    </t>
	    <t>
	      Determine the Key Management Mode employed by the algorithm
	      specified by the
	      <spanx style="verb">alg</spanx> (algorithm) header parameter.
	    </t>
	    <t>
	      Verify that the JWE uses a key known to the recipient.
	    </t>
	    <t>
	      When Direct Key Agreement or Key Agreement with Key Wrapping
	      are employed, use the key agreement algorithm
	      to compute the value of the agreed upon key.
	      When Direct Key Agreement is employed,
	      let the Content Encryption Key (CEK) be the agreed upon key.
	      When Key Agreement with Key Wrapping is employed,
	      the agreed upon key will be used to decrypt the JWE Encrypted Key.
	    </t>
	    <t>
	      When Key Wrapping, Key Encryption,
	      or Key Agreement with Key Wrapping are employed,
	      decrypt the JWE Encrypted Key to produce the Content Encryption Key (CEK).
	      The CEK MUST have a length equal to that
	      required for the content encryption algorithm.
	      Note that when there are multiple recipients,
	      each recipient will only be able decrypt any JWE Encrypted Key values
	      that were encrypted to a key in that recipient's possession.
	      It is therefore normal to only be able to decrypt one of the
	      per-recipient JWE Encrypted Key values to obtain the CEK value.
	      To mitigate the attacks described in <xref target="RFC3218">RFC 3218</xref>,
	      the recipient MUST NOT distinguish between format, padding, and
	      length errors of encrypted keys.  It is strongly recommended,
	      in the event of receiving an improperly formatted key,
	      that the receiver substitute a randomly generated
	      CEK and proceed to the next step, to mitigate timing attacks.
	    </t>
	    <t>
	      Otherwise, when Direct Key Agreement or Direct Encryption are employed,
	      verify that the JWE Encrypted Key value is empty octet sequence.
	    </t>
	    <t>
	      When Direct Encryption is employed,
	      let the Content Encryption Key (CEK) be the shared symmetric key.
	    </t>
	    <t>
	      If the JWE JSON Serialization is being used, repeat this process
	      for each recipient contained in the representation
	      until the CEK value has been determined.
	    </t>
	    <t>
	      Let the Additional Authenticated Data encryption parameter be
	      the octets of the ASCII representation of
	      the Encoded JWE Header value.
	      However if a top-level <spanx style="verb">aad</spanx> member is present
	      when using the JWE JSON Serialization,
	      instead let the Additional Authenticated Data encryption parameter be
	      the octets of the ASCII representation of
	      the concatenation of the Encoded JWE Header value,
	      a period ('.') character,
	      and the <spanx style="verb">aad</spanx> field value.
	    </t>
	    <t>
	      Decrypt the JWE Ciphertext using the CEK, the JWE Initialization Vector,
	      the Additional Authenticated Data value,
	      and the JWE Authentication Tag
	      (which is the Authentication Tag input to the calculation)
	      using the specified content encryption algorithm,
	      returning the decrypted plaintext and verifying the JWE Authentication Tag
	      in the manner specified for the algorithm,
	      rejecting the input without emitting any decrypted output
	      if the JWE Authentication Tag is incorrect.
	    </t>
	    <t>
	      Uncompress the decrypted plaintext
	      if a <spanx style="verb">zip</spanx> parameter was included.
	    </t>
	    <t>
	      Output the resulting Plaintext.
	    </t>
	  </list>
	</t>
      </section>

      <section title="String Comparison Rules" anchor="StringComparison">

	<t>
	  Processing a JWE inevitably requires comparing known strings
	  to values in JSON objects. For example, in checking what the
	  encryption method is, the Unicode string encoding
	  <spanx style="verb">enc</spanx> will be
	  checked against the member names in the JWE Header
	  to see if there is a matching Header Parameter Name.
	</t>
	<t>
	  Comparisons between JSON strings and other Unicode strings
	  MUST be performed by comparing Unicode code points without normalization
	  as specified in the String Comparison Rules in Section 5.3 of <xref target="JWS" />.
	</t>
      </section>

    </section>

    <section title="Key Identification" anchor="IDingKeys">
      <t>
	It is necessary for the recipient of a JWE to be able to determine
	the key that was employed for the encryption operation.
	The key employed can be identified using the
	Header Parameter methods described in <xref
	target="ReservedHeaderParameterName" /> or can be identified
	using methods that are outside the scope of this specification.
	Specifically, the Header Parameters
	<spanx style="verb">jku</spanx>,
	<spanx style="verb">jwk</spanx>,
	<spanx style="verb">x5u</spanx>,
	<spanx style="verb">x5t</spanx>,
	<spanx style="verb">x5c</spanx>,
	and <spanx style="verb">kid</spanx>
	can be used to identify the key used.
	These header parameters MUST be integrity protected if the
	information about the key that they convey is to be considered trusted.
      </t>
      <t>
	The sender SHOULD include sufficient information in the Header Parameters
	to identify the key used, unless the application uses another means
	or convention to determine the key used.
	Validation of the encrypted content fails when
	the key used cannot be determined.
      </t>
      <t>
	The means of exchanging any shared symmetric keys used
	is outside the scope of this specification. 
      </t>
    </section>

    <section title="Serializations" anchor="Serializations">

      <t>
	JWE objects use one of two serializations, the
	JWE Compact Serialization
	or the
	JWE JSON Serialization.
	The JWE Compact Serialization is mandatory to implement.
	Implementation of the JWE JSON Serialization is OPTIONAL.
      </t>

      <section title="JWE Compact Serialization" anchor="CompactSerialization">

	<t>
	  The JWE Compact Serialization represents encrypted
	  content as a compact URL-safe string.
	  This string is
	  the concatenation of
	  the Encoded JWE Header,
	  the Encoded JWE Encrypted Key,
	  the Encoded JWE Initialization Vector,
	  the Encoded JWE Ciphertext, and
	  the Encoded JWE Authentication Tag
	  in that order, with the five strings being separated
	  by four period ('.') characters.
	  Only one recipient is supported by the JWE Compact Serialization.
	</t>

      </section>

      <section title="JWE JSON Serialization" anchor="JSONSerialization">

	<t>
	  The JWE JSON Serialization represents encrypted
	  content as a JSON object.
	  Unlike the JWE Compact Serialization, content using
	  the JWE JSON Serialization can be encrypted to more than one recipient.
	</t>
	<t>
	  The representation is closely related to that used in the
	  JWE Compact Serialization,
	  with the following differences for the
	  JWE JSON Serialization:
	  <list style="symbols">
	    <t>
	      Values in the JWE JSON Serialization are represented as members of
	      a JSON object, rather than as base64url encoded strings
	      separated by period ('.') characters.
	      (However binary values and values that are integrity protected
	      are still base64url encoded.)
	    </t>
	    <t>
	      The Encoded JWE Header value, if non-empty, is stored in the
	      <spanx style="verb">protected</spanx> member.
	    </t>
	    <t>
	      The Encoded JWE Initialization Vector value, if non-empty, is stored in the
	      <spanx style="verb">iv</spanx> member.
	    </t>
	    <t>
	      The Encoded JWE Ciphertext value is stored in the
	      <spanx style="verb">ciphertext</spanx> member.
	    </t>
	    <t>
	      The Encoded JWE Authentication Tag value, if non-empty, is stored in the
	      <spanx style="verb">tag</spanx> member.
	    </t>
	    <t>
	      The JWE can be encrypted to multiple recipients, rather than just one.
	      A JSON array in the <spanx style="verb">recipients</spanx> member
	      is used to hold values that are specific to a particular
	      recipient, with one array element
	      per recipient represented.
	      These array elements are JSON objects.
	    </t>
	    <t>
	      Each Encoded JWE Encrypted Key value, if non-empty, is stored in the
	      <spanx style="verb">encrypted_key</spanx> member of a JSON object
	      that is an element of the <spanx style="verb">recipients</spanx> array.
	    </t>
	    <t>
	      Some header parameter values, such as the <spanx style="verb">alg</spanx>
	      value and parameters used for selecting keys, can also differ for different
	      recipient computations.
	      Per-recipient header parameter values, if present, are stored in the
	      <spanx style="verb">header</spanx> members of the same JSON objects
	      that are elements of the <spanx style="verb">recipients</spanx> array.
	    </t>
	    <t>
	      Some header parameters, including the <spanx style="verb">alg</spanx>
	      parameter, can be shared among all recipient computations.
	      These header parameters are stored in either of two
	      top-level member(s) of the JSON object:
	      the <spanx style="verb">protected</spanx> member and
	      the <spanx style="verb">unprotected</spanx> member.
	      The values of these members, if present, are JSON Text Objects containing
	      Header Parameters.
	    </t>
	    <t>
	      Not all header parameters are integrity protected.
	      The shared header parameters in the <spanx style="verb">protected</spanx>
	      member are integrity protected, and are base64url encoded.
	      The per-recipient header parameters in the
	      <spanx style="verb">header</spanx> array element members
	      and the shared header parameters in the
	      <spanx style="verb">unprotected</spanx> member are not integrity protected.
	      These JSON Text Objects containing header parameters that are
	      not integrity protected are not base64url encoded.
	    </t>
	    <t>
	      The header parameter values used when creating or validating
	      per-recipient Ciphertext and Authentication Tag values are
	      the union of the three sets of header parameter values that may be present:
	      (1) the per-recipient values in the <spanx style="verb">header</spanx>
	      member of the recipient's array element,
	      (2) the shared integrity-protected values in the
	      <spanx style="verb">protected</spanx> member, and
	      (3) the shared non-integrity-protected values in the
	      <spanx style="verb">unprotected</spanx> member.
	      The union of these sets of header parameters comprises the JWE Header.
	      The header parameter names in the three locations MUST be disjoint.
	    </t>
	    <t>
	      An <spanx style="verb">aad</spanx> (Additional Authenticated Data) member
	      can be included to supply a base64url encoded value
	      to be integrity protected but not encrypted.
	      (Note that this can also be achieved when using either serialization
	      by including the AAD value as a protected header parameter value,
	      but at the cost of the value being double base64url encoded.)
	    </t>
	    <t>
	      The <spanx style="verb">recipients</spanx> array MUST always be present,
	      even if the array elements contain only the empty JSON object
	      <spanx style="verb">{}</spanx>
	      (which can happen when all header parameter values are shared
	      between all recipients and when no encrypted key is used,
	      such as when doing Direct Encryption).
	    </t>
	  </list>
	</t>

	<figure>
	  <preamble>
	    The syntax of a JWE using the JWE JSON Serialization is as follows:
	  </preamble>
	  <artwork><![CDATA[
  {"protected":<integrity-protected shared header contents>",
   "unprotected":<non-integrity-protected shared header contents>",
   "recipients":[
    {"header":"<per-recipient unprotected header 1 contents>",
     "encrypted_key":"<encrypted key 1 contents>"},
    ...
    {"header":"<per-recipient unprotected header N contents>",
     "encrypted_key":"<encrypted key N contents>"}],
   "aad":"<additional authenticated data contents>",
   "iv":"<initialization vector contents>",
   "ciphertext":"<ciphertext contents>",
   "tag":"<authentication tag contents>"
  }
]]></artwork></figure>

	<t>
	  Of these members, only the
	  <spanx style="verb">ciphertext</spanx>
	  member MUST be present.
	  The
	  <spanx style="verb">iv</spanx>,
	  <spanx style="verb">tag</spanx>,
	  and <spanx style="verb">encrypted_key</spanx>
	  members MUST be present when corresponding
	  JWE Initialization Vector,
	  JWE Authentication Tag,
	  and JWE Encrypted Key
	  values are non-empty.
	  The <spanx style="verb">recipients</spanx> member MUST be present when any
	  <spanx style="verb">header</spanx> or <spanx style="verb">encrypted_key</spanx>
	  members are needed for recipients.
	  At least one of the
	  <spanx style="verb">header</spanx>,
	  <spanx style="verb">protected</spanx>,
	  and <spanx style="verb">unprotected</spanx>
	  members MUST be present so that <spanx style="verb">alg</spanx>
	  and <spanx style="verb">enc</spanx>
	  header parameter values are conveyed for each recipient computation.
	</t>
	<t>
	  The contents of the
	  Encoded JWE Encrypted Key,
	  Encoded JWE Initialization Vector,
	  Encoded JWE Ciphertext, and
	  Encoded JWE Authentication Tag
	  values are exactly as defined in the rest of this specification.
	  They are interpreted and validated in the same manner,
	  with each corresponding
	  Encoded JWE Encrypted Key,
	  Encoded JWE Initialization Vector,
	  Encoded JWE Ciphertext,
	  Encoded JWE Authentication Tag, and
	  set of header parameter values
	  being created and validated together.
	  The JWE Header values used are the union of the header parameters in the
	  <spanx style="verb">protected</spanx>,
	  <spanx style="verb">unprotected</spanx>, and
	  corresponding <spanx style="verb">header</spanx> members,
	  as described earlier.
	</t>
	<t>
	  Each JWE Encrypted Key value is computed using the
	  parameters of the corresponding JWE Header value
	  in the same manner as for the JWE Compact Serialization.
	  This has the desirable property that each
	  Encoded JWE Encrypted Key value
	  in the <spanx style="verb">recipients</spanx> array
	  is identical to the value
	  that would have been computed for the same parameter
	  in the JWE Compact Serialization.
	  Likewise, the JWE Ciphertext and JWE Authentication Tag values
	  match those produced for the JWE Compact Serialization,
	  provided that the Encoded JWE Header value
	  (which represents the integrity-protected header parameter values)
	  matches that used in
	  the JWE Compact Serialization.
	</t>
	<t>
	  All recipients use the same
	  JWE Protected Header,
	  JWE Initialization Vector,
	  JWE Ciphertext,
	  and JWE Authentication Tag values, resulting in
	  potentially significant space savings if the message is large.
	  Therefore, all header parameters that specify the treatment of
	  the Plaintext value MUST be the same for all recipients.
	  This primarily means that the <spanx
	  style="verb">enc</spanx> (encryption method) header parameter
	  value in the JWE Header for each recipient
	  and any parameters of that algorithm MUST be the same.
	</t>
	<t>
	  See <xref target="JSONSerializationExample"/> for an example
	  of computing a JWE using the JWE JSON Serialization.
	</t>

      </section>

    </section>

    <section title="Distinguishing Between JWS and JWE Objects" anchor="Distinguishing">

      <t>
	There are several ways of distinguishing whether an object is a
	JWS or JWE object.
	All these methods will yield the same result for all legal input values.

	<list style='symbols'>
	  <t>
	    If the object is using the JWS Compact Serialization or
	    the JWE Compact Serialization, the number of base64url encoded segments
	    separated by period ('.') characters differs for JWSs and JWEs.
	    JWSs have three segments separated by two period ('.') characters.
	    JWEs have five segments separated by four period ('.') characters.
	  </t>
	  <t>
	    If the object is using the JWS JSON Serialization or
	    the JWE JSON Serialization, the members used will be different.
	    JWSs have a <spanx style="verb">signatures</spanx> member and JWEs do not.
	    JWEs have a <spanx style="verb">recipients</spanx> member and JWSs do not.
	  </t>
	  <t>
	    A JWS Header can be distinguished from a JWE header by
	    examining the <spanx style="verb">alg</spanx>
	    (algorithm) header parameter value.
	    If the value represents a digital signature or MAC algorithm,
	    or is the value <spanx style="verb">none</spanx>, it is for a JWS;
	    if it represents a Key Encryption, Key Wrapping, Direct Key Agreement,
	    Key Agreement with Key Wrapping, or Direct Encryption algorithm, it is for a JWE.
	  </t>
	  <t>
	    A JWS Header can also be distinguished from a JWE header by
	    determining whether an
	    <spanx style="verb">enc</spanx> (encryption method) member exists.
	    If the <spanx style="verb">enc</spanx> member exists, it is a JWE;
	    otherwise, it is a JWS.
	  </t>
	</list>
      </t>
    </section>

    <section title="IANA Considerations" anchor="IANA">

      <section title="Registration of JWE Header Parameter Names" anchor="HdrReg">
	<t>
	  This specification registers the Header Parameter Names defined in
	  <xref target="ReservedHeaderParameterName"/> in the IANA
	  JSON Web Signature and Encryption Header Parameters registry
	  <xref target="JWS" />.
	</t>

        <section title="Registry Contents" anchor="HdrContents">
          <t> <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">alg</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="algDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
            <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">enc</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="encDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
            <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">zip</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="zipDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">jku</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="jkuDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">jwk</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification document(s): <xref target="jwkDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">x5u</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="x5uDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">x5t</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="x5tDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">x5c</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="x5cDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">kid</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="kidDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">typ</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="typDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">cty</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="ctyDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">crit</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="critDef"/> of [[ this document ]]
              </t>
            </list>
          </t>
	</section>
	<?rfc subcompact="no"?>
      </section>

    </section>

    <section title="Security Considerations" anchor="Security">
      <t>
	All of the security issues faced by any cryptographic application
	must be faced by a JWS/JWE/JWK agent.  Among these issues are protecting
	the user's private and symmetric keys, preventing various attacks, and helping the
	user avoid mistakes such as inadvertently encrypting a message for
	the wrong recipient.  The entire list of security considerations is
	beyond the scope of this document.
      </t>
      <t>
	All the security considerations in the JWS specification
	also apply to this specification.
	Likewise, all the security considerations in
	<xref target="W3C.CR-xmlenc-core1-20120313">XML Encryption 1.1</xref>
	also apply, other than those that are XML specific.
      </t>
      <t>
	When decrypting, particular care must be taken not to allow
	the JWE recipient to be used as an oracle for decrypting messages.
	<xref target="RFC3218">RFC 3218</xref> should be consulted for specific
	countermeasures to attacks on RSAES-PKCS1-V1_5.
	An attacker might modify the contents of the <spanx style="verb">alg</spanx>
	parameter from <spanx style="verb">RSA-OAEP</spanx> to
	<spanx style="verb">RSA1_5</spanx> in order to generate a
	formatting error that can be detected and used to recover the CEK
	even if RSAES OAEP was used to encrypt the CEK.
	It is therefore particularly important to report all
	formatting errors to the CEK, Additional Authenticated Data,
	or ciphertext as a single error when the encrypted content is rejected.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.1421.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.1951.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2046.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml' ?>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml2/reference.ITU.X690.1994.xml' ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml4/reference.W3C.CR-xmlenc-core1-20120313.xml" ?>

      <reference anchor="JWS">
        <front>
          <title>JSON Web Signature (JWS)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	    <address>
	      <email>ve7jtb@ve7jtb.com</email>
	    </address>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute</organization>
	    <address>
	      <email>n-sakimura@nri.co.jp</email>
	    </address>
	  </author>

	  <date day="3" month="September" year="2013" />
        </front>
        <seriesInfo value="draft-ietf-jose-json-web-signature" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-signature" type="HTML" />
      </reference>

      <reference anchor="JWK">
        <front>
	  <title>JSON Web Key (JWK)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <date day="3" month="September" year="2013" />
        </front>
        <seriesInfo value="draft-ietf-jose-json-web-key" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-key" type="HTML" />
      </reference>

      <reference anchor="JWA">
        <front>
	  <title>JSON Web Algorithms (JWA)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <date day="3" month="September" year="2013" />
        </front>
        <seriesInfo value="draft-ietf-jose-json-web-algorithms" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms" type="HTML" />
      </reference>

      <reference anchor="ECMAScript">
	<front>
	  <title>ECMAScript Language Specification, 5.1 Edition</title>
	  <author>
	    <organization>Ecma International</organization>
	  </author>
	  <date month="June" year="2011"/>
	</front>
	<seriesInfo name="ECMA" value="262"/>
	<format target="http://www.ecma-international.org/ecma-262/5.1/" type="HTML" />
	<format target="http://www.ecma-international.org/ecma-262/5.1/ECMA-262.pdf" type="PDF" />
      </reference>

    </references>

    <references title="Informative References">
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3218.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4122.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5652.xml' ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-rescorla-jsms-00.xml" ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-mcgrew-aead-aes-cbc-hmac-sha2-01.xml" ?>

      <reference anchor="JSE">
        <front>
          <title>JSON Simple Encryption</title>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	  </author>

	  <author fullname="Nat Sakimura (editor)" initials="N. " surname="Sakimura (editor)">
	    <organization abbrev="NRI">Nomura Research Institute</organization>
	  </author>

          <date month="September" year="2010" />
        </front>
        <format target="http://jsonenc.info/enc/1.0/" type="HTML" />
      </reference>

    </references>


    <section title="JWE Examples" anchor="JWEExamples">

      <t>
	This section provides examples of JWE computations.
      </t>


      <section title="Example JWE using RSAES OAEP and AES GCM" anchor="OAEPGCMExample">
	<t>
	  This example encrypts the plaintext
	  "The true sign of intelligence is not knowledge but imagination."
	  to the recipient using RSAES OAEP for key encryption
	  and AES GCM for content encryption.
	  The representation of this plaintext is:
	</t>
	<t>
[84, 104, 101, 32, 116, 114, 117, 101, 32, 115, 105, 103, 110, 32, 111, 102,
 32, 105, 110, 116, 101, 108, 108, 105, 103, 101, 110, 99, 101, 32, 105, 115,
 32, 110, 111, 116, 32, 107, 110, 111, 119, 108, 101, 100, 103, 101, 32, 98,
 117, 116, 32, 105, 109, 97, 103, 105, 110, 97, 116, 105, 111, 110, 46]
	</t>

	<section title="JWE Header" anchor="OAEPGCMHeader">
	  <t>
	    The following example JWE Header declares that:
	    <list style="symbols">
	      <t>
		the Content Encryption Key is encrypted to the recipient
		using the RSAES OAEP algorithm to produce
		the JWE Encrypted Key and
	      </t>
	      <t>
		the Plaintext is encrypted using the AES GCM
		algorithm with a 256 bit key to produce the Ciphertext.
	      </t>
	    </list>
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"RSA-OAEP","enc":"A256GCM"}
]]></artwork></figure>
	</section>

	<section title="Encoded JWE Header" anchor="OAEPGCMEncodedHeader">
	  <t>
	    Base64url encoding the octets of the UTF-8 representation of
	    the JWE Header yields this Encoded JWE Header value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ
]]></artwork></figure>
	</section>

	<section title="Content Encryption Key (CEK)" anchor="OAEPGCMCEK">
	  <t>
	    Generate a 256 bit random Content Encryption Key (CEK).
	    In this example, the value is:
	  </t>
	  <t>
[177, 161, 244, 128, 84, 143, 225, 115, 63, 180, 3, 255, 107, 154, 212, 246,
 138, 7, 110, 91, 112, 46, 34, 105, 47, 130, 203, 46, 122, 234, 64, 252]
	  </t>
	</section>

	<section title="Key Encryption" anchor="OAEPGCEKeyEncryption">
	  <t>
	    Encrypt the CEK with the recipient's public key using the RSAES OAEP
	    algorithm to produce the JWE Encrypted Key.
	    This example uses the RSA key
	    represented in JSON Web Key <xref target="JWK" /> format below
	    (with line breaks for display purposes only):
	  </t>
	  <figure><artwork><![CDATA[
  {"kty":"RSA",
   "n":"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUW
        cJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3S
        psk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2a
        sbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMS
        tPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2dj
        YgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw",
   "e":"AQAB",
   "d":"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5N
        WV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD9
        3Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghk
        qDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vl
        t3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSnd
        VTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ"
  }
]]></artwork></figure>

	  <t>
	    The resulting JWE Encrypted Key value is:
	  </t>
	  <t>
[56, 163, 154, 192, 58, 53, 222, 4, 105, 218, 136, 218, 29, 94, 203, 22,
 150, 92, 129, 94, 211, 232, 53, 89, 41, 60, 138, 56, 196, 216, 82, 98,
 168, 76, 37, 73, 70, 7, 36, 8, 191, 100, 136, 196, 244, 220, 145, 158,
 138, 155, 4, 117, 141, 230, 199, 247, 173, 45, 182, 214, 74, 177, 107, 211,
 153, 11, 205, 196, 171, 226, 162, 128, 171, 182, 13, 237, 239, 99, 193, 4,
 91, 219, 121, 223, 107, 167, 61, 119, 228, 173, 156, 137, 134, 200, 80, 219,
 74, 253, 56, 185, 91, 177, 34, 158, 89, 154, 205, 96, 55, 18, 138, 43,
 96, 218, 215, 128, 124, 75, 138, 243, 85, 25, 109, 117, 140, 26, 155, 249,
 67, 167, 149, 231, 100, 6, 41, 65, 214, 251, 232, 87, 72, 40, 182, 149,
 154, 168, 31, 193, 126, 215, 89, 28, 111, 219, 125, 182, 139, 235, 195, 197,
 23, 234, 55, 58, 63, 180, 68, 202, 206, 149, 75, 205, 248, 176, 67, 39,
 178, 60, 98, 193, 32, 238, 122, 96, 158, 222, 57, 183, 111, 210, 55, 188,
 215, 206, 180, 166, 150, 166, 106, 250, 55, 229, 72, 40, 69, 214, 216, 104,
 23, 40, 135, 212, 28, 127, 41, 80, 175, 174, 168, 115, 171, 197, 89, 116,
 92, 103, 246, 83, 216, 182, 176, 84, 37, 147, 35, 45, 219, 172, 99, 226,
 233, 73, 37, 124, 42, 72, 49, 242, 35, 127, 184, 134, 117, 114, 135, 206]
	  </t>
	</section>

	<section title="Encoded JWE Encrypted Key" anchor="OAEPGCMEncodedKey">
	  <t>
	    Base64url encode the JWE Encrypted Key to produce
	    the Encoded JWE Encrypted Key.
	    This result (with line breaks for display purposes only) is:
	  </t>
<figure><artwork><![CDATA[
  OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe
  ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb
  Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV
  mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8
  1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi
  6UklfCpIMfIjf7iGdXKHzg
]]></artwork></figure>
	</section>

	<section title="Initialization Vector" anchor="OAEPGCMIV">
	  <t>
	    Generate a random 96 bit JWE Initialization Vector.
	    In this example, the value is:
	  </t>
	  <t>
	    [227, 197, 117, 252, 2, 219, 233, 68, 180, 225, 77, 219]
	  </t>
	  <t>
	    Base64url encoding this value yields this Encoded JWE Initialization Vector value:
	  </t>
<figure><artwork><![CDATA[
  48V1_ALb6US04U3b
]]></artwork></figure>
	</section>

	<section title='Additional Authenticated Data' anchor="OAEPGCMAAD">
	  <t>
	    Let the Additional Authenticated Data encryption parameter be
	    the octets of the ASCII representation of
	    the Encoded JWE Header value.
	    This AAD value is:
	  </t>
	  <t>
[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 48, 69, 116,
 84, 48, 70, 70, 85, 67, 73, 115, 73, 109, 86, 117, 89, 121, 73, 54,
 73, 107, 69, 121, 78, 84, 90, 72, 81, 48, 48, 105, 102, 81]
	  </t>
	</section>

	<section title="Plaintext Encryption" anchor="OAEPGCMEncryption">
	  <t>
	    Encrypt the Plaintext with AES GCM
	    using the CEK as the encryption key,
	    the JWE Initialization Vector,
	    and the Additional Authenticated Data value above,
	    requesting a 128 bit Authentication Tag output.
	    The resulting Ciphertext is:
	  </t>
	  <t>
[229, 236, 166, 241, 53, 191, 115, 196, 174, 43, 73, 109, 39, 122, 233, 96,
 140, 206, 120, 52, 51, 237, 48, 11, 190, 219, 186, 80, 111, 104, 50, 142,
 47, 167, 59, 61, 181, 127, 196, 21, 40, 82, 242, 32, 123, 143, 168, 226,
 73, 216, 176, 144, 138, 247, 106, 60, 16, 205, 160, 109, 64, 63, 192]
	  </t>
	  <t>
	    The resulting Authentication Tag value is:
	  </t>
	  <t>
[92, 80, 104, 49, 133, 25, 161, 215, 173, 101, 219, 211, 136, 91, 210, 145]
	  </t>
	</section>

	<section title="Encoded JWE Ciphertext" anchor="OAEPGCMEncodedCiphertext">
	  <t>
	    Base64url encode the Ciphertext to create the Encoded JWE Ciphertext.
	    This result (with line breaks for display purposes only) is:
	  </t>
<figure><artwork><![CDATA[
  5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji
  SdiwkIr3ajwQzaBtQD_A
]]></artwork></figure>
	</section>

	<section title="Encoded JWE Authentication Tag" anchor="OAEPGCMEncodedTag">
	  <t>
	    Base64url encode the Authentication Tag to create
	    the Encoded JWE Authentication Tag.
	    This result is:
	  </t>
<figure><artwork><![CDATA[
  XFBoMYUZodetZdvTiFvSkQ
]]></artwork></figure>
	</section>

	<section title="Complete Representation" anchor="OAEPGCMComplete">
	  <t>
	    Assemble the final representation:
	    The Compact Serialization of this result is the
	    concatenation of
	    the Encoded JWE Header,
	    the Encoded JWE Encrypted Key,
	    the Encoded JWE Initialization Vector,
	    the Encoded JWE Ciphertext, and
	    the Encoded JWE Authentication Tag
	    in that order, with the five strings
	    being separated by four period ('.') characters.
	  </t>
	  <t>
	    The final result in this example
	    (with line breaks for display purposes only) is:
	  </t>
	  <figure><artwork><![CDATA[
  eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.
  OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe
  ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb
  Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV
  mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8
  1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi
  6UklfCpIMfIjf7iGdXKHzg.
  48V1_ALb6US04U3b.
  5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji
  SdiwkIr3ajwQzaBtQD_A.
  XFBoMYUZodetZdvTiFvSkQ
]]></artwork></figure>
	</section>

	<section title="Validation" anchor="OAEPGCMValidation">
	  <t>
	    This example illustrates the process of creating a JWE with
	    RSAES OAEP for key encryption
	    and AES GCM for content encryption.
	    These results can be used to validate JWE decryption implementations for these algorithms.
	    Note that since the RSAES OAEP computation includes random values,
	    the encryption results above will not be completely reproducible.
	    However, since the AES GCM computation is deterministic, the JWE Encrypted Ciphertext
	    values will be the same for all encryptions performed using these inputs.
	  </t>
	</section>
      </section>


      <section title="Example JWE using RSAES-PKCS1-V1_5 and AES_128_CBC_HMAC_SHA_256" anchor="RSACBCExample">
	<t>
	  This example encrypts the plaintext
	  "Live long and prosper."
	  to the recipient using RSAES-PKCS1-V1_5 for key encryption
	  and AES_128_CBC_HMAC_SHA_256 for content encryption.
	  The representation of this plaintext is:
	</t>
	<t>
[76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32, 112, 114,
 111, 115, 112, 101, 114, 46]
	</t>

	<section title="JWE Header" anchor="RSACBCHeader">
	  <t>
	    The following example JWE Header (with line breaks for display purposes only) declares that:
	    <list style="symbols">
	      <t>
		the Content Encryption Key is encrypted to the recipient
		using the RSAES-PKCS1-V1_5 algorithm to produce
		the JWE Encrypted Key and
	      </t>
	      <t>
		the Plaintext is encrypted using the AES_128_CBC_HMAC_SHA_256
		algorithm to produce the Ciphertext.
	      </t>
	    </list>
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"RSA1_5","enc":"A128CBC-HS256"}
]]></artwork></figure>
	</section>

	<section title="Encoded JWE Header" anchor="RSACBCEncodedHeader">
	  <t>
	    Base64url encoding the octets of the UTF-8 representation of
	    the JWE Header yields this Encoded JWE Header value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0
]]></artwork></figure>
	</section>

	<section title="Content Encryption Key (CEK)" anchor="RSACBCCEK">
	  <t>
	    Generate a 256 bit random Content Encryption Key (CEK).
	    In this example, the key value is:
	  </t>
	  <t>
[4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106, 206,
 107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44, 207]
	  </t>
	</section>

	<section title="Key Encryption" anchor="RSACBCKeyEncryption">
	  <t>
	    Encrypt the CEK with the recipient's public key using the RSAES-PKCS1-V1_5
	    algorithm to produce the JWE Encrypted Key.
	    This example uses the RSA key
	    represented in JSON Web Key <xref target="JWK" /> format below
	    (with line breaks for display purposes only):
	  </t>
	  <figure><artwork><![CDATA[
  {"kty":"RSA",
   "n":"sXchDaQebHnPiGvyDOAT4saGEUetSyo9MKLOoWFsueri23bOdgWp4Dy1Wl
        UzewbgBHod5pcM9H95GQRV3JDXboIRROSBigeC5yjU1hGzHHyXss8UDpre
        cbAYxknTcQkhslANGRUZmdTOQ5qTRsLAt6BTYuyvVRdhS8exSZEy_c4gs_
        7svlJJQ4H9_NxsiIoLwAEk7-Q3UXERGYw_75IDrGA84-lA_-Ct4eTlXHBI
        Y2EaV7t7LjJaynVJCpkv4LKjTTAumiGUIuQhrNhZLuF_RJLqHpM2kgWFLU
        7-VTdL1VbC2tejvcI2BlMkEpk1BzBZI0KQB0GaDWFLN-aEAw3vRw",
   "e":"AQAB",
   "d":"VFCWOqXr8nvZNyaaJLXdnNPXZKRaWCjkU5Q2egQQpTBMwhprMzWzpR8Sxq
        1OPThh_J6MUD8Z35wky9b8eEO0pwNS8xlh1lOFRRBoNqDIKVOku0aZb-ry
        nq8cxjDTLZQ6Fz7jSjR1Klop-YKaUHc9GsEofQqYruPhzSA-QgajZGPbE_
        0ZaVDJHfyd7UUBUKunFMScbflYAAOYJqVIVwaYR5zWEEceUjNnTNo_CVSj
        -VvXLO5VZfCUAVLgW4dpf1SrtZjSt34YLsRarSb127reG_DUwg9Ch-Kyvj
        T1SkHgUWRVGcyly7uvVGRSDwsXypdrNinPA4jlhoNdizK2zF2CWQ"
  }
]]></artwork></figure>

	  <t>
	    The resulting JWE Encrypted Key value is:
	  </t>
	  <t>
[80, 104, 72, 58, 11, 130, 236, 139, 132, 189, 255, 205, 61, 86, 151, 176,
 99, 40, 44, 233, 176, 189, 205, 70, 202, 169, 72, 40, 226, 181, 156, 223,
 120, 156, 115, 232, 150, 209, 145, 133, 104, 112, 237, 156, 116, 250, 65, 102,
 212, 210, 103, 240, 177, 61, 93, 40, 71, 231, 223, 226, 240, 157, 15, 31,
 150, 89, 200, 215, 198, 203, 108, 70, 117, 66, 212, 238, 193, 205, 23, 161,
 169, 218, 243, 203, 128, 214, 127, 253, 215, 139, 43, 17, 135, 103, 179, 220,
 28, 2, 212, 206, 131, 158, 128, 66, 62, 240, 78, 186, 141, 125, 132, 227,
 60, 137, 43, 31, 152, 199, 54, 72, 34, 212, 115, 11, 152, 101, 70, 42,
 219, 233, 142, 66, 151, 250, 126, 146, 141, 216, 190, 73, 50, 177, 146, 5,
 52, 247, 28, 197, 21, 59, 170, 247, 181, 89, 131, 241, 169, 182, 246, 99,
 15, 36, 102, 166, 182, 172, 197, 136, 230, 120, 60, 58, 219, 243, 149, 94,
 222, 150, 154, 194, 110, 227, 225, 112, 39, 89, 233, 112, 207, 211, 241, 124,
 174, 69, 221, 179, 107, 196, 225, 127, 167, 112, 226, 12, 242, 16, 24, 28,
 120, 182, 244, 213, 244, 153, 194, 162, 69, 160, 244, 248, 63, 165, 141, 4,
 207, 249, 193, 79, 131, 0, 169, 233, 127, 167, 101, 151, 125, 56, 112, 111,
 248, 29, 232, 90, 29, 147, 110, 169, 146, 114, 165, 204, 71, 136, 41, 252]
	  </t>
	</section>

	<section title="Encoded JWE Encrypted Key" anchor="RSACBCEncodedKey">
	  <t>
	    Base64url encode the JWE Encrypted Key to produce
	    the Encoded JWE Encrypted Key.
	    This result (with line breaks for display purposes only) is:
	  </t>
<figure><artwork><![CDATA[
  UGhIOguC7IuEvf_NPVaXsGMoLOmwvc1GyqlIKOK1nN94nHPoltGRhWhw7Zx0-kFm
  1NJn8LE9XShH59_i8J0PH5ZZyNfGy2xGdULU7sHNF6Gp2vPLgNZ__deLKxGHZ7Pc
  HALUzoOegEI-8E66jX2E4zyJKx-YxzZIItRzC5hlRirb6Y5Cl_p-ko3YvkkysZIF
  NPccxRU7qve1WYPxqbb2Yw8kZqa2rMWI5ng8OtvzlV7elprCbuPhcCdZ6XDP0_F8
  rkXds2vE4X-ncOIM8hAYHHi29NX0mcKiRaD0-D-ljQTP-cFPgwCp6X-nZZd9OHBv
  -B3oWh2TbqmScqXMR4gp_A
]]></artwork></figure>
	</section>

	<section title="Initialization Vector" anchor="RSACBCIV">
	  <t>
	    Generate a random 128 bit JWE Initialization Vector.
	    In this example, the value is:
	  </t>
	  <t>
	    [3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111, 116, 104, 101]
	  </t>
	  <t>
	    Base64url encoding this value yields this Encoded JWE Initialization Vector value:
	  </t>
<figure><artwork><![CDATA[
  AxY8DCtDaGlsbGljb3RoZQ
]]></artwork></figure>
	</section>

	<section title='Additional Authenticated Data' anchor="RSACBCAAD">
	  <t>
	    Let the Additional Authenticated Data encryption parameter be
	    the octets of the ASCII representation of
	    the Encoded JWE Header value.
	    This AAD value is:
	  </t>
	  <t>
[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 48, 69, 120,
 88, 122, 85, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66,
 77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50,
 73, 110, 48]
	  </t>
	</section>

	<section title="Plaintext Encryption" anchor="RSACBCEncryption">
	  <t>
	    Encrypt the Plaintext with AES_128_CBC_HMAC_SHA_256
	    using the CEK as the encryption key,
	    the JWE Initialization Vector,
	    and the Additional Authenticated Data value above.
	    The steps for doing this using the values from <xref target="WrapExample"/>
	    are detailed in <xref target="CBC_HMAC_Example"/>.
	    The resulting Ciphertext is:
	  </t>
	  <t>
[40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6, 75,
 129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143, 112, 56, 102]
	  </t>
	  <t>
	    The resulting Authentication Tag value is:
	  </t>
	  <t>
[246, 17, 244, 190, 4, 95, 98, 3, 231, 0, 115, 157, 242, 203, 100, 191]
	  </t>
	</section>

	<section title="Encoded JWE Ciphertext" anchor="RSACBCEncodedCiphertext">
	  <t>
	    Base64url encode the Ciphertext to create the Encoded JWE Ciphertext.
	    This result is:
	  </t>
<figure><artwork><![CDATA[
  KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY
]]></artwork></figure>
	</section>

	<section title="Encoded JWE Authentication Tag" anchor="RSACBCEncodedTag">
	  <t>
	    Base64url encode the Authentication Tag to create
	    the Encoded JWE Authentication Tag.
	    This result is:
	  </t>
<figure><artwork><![CDATA[
  9hH0vgRfYgPnAHOd8stkvw
]]></artwork></figure>
	</section>

	<section title="Complete Representation" anchor="RSACBCComplete">
	  <t>
	    Assemble the final representation:
	    The Compact Serialization of this result is the
	    concatenation of
	    the Encoded JWE Header,
	    the Encoded JWE Encrypted Key,
	    the Encoded JWE Initialization Vector,
	    the Encoded JWE Ciphertext, and
	    the Encoded JWE Authentication Tag
	    in that order, with the five strings
	    being separated by four period ('.') characters.
	  </t>
	  <t>
	    The final result in this example
	    (with line breaks for display purposes only) is:
	  </t>
	  <figure><artwork><![CDATA[
  eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.
  UGhIOguC7IuEvf_NPVaXsGMoLOmwvc1GyqlIKOK1nN94nHPoltGRhWhw7Zx0-kFm
  1NJn8LE9XShH59_i8J0PH5ZZyNfGy2xGdULU7sHNF6Gp2vPLgNZ__deLKxGHZ7Pc
  HALUzoOegEI-8E66jX2E4zyJKx-YxzZIItRzC5hlRirb6Y5Cl_p-ko3YvkkysZIF
  NPccxRU7qve1WYPxqbb2Yw8kZqa2rMWI5ng8OtvzlV7elprCbuPhcCdZ6XDP0_F8
  rkXds2vE4X-ncOIM8hAYHHi29NX0mcKiRaD0-D-ljQTP-cFPgwCp6X-nZZd9OHBv
  -B3oWh2TbqmScqXMR4gp_A.
  AxY8DCtDaGlsbGljb3RoZQ.
  KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.
  9hH0vgRfYgPnAHOd8stkvw
]]></artwork></figure>
	</section>

	<section title="Validation" anchor="RSACBCValidation">
	  <t>
	    This example illustrates the process of creating a JWE with
	    RSAES-PKCS1-V1_5 for key encryption
	    and AES_CBC_HMAC_SHA2 for content encryption.
	    These results can be used to validate JWE decryption implementations for these algorithms.
	    Note that since the RSAES-PKCS1-V1_5 computation includes random values,
	    the encryption results above will not be completely reproducible.
	    However, since the AES CBC computation is deterministic, the JWE Encrypted Ciphertext
	    values will be the same for all encryptions performed using these inputs.
	  </t>
	</section>
      </section>


      <section title="Example JWE using AES Key Wrap and AES_128_CBC_HMAC_SHA_256" anchor="WrapExample">
	<t>
	  This example encrypts the plaintext
	  "Live long and prosper."
	  to the recipient using AES Key Wrap for key encryption
	  and AES GCM for content encryption.
	  The representation of this plaintext is:
	</t>
	<t>
[76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32, 112, 114,
 111, 115, 112, 101, 114, 46]
	</t>

	<section title="JWE Header" anchor="WrapHeader">
	  <t>
	    The following example JWE Header declares that:
	    <list style="symbols">
	      <t>
		the Content Encryption Key is encrypted to the recipient
		using the AES Key Wrap algorithm with a 128 bit key to produce
		the JWE Encrypted Key and
	      </t>
	      <t>
		the Plaintext is encrypted using the AES_128_CBC_HMAC_SHA_256
		algorithm to produce the Ciphertext.
	      </t>
	    </list>
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"A128KW","enc":"A128CBC-HS256"}
]]></artwork></figure>
	</section>

	<section title="Encoded JWE Header" anchor="WrapEncodedHeader">
	  <t>
	    Base64url encoding the octets of the UTF-8 representation of
	    the JWE Header yields this Encoded JWE Header value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0
]]></artwork></figure>
	</section>

	<section title="Content Encryption Key (CEK)" anchor="WrapCEK">
	  <t>
	    Generate a 256 bit random Content Encryption Key (CEK).
	    In this example, the value is:
	  </t>
	  <t>
[4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106, 206,
 107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44, 207]
	  </t>
	</section>

	<section title="Key Encryption" anchor="WrapKeyEncryption">
	  <t>
	    Encrypt the CEK with the shared symmetric key using the AES Key Wrap
	    algorithm to produce the JWE Encrypted Key.
	    This example uses the symmetric key
	    represented in JSON Web Key <xref target="JWK" /> format below:
	  </t>
	  <figure><artwork><![CDATA[
  {"kty":"oct",
   "k":"GawgguFyGrWKav7AX4VKUg"
  }
]]></artwork></figure>

	  <t>
	    The resulting JWE Encrypted Key value is:
	  </t>
	  <t>
[232, 160, 123, 211, 183, 76, 245, 132, 200, 128, 123, 75, 190, 216, 22, 67,
 201, 138, 193, 186, 9, 91, 122, 31, 246, 90, 28, 139, 57, 3, 76, 124,
 193, 11, 98, 37, 173, 61, 104, 57]
	  </t>
	</section>

	<section title="Encoded JWE Encrypted Key" anchor="WrapEncodedKey">
	  <t>
	    Base64url encode the JWE Encrypted Key to produce
	    the Encoded JWE Encrypted Key.
	    This result is:
	  </t>
<figure><artwork><![CDATA[
  6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ
]]></artwork></figure>
	</section>

	<section title="Initialization Vector" anchor="WrapIV">
	  <t>
	    Generate a random 128 bit JWE Initialization Vector.
	    In this example, the value is:
	  </t>
	  <t>
	    [3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111, 116, 104, 101]
	  </t>
	  <t>
	    Base64url encoding this value yields this Encoded JWE Initialization Vector value:
	  </t>
<figure><artwork><![CDATA[
  AxY8DCtDaGlsbGljb3RoZQ
]]></artwork></figure>
	</section>

	<section title='Additional Authenticated Data' anchor="WrapAAD">
	  <t>
	    Let the Additional Authenticated Data encryption parameter be
	    the octets of the ASCII representation of
	    the Encoded JWE Header value.
	    This AAD value is:
	  </t>
	  <t>
[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 66, 77, 84, 73, 52,
 83, 49, 99, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66,
 77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50,
 73, 110, 48]
	  </t>
	</section>

	<section title="Plaintext Encryption" anchor="WrapEncryption">
	  <t>
	    Encrypt the Plaintext with AES_128_CBC_HMAC_SHA_256
	    using the CEK as the encryption key,
	    the JWE Initialization Vector,
	    and the Additional Authenticated Data value above.
	    The steps for doing this using the values from this example
	    are detailed in <xref target="CBC_HMAC_Example"/>.
	    The resulting Ciphertext is:
	  </t>
	  <t>
[40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6, 75,
 129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143, 112, 56, 102]
	  </t>
	  <t>
	    The resulting Authentication Tag value is:
	  </t>
	  <t>
[83, 73, 191, 98, 104, 205, 211, 128, 201, 189, 199, 133, 32, 38, 194, 85]
	  </t>
	</section>

	<section title="Encoded JWE Ciphertext" anchor="WrapEncodedCiphertext">
	  <t>
	    Base64url encode the Ciphertext to create the Encoded JWE Ciphertext.
	    This result is:
	  </t>
<figure><artwork><![CDATA[
  KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY
]]></artwork></figure>
	</section>

	<section title="Encoded JWE Authentication Tag" anchor="WrapEncodedTag">
	  <t>
	    Base64url encode the Authentication Tag to create
	    the Encoded JWE Authentication Tag.
	    This result is:
	  </t>
<figure><artwork><![CDATA[
  U0m_YmjN04DJvceFICbCVQ
]]></artwork></figure>
	</section>

	<section title="Complete Representation" anchor="WrapComplete">
	  <t>
	    Assemble the final representation:
	    The Compact Serialization of this result is the
	    concatenation of
	    the Encoded JWE Header,
	    the Encoded JWE Encrypted Key,
	    the Encoded JWE Initialization Vector,
	    the Encoded JWE Ciphertext, and
	    the Encoded JWE Authentication Tag
	    in that order, with the five strings
	    being separated by four period ('.') characters.
	  </t>
	  <t>
	    The final result in this example
	    (with line breaks for display purposes only) is:
	  </t>
	  <figure><artwork><![CDATA[
  eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.
  6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.
  AxY8DCtDaGlsbGljb3RoZQ.
  KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.
  U0m_YmjN04DJvceFICbCVQ
]]></artwork></figure>
	</section>

	<section title="Validation" anchor="WrapValidation">
	  <t>
	    This example illustrates the process of creating a JWE with
	    AES Key Wrap for key encryption
	    and AES GCM for content encryption.
	    These results can be used to validate JWE decryption implementations for these algorithms.
	    Also, since both the AES Key Wrap and AES GCM computations are deterministic,
	    the resulting JWE value will be the same for all encryptions performed using these inputs.
	    Since the computation is reproducible, these results can also be used to validate
	    JWE encryption implementations for these algorithms.
	  </t>
	</section>
      </section>

      <section title="Example JWE Using JWE JSON Serialization" anchor="JSONSerializationExample">
	<t>
	  This section contains an example using the JWE JSON Serialization.
	  This example demonstrates the capability for
	  encrypting the same plaintext to multiple recipients.
	</t>
	<t>
	  Two recipients are present in this example.
	  The algorithm and key used for the first recipient
	  are the same as that used in <xref target="RSACBCExample"/>.
	  The algorithm and key used for the second recipient
	  are the same as that used in <xref target="WrapExample"/>.
	  The resulting JWE Encrypted Key values are therefore the same;
	  those computations are not repeated here.
	</t>
	<t>
	  The Plaintext, the Content Encryption Key (CEK), Initialization Vector,
	  and JWE Protected Header are shared by all recipients
	  (which must be the case, since the Ciphertext and
	  Authentication Tag are also shared).
	</t>

	<section title="JWE Per-Recipient Unprotected Headers" anchor="JSRecipientHeaders">
	  <t>
	    The first recipient uses the RSAES-PKCS1-V1_5 algorithm
	    to encrypt the Content Encryption Key (CEK).
	    The second uses AES Key Wrap to encrypt the CEK.
	    Key ID values are supplied for both keys.
	    The two per-recipient header values used to represent
	    these algorithms and Key IDs are:
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"RSA1_5","kid":"2011-04-29"}
]]></artwork></figure>

	  <t>
	    and:
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"A128KW","kid":"7"}
]]></artwork></figure>
	</section>

	<section title="JWE Protected Header" anchor="JSProtectedHeader">
	  <t>
	    The Plaintext is encrypted using the AES_128_CBC_HMAC_SHA_256 algorithm
	    to produce the common JWE Ciphertext and JWE Authentication Tag values.
	    The JWE Protected Header value representing this is:
	  </t>

	  <figure><artwork><![CDATA[
  {"enc":"A128CBC-HS256"}
]]></artwork></figure>

	  <t>
	    Base64url encoding the octets of the UTF-8 representation of
	    the JWE Protected Header yields this Encoded JWE Protected Header value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0
]]></artwork></figure>

	</section>

	<section title="JWE Unprotected Header" anchor="JSUnprotectedHeader">
	  <t>
	    This JWE uses the <spanx style="verb">jku</spanx> header parameter
	    to reference a JWK Set.
	    This is represented in the following JWE Unprotected Header value as:
	  </t>

	  <figure><artwork><![CDATA[
  {"jku":"https://server.example.com/keys.jwks"}
]]></artwork></figure>

	</section>

	<section title="Complete JWE Header Values" anchor="JSHeader">
	  <t>
	    Combining the per-recipient, protected, and unprotected header values
	    supplied, the JWE Header values used for the first and second recipient
	    respectively are:
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"RSA1_5",
   "kid":"2011-04-29",
   "enc":"A128CBC-HS256",
   "jku":"https://server.example.com/keys.jwks"}
]]></artwork></figure>

	  <t>
	    and:
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"A128KW",
   "kid":"7",
   "enc":"A128CBC-HS256",
   "jku":"https://server.example.com/keys.jwks"}
]]></artwork></figure>

	</section>

	<section title='Additional Authenticated Data' anchor="JSAAD">
	  <t>
	    Let the Additional Authenticated Data encryption parameter be
	    the octets of the ASCII representation of
	    the Encoded JWE Protected Header value.
	    This AAD value is:
	  </t>
	  <t>
	    [101, 121, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66, 77, 84, 73, 52,
	    81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50, 73, 110, 48]
	  </t>
	</section>

	<section title="Plaintext Encryption" anchor="JSEncryption">
	  <t>
	    Encrypt the Plaintext with AES_128_CBC_HMAC_SHA_256
	    using the CEK as the encryption key,
	    the JWE Initialization Vector,
	    and the Additional Authenticated Data value above.
	    The steps for doing this using the values from <xref target="WrapExample"/>
	    are detailed in <xref target="CBC_HMAC_Example"/>.
	    The resulting Ciphertext is:
	  </t>
	  <t>
	    [40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6, 75,
	    129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143, 112, 56, 102]
	  </t>
	  <t>
	    The resulting Authentication Tag value is:
	  </t>
	  <t>
	    [51, 63, 149, 60, 252, 148, 225, 25, 92, 185, 139, 245, 35, 2, 47, 207]
	  </t>
	</section>

	<section title="Encoded JWE Ciphertext" anchor="JSEncodedCiphertext">
	  <t>
	    Base64url encode the Ciphertext to create the Encoded JWE Ciphertext.
	    This result is:
	  </t>
	  <figure><artwork><![CDATA[
  KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY
]]></artwork></figure>
	</section>

	<section title="Encoded JWE Authentication Tag" anchor="JSEncodedTag">
	  <t>
	    Base64url encode the Authentication Tag to create
	    the Encoded JWE Authentication Tag.
	    This result is:
	  </t>
	  <figure><artwork><![CDATA[
  Mz-VPPyU4RlcuYv1IwIvzw
]]></artwork></figure>
	</section>

	<section title="Complete JWE JSON Serialization Representation" anchor="JSComplete">

	  <t>
	    The complete JSON Web Encryption JSON Serialization
	    for these values is as follows
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  {"protected":
    "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0",
   "unprotected":
    {"jku":"https://server.example.com/keys.jwks"},
   "recipients":[
    {"header":
      {"alg":"RSA1_5"},
     "encrypted_key":
      "UGhIOguC7IuEvf_NPVaXsGMoLOmwvc1GyqlIKOK1nN94nHPoltGRhWhw7Zx0-
       kFm1NJn8LE9XShH59_i8J0PH5ZZyNfGy2xGdULU7sHNF6Gp2vPLgNZ__deLKx
       GHZ7PcHALUzoOegEI-8E66jX2E4zyJKx-YxzZIItRzC5hlRirb6Y5Cl_p-ko3
       YvkkysZIFNPccxRU7qve1WYPxqbb2Yw8kZqa2rMWI5ng8OtvzlV7elprCbuPh
       cCdZ6XDP0_F8rkXds2vE4X-ncOIM8hAYHHi29NX0mcKiRaD0-D-ljQTP-cFPg
       wCp6X-nZZd9OHBv-B3oWh2TbqmScqXMR4gp_A"},
    {"header":
      {"alg":"A128KW"},
     "encrypted_key":
      "6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ"}],
   "iv":
    "AxY8DCtDaGlsbGljb3RoZQ",
   "ciphertext":
    "KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY",
   "tag":
    "Mz-VPPyU4RlcuYv1IwIvzw"
  }
]]></artwork></figure>
	</section>

      </section>

    </section>

    <section title="Example AES_128_CBC_HMAC_SHA_256 Computation"
	     anchor="CBC_HMAC_Example">
      <t>
	This example shows the steps in the AES_128_CBC_HMAC_SHA_256
	authenticated encryption computation using the values from
	the example in <xref target="WrapExample"/>.
	As described where this algorithm is defined in
	Sections 4.8 and 4.8.3 of JWA, the AES_CBC_HMAC_SHA2 family
	of algorithms are implemented using
	Advanced Encryption Standard (AES) in Cipher Block Chaining (CBC) mode with PKCS #5 padding
	to perform the encryption and
	an HMAC SHA-2 function to perform the integrity calculation
	- in this case, HMAC SHA-256.
      </t>

      <section title="Extract MAC_KEY and ENC_KEY from Key" anchor="ExtractKeys">
	<t>
	  The 256 bit AES_128_CBC_HMAC_SHA_256 key K used in this example is:
	</t>
	<t>
	  [4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106, 206,
 107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44, 207]
	</t>
	<t>
	  Use the first 128 bits of this key as the HMAC SHA-256 key MAC_KEY, which is:
	</t>
	<t>
	  [4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106, 206]
	</t>
	<t>
	  Use the last 128 bits of this key as the AES CBC key ENC_KEY, which is:
	</t>
	<t>
	  [107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44, 207]
	</t>
	<t>
	  Note that the MAC key comes before the encryption key in the input key K;
	  this is in the opposite order of the algorithm names in
	  the identifiers "AES_128_CBC_HMAC_SHA_256" and
	  <spanx style="verb">A128CBC-HS256</spanx>.
	</t>
      </section>

      <section title="Encrypt Plaintext to Create Ciphertext"
	       anchor="EncryptWithCBC">
	<t>
	  Encrypt the Plaintext with
	  AES in Cipher Block Chaining (CBC) mode using PKCS #5 padding
	  using the ENC_KEY above.
	  The Plaintext in this example is:
	</t>
	<t>
[76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32, 112, 114,
 111, 115, 112, 101, 114, 46]
	</t>
	<t>
	  The encryption result is as follows, which is the Ciphertext output:
	</t>
	<t>
[40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6, 75,
 129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143, 112, 56, 102]
	</t>
      </section>

      <section title="64 Bit Big Endian Representation of AAD Length"
	       anchor="CreateAL">
	<t>
	  The Additional Authenticated Data (AAD) in this example is:
	</t>
	<t>
[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 66, 77, 84, 73, 52,
 83, 49, 99, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66,
 77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50,
 73, 110, 48]
	</t>
	<t>
	  This AAD is 51 bytes long, which is 408 bits long.
	  The octet string AL, which is the number of bits in AAD
	  expressed as a big endian 64 bit unsigned integer is:
	</t>
	<t>
	  [0, 0, 0, 0, 0, 0, 1, 152]
	</t>
      </section>

      <section title="Initialization Vector Value" anchor="IVValue">
	<t>
	  The Initialization Vector value used in this example is:
	</t>
	<t>
[3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111, 116, 104, 101]
	</t>
      </section>

      <section title="Create Input to HMAC Computation" anchor="HMACInput">
	<t>
	  Concatenate
	  the AAD,
	  the Initialization Vector,
	  the Ciphertext,
	  and the AL value.
	  The result of this concatenation is:
	</t>
	<t>
[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 66, 77, 84, 73, 52,
 83, 49, 99, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66,
 77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50,
 73, 110, 48, 3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111,
 116, 104, 101, 40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152,
 230, 6, 75, 129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143,
 112, 56, 102, 0, 0, 0, 0, 0, 0, 1, 152]
	</t>
      </section>

      <section title="Compute HMAC Value" anchor="DoHMAC">
	<t>
	  Compute the HMAC SHA-256 of the concatenated value above.  This result M is:
	</t>
	<t>
[83, 73, 191, 98, 104, 205, 211, 128, 201, 189, 199, 133, 32, 38, 194, 85,
 9, 84, 229, 201, 219, 135, 44, 252, 145, 102, 179, 140, 105, 86, 229, 116]
	</t>
      </section>

      <section title="Truncate HMAC Value to Create Authentication Tag"
	       anchor="DoTruncate">
	<t>
	  Use the first half (128 bits) of the HMAC output M as
	  the Authentication Tag output T. This truncated value is:
	</t>
	<t>
[83, 73, 191, 98, 104, 205, 211, 128, 201, 189, 199, 133, 32, 38, 194, 85]
	</t>
      </section>
    
    </section>


    <section title="Acknowledgements" anchor="Acknowledgements">

      <t>
	Solutions for encrypting JSON content were also explored by
	<xref target="JSE">JSON Simple Encryption</xref> and
	<xref target="I-D.rescorla-jsms">JavaScript Message Security
	Format</xref>, both of which significantly influenced this draft.
	This draft attempts to explicitly reuse as many of the relevant concepts from
	<xref target="W3C.CR-xmlenc-core1-20120313">XML Encryption 1.1</xref>
	and <xref target="RFC5652">RFC 5652</xref> as possible,
	while utilizing simple, compact JSON-based data structures.
      </t>
      <t>
	Special thanks are due to John Bradley and Nat Sakimura for
	the discussions that helped inform the content of this
	specification and to Eric Rescorla and Joe Hildebrand for
	allowing the reuse of text from <xref
	target="I-D.rescorla-jsms"/> in this document.
      </t>
      <t>
	Thanks to Axel Nennker, Emmanuel Raviart, Brian Campbell, and Edmund Jay
	for validating the examples in this specification.
      </t>
      <t>
        This specification is the work of the JOSE Working Group,
	which includes dozens of active and dedicated participants.
	In particular, the following individuals contributed ideas,
        feedback, and wording that influenced this specification:
      </t>
      <t>
	Richard Barnes,
	John Bradley,
	Brian Campbell,
	Breno de Medeiros,
	Dick Hardt,
	Jeff Hodges,
	Edmund Jay,
	James Manger,
	Matt Miller,
	Tony Nadalin,
	Axel Nennker,
	Emmanuel Raviart,
	Nat Sakimura,
	Jim Schaad,
	Hannes Tschofenig,
	and Sean Turner.
      </t>
      <t>
	Jim Schaad and Karen O'Donoghue chaired the JOSE working group and
	Sean Turner and Stephen Farrell served as Security area directors
	during the creation of this specification.
      </t>
    </section>

    <section title="Document History" anchor="History">
      <t>
	[[ to be removed by the RFC editor before publication as an RFC ]]
      </t>

      <t>
	-15
	<list style='symbols'>
	  <t>
	    Clarified that it is an application decision which
	    recipients' encrypted content
	    must successfully validate for the JWE to be accepted,
	    addressing issue #35.
	  </t>
	  <t>
	    Changes to address editorial issues
	    #34, #164, and #169.
	  </t>
	</list>
      </t>

      <t>
	-14
	<list style='symbols'>
	  <t>
	    Clarified that the <spanx style="verb">protected</spanx>,
	    <spanx style="verb">unprotected</spanx>, <spanx style="verb">header</spanx>,
	    <spanx style="verb">iv</spanx>, <spanx style="verb">tag</spanx>,
	    and <spanx style="verb">encrypted_key</spanx>
	    parameters are to be omitted in the JWE JSON Serialization
	    when their values would be empty.
	    Stated that the <spanx style="verb">recipients</spanx>
	    array must always be present.
	  </t>
	</list>
      </t>

      <t>
	-13
	<list style='symbols'>
	  <t>
	    Added an <spanx style="verb">aad</spanx> (Additional Authenticated Data) member
	    for the JWE JSON Serialization, enabling Additional Authenticated Data
	    to be supplied that is not double base64url encoded,
	    addressing issue #29.
	  </t>
	</list>
      </t>

      <t>
	-12
	<list style='symbols'>
	  <t>
	    Clarified that the <spanx style="verb">typ</spanx> and
	    <spanx style="verb">cty</spanx> header parameters are used
	    in an application-specific manner
	    and have no effect upon the JWE processing.
	  </t>
	  <t>
	    Replaced the MIME types
	    <spanx style="verb">application/jwe+json</spanx> and
	    <spanx style="verb">application/jwe</spanx> with
	    <spanx style="verb">application/jose+json</spanx> and
	    <spanx style="verb">application/jose</spanx>.
	  </t>
	  <t>
	    Stated that recipients MUST either reject JWEs with
	    duplicate Header Parameter Names
	    or use a JSON parser that returns only
	    the lexically last duplicate member name.
	  </t>
	  <t>
	    Moved the
	    <spanx style="verb">epk</spanx>,
	    <spanx style="verb">apu</spanx>, and
	    <spanx style="verb">apv</spanx>
	    Header Parameter definitions to be with
	    the algorithm descriptions that use them.
	  </t>
	  <t>
	    Added a Serializations section with parallel treatment of the
	    JWE Compact Serialization
	    and the
	    JWE JSON Serialization
	    and also moved the former Implementation Considerations content there.
	  </t>
	  <t>
	    Restored use of the term "AEAD".
	  </t>
	  <t>
	    Changed terminology from "block encryption" to "content encryption".
	  </t>
	</list>
      </t>

      <t>
	-11
	<list style='symbols'>
	  <t>
	    Added Key Identification section.
	  </t>
	  <t>
	    Removed the Encrypted Key value from the AAD computation since it is
	    already effectively integrity protected by the encryption process.
	    The AAD value now only contains the representation of the JWE Encrypted Header.
	  </t>
	  <t>
	    For the JWE JSON Serialization, enable header parameter values
	    to be specified in any of three parameters:
	    the <spanx style="verb">protected</spanx> member that is
	    integrity protected and shared among all recipients,
	    the <spanx style="verb">unprotected</spanx> member that is
	    not integrity protected and shared among all recipients,
	    and the <spanx style="verb">header</spanx> member that is
	    not integrity protected and specific to a particular recipient.
	    (This does not affect the JWE Compact Serialization, in which all
	    header parameter values are in a single integrity protected JWE Header value.)
	  </t>
	  <t>
	    Shortened the names <spanx style="verb">authentication_tag</spanx> to
	    <spanx style="verb">tag</spanx> and
	    <spanx style="verb">initialization_vector</spanx> to
	    <spanx style="verb">iv</spanx> in the JWE JSON Serialization,
	    addressing issue #20.
	  </t>
	  <t>
	    Removed <spanx style="verb">apv</spanx> (agreement PartyVInfo)
	    since it is no longer used.
	  </t>
	  <t>
	    Removed suggested compact serialization for multiple recipients.
	  </t>
	  <t>
	    Changed the MIME type name <spanx style="verb">application/jwe-js</spanx>
	    to <spanx style="verb">application/jwe+json</spanx>,
	    addressing issue #22.
	  </t>
	  <t>
	    Tightened the description of the
	    <spanx style="verb">crit</spanx> (critical) header parameter.
	  </t>
	</list>
      </t>
      <t>
	-10
	<list style='symbols'>
	  <t>
	    Changed the JWE processing rules for multiple recipients so that
	    a single AAD value contains the header parameters and encrypted key
	    values for all the recipients,
	    enabling AES GCM to be safely used for multiple recipients.
	  </t>
	  <t>
	    Added an appendix suggesting a possible compact serialization
	    for JWEs with multiple recipients.
	  </t>
	</list>
      </t>
      <t>
	-09
	<list style='symbols'>
	  <t>
	    Added JWE JSON Serialization, as specified by
	    draft-jones-jose-jwe-json-serialization-04.
	  </t>
	  <t>
	    Registered <spanx style="verb">application/jwe-js</spanx> MIME type
	    and <spanx style="verb">JWE-JS</spanx> typ header parameter value.
	  </t>
	  <t>
	    Defined that the default action for header parameters that
	    are not understood is to ignore them unless specifically
	    designated as "MUST be understood" or included in the new
	    <spanx style="verb">crit</spanx> (critical) header parameter list.
	    This addressed issue #6.
	  </t>
	  <t>
	    Corrected <spanx style="verb">x5c</spanx> description.
	    This addressed issue #12.
	  </t>
	  <t>
	    Changed from using the term "byte" to "octet" when referring to 8 bit values.
	  </t>
	  <t>
	    Added Key Management Mode definitions to terminology section
	    and used the defined terms to provide clearer key management instructions.
	    This addressed issue #5.
	  </t>
	  <t>
	    Added text about preventing the recipient from behaving as an oracle
	    during decryption, especially when using RSAES-PKCS1-V1_5.
	  </t>
	  <t>
	    Changed from using the term "Integrity Value" to "Authentication Tag".
	  </t>
	  <t>
	    Changed member name from <spanx style="verb">integrity_value</spanx> to
	    <spanx style="verb">authentication_tag</spanx> in the JWE JSON Serialization.
	  </t>
	  <t>
	    Removed Initialization Vector from the AAD value since it is already
	    integrity protected by all of the authenticated encryption algorithms
	    specified in the JWA specification.
	  </t>
	  <t>
	    Replaced <spanx style="verb">A128CBC+HS256</spanx>
	    and <spanx style="verb">A256CBC+HS512</spanx>
	    with <spanx style="verb">A128CBC-HS256</spanx>
	    and <spanx style="verb">A256CBC-HS512</spanx>.
	    The new algorithms perform the same cryptographic computations as
	    <xref target="I-D.mcgrew-aead-aes-cbc-hmac-sha2"/>,
	    but with the Initialization Vector and Authentication Tag values remaining
	    separate from the Ciphertext value in the output representation.
	    Also deleted the header parameters
	    <spanx style="verb">epu</spanx> (encryption PartyUInfo) and
	    <spanx style="verb">epv</spanx> (encryption PartyVInfo),
	    since they are no longer used.
	  </t>
	</list>
      </t>
      <t>
	-08
	<list style='symbols'>
	  <t>
	    Replaced uses of the term "AEAD" with "Authenticated Encryption", since
	    the term AEAD in the RFC 5116 sense implied the use of a particular
	    data representation, rather than just referring to the class of
	    algorithms that perform authenticated encryption with associated data.
	  </t>
	  <t>
	    Applied editorial improvements suggested by
	    Jeff Hodges and Hannes Tschofenig.
	    Many of these simplified the terminology used.
	  </t>
	  <t>
	    Clarified statements of the form "This header parameter is OPTIONAL"
	    to "Use of this header parameter is OPTIONAL".
	  </t>
	  <t>
	    Added a Header Parameter Usage Location(s) field to the
	    IANA JSON Web Signature and Encryption Header Parameters registry.
	  </t>
	  <t>
	    Added seriesInfo information to Internet Draft references.
	  </t>
	</list>
      </t>
      <t>
	-07
	<list style='symbols'>
	  <t>
	    Added a data length prefix to PartyUInfo and PartyVInfo values.
	  </t>
	  <t>
	    Updated values for example AES CBC calculations.
	  </t>
	  <t>
	    Made several local editorial changes to clean up loose ends
	    left over from to the decision to only support
	    block encryption methods providing integrity.
	    One of these changes was to explicitly state that the
	    <spanx style="verb">enc</spanx> (encryption method) algorithm
	    must be an Authenticated Encryption algorithm with a specified key length.
	  </t>
	</list>
      </t>
      <t>
	-06
	<list style='symbols'>
	  <t>
	    Removed the <spanx style="verb">int</spanx> and
	    <spanx style="verb">kdf</spanx> parameters and defined the new composite
	    Authenticated Encryption algorithms <spanx style="verb">A128CBC+HS256</spanx> and
	    <spanx style="verb">A256CBC+HS512</spanx> to replace the former
	    uses of AES CBC, which required the use of separate integrity
	    and key derivation functions.
	  </t>
	  <t>
	    Included additional values in the Concat KDF calculation -- the
	    desired output size and the algorithm value,
	    and optionally PartyUInfo and PartyVInfo values.
	    Added the optional header parameters
	    <spanx style="verb">apu</spanx> (agreement PartyUInfo),
	    <spanx style="verb">apv</spanx> (agreement PartyVInfo),
	    <spanx style="verb">epu</spanx> (encryption PartyUInfo), and
	    <spanx style="verb">epv</spanx> (encryption PartyVInfo).
	    Updated the KDF examples accordingly.
	  </t>
	  <t>
	    Promoted Initialization Vector from being a header parameter to being
	    a top-level JWE element.
	    This saves approximately 16 bytes in the compact serialization,
	    which is a significant savings for some use cases.
	    Promoting the Initialization Vector out of the header also avoids repeating
	    this shared value in the JSON serialization.
	  </t>
	  <t>
	    Changed <spanx style="verb">x5c</spanx> (X.509 Certificate Chain)
	    representation from being a single string to being an array of strings,
	    each containing a single base64 encoded DER certificate value,
	    representing elements of the certificate chain.
	  </t>
	  <t>
	    Added an AES Key Wrap example.
	  </t>
	  <t>
	    Reordered the encryption steps so CMK creation is first, when required.
	  </t>
	  <t>
	    Correct statements in examples about which algorithms produce
	    reproducible results.
	  </t>
	</list>
      </t>
      <t>
	-05
	<list style='symbols'>
	  <t>
	    Support both direct encryption using a
	    shared or agreed upon symmetric key, and the use of a
	    shared or agreed upon symmetric key to key wrap the CMK.
	  </t>
	  <t>
	    Added statement that
	    "StringOrURI values are compared as case-sensitive strings
	    with no transformations or canonicalizations applied".
	  </t>
	  <t>
	    Updated open issues.
	  </t>
	  <t>
	    Indented artwork elements to better distinguish them from the body text.
	  </t>
	</list>
      </t>
      <t>
	-04
	<list style='symbols'>
	  <t>
	    Refer to the registries as the primary sources of defined
	    values and then secondarily reference the sections
	    defining the initial contents of the registries.
	  </t>
	  <t>
	    Normatively reference
	    <xref target="W3C.CR-xmlenc-core1-20120313">XML Encryption 1.1</xref>
	    for its security considerations.
	  </t>
	  <t>
	    Reference draft-jones-jose-jwe-json-serialization
	    instead of draft-jones-json-web-encryption-json-serialization.
	  </t>
	  <t>
	    Described additional open issues.
	  </t>
	  <t>
	    Applied editorial suggestions.
	  </t>
	</list>
      </t>
      <t>
        -03
        <list style='symbols'>
	  <t>
	    Added the <spanx style="verb">kdf</spanx> (key derivation function) header parameter
	    to provide crypto agility for key derivation.
	    The default KDF remains the Concat KDF with the SHA-256 digest function.
	  </t>
	  <t>
	    Reordered encryption steps so that the Encoded JWE Header
	    is always created before it is needed as an input to the Authenticated Encryption
	    "additional authenticated data" parameter.
	  </t>
	  <t>
	    Added the <spanx style="verb">cty</spanx> (content type) header parameter
	    for declaring type information about the secured content,
	    as opposed to the <spanx style="verb">typ</spanx> (type) header parameter,
	    which declares type information about this object.
	  </t>
	  <t>
	    Moved description of how to determine whether a header is
	    for a JWS or a JWE from the JWT spec to the JWE spec.
	  </t>
	  <t>
	    Added complete encryption examples for both Authenticated Encryption and non-Authenticated Encryption algorithms.
	  </t>
	  <t>
	    Added complete key derivation examples.
	  </t>
	  <t>
	    Added "Collision Resistant Namespace" to the terminology section.
	  </t>
	  <t>
	    Reference ITU.X690.1994 for DER encoding.
	  </t>
	  <t>
	    Added Registry Contents sections to populate registry values.
	  </t>
	  <t>
	    Numerous editorial improvements.
	  </t>
        </list>
      </t>
      <t>
        -02
        <list style='symbols'>
	  <t>
	    When using Authenticated Encryption algorithms (such as AES GCM),
	    use the "additional authenticated data" parameter
	    to provide integrity for the header, encrypted key, and
	    ciphertext and use the resulting "authentication tag"
	    value as the JWE Authentication Tag.
	  </t>
	  <t>
	    Defined KDF output key sizes.
	  </t>
	  <t>
	    Generalized text to allow key agreement to be employed
	    as an alternative to key wrapping or key encryption.
	  </t>
	  <t>
	    Changed compression algorithm from gzip to DEFLATE.
	  </t>
	  <t>
	    Clarified that it is an error when a <spanx style="verb">kid</spanx>
	    value is included and no matching key is found.
	  </t>
	  <t>
	    Clarified that JWEs with duplicate Header Parameter Names
	    MUST be rejected.
	  </t>
	  <t>
	    Clarified the relationship between
	    <spanx style="verb">typ</spanx> header parameter values
	    and MIME types.
	  </t>
	  <t>
	    Registered application/jwe MIME type and "JWE" typ header parameter value.
	  </t>
	  <t>
	    Simplified JWK terminology to get replace the "JWK Key Object" and
	    "JWK Container Object" terms with simply "JSON Web Key (JWK)"
	    and "JSON Web Key Set (JWK Set)" and to eliminate potential
	    confusion between single keys and sets of keys.
	    As part of this change, the Header Parameter Name for a
	    public key value was changed from
	    <spanx style="verb">jpk</spanx> (JSON Public Key) to
	    <spanx style="verb">jwk</spanx> (JSON Web Key).
	  </t>
	  <t>
	    Added suggestion on defining additional header parameters
	    such as <spanx style="verb">x5t#S256</spanx> in the future
	    for certificate thumbprints using hash algorithms other
	    than SHA-1.
	  </t>
	  <t>
	    Specify RFC 2818 server identity validation, rather than
	    RFC 6125 (paralleling the same decision in the OAuth specs).
	  </t>
	  <t>
	    Generalized language to refer to Message Authentication Codes (MACs)
	    rather than Hash-based Message Authentication Codes (HMACs)
	    unless in a context specific to HMAC algorithms.
	  </t>
          <t>
            Reformatted to give each header parameter its own section heading.
          </t>
        </list>
      </t>
      <t>
        -01
        <list style='symbols'>
          <t>
           Added an integrity check for non-Authenticated Encryption algorithms.
          </t>
	  <t>
	    Added <spanx style="verb">jpk</spanx> and <spanx
	    style="verb">x5c</spanx> header parameters for including
	    JWK public keys and X.509 certificate chains directly in
	    the header.
	  </t>
	  <t>
	    Clarified that this specification is defining the JWE
	    Compact Serialization.  Referenced the new JWE-JS spec,
	    which defines the JWE JSON Serialization.
	  </t>
	  <t>
	    Added text "New header parameters should be introduced
	    sparingly since an implementation that does not understand
	    a parameter MUST reject the JWE".
	  </t>
	  <t>
	    Clarified that the order of the encryption and decryption
	    steps is not significant in cases where there are no
	    dependencies between the inputs and outputs of the steps.
	  </t>
	  <t>
	    Made other editorial improvements suggested by JOSE
	    working group participants.
	  </t>
        </list>
      </t>
      <t>
        -00
        <list style='symbols'>
          <t>
            Created the initial IETF draft based upon
            draft-jones-json-web-encryption-02 with no normative
            changes.
          </t>
	  <t>
	    Changed terminology to no longer call both digital
	    signatures and HMACs "signatures".
	  </t>
        </list>
      </t>
    </section>     

  </back>
</rfc>
