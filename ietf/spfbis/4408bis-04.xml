<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="http://xml.resource.org/authoring/rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY rfc1034 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1034.xml">
  <!ENTITY rfc1035 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1035.xml">
  <!ENTITY rfc1123 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1123.xml">
  <!ENTITY rfc2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
  <!ENTITY rfc2782 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2782.xml">
  <!ENTITY rfc1983 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1983.xml">
  <!ENTITY rfc2308 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2308.xml">
  <!ENTITY rfc3463 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3463.xml">
  <!ENTITY rfc3464 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3464.xml">
  <!ENTITY rfc3696 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3696.xml">
  <!ENTITY rfc3833 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3833.xml">
  <!ENTITY rfc3834 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3834.xml">
  <!ENTITY rfc3864 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3864.xml">
  <!ENTITY rfc3986 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
  <!ENTITY rfc3978 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3833.xml">
  <!ENTITY rfc4291 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4291.xml">
  <!ENTITY rfc4408 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4408.xml">
  <!ENTITY rfc4632 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4632.xml">
  <!ENTITY rfc4880 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4880.xml">
  <!ENTITY rfc4954 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4954.xml">
  <!ENTITY rfc5317 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5317.xml">
  <!ENTITY rfc5321 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5321.xml">
  <!ENTITY rfc5322 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5322.xml">
  <!ENTITY rfc5234 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml">
  <!ENTITY rfc5451 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5451.xml">
  <!ENTITY rfc5598 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5598.xml">
  <!ENTITY rfc5617 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5617.xml">
  <!ENTITY rfc5751 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5751.xml">
  <!ENTITY rfc5782 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5782.xml">
  <!ENTITY rfc5890 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5890.xml">
  <!ENTITY rfc6409 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6409.xml">
  <!ENTITY rfc6647 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6647.xml">
  <!ENTITY rfc6652 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6652.xml">
  <!ENTITY rfc6686 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6686.xml">
]>

<rfc category="std" ipr="pre5378Trust200902" docName="draft-ietf-spfbis-4408bis-04.txt" obsoletes="4408">
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc strict="yes" ?>
<?rfc compact="yes"?>
  <front>
    <title abbrev="Sender Policy Framework (SPF)">
      Sender Policy Framework (SPF) for
      Authorizing Use of Domains in Email, Version 1
    </title>
    <author fullname="Scott Kitterman" initials="S." surname="Kitterman">
      <organization>Kitterman Technical Services</organization>
      <address>
        <postal>
          <street>3611 Scheel Dr</street>
          <city>Ellicott City</city>
          <region>MD</region>
          <code>21042</code>
          <country>United States of America</country>
        </postal>
        <email>scott@kitterman.com</email>
      </address>
    </author>
    <date year="2012"/>
    <workgroup>Network Working Group</workgroup>
    <abstract>
      <t>
        Email on the Internet can be forged in a number of ways.  In
        particular, existing protocols place no restriction on what a sending
        host can use as the author's address of a message or the domain given on
        the SMTP HELO/EHLO commands.  This document describes version 1 of
        the Sender Policy Framework (SPF) protocol, whereby a domain can
        explicitly authorize the hosts that are allowed to use its domain
        name, and a receiving host can check such authorization.
      </t>
      <t>This document obsoletes RFC4408.
      </t>
    </abstract>
  </front>
  <?rfc compact="no"?>
  <middle>
    <section anchor="intro" title="Introduction">
      <t>
        The current email infrastructure has the property that any host
        injecting mail into the system can use any DNS domain name it wants in
        each of the various identifiers specified by <xref target="RFC5321"/>
        and <xref target="RFC5322"/>, plus the "reverse pointer" which is the
        purported hostname of the SMTP client as far as the DNS is concerned
        <xref target="RFC1035"/>.  Although this feature is desirable in
        some circumstances, it is a major obstacle to reducing Unsolicited Bulk
        email (UBE, aka spam).  Furthermore, many domain owning ADMDs
        (ADministrative Management Domains, see <xref target="RFC5598"/>) are
        understandably concerned about the ease with which other entities can
        make use of their domain names, often with malicious intent.
      </t>
      <t>
        This document defines a protocol by which ADMDs can authorize hosts to
        use their domain names in the RFC5321.MailFrom or RFC5321.HELO/.EHLO
        identities.  Compliant ADMDs publish Sender Policy Framework (SPF)
        records in DNS specifying which hosts are permitted to use their names,
        and compliant mail receivers use the published SPF records to test the
        authorization of sending Mail Transfer Agents (MTAs) using a given
        RFC5321.HELO/.EHLO or RFC5321.MailFrom identity during a mail
        transaction.
      </t>
      <t>
        An additional benefit to mail receivers is that after the use of an
        identity is verified, local policy decisions about the mail can be
        made based on the sender's domain, rather than the host's IP address.
        This is advantageous because reputation of domain names is likely to
        be more accurate than reputation of host IP addresses.  Furthermore,
        if a claimed identity fails verification, local policy can take
        stronger action against such email, such as rejecting it.
      </t>
      <section title="Protocol Status">
        <t>
          SPF has been in development since the summer of 2003 and has seen
          deployment beyond the developers beginning in December 2003.  The
          design of SPF slowly evolved until the spring of 2004 and has since
          stabilized. There have been quite a number of forms of SPF, some
          written up as documents, some submitted as Internet Drafts, and
          many discussed and debated in development forums.  The protocol was
          originally defined in <xref target="RFC4408"/>, which this document
          replaces.
        </t>
        <t>
          The goal of this work is to clearly document the protocol
          defined by earlier draft specifications of SPF as used in existing
          implementations.  This conception of SPF is sometimes called "SPF
          Classic".  It is understood that particular implementations and
          deployments will differ from, and build upon, this work.  It is
          hoped that we have nonetheless captured the common understanding of
          SPF version 1.
        </t>
      </section>
      <section title="Experimental History">
      <t>
        This document updates and replaces RFC 4408 that was part of a group of
        simultaneously published Experimental RFCs (RFC 4405, RFC 4406, RFC 4407,
        and RFC 4408) in 2006.  At that time the IESG requested the community
        observe the success or failure of the two approaches documented in these
        RFCs during the two years following publication, in order that a
        community consensus could be reached in the future.
      </t>
      <t>
        SPF is widely deployed by large and small email providers alike.  There
        are multiple, interoperable implementations.
      </t>
      <t>
        For SPF (as documented in RFC 4408) a careful effort was made to collect
        and document lessons learned and errata during the two year period.  The
        errata list has been stable (no new submissions) and only minor protocol
        lessons learned were identified.  Resolution of the IESG's experiment
        is documented in  <xref target="RFC6686"/>.
      </t>
      </section>
      <section title="Terminology">
          <section anchor="keywords" title="Keywords">
            <t>
              The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
              "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
              "OPTIONAL" in this document are to be interpreted as described in
              <xref target="RFC2119"/>.
            </t>
          </section>
          <section anchor="imports" title="Imported Definitions">
             <t>
               The ABNF tokens "ALPHA", "DIGIT", and "SP" are defined in
               <xref target="RFC5234"/>.
             </t>
             <t> 
               The token "local-part" is defined in <xref target="RFC5321"/>.
             </t>
             <t>
               "dot-atom", "quoted-string", "comment", "CFWS", "FWS", and
               "CRLF" are defined in <xref target="RFC5322"/>.
             </t>   
          </section>
          <section anchor="mfrom-def" title="Mail From Definition">
            <t>
              This document is concerned with the portion of a mail message
              commonly called "envelope sender", "return path", "reverse path",
              "bounce address", "5321 FROM", or "MAIL FROM".  Since these terms
              are either not well defined or often used casually, this document
              uses RFC5321.MailFrom as defined in <xref target="RFC5598"/>.
              Note that other terms that might superficially look like the common
              terms, such as "reverse-path", are used only with the defined
              meanings from normative documents.
            </t>
          </section>
          <section title="HELO Definition" anchor="helo-def">
            <t>
              This document also makes use of the HELO/EHLO identity.  The
              "HELO" identity derives from either the SMTP HELO or EHLO
              command (see <xref target="RFC5321"/>).  Since HELO and EHLO can,
              in many cases, be used interchangeably, they are identified as
              RFC5321.HELO/.EHLO in <xref target="RFC5598"/>.  These commands
              supply the identity of the SMTP client (sending host) for the SMTP
              session.
            </t>
          </section>
          <section anchor="deprecate" title="Deprecated">
            <t>
              There are <xref target="RFC4408"/> features that are marked
              "deprecated".  In the context of this document, deprecated means
              that senders SHOULD NOT publish SPF records that make use of such
              features because they might be removed entirely in future updates
              to the protocol.  Such features do, however, remain part of the
              SPF protocol and receiving systems MUST support them unless this
              document explicitly says otherwise.
            </t>
          </section>
      </section>
    </section>
    <section title="Operation">
      <section title="The RFC5321.HELO/.EHLO Identity" anchor="helo-ident">
        <t>
          It is RECOMMENDED that SPF clients not only check the RFC5321.MailFrom
          identity, but also separately check the RFC5321.HELO/.EHLO identity by
          applying the check_host() function (<xref target="function"/>) to the
          RFC5321.HELO/.EHLO identity as the &lt;sender&gt;.  Checking
          RFC5321.HELO/.EHLO promotes consistency of results and can reduce DNS
          resource usage.  Additionally, since SPF records published for
          RFC5321.HELO/.EHLO identities refer to a single host, when available,
          they are a very reliable source of host authorization status.
        </t>
        <t>
          Note that requirements for the domain presented in the EHLO or HELO
          command are not always clear to the sending party, and SPF clients
          MUST be prepared for the RFC5321.HELO/.EHLO identity to be malformed
          or an IP address literal.
        </t>
      </section>
      <section title="The RFC5321.MailFrom Identity" anchor="mfrom-ident">
        <t>
          <xref target="RFC5321"/> allows the reverse-path to be null (see
          Section 4.5.5 in <xref target="RFC5321"/>).  In this case, there is no
          explicit sender mailbox, and such a message can be assumed to be a
          notification message from the mail system itself.  When the
          reverse-path is null, this document defines the RFC5321.MailFrom
          identity to be the mailbox composed of the local-part "postmaster"
          and the RFC5321.HELO/.EHLO identity (which might or might not have been
          checked separately before).
        </t>
        <t>
          SPF clients MUST check the "RFC5321.MailFrom identity if a completed
          RFC5321.HELO/.EHLO check has not reached a definitive policy result by
          applying the check_host() function to the RFC5321.MailFrom identity as
          the &lt;sender&gt;.
        </t>
      </section>
      <section title="Publishing Authorization">
        <t>
          An SPF-compliant domain MUST publish a valid SPF record as
          described in <xref target="records"/>.  This record authorizes the
          use of the domain name in the RFC5321.HELO/.EHLO and RFC5321.MailFrom
          identities by the MTAs it specifies.
        </t>
        <t>
          SPF results can be used to make both positive (source is authorized)
          and negative (source is not authorized) determinations.  If domain
          owners choose to publish SPF records and want to support receivers
          making negative authorization determinations, then they MUST publish
          records that end in "-all", or redirect to other records that do,
          otherwise, no definitive determination of authorization can be made.
          Potential issues and mitigations associated with negative
          determinations are discussed in <xref target="implications"/>.
        </t>
        <t>
          Domain holders can publish SPF records that explicitly authorize no
          hosts if mail is not expected to originate using that domain.
        </t>
        <t>
          When changing SPF records, care must be taken to ensure that there
          is a transition period so that the old policy remains valid until
          all legitimate email can reasonably expect to have been checked.  This
          can be as much as 30 days.
        </t>
      </section>
      <section title="Checking Authorization">
        <t>
          A mail receiver can perform a set of SPF checks for each mail
          message it receives.  An SPF check tests the authorization of a
          client host to emit mail with a given identity.  Typically, such
          checks are done by a receiving MTA, but can be performed elsewhere
          in the mail processing chain so long as the required information is
          available and reliable.  At least the RFC5321.MailFrom identity MUST be
          checked, but it is RECOMMENDED that the RFC5321.HELO/.EHLO identity
          also be checked beforehand. 
        </t>
        <t>
          Without explicit approval of the domain owner, checking other
          identities against SPF version 1 records is NOT RECOMMENDED because
          there are cases that are known to give incorrect results.  For
          example, almost all mailing lists rewrite the RFC5321.MailFrom identity
          (see <xref target="mailing-lists"/>), but some do not change any
          other identities in the message.  The scenario described in <xref
          target="forwarding"/>, sub-section 1.2, is another example.
          Documents that define other identities will have to define the method
          for explicit approval.
        </t>
        <t>
          It is possible that mail receivers will use the SPF check as part
          of a larger set of tests on incoming mail.  The results of other
          tests might influence whether or not a particular SPF check is
          performed.  For example, finding the sending host's IP address on a
          local white list might cause all other tests to be skipped and all
          mail from that host to be accepted.
        </t>
        <t>
          When a mail receiver decides to perform an SPF check, it MUST use a
          correctly-implemented check_host() function (<xref
          target="function"/>) evaluated with the correct parameters.
          Although the test as a whole is optional, once it has been decided
          to perform a test it must be performed as specified so that the
          correct semantics are preserved between publisher and receiver.
        </t>
        <t>
          To make the test, the mail receiver MUST evaluate the check_host()
          function with the arguments set as follows:
        </t>
        <t>
          <?rfc compact="no"?>
          <list style="hanging" hangIndent="9">
            <t hangText="&lt;ip&gt;">
              - the IP address of the SMTP client that is emitting the &nbsp;&nbsp;
              &nbsp; mail, either IPv4 or IPv6.
            </t>
            <t hangText="&lt;domain&gt;">
              - the domain portion of the RFC5321.MailFrom or RFC5321.HELO/.EHLO identity.
            </t>
            <t hangText="&lt;sender&gt;">
              - the RFC5321.MailFrom or RFC5321.HELO/.EHLO identity.
            </t>
          </list>
          <!-- <?rfc compact="yes"?> -->
        </t>
        <t>
          Note that the &lt;domain&gt; argument might not be a well-formed
          domain name.  For example, if the reverse-path was null, then the
          EHLO/HELO domain is used, with its associated problems (see <xref
          target="helo-ident"/>).  In these cases, check_host() is defined in
          <xref target="initial"/> to return a "none" result.
        </t>
        <t>
          Although invalid, malformed, or non-existent domains cause SPF
          checks to return "none" because no SPF record can be found, it has
          long been the policy of many MTAs to reject email from such
          domains, especially in the case of invalid RFC5321.MailFrom. Rejecting
          email will prevent one method of circumventing of SPF records.
        </t>
        <t>
          Implementations MUST take care to correctly extract the
          &lt;domain&gt; from the data given with the SMTP MAIL FROM command
          as many MTAs will still accept such things as source routes (see
          <xref target="RFC5321"/>, Appendix C), the %-hack (see <xref
          target="RFC1123"/>), and bang paths (see <xref target="RFC1983"/>).
          These archaic features have been maliciously used to bypass
          security systems.
        </t>
      </section>
      <section title="Interpreting the Result" anchor="op-result">
        <t>
          This section describes how software that performs the authorization
          should interpret the results of the check_host() function.  The
          authorization check SHOULD be performed during the processing of
          the SMTP transaction that sends the mail.  This allows errors to be
          returned directly to the sending MTA by way of SMTP replies.
        </t>
        <t>
          Performing the authorization other than using the return-path and
          client address at the time of the MAIL command during the SMTP
          transaction can cause problems, such as the following: (1) It might be
          difficult to accurately extract the required information from
          potentially deceptive headers; (2) legitimate email might fail because
          the sender's policy had since changed.
        </t>
        <t>
          Generating non-delivery notifications to forged identities that
          have failed the authorization check is a source of backscatter and
          SHOULD be avoided.  <xref target="RFC3834"/> section 2 describes
          backscatter and the problems it causes.
        </t>
        <section title="None" anchor="op-result-none">
          <t>
            A result of "none" means either (a) no syntactically valid DNS
            domain name was extracted from the SMTP session that could be used
            as the one to be authorized, or (b) no TXT records were retrieved
            from the DNS that appeared to be intended for use by SPF verifiers.
          </t>
        </section>
        <section title="Neutral" anchor="op-result-neutral">
          <t>
            The domain owner has explicitly stated that they cannot or do not
            want to assert whether the IP address is authorized or not.  A
            "neutral" result MUST be treated exactly like the "none" result;
            the distinction exists only for informational purposes.  Treating
            "neutral" more harshly than "none" would discourage domain owners
            from testing the use of SPF records (see <xref
            target="sending-impl"/>).
          </t>
        </section>
        <section title="Pass"  anchor="op-result-pass">
          <t>
            A "pass" result means that the client is authorized to inject
            mail with the given identity. The domain can now, in the sense of
            reputation, be considered responsible for sending the message.
            Further policy checks can now proceed with confidence in the
            legitimate use of the identity.
          </t>
        </section>
        <section title="Fail" anchor="op-result-fail">
          <t>
            A "fail" result is an explicit statement that the client is not
            authorized to use the domain in the given identity.  Disposition of
            SPF fail messages is a matter of local policy. See <xref
            target="receiver-policy"/> for considerations on developing local
            policy.
          </t>
          <t>
            If the checking software chooses to reject the mail during the
            SMTP transaction, then it SHOULD use an SMTP reply code of 550
            (see <xref target="RFC5321"/>) and, if supported, the 5.7.1
            enhanced status code (see <xref
            target="RFC3463"/>), in addition to an appropriate reply text.
            The check_host() function will return either a default explanation
            string or one from the domain that published the SPF records (see
            <xref target="mod-exp"/>).  If the information does not originate
            with the checking software, it should be made clear that the text
            is provided by the sender's domain.  For example:
          </t>
          <figure>
            <artwork>
    550-5.7.1 SPF MAIL FROM check failed: 
    550-5.7.1 The domain example.com explains:
    550 5.7.1 Please see http://www.example.com/mailpolicy.html
            </artwork>
          </figure>
        </section>
        <section title="Softfail" anchor="op-result-softfail">
          <t>
            A "softfail" result should be treated as somewhere between a
            "fail" and a "neutral".  The domain believes the host is not
            authorized but is not willing to make a strong policy statement.
            Receiving software SHOULD NOT reject the message based solely on
            this result, but MAY subject the message to closer scrutiny than
            normal.
          </t>
          <t>
            The domain owner wants to discourage the use of this host and
            thus desires limited feedback when a "softfail" result occurs.
            For example, the recipient's Mail User Agent (MUA) could
            highlight the "softfail" status, or the receiving MTA could give
            the sender a message using greylisting, <xref target="RFC6647"/>,
            with a note the first time the message is received, but accept it
            on a later attempt based on receiver policy.
          </t>
        </section>
        <section title="TempError" anchor="op-result-temperror">
          <t>
            A "temperror" result means the SPF client encountered a transient
            (DNS) error while performing the check.  Checking software can
            choose to accept or temporarily reject the message.  If the
            message is rejected during the SMTP transaction for this reason,
            the software SHOULD use an SMTP reply code of 451 and, if
            supported, the 4.4.3 enhanced status code.  These errors can be
            caused by DNS problems in either the sender's or receiver's DNS.
          </t>
        </section>
        <section title="PermError" anchor="op-result-permerror">
          <t>
            A "permerror" result means the domain's published records could not
            be correctly interpreted.  This signals an error condition that
            definitely requires manual intervention to be resolved.  If the
            message is rejected during the SMTP transaction for this reason, the
            software SHOULD use an SMTP reply code of 550 and, if supported, the
            5.5.2 enhanced status code.  Be aware that if the domain owner uses
            macros (<xref target="macros"/>), it is possible that this result
            is due to the checked identities having an unexpected format.
          </t>
        </section>
      </section>
    </section>
    <section title="SPF Records" anchor="records">
      <t>
        An SPF record is a DNS TXT (type 16) Resource Record (RR) that declares
        which hosts are, and are not, authorized to use a domain name for the
        RFC5321.HELO/.EHLO and RFC5321.MailFrom identities. Loosely, the record
        partitions all hosts into permitted and not-permitted sets (though some
        hosts might fall into neither category).
      </t>
      <t>
        The SPF record is a single string of text. An example record is the
        following:
      </t>
      <t>
        <list>
          <t>v=spf1 +mx a:colo.example.com/28 -all</t>
        </list>
      </t>
      <t>
        This record has a version of "spf1" and three directives: "+mx",
        "a:colo.example.com/28" (the + is implied), and "-all".
      </t>
        <t>
          Domain owners wishing to be SPF compliant MUST publish SPF records
          for the hosts that are used in the RFC5321.MailFrom and RFC5321.HELO/.EHLO
          identities.  The SPF records are placed in the DNS tree at the host
          name it pertains to, not a subdomain under it, such as is done with
          SRV records <xref target="RFC2782"/>.
        </t>
        <t>
          The example in <xref target="records"/> might be published via these
          lines in a domain zone file:
        </t>
        <figure>
          <artwork>
   example.com.          TXT "v=spf1 +mx a:colo.example.com/28 -all"
   smtp-out.example.com. TXT "v=spf1 a -all"
          </artwork>
        </figure>
        <t>
          Since TXT records have multiple uses, beware of other TXT records
          published there for other purposes.  They might cause problems with
          size limits (see <xref target="rsize"/>) and care MUST be taken to
          ensure only SPF records are used for SPF processing.
        </t>
        <t>
          Domains publishing records SHOULD try to keep the number of
          "include" mechanisms and chained "redirect" modifiers to a minimum.
          Domains SHOULD also try to minimize the amount of other DNS
          information needed to evaluate a record.
          <xref target="sending-resources"/>  provides some suggestions on how
          to achieve this.
        </t>
        <section title="DNS Resource Records" anchor="rr-types">
          <t>
            SPF records MUST be published as type TXT <xref target="RFC1035"/>.
            The character content of the record is encoded as
            <xref target="US-ASCII"/>.  Use of alternate DNS RR types was
            supported in SPF's experimental phase, but has been discontinued.
            See Appendix A of <xref target="RFC6686"/> for
            further information.
          </t>
        </section>
        <section title="Multiple DNS Records">
          <t>
            A domain name MUST NOT have multiple records that would cause an
            authorization check to select more than one record. See <xref
            target="version"/> for the selection rules.
          </t>
        </section>
        <section title="Multiple Strings in a Single DNS record">
          <t>
            As defined in <xref target="RFC1035"/> sections 3.3.14 and 3.3, a
            single text DNS record (either TXT or SPF RR types) can be
            composed of more than one string. If a published record contains
            multiple character-strings, then the record MUST be treated as if
            those strings are concatenated together without adding spaces. For
            example:
          </t>
          <t>
            <list style="empty">
              <t>IN TXT "v=spf1 .... first" "second string..."</t>
            </list>
          </t>
          <t>MUST be treated as equivalent to</t>
          <t>
            <list style="empty">
              <t>IN TXT "v=spf1 .... firstsecond string..."</t>
            </list>
          </t>
          <t>
            TXT records containing multiple strings are useful in
            constructing records that would exceed the 255-byte maximum
            length of a character-string within a single TXT record.
          </t>
        </section>
        <section title="Record Size" anchor="rsize">
          <t>
            The published SPF record for a given domain name SHOULD remain
            small enough that the results of a query for it will fit within
            512 octets.  This UDP limit is defined in <xref target="RFC1035"/>
            section 2.3.4.  This will keep even older DNS implementations from
            falling over to TCP.  Since the answer size is dependent on many
            things outside the scope of this document, it is only possible to
            give this guideline: If the combined length of the DNS name and
            the text of all the records of a given type is under 450 characters,
            then DNS answers ought to fit in UDP packets.  Note that when
            computing the sizes for queries of the TXT format, one must take
            into account any other TXT records published at the domain name.
            Records that are too long to fit in a single UDP packet could be
            silently ignored by SPF clients due to firewall and other issues
            that cause DNS over TCP to be less reliable than DNS over UDP.
          </t>
        </section>
        <section title="Wildcard Records">
          <t>
            Use of wildcard records for publishing is NOT RECOMMENDED. Care
            must be taken if wildcard records are used. If a domain publishes
            wildcard MX records, it might want to publish wildcard
            declarations, subject to the same requirements and problems. In
            particular, the declaration MUST be repeated for any host that
            has any RR records at all, and for subdomains thereof. For
            example, the example given in <xref target="RFC1034"/>, Section
            4.3.3, could be extended with the following:
          </t>
          <figure>
            <artwork>
    X.COM.          MX      10      A.X.COM
    X.COM.          TXT     "v=spf1 a:A.X.COM -all"
    
    *.X.COM.        MX      10      A.X.COM
    *.X.COM.        TXT     "v=spf1 a:A.X.COM -all"
                    
    A.X.COM.        A       1.2.3.4
    A.X.COM.        MX      10      A.X.COM
    A.X.COM.        TXT     "v=spf1 a:A.X.COM -all"
                    
    *.A.X.COM.      MX      10      A.X.COM
    *.A.X.COM.      TXT     "v=spf1 a:A.X.COM -all"
            </artwork>
          </figure>
          <t>
            Notice that SPF records MUST be repeated twice for every name
            within the domain: once for the name, and once with a wildcard to
            cover the tree under the name.
          </t>
          <t>
            Use of wildcards is discouraged in general as they cause every
            name under the domain to exist and queries against arbitrary
            names will never return RCODE 3 (Name Error) and will interfere with
            existence tests such as the one described in <xref
            target="RFC5617"/>. 
          </t>
        </section>
    </section>
    <section title="The check_host() Function" anchor="function">
      <t>
        This description is not an API (Application Program Interface)
        definition, but rather a function description used to illustrate the
        algorithm.  A compliant SPF implementation MUST do something
        semantically equivalent to this description.
      </t>
      <t>
        The check_host() function fetches SPF records, parses them, and
        evaluates them to determine whether a particular host is or is not
        permitted to send mail with a given identity. Mail receivers that
        perform this check MUST correctly evaluate the check_host() function
        as described here.
      </t>
      <t>
        Implementations MAY use a different algorithm than the canonical
        algorithm defined here, so long as the results are the same in all
        cases.
      </t>
      <section title="Arguments">
        <t>The check_host() function takes these arguments:</t>
        <t>
          <?rfc compact="no"?>
          <list style="hanging" hangIndent="9">
            <t hangText="&lt;ip&gt;">
              - the IP address of the SMTP client that is emitting the &nbsp;&nbsp;
              &nbsp; mail, either IPv4 or IPv6.
            </t>
            <t hangText="&lt;domain&gt;">
              - the domain that provides the sought-after authorization &nbsp;
              &nbsp; information; initially, the domain portion of the "MAIL &nbsp;
              &nbsp; FROM" or RFC5321.HELO/.EHLO identity.
            </t>
            <t hangText="&lt;sender&gt;">
              - the RFC5321.MailFrom or RFC5321.HELO/.EHLO identity.
            </t>
          </list>
          <!-- <?rfc compact="yes"?> -->
        </t>
        <t>
          The domain portion of &lt;sender&gt; will usually be the same as
          the &lt;domain&gt; argument when check_host() is initially
          evaluated. However, this will generally not be true for recursive
          evaluations (see <xref target="mech-include"/> below).
        </t>
        <t>
          Actual implementations of the check_host() function might need
          additional arguments.
        </t>
      </section>
      <section title="Results">
        <t>
          The function check_host() can return one of several results
          described in <xref target="op-result"/>. Based on the result, the
          action to be taken is determined by the local policies of the
          receiver.
        </t>
      </section>
      <section title="Initial Processing" anchor="initial">
        <t>
          If the &lt;domain&gt; is malformed (e.g. label longer than 63
          characters, zero-length label not at the end, etc.) or is not a
          fully qualified domain name, or if the DNS lookup returns "domain
          does not exist" (RCODE 3), check_host() immediately returns the
          result "none".  Properly formed domains are fully qualified email
          domains as described in <xref target="RFC5321"/> Section 2.3.5.
          Internationalized domain names MUST be encoded as A-labels, as
          described in Section 2.3 of <xref target="RFC5890"/>.
        </t>
        <t>
          If the &lt;sender&gt; has no local-part, substitute the string
          "postmaster" for the local-part. 
        </t>
      </section>
      <section title="Record Lookup">
        <t>
          In accordance with how the records are published (see <xref
          target="records"/> above), a DNS query needs to be made for the
          &lt;domain&gt; name, querying for type TXT only.
        </t>
        <t>
          If all DNS lookups that are made return a server failure (RCODE 2),
          or other error (RCODE other than 0 or 3), or time out, then
          check_host() terminates immediately with the result "temperror".
          Alternatively, for a server failure (RCODE 2) result, check_host() MAY
          track failures and treat multiple failures within 24 hours for the
          same domain as "permerror".
        </t>
        <t>
          This alternative is intended to shorten the queue time of messages
          that cannot be accepted, by returning a permanent negative
          completion reply code to the client, instead of a transient one.
          <xref target="RFC2308"/> suggests on an algorithm for doing such
          tracking and handling of server failure codes.
        </t>
      </section>
      <section title="Selecting Records" anchor="version">
        <t>Records begin with a version section:</t>
        <figure>
          <artwork type="abnf"><![CDATA[
record           = version terms *SP
version          = "v=spf1"
]]></artwork>
        </figure>
        <t>
          Starting with the set of records that were returned by the lookup,
          discard records that do not begin with a version section of exactly
          "v=spf1".  Note that the version section is terminated either by an
          SP character or the end of the record.  A record with a version
          section of "v=spf10" does not match and must be discarded.
        </t>
        <t>
          If the resultant record set includes no records, check_host() produces
          the "none" result.  If the resultant record set includes more than one
          record, check_host() produces the "permerror" result.
        </t>
      </section>
      <section title="Record Evaluation">
        <t>
          After one SPF record has been selected, the check_host() function
          parses and interprets it to find a result for the current test. If
          there are any syntax errors, check_host() returns immediately with
          the result "permerror".
        </t>
        <t>
          Implementations MAY choose to parse the entire record first and
          return "permerror" if the record is not syntactically well formed.
          However, in all cases, any syntax errors anywhere in the record
          MUST be detected.
        </t>
        <section title="Term Evaluation">
          <t>
            There are two types of terms: mechanisms and modifiers.  A record
            contains an ordered list of these as specified in the following
            Augmented Backus-Naur Form (ABNF).
          </t>
          <figure>
            <artwork type="abnf"><![CDATA[
terms            = *( 1*SP ( directive / modifier ) )

directive        = [ qualifier ] mechanism
qualifier        = "+" / "-" / "?" / "~"
mechanism        = ( all / include
                   / A / MX / PTR / IP4 / IP6 / exists )
modifier         = redirect / explanation / unknown-modifier
unknown-modifier = name "=" macro-string
                   ; where name is not any known modifier

name             = ALPHA *( ALPHA / DIGIT / "-" / "_" / "." )
]]></artwork>
          </figure>
          <t>
            Most mechanisms allow a ":" or "/" character after the name.
          </t>
          <t>
            Modifiers always contain an equals ('=') character immediately
            after the name, and before any ":" or "/" characters that might be
            part of the macro-string.
          </t>
          <t>
            Terms that do not contain any of "=", ":", or "/" are mechanisms,
            as defined in <xref target="mechanisms"/>.
          </t> 
          <t>
            As per the definition of the ABNF notation in <xref
            target="RFC5234"/>, mechanism and modifier names are
            case-insensitive.
          </t>
        </section>
        <section title="Mechanisms">
          <t>
            Each mechanism is considered in turn from left to right. If there
            are no more mechanisms, the result is specified in <xref
            target="default"/>.
          </t>
          <t>
            When a mechanism is evaluated, one of three things can happen: it
            can match, not match, or throw an exception. 
          </t>
          <t>
            If it matches, processing ends and the qualifier value is
            returned as the result of that record.  If it does not match,
            processing continues with the next mechanism.  If it throws an
            exception, mechanism processing ends and the exception value is
            returned.
          </t>
          <t>
            The possible qualifiers, and the results they cause check_host() to
            return are as follows:
          </t>
          <figure>
            <artwork>
   "+" pass
   "-" fail
   "~" softfail
   "?" neutral
            </artwork>
          </figure>
          <t>The qualifier is optional and defaults to "+".</t>
          <t>
            When a mechanism matches and the qualifier is "-", then a "fail"
            result is returned and the explanation string is computed as
            described in <xref target="mod-exp"/>.
          </t>
          <t>
            The specific mechanisms are described in <xref
            target="mechanisms"/>.
           </t>
        </section>
        <section title="Modifiers">
          <t>
            Modifiers are not mechanisms.  They do not return match or
            not-match.  Instead, they provide additional information.
            Although modifiers do not directly affect the evaluation of the
            record, the "redirect" modifier has an effect after all the
            mechanisms have been evaluated.
          </t>
        </section>
        <section title="DNS Lookup Limits" anchor="eval-limits">
          <t>
            SPF implementations MUST limit the number of mechanisms and
            modifiers ("terms") that DNS lookups to at most 10 during SPF
            evaluation.  Specifically, the "include", "a", "mx",
            "ptr", and "exists" mechanisms as well as the "redirect" modifier
            count against this limit.  The "all", "ip4", and "ip6" mechanisms
            do not count against this limit.  If this number is exceeded
            during a check, a permerror MUST be returned.  The "exp" modifier
            does not count against this limit because the DNS lookup to fetch
            the explanation string occurs after the SPF record evaluation
            has been completed.
          </t>
          <t>
            When evaluating the "mx" and "ptr" mechanisms, or the %{p} macro,
            there MUST be a limit of no more than 10 MX or PTR RRs looked up
            and checked.  If more than 10 "mx" or "ptr" records are returned for
            this further lookup, a permerror MUST be returned.  This limit is
            per mechanism or macro in the record and in addition to the lookup
            limits above.
          </t>
        </section>
      </section>
      <section title="Default Result" anchor="default">
        <t>
          If none of the mechanisms match and there is no "redirect"
          modifier, then the check_host() returns a result of "neutral", just
          as if "?all" were specified as the last directive.  If there is a
          "redirect" modifier, check_host() proceeds as defined in <xref
          target="mod-redirect"/>.
        </t>
        <t>
          Note that records SHOULD always use either a "redirect" modifier or
          an "all" mechanism to explicitly terminate processing.  Although the
          latter has default (specifically "?all"), it aids debugging efforts if
          it is explicitly included.
        </t>
        <t>For example:</t>
        <t>
          <?rfc compact="yes"?>
          <list style="empty">
            <t>v=spf1 +mx -all</t>
          </list>
          or
          <list style="empty">
            <t>v=spf1 +mx redirect=_spf.example.com</t>
          </list>
          <?rfc compact="no"?>
        </t>
      </section>
      <section title="Domain Specification">
        <t>
          Several of these mechanisms and modifiers have a domain-spec section.
          The domain-spec string is subject to macro expansion (see <xref
          target="macros"/>). The resulting string is the common presentation
          form of a fully-qualified DNS name: a series of labels separated by
          periods. This domain is called the &lt;target-name&gt; in the rest of
          this document.
        </t>
        <t>
          Note: The result of the macro expansion is not subject to any
          further escaping. Hence, this facility cannot produce all
          characters that are legal in a DNS label (e.g., the control
          characters).  However, this facility is powerful enough to express
          legal host names and common utility labels (such as "_spf") that
          are used in DNS.
        </t>
        <t>
          For several mechanisms, the &lt;domain-spec&gt; is optional. If it
          is not provided, the &lt;domain&gt; is used as the
          &lt;target-name&gt;.  Domain and domain-spec are syntactically
          identical after macro expansion.  Domain is an input value for
          check_host() while domain-spec is computed by check_host().
        </t>
      </section>
    </section>
    <section title="Mechanism Definitions" anchor="mechanisms">
      <t>This section defines two types of mechanisms.</t>
      <t>
        Basic mechanisms contribute to the language framework. They do not
        specify a particular type of authorization scheme.
      </t>
      <figure>
        <artwork>
   all
   include
        </artwork>
      </figure>
      <t>
        Designated sender mechanisms are used to designate a set of
        &lt;ip&gt; addresses as being permitted or not permitted to use the
        &lt;domain&gt; for sending mail. 
      </t>
      <figure>
        <artwork>
   a
   mx
   ptr (deprecated)
   ip4
   ip6
   exists
        </artwork>
      </figure>
      <t>
        The following conventions apply to all mechanisms that perform a
        comparison between &lt;ip&gt; and an IP address at any point: 
      </t>
      <t>
        If no CIDR prefix length is given in the directive, then &lt;ip&gt; and
        the IP address are compared for equality.  (Here, CIDR is Classless
        Inter-Domain Routing, described in <xref target="RFC4632"/>.)
      </t>
      <t>
        If a CIDR prefix length is specified, then only the specified number of
        high-order bits of &lt;ip&gt; and the IP address are compared for
        equality. 
      </t>
      <t>
        When any mechanism fetches host addresses to compare with &lt;ip&gt;,
        when &lt;ip&gt; is an IPv4 address, A records are fetched; when
        &lt;ip&gt; is an IPv6 address, AAAA records are fetched.  Even if the
        SMTP connection uses IPv6, an IPv4-mapped IPv6 IP address (see
        <xref target="RFC4291"/>, Section 2.5.5) MUST still be considered an
        IPv4 address and MUST be evaluated using IPv4 mechanisms (i.e. "ip4"
        and "a").
      </t>
      <t>
        Several mechanisms rely on information fetched from the DNS.  For these
        DNS queries, except where noted, if the DNS server returns an error
        (RCODE other than 0 or 3) or the query times out, the mechanism
        throws the exception "temperror".  If the server returns "domain does
        not exist" (RCODE 3), then evaluation of the mechanism continues as
        if the server returned no error (RCODE 0) and zero answer records.
      </t>
      <section title="&quot;all&quot;" anchor="mech-all">
        <figure>
          <artwork type="abnf"><![CDATA[
all              = "all"
]]></artwork>
        </figure>
        <t>
          The "all" mechanism is a test that always matches. It is used as
          the rightmost mechanism in a record to provide an explicit default. 
        </t>
        <t>
          For example:
          <?rfc compact="no"?>
          <list style="empty">
            <t>v=spf1 a mx -all</t>
          </list>
          <!-- <?rfc compact="yes"?> -->
        </t>
        <t>
          Mechanisms after "all" will never be tested.  Mechanisms listed after
          "all" MUST be ignored. Any "redirect" modifier (<xref
          target="mod-redirect"/>) has MUST be ignored when there is an "all"
          mechanism in the record.
        </t>
      </section>
      <section title="&quot;include&quot;" anchor="mech-include">
        <figure>
          <artwork type="abnf"><![CDATA[
include          = "include"  ":" domain-spec
]]></artwork>
        </figure>
        <t>
          The "include" mechanism triggers a recursive evaluation of
          check_host().
              <list style="numbers">
                  <t>
                    The domain-spec is expanded as per <xref target="macros"/>.
                  </t>
                  <t>
                    Check_host() is evaluated with the resulting string as the
                    &lt;domain&gt;. The &lt;ip&gt; and &lt;sender&gt; arguments
                    remain the same as in the current evaluation of
                    check_host().
                  </t>
                  <t>
                    The recursive evaluation returns either match, not match,
                    or an error.  If it matches, then the appropriate result for
                    the include: mechanism is used (e.g. include or +include
                    gives a "pass" result and -include gives "fail).
                  </t>
                  <t>
                    If there is no match, the parent check_host() resumes
                    processing as per the table below, with the previous value
                    of &lt;domain&gt; restored.
                  </t>
              </list>
        </t>
        <t>
          In hindsight, the name "include" was poorly chosen.  Only the
          evaluated result of the referenced SPF record is used, rather than
          acting as if the referenced SPF record was literally included in
          the first.  For example, evaluating a "-all" directive in the
          referenced record does not terminate the overall processing and
          does not necessarily result in an overall "fail".  (Better names
          for this mechanism would have been "if-match", "on-match", etc.)
        </t>
        <t>
          The "include" mechanism makes it possible for one domain to
          designate multiple administratively-independent domains.  For
          example, a vanity domain "example.net" might send mail using the
          servers of administratively-independent domains example.com and
          example.org.
        </t>
        <t>Example.net could say</t>
        <t>
          <list style="empty">
            <t>IN TXT "v=spf1 include:example.com include:example.org -all"</t>
          </list>
        </t>
        <t>
          This would direct check_host() to, in effect, check the records of
          example.com and example.org for a "pass" result. Only if the host
          were not permitted for either of those domains would the result be
          "fail".
        </t>
        <t>
          Whether this mechanism matches, does not match, or throws an
          exception depends on the result of the recursive evaluation of
          check_host():
        </t>
        <texttable>
          <ttcol>A recursive check_host() result of:</ttcol>
          <ttcol>Causes the "include" mechanism to:</ttcol>
          <c>pass</c>       <c>match</c>
          <c>fail</c>       <c>not match</c>
          <c>softfail</c>   <c>not match</c>
          <c>neutral</c>    <c>not match</c>
          <c>temperror</c>  <c>throw temperror</c>
          <c>permerror</c>  <c>throw permerror</c>
          <c>none</c>       <c>throw permerror</c>
        </texttable>
        <t>
          The "include" mechanism is intended for crossing administrative
          boundaries.  For example, if example.com and example.org were managed
          by the same entity, and if the permitted set of hosts for both domains
          was <vspace/>
          <!-- FIXME: prevent automatic line break after '"mx:' -->
          "mx:example.com", it would be possible for example.org to specify
          "include:example.com", but it would be preferable to specify
          "redirect=example.com" or even "mx:example.com".
        </t>
        <t>
          With the "include" mechanism an administratively external set of hosts
          can be authorized, but determination of sender policy is still a
          function of the original domain's SPF record (as determined by the
          "all" mechanism in that record).  The redirect modifier is more
          suitable for consolidating both authorizations and policy into a
          common set to be shared within an ADMD.  Redirect is much more like a
          common code element to be shared among records in a single ADMD.  It
          is possible to control both authorized hosts and policy for an
          arbitrary number of domains from a single record.
        </t>
      </section>
      <section title="&quot;a&quot;" anchor="mech-a">
        <t>
          This mechanism matches if &lt;ip&gt; is one of the
          &lt;target-name&gt;'s IP addresses. 
        </t>
        <figure>
          <artwork type="abnf"><![CDATA[
a                = "a"      [ ":" domain-spec ] [ dual-cidr-length ]
]]></artwork>
        </figure>
        <t>
          An address lookup is done on the &lt;target-name&gt;. The
          &lt;ip&gt; is compared to the returned address(es). If any address
          matches, the mechanism matches. 
        </t>
      </section>
      <section title="&quot;mx&quot;" anchor="mech-mx">
        <t>
          This mechanism matches if &lt;ip&gt; is one of the MX hosts for a
          domain name. 
        </t>
        <figure>
          <artwork type="abnf"><![CDATA[
mx               = "mx"     [ ":" domain-spec ] [ dual-cidr-length ]
]]></artwork>
        </figure>
        <t>
          check_host() first performs an MX lookup on the
          &lt;target-name&gt;. Then it performs an address lookup on each MX
          name returned. The &lt;ip&gt; is compared to each returned IP
          address. To prevent Denial of Service (DoS) attacks, more than 10
          MX names MUST NOT be looked up during the evaluation of an "mx"
          mechanism (see <xref target="security"/>).  If any address matches,
          the mechanism matches.
        </t>
        <t>
          Note regarding implicit MXs: If the &lt;target-name&gt; has no MX
          records, check_host() MUST NOT pretend the target is its single MX,
          and MUST NOT default to an A or AAAA lookup on the &lt;target-name&gt;
          directly. This behavior diverges from the legacy "implicit MX" rule,
          (See <xref target="RFC5321"/>, Section 5. If such behavior is
          desired, the publisher should specify an "a" directive).
        </t>
      </section>
      <section title="&quot;ptr&quot; (deprecated)" anchor="mech-ptr">
        <t>
          This mechanism tests whether the DNS reverse-mapping for &lt;ip&gt;
          exists and correctly points to a domain name within a particular
          domain.  This mechanism is deprecated and SHOULD NOT be used.
        </t>
        <figure>
          <artwork type="abnf"><![CDATA[
ptr              = "ptr"    [ ":" domain-spec ]
          ]]></artwork>
        </figure>
        <t>
          The &lt;ip&gt;'s name is looked up using this procedure:
          <list style="numbers">
              <t>Perform a DNS reverse-mapping for &lt;ip&gt;</t>
              <t>Look up the corresponding PTR record in "in-addr.arpa." if the
                 address is an IPv4 one and in "ip6.arpa." if it is an IPv6
                 address.</t>
              <t>For each record returned, validate the domain name by looking
                 up its IP address.  To prevent DoS attacks, more than 10 PTR
                 names MUST NOT be looked up during the evaluation of a "ptr"
                 mechanism (see <xref target="eval-limits"/>).</t>
              <t>If &lt;ip&gt; is among the returned IP addresses, then that
                 domain name is validated.</t>
          </list>        
        </t>
        <t>
          Check all validated domain names to see if they either match the
          <!-- FIXME: prevent automatic line break in "<target-name>" -->
          &lt;target-name&gt; domain or are a subdomain of the
          &lt;target-name&gt; domain. If any do, this mechanism matches.  If
          no validated domain name can be found, or if none of the validated
          domain names match or are a subdomain of the &lt;target-name&gt;, this
          mechanism fails to match. If a DNS error occurs while doing the PTR RR
          lookup, then this mechanism fails to match.  If a DNS error occurs
          while doing an A RR lookup, then that domain name is skipped and the
          search continues.
        </t>
        <figure>
          <preamble>Pseudocode:</preamble>
          <artwork>
sending-domain_names := ptr_lookup(sending-host_IP);
if more than 10 sending-domain_names are found, use at most 10.
for each name in (sending-domain_names) {
  IP_addresses := a_lookup(name);
  if the sending-domain_IP is one of the IP_addresses {
    validated-sending-domain_names += name;
  }
}

for each name in (validated-sending-domain_names) {
  if name ends in &lt;domain-spec&gt;, return match.
  if name is &lt;domain-spec&gt;, return match.
}
return no-match.
          </artwork>
        </figure>
        <t>
          This mechanism matches if the &lt;target-name&gt; is either a
          subdomain of a validated domain name or if the &lt;target-name&gt;
          and a validated domain name are the same.  For example:
          "mail.example.com" is within the domain "example.com", but
          "mail.bad-example.com" is not.
        </t>
        <t>
          Note: This mechanism has been deprecated because it is slow, it
          is not as reliable as other mechanisms in cases of DNS errors, and
          it places a large burden on the .arpa name servers. If used, proper
          PTR records must be in place for the domain's hosts and the "ptr"
          mechanism should be one of the last mechanisms checked.  After
          many yearrs of SPF deployment experience it has been concluded
          it is unnecessary and more reliable alternatives used instead.  It is,
          however, still in use and part of the SPF protocol, so compliant
          check_host() implementations MUST support it.
        </t>
      </section>
      <section title="&quot;ip4&quot; and &quot;ip6&quot;" anchor="mech-ip">
        <t>
          These mechanisms test whether &lt;ip&gt; is contained within a
          given IP network. 
        </t>
        <figure>
          <artwork type="abnf"><![CDATA[
ip4              = "ip4"      ":" ip4-network   [ ip4-cidr-length ]
ip6              = "ip6"      ":" ip6-network   [ ip6-cidr-length ]

ip4-cidr-length  = "/" 1*DIGIT
ip6-cidr-length  = "/" 1*DIGIT
dual-cidr-length = [ ip4-cidr-length ] [ "/" ip6-cidr-length ]

ip4-network      = qnum "." qnum "." qnum "." qnum
qnum             = DIGIT                 ; 0-9
                   / %x31-39 DIGIT       ; 10-99
                   / "1" 2DIGIT          ; 100-199
                   / "2" %x30-34 DIGIT   ; 200-249
                   / "25" %x30-35        ; 250-255
         ; as per conventional dotted quad notation.  e.g., 192.0.2.0
ip6-network      = <as per [RFC 4291], section 2.2>
         ; e.g., 2001:DB8::CD30
]]></artwork>
        </figure>
        <t>
          The &lt;ip&gt; is compared to the given network. If
          CIDR prefix length high-order bits match, the mechanism matches. 
        </t>
        <t>
          If ip4-cidr-length is omitted, it is taken to be "/32". If<vspace/>
          <!-- FIXME: prevent automatic line break in "<ip6-cidr-length>" -->
          ip6-cidr-length is omitted, it is taken to be "/128".  It is not
          permitted to omit parts of the IP address instead of using CIDR
          notations.  That is, use 192.0.2.0/24 instead of 192.0.2.
        </t>
      </section>
      <section title="&quot;exists&quot;" anchor="mech-exists">
        <t>
          This mechanism is used to construct an arbitrary domain name that
          is used for a DNS A record query. It allows for complicated schemes
          involving arbitrary parts of the mail envelope to determine what is
          permitted.
        </t>
        <figure>
          <artwork type="abnf"><![CDATA[
exists           = "exists"   ":" domain-spec
]]></artwork>
        </figure>
        <t>
          The domain-spec is expanded as per <xref target="macros"/>. The
          resulting domain name is used for a DNS A RR lookup. If any A
          record is returned, this mechanism matches. The lookup type is A
          even when the connection type is IPv6.
        </t>
        <t>
          Domains can use this mechanism to specify arbitrarily complex
          queries. For example, suppose example.com publishes the record:
        </t>
        <t>
          <list style="empty">
            <t>v=spf1 exists:%{ir}.%{l1r+-}._spf.%{d} -all</t>
          </list>
        </t>
        <t>
          The &lt;target-name&gt; might expand to
          "1.2.0.192.someuser._spf.example.com". This makes fine-grained
          decisions possible at the level of the user and client IP address.
        </t>
        <t>
          This mechanism enables queries that mimic the style of tests that
          existing DNS white/black lists (DNSxLs) use, as described in
          <xref target="RFC5782"/>.  The query will either return NXDOMAIN (no
          match), any valid answer (match), or an error.
        </t>
      </section>
    </section>
    <section title="Modifier Definitions" anchor="modifiers">
      <t>
        Modifiers are name/value pairs that provide additional information.
        Modifiers always have an "=" separating the name and the value.
      </t>
      <t>
        The modifiers defined in this document ("redirect" and "exp") MAY
        appear anywhere in the record, but SHOULD appear at the end, after
        all mechanisms.  Ordering of these two modifiers does not matter.
        These two modifiers MUST NOT appear in a record more than once each.
        If they do, then check_host() exits with a result of "permerror".
      </t>
      <t>
        Unrecognized modifiers MUST be ignored no matter where in a record,
        or how often.  This allows implementations of this document to
        gracefully handle records with modifiers that are defined in other
        specifications.
      </t>
      <section title="redirect: Redirected Query" anchor="mod-redirect">
        <t>
          The redirect modifier intended for consolidating both authorizations
          and policy into a common set to be shared within a single ADMD.
          Redirect is like a common code element to be shared among records in a
          single ADMD.  It is possible to control both authorized hosts and
          policy for an arbitrary number of domains from a single record.          
        </t>
        <figure>
          <artwork type="abnf"><![CDATA[
redirect         = "redirect" "=" domain-spec
]]></artwork>
        </figure>
        <t>
          If all mechanisms fail to match, and a "redirect" modifier is
          present, then processing proceeds as follows:
        </t>
        <t>
          The domain-spec portion of the redirect section is expanded as per
          the macro rules in <xref target="macros"/>. Then check_host() is
          evaluated with the resulting string as the &lt;domain&gt;. The
          &lt;ip&gt; and &lt;sender&gt; arguments remain the same as in the
          current evaluation of check_host().
        </t>
        <t>
          The result of this new evaluation of check_host() is then
          considered the result of the current evaluation with the exception
          that if no SPF record is found, or if the target-name is malformed,
          the result is a "permerror" rather than "none".
        </t>
        <t>
          Note that the newly-queried domain can itself specify redirect
          processing. 
        </t>
        <t>
          This facility is intended for use by organizations that wish to
          apply the same record to multiple domains. For example: 
        </t>
        <figure>
          <artwork>
  la.example.com. TXT "v=spf1 redirect=_spf.example.com"
  ny.example.com. TXT "v=spf1 redirect=_spf.example.com"
  sf.example.com. TXT "v=spf1 redirect=_spf.example.com"
_spf.example.com. TXT "v=spf1 mx:example.com -all"
          </artwork>
        </figure>
        <t>
          In this example, mail from any of the three domains is described by
          the same record. This can be an administrative advantage.
        </t>
        <t>
          Note: In general, the domain "A" cannot reliably use a redirect to
          another domain "B" not under the same administrative control. Since
          the &lt;sender&gt; stays the same, there is no guarantee that the
          record at domain "B" will correctly work for mailboxes in domain
          "A", especially if domain "B" uses mechanisms involving local-parts.
          An "include" directive is generally be more appropriate.
        </t>
        <t>
          For clarity, it is RECOMMENDED that any "redirect" modifier appear
          as the very last term in a record.
        </t>
      </section>
      <section title="exp: Explanation" anchor="mod-exp">
        <figure>
          <artwork type="abnf"><![CDATA[
explanation      = "exp" "=" domain-spec
]]></artwork>
        </figure>
        <t>
          If check_host() results in a "fail" due to a mechanism match (such
          as "-all"), and the "exp" modifier is present, then the explanation
          string returned is computed as described below. If no "exp"
          modifier is present, then either a default explanation string or an
          empty explanation string MUST be returned.
        </t>
        <t>
          The domain-spec is macro expanded (see <xref target="macros"/>) and
          becomes the &lt;target-name&gt;. The DNS TXT record for the
          &lt;target-name&gt; is fetched.
        </t>
        <t>
          If there are any DNS processing errors (any RCODE other than 0), or
          if no records are returned, or if more than one record is returned,
          or if there are syntax errors in the explanation string, then
          proceed as if no exp modifier was given.
        </t>
        <t>
          The fetched TXT record's strings are concatenated with no spaces,
          and then treated as an explain-string, which is macro-expanded.
          This final result is the explanation string.  Implementations MAY
          limit the length of the resulting explanation string to allow for
          other protocol constraints and/or reasonable processing limits.
          Since the explanation string is intended for an SMTP response and
          <xref target="RFC5321"/> Section 2.4 says that responses are in
          <xref target="US-ASCII"/>, the explanation string MUST be limited
          to US-ASCII.
        </t>
        <t>
          Software evaluating check_host() can use this string to communicate
          information from the publishing domain in the form of a short
          message or URL.  Software SHOULD make it clear that the explanation
          string comes from a third party. For example, it can prepend the
          macro string "%{o} explains: " to the explanation, such as shown in
          <xref target="op-result-fail"/>.
        </t>
        <t>Suppose example.com has this record:</t>
        <t>
          <list style="empty">
            <t>v=spf1 mx -all exp=explain._spf.%{d}</t>
          </list>
        </t>
        <t>
          Here are some examples of possible explanation TXT records at
          explain._spf.example.com:
        </t>
        <t>
          <?rfc compact="yes"?>
          <list style="empty">
            <t>
              "Mail from example.com should only be sent by its own
              servers." 
              <list style="hanging" hangIndent="7">
                <t hangText="&nbsp;&nbsp;&nbsp;--">a simple, constant message</t>
              </list>
            </t>
            <t> <vspace/>
              "%{i} is not one of %{d}'s designated mail servers."
              <list style="hanging" hangIndent="7">
                <t hangText="&nbsp;&nbsp;&nbsp;--">
                  a message with a little more information, including the IP
                  address that failed the check
                </t>
              </list>
            </t>
            <t> <vspace/>
              "See http://%{d}/why.html?s=%{S}&amp;i=%{I}"
              <list style="hanging" hangIndent="7">
                <t hangText="&nbsp;&nbsp;&nbsp;--">
                  a complicated example that constructs a URL with the
                  arguments to check_host() so that a web page can be
                  generated with detailed, custom instructions
                </t>
              </list>
            </t>
          </list>
          <?rfc compact="no"?>
        </t>
        <t>
          Note: During recursion into an "include" mechanism, an exp=
          modifier from the &lt;target-name&gt; MUST NOT be used.  In
          contrast, when executing a "redirect" modifier, an exp= modifier
          from the original domain MUST NOT be used.
        </t>
      </section>
    </section>
    <section title="Recording The Result" anchor="results-headers">
      <t>
        It is RECOMMENDED that SMTP receivers record the result of SPF
        processing in the message header.  There are two methods for doing this:
        the Received-SPF Header Field defined here and the more generic
        Authentication-Results Header Field defined in  <xref
        target="RFC5451"/>.  Because these fields are generally used within a
        receiving ADMD, it is a local policy choice which to include.  In
        general, the more broadly applicable Authentication-Results Header Field
        ought to be used, but it SHOULD provide the same information as if a
        Received-SPF Header Field were used.
      </t>
      <t>
        If an SMTP receiver chooses to do so, it SHOULD use one of these header
        fields for each identity that was checked.  This information is intended
        for the recipient.  (Information intended for the sender is described in
        <xref target="mod-exp"/>, Explanation.)
      </t>
      <section title="The Received-SPF Header Field">
      <t>
        The Received-SPF header field is a trace field (see <xref
        target="RFC5322"/> Section 3.6.7) and SHOULD be prepended to the
        existing header, above the Received: field that is generated by the
        SMTP receiver.  It MUST appear above all other Received-SPF fields in
        the message.  The header field has the following format:
      </t>
      <figure>
        <artwork type="abnf"><![CDATA[
header-field     = "Received-SPF:" [CFWS] result FWS [comment FWS]
                   [ key-value-list ] CRLF

result           = "pass" / "fail" / "softfail" / "neutral" /
                   "none" / "temperror" / "permerror"

key-value-list   = key-value-pair *( ";" [CFWS] key-value-pair )
                   [";"]

key-value-pair   = key [CFWS] "=" ( dot-atom / quoted-string )

key              = "client-ip" / "envelope-from" / "helo" /
                   "problem" / "receiver" / "identity" /
                    mechanism / name

identity         = "mailfrom"   ; for the RFC5321.MailFrom identity
                   / "helo"     ; for the RFC5321.HELO/.EHLO identity
                   / name       ; other identities
        
dot-atom         = <unquoted word as per [RFC5322]>
quoted-string    = <quoted string as per [RFC5322]>
comment          = <comment string as per [RFC5322]>
CFWS             = <comment or folding white space as per [RFC5322]>
FWS              = <folding white space as per [RFC5322]>
CRLF             = <standard end-of-line token as per [RFC2532]>
]]></artwork>
      </figure>
      <t>
        The header field SHOULD include a "(...)" style comment after the
        result, conveying supporting information for the result, such as
        &lt;ip&gt;, &lt;sender&gt;, and &lt;domain&gt;.
      </t>
      <t>
        The following key-value pairs are designed for later machine parsing.
        SPF clients SHOULD give enough information so that the SPF results
        can be verified.  That is, at least "client-ip", "helo", and, if the
        RFC5321.MailFrom identity was checked, "envelope-from".
      </t>
      <t>
        <?rfc compact="no"?>
        <list style="hanging" hangIndent="15">
          <t hangText="client-ip">      the IP address of the SMTP client</t>
          <t hangText="envelope-from">  the envelope sender mailbox</t>
          <t hangText="helo">           the host name given in the HELO
            or EHLO command
          </t>
          <t hangText="mechanism">      the mechanism that matched (if
            no mechanisms matched, substitute the word "default")
          </t>
          <t hangText="problem">        if an error was returned,
            details about the error
          </t>
          <t hangText="receiver">       the host name of the SPF client</t>
          <t hangText="identity">       the identity that was checked;
            see the &lt;identity&gt; ABNF rule
          </t>
        </list>
        <!-- <?rfc compact="yes"?> -->
      </t>
      <t>
        Other keys MAY be defined by SPF clients.
      </t>
      <t>
        SPF clients MUST make sure that the Received-SPF header field does
        not contain invalid characters, is not excessively long (See <xref
        target="RFC5322"/> Section 2.1.1), and does not contain malicious data
        that has been provided by the sender.
      </t>
      <t>
        Examples of various header field styles that could be generated are the
        following:
      </t>
      <figure>
        <artwork>
Received-SPF: pass (mybox.example.org: domain of
 myname@example.com designates 192.0.2.1 as permitted sender)
    receiver=mybox.example.org; client-ip=192.0.2.1;
    envelope-from="myname@example.com"; helo=foo.example.com;

Received-SPF: fail (mybox.example.org: domain of
                  myname@example.com does not designate
                  192.0.2.1 as permitted sender)
                  identity=mailfrom; client-ip=192.0.2.1;
                  envelope-from="myname@example.com";
        </artwork>
      </figure>
      </section>
      <section title="SPF Results in the Authentication-Results Header Field">
        <t> As mentioned in <xref target="results-headers"/>, the
        Authentication-Results header field is designed to communicate lists of
        tests a border MTA did and their results.  The specified elements of the
        field provide less information than SPF-Received:
        </t>
        <figure>
            <artwork>
Authentication-Results: myhost.example.org; spf=pass
  smtp.mailfrom=example.net

Received-SPF: pass (myhost.example.org: domain of
 myname@example.com designates 192.0.2.1 as permitted sender)
    receiver=mybox.example.org; client-ip=192.0.2.1;
    envelope-from="myname@example.com"; helo=foo.example.com;
            </artwork>
        </figure>
      <t>
        It is, however, possible to add CFWS in an Authentication-Results
        Header Field to provide the equivalent information.  Receivers SHOULD
        include the explanation ("myhost.example.org: domain of
        myname@example.com designates 192.0.2.1 as permitted sender" in the
        example above), the recipient address ("receiver=mybox.example.org"),
        the IP address of the sending SMTP client ("client-ip=192.0.2.1"), and
        both the 5321.MailFrom address and/or the 5321.HELO/.EHLO.
      </t>
      <t>
      Authserv-id SHOULD be the name of the receiving host performing the check.
      reason SHOULD include a key-value-list with keys provinding information
      normally included in a Received-SPF Header Field that is not already part
      of the Authentication-Results Header Field.  That is, at least
      "client-ip", "helo", and, if the RFC5321.MailFrom identity was checked,
      "envelope-from".
      </t>
      <figure>
        <artwork type="abnf"><![CDATA[
authserv-id      = <authserv-id per [RFC5451]>
reasonspec       = <reason per [RFC5451]>
        ]]></artwork>
      </figure>
      <t>
        A suitably enhanced Authentication-Results Header Field might look
        like:
        <figure>
            <artwork>
Authentication-Results: myhost.example.org; spf=pass
  reason="client-ip=192.0.2.1" smtp.helo=foo.example.com
  smtp.mailfrom=user@example.net
            </artwork>
        </figure>
      </t>
      </section>
    </section>
    <section title="Macros" anchor="macros">
      <section title="Macro Definitions">
        <t>
          Many mechanisms and modifiers perform macro expansion on a term.
        </t>
        <figure>
          <artwork type="abnf"><![CDATA[
domain-spec      = macro-string domain-end
domain-end       = ( "." toplabel [ "." ] ) / macro-expand

toplabel         = ( *alphanum ALPHA *alphanum ) /
                   ( 1*alphanum "-" *( alphanum / "-" ) alphanum )
                   ; LDH rule plus additional TLD restrictions
                   ; (see [RFC3696], Section 2 for background)
alphanum         = ALPHA / DIGIT

explain-string   = *( macro-string / SP )

macro-string     = *( macro-expand / macro-literal )
macro-expand     = ( "%{" macro-letter transformers *delimiter "}" )
                   / "%%" / "%_" / "%-"
macro-literal    = %x21-24 / %x26-7E
                   ; visible characters except "%"
macro-letter     = "s" / "l" / "o" / "d" / "i" / "p" / "h" /
                   "c" / "r" / "t" / "v"
transformers     = *DIGIT [ "r" ]
delimiter        = "." / "-" / "+" / "," / "/" / "_" / "="
]]></artwork>
        </figure>
        <t>
          A literal "%" is expressed by "%%".
        </t>
        <t>
          <list style="empty">
            <t>
              "%_" expands to a single " " space.<vspace/>
              "%-" expands to a URL-encoded space, viz., "%20".
            </t>
          </list>
        </t>
        <t>The following macro letters are expanded in term arguments:</t>
        <t>
          <list style="empty">
            <t>
              s = &lt;sender&gt;<vspace/>
              l = local-part of &lt;sender&gt;<vspace/>
              o = domain of &lt;sender&gt;<vspace/>
              d = &lt;domain&gt;<vspace/>
              i = &lt;ip&gt;<vspace/>
              p = the validated domain name of &lt;ip&gt; (deprecated)<vspace/>
              v = the string "in-addr" if &lt;ip&gt; is ipv4, or "ip6" if
                  &lt;ip&gt; is ipv6<vspace/>
              h = HELO/EHLO domain
            </t>
          </list>
        </t>
        <t>The following macro letters are allowed only in "exp" text:</t>
        <t>
          <list style="empty">
            <t>
              c = SMTP client IP (easily readable format)<vspace/>
              r = domain name of host performing the check<vspace/>
              t = current timestamp
            </t>
          </list>
        </t>
        <?rfc compact="yes"?>
        <t>
          A '%' character not followed by a '{', '%', '-', or '_' character
          is a syntax error. So
          <list style="empty">
            <t>-exists:%(ir).sbl.spamhaus.example.org</t>
          </list>
          is incorrect and will cause check_host() to yield a "permerror".
          Instead, say 
          <list style="empty">
            <t>-exists:%{ir}.sbl.spamhaus.example.org</t>
          </list>
        </t>
        <t>
          Optional transformers are the following:
          <list style="empty">
            <t>
              <list style="hanging" hangIndent="7">
                <t hangText="*DIGIT">= zero or more digits</t>
                <t hangText="'r'">
                  = reverse value, splitting on dots by default
                </t>
              </list>
            </t>
          </list>
        </t>
        <?rfc compact="no"?>
        <t>
          If transformers or delimiters are provided, the replacement value
          for a macro letter is split into parts. After performing any
          reversal operation and/or removal of left-hand parts, the parts are
          rejoined using "." and not the original splitting characters.
        </t>
        <t>
          By default, strings are split on "." (dots). Note that no special
          treatment is given to leading, trailing, or consecutive delimiters in
          input strings, and so the list of parts might contain empty strings.
          Some older implementations of SPF prohibit trailing dots in domain
          names, so trailing dots SHOULD NOT be published by domain owners,
          although they MUST be accepted by implementations conforming to this
          document.  Macros MAY specify delimiter characters that are used
          instead of ".".
        </t>
        <t>
          The 'r' transformer indicates a reversal operation: if the client
          IP address were 192.0.2.1, the macro %{i} would expand to
          "192.0.2.1" and the macro %{ir} would expand to "1.2.0.192".
        </t>
        <t>
          The DIGIT transformer indicates the number of right-hand parts to
          use, after optional reversal. If a DIGIT is specified, the value
          MUST be nonzero. If no DIGITs are specified, or if the value
          specifies more parts than are available, all the available parts
          are used. If the DIGIT was 5, and only 3 parts were available, the
          macro interpreter would pretend the DIGIT was 3. Implementations
          MUST support at least a value of 128, as that is the maximum number
          of labels in a domain name.
        </t>
        <t>
          The "s" macro expands to the &lt;sender&gt; argument. It is an
          email address with a local-part, an "@" character, and a domain.
          The "l" macro expands to just the local-part. The "o" macro expands
          to just the domain part. Note that these values remain the same
          during recursive and chained evaluations due to "include" and/or
          "redirect".  Note also that if the original &lt;sender&gt; had no
          local-part, the local-part was set to "postmaster" in initial
          processing (see <xref target="initial"/>).  local-parts MUST either be
          ASCII or encoded as A-labels per Section 2.3 of <xref
          target="RFC5890"/> to be used in the "s" or "l" macros.
        </t>
        <t>
          For IPv4 addresses, both the "i" and "c" macros expand to the
          standard dotted-quad format. 
        </t>
        <t>
          For IPv6 addresses, the "i" macro expands to a dot-format address;
          it is intended for use in %{ir}. The "c" macro MAY expand to any of
          the hexadecimal colon-format addresses specified in <xref
          target="RFC4291"/>, Section 2.2. It is intended for humans to read.
        </t>
        <t>
          The "p" macro expands to the validated domain name of &lt;ip&gt;.
          The procedure for finding the validated domain name is defined in
          <xref target="mech-ptr"/>.  If the &lt;domain&gt; is present in the
          list of validated domains, it SHOULD be used.  Otherwise, if a
          subdomain of the &lt;domain&gt; is present, it SHOULD be used.
          Otherwise, any name from the list MAY be used.  If there are no
          validated domain names or if a DNS error occurs, the string
          "unknown" is used.  This macro is deprecated and SHOULD NOT be
          used.
        </t>
        <t>
          The "r" macro expands to the name of the receiving MTA. This SHOULD
          be a fully qualified domain name, but if one does not exist (as
          when the checking is done by a MUA) or if policy restrictions
          dictate otherwise, the word "unknown" SHOULD be substituted. The
          domain name can be different from the name found in the MX record
          that the client MTA used to locate the receiving MTA.
        </t>
        <t>
          The "t" macro expands to the decimal representation of the
          approximate number of seconds since the Epoch (Midnight, January 1,
          1970, UTC) at the time of the evaluation.  This is the same value as
          is returned by the POSIX time() function in most standards-compliant
          libraries.
        </t>
        <t>
          When the result of macro expansion is used in a domain name query,
          if the expanded domain name exceeds 253 characters (the maximum
          length of a domain name), the left side is truncated to fit, by
          removing successive domain labels (and their following dots) until the
          total length does not exceed 253 characters.
        </t>
        <t>
          Uppercased macros expand exactly as their lowercased equivalents,
          and are then URL escaped. URL escaping must be performed for
          characters not in the "unreserved" set, which is defined in <xref
          target="RFC3986"/>.
        </t>
        <t>
          Note: Care must be taken so that macro expansion for legitimate
          email does not exceed the 63-character limit on DNS labels.  The
          local-part of email addresses, in particular, can have more than 63
          characters between dots.
        </t>
        <t>
          Note: Domains SHOULD avoid using the "s", "l", "o", or "h" macros
          in conjunction with any mechanism directive. Although these macros
          are powerful and allow per-user records to be published, they
          severely limit the ability of implementations to cache results of
          check_host() and they reduce the effectiveness of DNS caches.
        </t>
        <t>
          Implementations SHOULD be aware that if no directive processed
          during the evaluation of check_host() contains an "s", "l", "o", or
          "h" macro, then the results of the evaluation can be cached on the
          basis of &lt;domain&gt; and &lt;ip&gt; alone for as long as the
          shortest Time To Live (TTL) of all the DNS records involved.
        </t>
        <t>
          The macro ABNF does not in itself limit macro expansion so that it
          results in a valid domain-spec.  Nonsense such as this is permitted:
        <figure>
            <artwork>
%{s.-+,/_=.+,..+.}
            </artwork>
        </figure>
          Just because the macro ABNF allows it, does not make it valid.  The
          result of macro expansion MUST still be a valid domain-spec.
        </t>
      </section>
      <section title="Expansion Examples">
        <?rfc compact="yes"?>
        <t>
          <list>
            <t>
              The &lt;sender&gt; is strong-bad@email.example.com.<vspace/>
              The IPv4 SMTP client IP is 192.0.2.3.<vspace/>
              The IPv6 SMTP client IP is 2001:DB8::CB01.<vspace/>
              The PTR domain name of the client IP is mx.example.org.
            </t>
          </list>
        </t>
        <?rfc compact="no"?>
        <figure>
          <artwork>
macro                       expansion
-------  ----------------------------
%{s}     strong-bad@email.example.com
%{o}                email.example.com
%{d}                email.example.com
%{d4}               email.example.com
%{d3}               email.example.com
%{d2}                     example.com
%{d1}                             com
%{dr}               com.example.email
%{d2r}                  example.email
%{l}                       strong-bad
%{l-}                      strong.bad
%{lr}                      strong-bad
%{lr-}                     bad.strong
%{l1r-}                        strong

macro-string                                               expansion
--------------------------------------------------------------------
%{ir}.%{v}._spf.%{d2}             3.2.0.192.in-addr._spf.example.com
%{lr-}.lp._spf.%{d2}                  bad.strong.lp._spf.example.com

%{lr-}.lp.%{ir}.%{v}._spf.%{d2}
                    bad.strong.lp.3.2.0.192.in-addr._spf.example.com

%{ir}.%{v}.%{l1r-}.lp._spf.%{d2}
                        3.2.0.192.in-addr.strong.lp._spf.example.com

%{d2}.trusted-domains.example.net
                             example.com.trusted-domains.example.net

IPv6:
%{ir}.%{v}._spf.%{d2}                               1.0.B.C.0.0.0.0.
0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.B.D.0.1.0.0.2.ip6._spf.example.com
          </artwork>
        </figure>
      </section>
    </section>
    <section title="Implications" anchor="implications">
      <t>
        This section outlines the major implications that adoption of this
        document will have on various entities involved in Internet email.
        It is intended to make clear to the reader where this document
        knowingly affects the operation of such entities.  This section is
        not a "how-to" manual, or a "best practices" document, and it is not
        a comprehensive list of what such entities should do in light of this
        document.
      </t>
      <t>
        This section is non-normative.  <xref target="RFC5598"/> describes the
        Internet email architecture.  This section is organized based on the
        different segments of the architecture.
      </t>
      <section title="Sending Domains" anchor="sending-impl">
        <t>
          Originating ADMDs (ADministrative Management Domains -
          <xref target="RFC5598"/> Section 2.2.1 and Section 2.3) that wish to
          be compliant with this specification will need to determine the list
          of relays (<xref target="RFC5598"/> Section 2.2.2) that they allow to
          use their domain name in the RFC5321.HELO/.EHLO and RFC5321.MailFrom
          identities when relaying to other ADMDs.  It is recognized that
          forming such a list is not just a simple technical exercise, but
          involves policy decisions with both technical and administrative
          considerations.
        </t>
        <section title="DNS Resource Considerations" anchor="sending-resources">
          <t>
            Minimizing the DNS resources required for SPF lookups can be done by
            choosing directives that require less DNS information and by placing
            lower-cost mechanisms earlier in the SPF record.
          </t>
          <?rfc needLines="12"?>
          <figure>
          <artwork><![CDATA[
          +----------+--------+-----------------+
          | term     | cost   | limit           |
          +----------+--------+-----------------+
          | ip4/ip6  | 0      | -               |
          | a        | 1      | 10              |
          | include  | 1      | 10              |
          | redirect | 1      | 10              |
          | exists   | 1      | 10              |
          | mx       | 1 + N* | 10 and N* <= 10 |
          | ptr/%{p} | 1 + N* | 10 and N* <= 10 |
          +----------+--------+-----------------+
           * N is the number of RRs found during each term evaluation
          ]]></artwork>
          </figure>

          <t>          
            <xref target="eval-limits"/> specifies the limits receivers have to
            use.  It is essential to publish records that do not exceed these
            requirements.
            It is also required to carefully weight the cost and the
            maintainability of licit solutions.
          </t>
          <t>For example, consider a domain set up as follows:</t>
          <figure>
            <artwork>
   example.com.     IN MX   10 mx.example.com.
                    IN MX   20 mx2.example.com.
   mx.example.com.  IN A    192.0.2.1
   mx2.example.com. IN A    192.0.2.129
            </artwork>
          </figure>
          <t>
            Assume the administrative point is to authorize (pass) mx and mx2
            while failing every other host.  Compare the following solutions:
          </t>

          <figure>
            <artwork>
Best record:
   example.com.   IN TXT  "v=spf1 ip4:192.0.2.1 ip4:192.0.2.129 -all"
            </artwork>
          </figure>

          <figure>
            <artwork>
Good record:
   $ORIGIN example.com.
   @              IN TXT  "v=spf1 a:authorized_spf.example.com -all"
   authorized_spf IN A    192.0.2.1
                  IN A    192.0.2.129
            </artwork>
          </figure>

          <figure>
            <artwork>
Expensive record:
   example.com.   IN TXT  "v=spf1 mx:example.com -all"
            </artwork>
          </figure>

          <figure>
            <artwork>
Wasteful, bad record:
   example.com.   IN TXT  "v=spf1 ip4:192.0.2.0/24 mx -all"
            </artwork>
          </figure>
        </section>
        <section title="Administrator's Considerations" anchor="sending-admin">
          <t>
            There might be administrative considerations: using "a" over
            "ip4" or "ip6" allows hosts to be renumbered easily. Using "mx"
            over "a" allows the set of mail hosts to be changed easily.  Unless
            such changes are common, it is better to use the less resource
            intensive mechanisms like "ip4" and "ip6".
          </t>
          <t>
            Validating correct deployment is difficult.  <xref target="RFC6652"/>
            describes one mechanism for soliciting feedback on SPF failures.
            Another approach that can be helpful to publish records that include
            a "tracking  exists:" mechanism.  By looking at the name server logs,
            a rough list can then be generated. For example:
            <!-- <?rfc subcompact="no"?> -->
            <list>
              <t>v=spf1 exists:_h.%{h}._l.%{l}._o.%{o}._i.%{i}._spf.%{d} ?all</t>
            </list>
            <!-- <?rfc subcompact="yes"?> -->
          </t>
          <t>
            Regardless of the method used, understanding the ADMD's outbound
            mail architecture is essential to effective deployment.
          </t>
        </section>
        <section title="Bounces">
          <t>
            As explained in <xref target="mfrom-def"/>,  <xref
            target="RFC5321"/> allows the reverse-path to be null, which is
            typical of some Delivery Status Notification  <xref
            target="RFC3464"/>, commonly called email bounces.  In this case the
            only entity available for performing an SPF check is the
            RFC5321.HELO/.EHLO identity defined in <xref target="helo-def"/>.
            SPF functionality is enhanced by administrators ensuring this
            identity is set correctly and has an appropriate SPF record. It is
            common to have the HELO identity set to hostname instead of domain.
            Zone file generation for significant numbers of hosts can be
            consolidated using the redirect modifier and scripted for initial
            deployment.  Administrators might alternatively consider publishing
            an SPF for *.domain (wildcard domains) in that case if the involved
            hostnames do not have already any other DNS record.
          </t>
        </section>
      </section>
      <section title="Mediators" anchor="middle-lists">
        <t>
          Broadly speaking, there are two types of mediating ADMDs that can
          affect SPF deployment of other ADMDs: mailing lists (see
          <xref target="RFC5598"/> Section 5.3) and ReSenders
          (<xref target="RFC5598"/> Section 5.2).
        </t>
        <section title="Mailing Lists" anchor="mailing-lists">
        <t>
          Mailing lists must be aware of how they re-inject mail that is sent
          to the list. Mailing lists MUST comply with the requirements in
          <xref target="RFC5321"/>, Section 3.10, and <xref
          target="RFC1123"/>, Section 5.3.6, that say that the reverse-path
          MUST be changed to be the mailbox of a person or other entity who
          administers the list.  Whereas the reasons for changing the
          reverse-path are many and long-standing, SPF adds enforcement to
          this requirement.
        </t>
        <t>
          In practice, almost all mailing list software in use already
          complies with this requirement.  Mailing lists that do not comply
          might encounter problems depending on how access to the
          list is restricted.  Such lists that are entirely internal to a
          domain (only people in the domain can send to or receive from the
          list) are not affected.
        </t>
        </section>
        <section title="Forwarding Services and Aliases" anchor="forwarding">
        <t>
          Forwarding services take mail that is received at a mailbox and
          direct it to some external mailbox.  At the time of this writing,
          the near-universal practice of such services is to use the original
          RFC5321.MailFrom of a message when re-injecting it for delivery to the
          external mailbox.  <xref target="RFC1123"/> and <xref
          target="RFC5321"/> describe this action as an "alias" rather than a
          "mail list".  This means the external mailbox's MTA sees all such mail
          in a connection from a host of the forwarding service, and so the
          RFC5321.MailFrom identity will not, in general, pass authorization.
        </t>
        <t>
          There are three places that techniques can be used to ameliorate
          this problem.
          <!-- <?rfc subcompact="no"?> -->
          <list style="numbers"  hangIndent="3">
            <t>
              The beginning, when email is first sent (Originating ADMDs).
              <list style="numbers">
                <t>
                  "Neutral" results could be given for IP addresses that might
                  be forwarders, instead of "fail" results.  For example:
                  <list style="empty">
                    <t>"v=spf1 mx -exists:%{ir}.sbl.spamhaus.example.org ?all"</t>
                  </list>
                  This would cause a lookup on an anti-spam DNS blacklist
                  (DNSBL) and cause a result of "fail" only for email coming
                  from listed sources.  All other email, including email
                  sent through forwarders, would receive a "neutral" result.
                  By checking the DNSBL after the known good sources,
                  problems with incorrect listing on the DNSBL are greatly
                  reduced.
                </t>
                <t>
                  The RFC5321.MailFrom identity could have additional information
                  in the local-part that cryptographically identifies the mail
                  as coming from an authorized source.  In this case, such an
                  SPF record could be used:
                  <list style="empty">
                    <t>"v=spf1 mx exists:%{l}._spf_verify.%{d} -all"</t>
                  </list>
                  Then, a specialized DNS server can be set up to serve the
                  _spf_verify subdomain that validates the local-part.
                  Although this requires an extra DNS lookup, this happens
                  only when the email would otherwise be rejected as not
                  coming from a known good source.
                  <vspace/>
                  Note that due to the 63-character limit for domain labels,
                  this approach only works reliably if the local-part
                  signature scheme is guaranteed either to only produce
                  local-parts with a maximum of 63 characters or to gracefully
                  handle truncated local-parts.
                </t>
                <t>
                  Similarly, a specialized DNS server could be set up that
                  will rate-limit the email coming from unexpected IP
                  addresses.
                  <list style="empty">
                    <t>"v=spf1 mx exists:%{ir}._spf_rate.%{d} -all"</t>
                  </list>
                </t>
                <t>
                  SPF allows the creation of per-user policies for special
                  cases.  For example, the following SPF record and
                  appropriate wildcard DNS records can be used:
                  <list style="empty">
                    <t>"v=spf1 mx redirect=%{l1r+}._at_.%{o}._spf.%{d}"</t>
                  </list>
                </t>
              </list>
            </t>
            <t>
              The middle, when email is forwarded (Mediating ADMDs).
              <list style="numbers">
                <t>
                  Forwarding services can solve the problem by rewriting the
                  RFC5321.MailFrom to be in their own domain.  This means mail
                  rejected from the external mailbox will have to be forwarded
                  back to the original sender by the forwarding service.
                  Various schemes to do this exist though they vary widely in
                  complexity and resource requirements on the part of the
                  forwarding service.
                </t>
                <t>
                  Several popular MTAs can be forced from "alias" semantics
                  to "mailing list" semantics by configuring an additional
                  alias with "owner-" prepended to the original alias name
                  (e.g., an alias of "friends: george@example.com,
                  fred@example.org" would need another alias of the form
                  "owner-friends: localowner").
                </t>
              </list>
            </t>
            <t>
              The end, when email is received (Receiving ADMDs).
              <list style="numbers">
                <t>
                  If the owner of the external mailbox wishes to trust the
                  forwarding service, he can direct the external mailbox's
                  MTA to skip SPF tests when the client host belongs to the
                  forwarding service.
                </t>
                <t>
                  Tests against other identities, such as the RFC5321.HELO/.EHLO
                  identity, MAY be used to override a failed test against the
                  RFC5321.MailFrom identity.
                </t>
                <t>
                  For larger domains, it might not be possible to have a
                  complete or accurate list of forwarding services used by
                  the owners of the domain's mailboxes.  In such cases,
                  whitelists of generally-recognized forwarding services
                  could be employed.
                </t>
              </list>
            </t>
          </list>
          <!-- <?rfc subcompact="yes"?> -->
        </t>
        </section>
        <section title="Mail Services">
        <t>
          MSPs (Mail Service Providers - <xref target="RFC5598"/> Section 2.3)
          that offer mail services to third-party domains, such as sending of
          bulk mail, might want to adjust their configurations in light of the
          authorization check described in this document.  If the domain part of
          the RFC5321.MailFrom identity used for such email uses the domain of
          one of the MSPs domain, then the provider needs only to ensure that its
          sending host is authorized by its own SPF record, if any.
        </t>
        <t>
          If the RFC5321.MailFrom identity does not use the MSP's domain, then
          extra care must be taken.  The SPF record format has several options
          for the third-party domain to authorize the service provider's MTAs to
          send mail on its behalf.  For MSPs, such as ISPs, that have a wide
          variety of customers using the same MTA, steps should be taken to
          prevent cross-customer forgery (see <xref
          target="cross-user-forgery"/>).
        </t>
        </section>
        <section title="MTA Relays">
        <t>
          Relays are described in <xref target="RFC5598"/> Section 2.2.2.  The
          authorization check generally precludes the use of arbitrary
          MTA relays between sender and receiver of an email message.
        </t>
        <t>
          Within an organization, MTA relays can be effectively deployed.
          However, for purposes of this document, such relays are effectively
          transparent.  The SPF authorization check is a check between border
          MTAs of different ADMDs.
        </t>
        <t>
          For mail senders, this means that published SPF records must
          authorize any MTAs that actually send across the Internet.
          Usually, these are just the border MTAs as internal MTAs simply
          forward mail to these MTAs for delivery.
        </t>
        <t>
          The receiving ADMD will generally want to perform the authorization
          check at the boundary MTAs, including all secondary MXs.  Internal
          MTAs (including MTAs that might serve both as boundary MTAs and
          internal relays from secondary MXs when they are processing the
          relayed mail stream) then do not perform the authorization test.  To
          perform the authorization test other than at the boundary, the host
          that first transferred the message to the receiving ADMD must be
          determined, which can be difficult to extract from the message header
          because (a) header fields can be forged or malformed, and (b) there's
          no standard way to encode that information such that it can be
          reliably extracted.  Testing other than at the boundary is likely to
          produce unreliable results.
        </t>
        </section>
      </section>
      <section title="Receivers" anchor="receiver-policy">
        <t>
          SPF results can be used in combination with other methods to determine
          the final local disposition (either positive or negative of a message.
          It can also be considered dispositive on it's own.
        </t>
        <section title="Policy For SPF Pass">
        <t>
          SPF pass results can be used in combination with "white lists" of
          known "good" domains to bypass some or all additional pre-delivery
          email checks.  Exactly which checks and how to determine appropriate
          white list entries has to be based on local conditions and
          requirements.
        </t>
        </section>
        <section title="Policy For SPF Fail">
        <t>
          SPF fail results can be used to reject messages during the SMTP
          transaction based on either RFC5321.MailFrom or RFC5321.HELO/.EHLO
          identity results.  This reduces resource requirements for various
          content filtering methods and conserves bandwidth since rejection can
          be done before the SMTP content is transferred.  It also gives
          immediate feedback to the sender who might then be able to resolve the
          issue.  Due to some of the issues described above in this
          <xref target="implications"/> section, SPF based rejection does
          present some risk of rejecting legitimate email when rejecting based
          on RFC5321.MailFrom results.
        </t>
        <t>
          SPF fail results can also be used as one input into a larger set of
          evaluations which might, based on the overall evaluation result in the
          email being marked negatively in some way (this might be via delivery
          to a special spam folder, modifying subject lines, or other locally
          determined means).  Developing the details of such an approach have to
          be based on local conditions and requirements.  Using SPF results in
          this way does not have the advantages of resource conservation and
          immediate feedback to the sender associated with SMTP rejection, but
          could produce fewer undesireable rejections in a well designed system.
        </t>
        <t>
          Either general approach can be used as they both leave a clear
          disposition of emails.  They are either delivered in some manner or
          the sender is notified of the failure.  Other dispositions such as
          "dropping" or deleting email after acceptance are inappropriate
          because they leave uncertainty and reduce the overall reliabilility
          and utility of email across the Internet.
        </t>
        </section>
        <section title="Policy For SPF Permerror">
        <t>
          The "permerror" result (see <xref target="op-result-permerror"/>)
          indicates the SPF processing module at the receiver determined that
          the retrieved SPF policy record could not be interpreted.  This
          gives no true indication about the authorized use of the data found
          in the envelope.
        </t>
        <t>
          As with all results, implementers have a choice to make regarding what
          to do with a message that yields this result.  SMTP allows only a few
          basic options.
        </t>
        <t>
          Rejection of the message is an option, in that it is the one thing a
          receiver can do to draw attention to the difficulty encountered while
          protecting itself from messages that do not have a definite SPF result
          of some kind.  However, if the SPF implementation is defective and
          returns spurious "permerror" results, only the sender is actively
          notified of the defect (in the form of rejected mail), and not the
          receiver making use of SPF.
        </t>
        <t>
          The less intrusive handling choice is to deliver the message, perhaps
          with some kind of annotation of the difficulty encountered and/or
          logging of a similar nature.  However, this will not be desirable to
          operators that wish to implement SPF checking as strictly as possible,
          nor is this sort of passive problem reporting typically effective.
        </t>
        <t>
          There is of course the option placing this choice in the hands of the
          operator rather than the implementer since this kind of choice is
          often a matter of local policy rather than a condition with a
          universal solution, but this adds one more piece of complexity to an
          already non-trivial environment.
        </t>
        <t>
          Both implementers and operators need to be cautious of all choices and
          outcomes when handling SPF results.
        </t>
        </section>
      </section>
    </section>
    <section title="Security Considerations" anchor="security">
      <section title="Processing Limits">
        <t>
          As with most aspects of email, there are a number of ways that
          malicious parties could use the protocol as an avenue for a
          <vspace/>
          <!-- FIXME: prevent automatic line break in "Denial-of-Service" -->
          Denial-of-Service (DoS) attack.  The processing limits outlined
          in <xref target="eval-limits"/> are designed to prevent attacks such
          as the following:
        </t>
        <t>
          <!-- <?rfc subcompact="no"?> -->
          <list style="symbols">
            <t>
              A malicious party could create an SPF record with many
              references to a victim's domain and send many emails to
              different SPF clients; those SPF clients would then create a
              DoS attack.  In effect, the SPF clients are being used to
              amplify the attacker's bandwidth by using fewer bytes in the
              SMTP session than are used by the DNS queries.  Using SPF
              clients also allows the attacker to hide the true source of the
              attack.
            </t>
            <t>
              Whereas implementations of check_host() are supposed to limit
              the number of DNS lookups, malicious domains could publish
              records that exceed these limits in an attempt to waste
              computation effort at their targets when they send them mail.
              Malicious domains could also design SPF records that cause
              particular implementations to use excessive memory or CPU
              usage, or to trigger bugs.
            </t>
            <t>
              Malicious parties could send a large volume of mail purporting
              to come from the intended target to a wide variety of
              legitimate mail hosts.  These legitimate machines would then
              present a DNS load on the target as they fetched the relevant
              records.
            </t>
          </list>
          <!-- <?rfc subcompact="yes"?> -->
        </t>
        <t>
          Of these, the case of a third party referenced in the SPF record is
          the easiest for a DoS attack to effectively exploit. As a result,
          limits that might seem reasonable for an individual mail server can
          still allow an unreasonable amount of bandwidth amplification.
          Therefore, the processing limits need to be quite low.
        </t>
        <t>
          MTAs or other processors SHOULD impose a limit on the maximum
          amount of elapsed time to evaluate check_host(). Such a limit
          SHOULD allow at least 20 seconds. If such a limit is exceeded, the
          result of authorization SHOULD be "temperror".
        </t>
      </section>
      <section title="SPF-Authorized Email May Contain Other False Identities">
        <t>
          The RFC5321.MailFrom and RFC5321.HELO/.EHLO identity authorizations must not be
          construed to provide more assurance than they do.  It is entirely
          possible for a malicious sender to inject a message using his own
          domain in the identities used by SPF, to have that domain's SPF
          record authorize the sending host, and yet the message can easily
          list other identities in its header.  Unless the user or the MUA
          takes care to note that the authorized identity does not match the
          other more commonly-presented identities (such as the From: header
          field), the user might be lulled into a false sense of security.
        </t>
      </section>
      <section title="Spoofed DNS and IP Data">
        <t>
          There are two aspects of this protocol that malicious parties could
          exploit to undermine the validity of the check_host() function:
        </t>
        <t>
          <list style="symbols">
            <t>
              The evaluation of check_host() relies heavily on DNS.  A
              malicious attacker could attack the DNS infrastructure and
              cause check_host() to see spoofed DNS data, and then return
              incorrect results.  This could include returning "pass" for an
              &lt;ip&gt; value where the actual domain's record would
              evaluate to "fail".  See <xref target="RFC3833"/> for a
              description of DNS weaknesses.
            </t>
            <t>
              The client IP address, &lt;ip&gt;, is assumed to be correct.  A
              malicious attacker could spoof TCP sequence numbers to make
              mail appear to come from a permitted host for a domain that the
              attacker is impersonating.
            </t>
          </list>
        </t>
      </section>
      <section title="Cross-User Forgery" anchor="cross-user-forgery">
        <t>
          By definition, SPF policies just map domain names to sets of
          authorized MTAs, not whole email addresses to sets of authorized
          users.  Although the "l" macro (<xref target="macros"/>) provides a
          limited way to define individual sets of authorized MTAs for
          specific email addresses, it is generally impossible to verify,
          through SPF, the use of specific email addresses by individual
          users of the same MTA.
        </t>
        <t>
          It is up to mail services and their MTAs to directly prevent<vspace/>
          cross-user forgery: based on SMTP AUTH (<xref target="RFC4954"/>),
          users should be restricted to using only those email addresses
          that are actually under their control (see <xref
          target="RFC6409"/>, Section 6.1).  Another means to verify the
          identity of individual users is message cryptography such as PGP
          (<xref target="RFC4880"/>) or S/MIME (<xref target="RFC5751"/>).
        </t>
      </section>
      <section title="Untrusted Information Sources">
        <t>
          An SPF compliant receiver gathers information from the SMTP commands
          it receives and from the published DNS records of the sending
          domain holder, (e.g., RFC5321.HELO/.EHLO domain name, the RFC5321.MailFrom address
          from the envelope, and SPF DNS records published by the domain
          holder).
        </t>
        <t>
          This information, passed to the receiver in the Received-SPF: trace
          fields, may be returned to the client MTA as an SMTP rejection
          message.  If such an SMTP rejection message is generated, the
          information from the trace fields must be checked for such
          problems as invalid characters and excessively long lines.
        </t>
        <t>
          When the authorization check fails, an explanation string could be
          included in the reject response.  Both the sender and the rejecting
          receiver need to be aware that the explanation was determined by
          the publisher of the SPF record checked and, in general, not the
          receiver.  The explanation can contain malicious URLs, or it might be
          offensive or misleading.
        </t>
        <t>
          Explanations returned to sender domains due to "exp" modifiers,
          (<xref target="mod-exp"/>), were generated by the sender policy
          published by the domain holders themselves.  As long as messages are
          only returned with non-delivery notification (<xref
          target="RFC3464"/>) to domains publishing the explanation strings from
          their own DNS SPF records, the only affected parties are the original
          publishers of the domain's SPF records.
        </t>
        <t>
          In practice, such non-delivery notifications can be misdirected,
          such as when an MTA accepts an email and only later generates the
          notification to a forged address, or when an email forwarder does
          not direct the bounce back to the original sender.
        </t>
      </section>
      <section title="Privacy Exposure">
        <t>
          Checking SPF records causes DNS queries to be sent to the domain
          owner.  These DNS queries, especially if they are caused by the
          "exists" mechanism, can contain information about who is sending
          email and likely to which MTA the email is being sent.  This can
          introduce some privacy concerns, which are more or less of an
          issue depending on local laws and the relationship between the
          domain owner and the person sending the email.
        </t>
      </section>
    </section>
    <section title="Contributors and Acknowledgements">
      <t>
        This document is largely based on the work of Meng Weng Wong, Mark
        Lentczner, and Wayne Schlitt.  Although, as this section acknowledges,
        many people have contributed to this document, a very large portion of
        the writing and editing are due to Meng, Mark, and Wayne.
      </t>
      <t>
        This design owes a debt of parentage to <xref target="RMX"/> by
        Hadmut Danisch and to <xref target="DMP"/> by Gordon Fecyk.  The idea
        of using a DNS record to check the legitimacy of an email address
        traces its ancestry further back through messages on the namedroppers
        mailing list by Paul Vixie <xref target="Vixie"/> (based on
        suggestion by Jim Miller) and by David Green <xref target="Green"/>.
      </t>
      <t>
        Philip Gladstone contributed the concept of macros to the
        specification, multiplying the expressiveness of the language and
        making per-user and per-IP lookups possible.
      </t>
      <t>
        The authors of both this document and <xref target="RFC4408"/> would
        also like to thank the literally hundreds of individuals who have
        participated in the development of this design. They are far too
        numerous to name, but they include the following:
      </t>
      <t>
        <list style="empty">
          <t>
            The participants in the SPFbis working group.<vspace/>
            The folks on the spf-discuss mailing list.<vspace/>
            The folks on the SPAM-L mailing list.<vspace/>
            The folks on the IRTF ASRG mailing list.<vspace/>
            The folks on the IETF MARID mailing list.<vspace/>
            The folks on #perl.
          </t>
        </list>
      </t>
    </section>
    <section title="IANA Considerations">
      <section title="The SPF DNS Record Type">
        <t>
          Per <xref target="RFC4408"/>, the IANA assigned the Resource Record
          Type and Qtype from the DNS Parameters Registry for the SPF RR type
          with code 99.   The format of this type is identical to the TXT RR
          <xref target="RFC1035"/>.  The character content of the record is
          encoded as <xref target="US-ASCII"/>.  Use of this record type is
          obsolete for SPF Version 1.
        </t>
        <t>
          IANA is requested to add an annotation to the SPF RRTYPE saying 
          "(OBSOLETE - use TXT)" in the DNS Parameters registry.
        </t>
        <t>
          [NOTE TO RFC EDITOR: (to be changed to " ... has added ..." upon
          publication)]
        </t>
      </section>
      <section title="The Received-SPF Mail Header Field">
        <t>
          Per <xref target="RFC3864"/>,
          the "Received-SPF:" header field is added to the IANA
          Permanent Message Header Field Registry.  The following is the
          registration template:
        </t>
        <t>
          <list style="empty">
            <t>
              Header field name: Received-SPF<vspace/>
              Applicable protocol: mail (<xref target="RFC5322"/>)<vspace/>
              Status: Standards Track<vspace/>
              Author/Change controller: IETF<vspace/>
              Specification document(s): RFC &rfc.number;<vspace/>
              [NOTE TO RFC EDITOR: (this document)]
            </t>
          </list>
        </t>
      </section>
      <section anchor="iana-spf-tags" title="SPF Modifier Registration">
          <t>
              <xref target="RFC6652"/> created a new SPF Modifier Registration.
              IANA is requested to change the reference for the exp and redirect
              modifiers from <xref target="RFC4408"/> to this document.  Their
              status should not be changed.
          </t>
      </section>
    </section>
  </middle>
  <back>
    <references title="Normative References">
      &rfc1035;
      &rfc1123;
      &rfc2119;
      &rfc3463;
      &rfc3864;
      &rfc3986;
      &rfc4291;
      &rfc5234;
      &rfc5321;
      &rfc5322;
      &rfc5451;
      &rfc5598;
      &rfc5890;
      <reference anchor="US-ASCII">
        <front>
          <title>USA Code for Information Interchange, X3.4</title>
          <author>
            <organization abbrev="ANSI">
              American National Standards Institute (formerly United States of
              America Standards Institute)
            </organization>
          </author>
          <date year="1968"/>
        </front>
        <annotation>
          ANSI X3.4-1968 has been replaced by newer versions with
          slight modifications, but the 1968 version remains
          definitive for the Internet. 
        </annotation>
      </reference>
    </references>
    <references title="Informative References">
      &rfc1034;
      &rfc1983;
      &rfc2308;
      &rfc2782;
      &rfc3464;
      &rfc3696;
      &rfc3833;
      &rfc3834;
      &rfc4408;
      &rfc4632;
      &rfc4880;
      &rfc4954;
      &rfc5617;
      &rfc5751;
      &rfc5782;
      &rfc6409;
      &rfc6647;
      &rfc6652;
      &rfc6686;
      <reference anchor="RMX">
        <front>
          <title>The RMX DNS RR Type for light weight sender authentication</title>
          <author fullname="Hadmut Danisch" initials="H." surname="Danisch">
            <organization/>
          </author>
        </front>
        <format type="HTML" target="http://www.danisch.de/work/security/antispam.html"/>
        <annotation>Work In Progress</annotation>
      </reference>
      <reference anchor="DMP">
        <front>
          <title>Designated Mailers Protocol</title>
          <author fullname="Gordon Fecyk" initials="G." surname="Fecyk">
            <organization/>
          </author>
        </front>
        <format type="HTML" target="http://www.pan-am.ca/dmp/"/>
        <annotation>Work In Progress</annotation>
      </reference>
      <reference anchor="Vixie">
        <front>
          <title>Repudiating MAIL FROM</title>
          <author fullname="Paul Vixie" initials="P." surname="Vixie">
            <organization/>
          </author>
          <date year="2002"/>
        </front>
        <format type="HTML" target="http://ops.ietf.org/lists/namedroppers/namedroppers.2002/msg00658.html"/>
      </reference>
      <reference anchor="Green">
        <front>
          <title>Domain-Authorized SMTP Mail</title>
          <author fullname="David Green" initials="D." surname="Green">
            <organization/>
          </author>
          <date year="2002"/>
        </front>
        <format type="HTML" target="http://ops.ietf.org/lists/namedroppers/namedroppers.2002/msg00656.html"/>
      </reference>
    </references>
    <section title="Collected ABNF">
      <t>
        This section is normative and any discrepancies with the ABNF
        fragments in the preceding text are to be resolved in favor of this
        grammar. 
      </t>
      <t>
        See <xref target="RFC5234"/> for ABNF notation. Please note that as
        per this ABNF definition, literal text strings (those in quotes) are
        case-insensitive.  Hence, "mx" matches "mx", "MX", "mX", and "Mx".
      </t>
      <figure>
        <artwork type="abnf"><![CDATA[
record           = version terms *SP
version          = "v=spf1"

terms            = *( 1*SP ( directive / modifier ) )

directive        = [ qualifier ] mechanism
qualifier        = "+" / "-" / "?" / "~"
mechanism        = ( all / include
                   / A / MX / PTR / IP4 / IP6 / exists )

all              = "all"
include          = "include"  ":" domain-spec
A                = "a"      [ ":" domain-spec ] [ dual-cidr-length ]
MX               = "mx"     [ ":" domain-spec ] [ dual-cidr-length ]
PTR              = "ptr"    [ ":" domain-spec ]
IP4              = "ip4"      ":" ip4-network   [ ip4-cidr-length ]
IP6              = "ip6"      ":" ip6-network   [ ip6-cidr-length ]
exists           = "exists"   ":" domain-spec

modifier         = redirect / explanation / unknown-modifier
redirect         = "redirect" "=" domain-spec
explanation      = "exp" "=" domain-spec
unknown-modifier = name "=" macro-string
                   ; where name is not any known modifier

ip4-cidr-length  = "/" 1*DIGIT
ip6-cidr-length  = "/" 1*DIGIT
dual-cidr-length = [ ip4-cidr-length ] [ "/" ip6-cidr-length ]

ip4-network      = qnum "." qnum "." qnum "." qnum
qnum             = DIGIT                 ; 0-9
                   / %x31-39 DIGIT       ; 10-99
                   / "1" 2DIGIT          ; 100-199
                   / "2" %x30-34 DIGIT   ; 200-249
                   / "25" %x30-35        ; 250-255
         ; conventional dotted quad notation.  e.g., 192.0.2.0
ip6-network      = <as per [RFC 4291], section 2.2>
         ; e.g., 2001:DB8::CD30

domain-spec      = macro-string domain-end
domain-end       = ( "." toplabel [ "." ] ) / macro-expand

toplabel         = ( *alphanum ALPHA *alphanum ) /
                   ( 1*alphanum "-" *( alphanum / "-" ) alphanum )
                   ; LDH rule plus additional TLD restrictions
                   ; (see [RFC3696], Section 2 for background)
alphanum         = ALPHA / DIGIT

explain-string   = *( macro-string / SP )

macro-string     = *( macro-expand / macro-literal )
macro-expand     = ( "%{" macro-letter transformers *delimiter "}" )
                   / "%%" / "%_" / "%-"
macro-literal    = %x21-24 / %x26-7E
                   ; visible characters except "%"
macro-letter     = "s" / "l" / "o" / "d" / "i" / "p" / "h" /
                   "c" / "r" / "t" / "v"
transformers     = *DIGIT [ "r" ]
delimiter        = "." / "-" / "+" / "," / "/" / "_" / "="

name             = ALPHA *( ALPHA / DIGIT / "-" / "_" / "." )

header-field     = "Received-SPF:" [CFWS] result FWS [comment FWS]
                   [ key-value-list ] CRLF

result           = "pass" / "fail" / "softfail" / "neutral" /
                   "none" / "temperror" / "permerror"

key-value-list   = key-value-pair *( ";" [CFWS] key-value-pair )
                   [";"]

key-value-pair   = key [CFWS] "=" ( dot-atom / quoted-string )

key              = "client-ip" / "envelope-from" / "helo" /
                   "problem" / "receiver" / identity /
                    mechanism / name

identity         = "mailfrom"   ; for the RFC5321.MailFrom identity
                   / "helo"     ; for the RFC5321.HELO/.EHLO identity
                   / name       ; other identities

ALPHA            = <A-Z / a-z as per [RFC5234]>
DIGIT            = <0-9 as per [RFC5234]>
SP               = <space character as per [RFC5234]>
domain           = <fully qualified domain as per [RFC5321]>
dot-atom         = <unquoted word as per [RFC5322]>
quoted-string    = <quoted string as per [RFC5322]>
comment          = <comment string as per [RFC5322]>
CFWS             = <comment or folding white space as per [RFC5322]>
FWS              = <folding white space as per [RFC5322]>
CRLF             = <standard end-of-line token as per [RFC5322]>
authserv-id      = <authserv-id per [RFC5451]>
reasonspec       = <reason per [RFC5451]>
]]></artwork>
      </figure>
    </section>
    <section title="Extended Examples" anchor="examples">
      <t>These examples are based on the following DNS setup:</t>
      <figure>
        <artwork>
; A domain with two mail servers, two hosts
; and two servers at the domain name 
$ORIGIN example.com.
@           MX  10 mail-a
            MX  20 mail-b
            A   192.0.2.10
            A   192.0.2.11
amy         A   192.0.2.65
bob         A   192.0.2.66
mail-a      A   192.0.2.129
mail-b      A   192.0.2.130
www         CNAME example.com.

; A related domain
$ORIGIN example.org.
@           MX  10 mail-c
mail-c      A   192.0.2.140

; The reverse IP for those addresses
$ORIGIN 2.0.192.in-addr.arpa.
10          PTR example.com.
11          PTR example.com.
65          PTR amy.example.com.
66          PTR bob.example.com.
129         PTR mail-a.example.com.
130         PTR mail-b.example.com.
140         PTR mail-c.example.org.

; A rogue reverse IP domain that claims to be
; something it's not
$ORIGIN 0.0.10.in-addr.arpa.
4           PTR bob.example.com.
        </artwork>
      </figure>
      <section title="Simple Examples">
        <t>
          These examples show various possible published records for
          example.com and which values if &lt;ip&gt; would cause check_host()
          to return "pass". Note that &lt;domain&gt; is "example.com". 
        </t>
        <?rfc compact="yes"?>
        <t>
          v=spf1 +all
          <list style="hanging" hangIndent="7">
            <t hangText="&nbsp;&nbsp;&nbsp;--">any &lt;ip&gt; passes</t>
          </list>
        </t>
        <t>
          v=spf1 a -all
          <list style="hanging" hangIndent="7">
            <t hangText="&nbsp;&nbsp;&nbsp;--">hosts 192.0.2.10 and 192.0.2.11 pass</t>
          </list>
        </t>
        <t>
          v=spf1 a:example.org -all
          <list style="hanging" hangIndent="7">
            <t hangText="&nbsp;&nbsp;&nbsp;--">
              no sending hosts pass since example.org has no A records
            </t>
          </list>
        </t>
        <t>
          v=spf1 mx -all
          <list style="hanging" hangIndent="7">
            <t hangText="&nbsp;&nbsp;&nbsp;--">sending hosts 192.0.2.129 and 192.0.2.130 pass</t>
          </list>
        </t>
        <t>
          v=spf1 mx:example.org -all
          <list style="hanging" hangIndent="7">
            <t hangText="&nbsp;&nbsp;&nbsp;--">sending host 192.0.2.140 passes</t>
          </list>
        </t>
        <t>
          v=spf1 mx mx:example.org -all
          <list style="hanging" hangIndent="7">
            <t hangText="&nbsp;&nbsp;&nbsp;--">
              sending hosts 192.0.2.129, 192.0.2.130, and 192.0.2.140 pass
            </t>
          </list>
        </t>
        <t>
          v=spf1 mx/30 mx:example.org/30 -all
          <list style="hanging" hangIndent="7">
            <t hangText="&nbsp;&nbsp;&nbsp;--">
              any sending host in 192.0.2.128/30 or 192.0.2.140/30 passes
            </t>
          </list>
        </t>
        <t>
          v=spf1 ptr -all
          <list style="hanging" hangIndent="7">
            <t hangText="&nbsp;&nbsp;&nbsp;--">
              sending host 192.0.2.65 passes (reverse DNS is valid and is in example.com)
            </t>
            <t hangText="&nbsp;&nbsp;&nbsp;--">
              sending host 192.0.2.140 fails (reverse DNS is valid, but not in example.com)
            </t>
            <t hangText="&nbsp;&nbsp;&nbsp;--">
              sending host 10.0.0.4 fails (reverse IP is not valid)
            </t>
          </list>
        </t>
        <t>
          v=spf1 ip4:192.0.2.128/28 -all
          <list style="hanging" hangIndent="7">
            <t hangText="&nbsp;&nbsp;&nbsp;--">sending host 192.0.2.65 fails</t>
            <t hangText="&nbsp;&nbsp;&nbsp;--">sending host 192.0.2.129 passes</t>
          </list>
        </t>
        <?rfc compact="no"?>
      </section>
      <section title="Multiple Domain Example">
        <t>These examples show the effect of related records:</t>
        <t>
          <list style="empty">
            <t>example.org: "v=spf1 include:example.com include:example.net -all"</t>
          </list>
        </t>
        <t>
          This record would be used if mail from example.org actually came
          through servers at example.com and example.net. Example.org's
          designated servers are the union of example.com's and example.net's
          designated servers. 
        </t>
        <t>
          <?rfc compact="yes"?>
          <list style="empty">
            <t>la.example.org: "v=spf1 redirect=example.org"</t>
            <t>ny.example.org: "v=spf1 redirect=example.org"</t>
            <t>sf.example.org: "v=spf1 redirect=example.org"</t>
          </list>
          <?rfc compact="no"?>
        </t>
        <t>
          These records allow a set of domains that all use the same mail
          system to make use of that mail system's record. In this way, only
          the mail system's record needs to be updated when the mail setup
          changes.  These domains' records never have to change. 
        </t>
      </section>
      <section title="DNSBL Style Example">
        <t>
          Imagine that, in addition to the domain records listed above, there
          are these: 
        </t>
        <figure>
          <artwork>
$ORIGIN _spf.example.com.
mary.mobile-users                   A 127.0.0.2
fred.mobile-users                   A 127.0.0.2
15.15.168.192.joel.remote-users     A 127.0.0.2
16.15.168.192.joel.remote-users     A 127.0.0.2
          </artwork>
        </figure>
        <t>
          The following records describe users at example.com who mail from
          arbitrary servers, or who mail from personal servers. 
        </t>
        <t>example.com:</t>
        <figure>
          <artwork>
v=spf1 mx
       include:mobile-users._spf.%{d}
       include:remote-users._spf.%{d}
       -all
          </artwork>
        </figure>
        <t>mobile-users._spf.example.com: </t>
        <figure>
          <artwork>
v=spf1 exists:%{l1r+}.%{d}
          </artwork>
        </figure>
        <t>remote-users._spf.example.com: </t>
        <figure>
          <artwork>
v=spf1 exists:%{ir}.%{l1r+}.%{d}
          </artwork>
        </figure>
      </section>
      <section title="Multiple Requirements Example">
        <t>
          Say that your sender policy requires both that the IP address is
          within a certain range and that the reverse DNS for the IP matches.
          This can be done several ways, including the following:
        </t>
        <figure>
          <artwork>
example.com.           SPF  ( "v=spf1 "
                              "-include:ip4._spf.%{d} "
                              "-include:ptr._spf.%{d} "
                              "+all" )
ip4._spf.example.com.  SPF  "v=spf1 -ip4:192.0.2.0/24 +all"
ptr._spf.example.com.  SPF  "v=spf1 -ptr +all"
          </artwork>
        </figure>
        <t>
          This example shows how the "-include" mechanism can be useful, how
          an SPF record that ends in "+all" can be very restrictive, and the
          use of De Morgan's Law.
        </t>
      </section>
    </section>
    <section title="Change History" anchor="changelog">
      <t>Changes since RFC 4408 (to be removed prior to publication)</t>
      <t>
          <list style="empty">
            <t>Moved to standards track</t>
            <t>Authors updated</t>
            <t>IESG Note regarding experimental use replaced with discussion of results</t>
            <t>Process errata:</t>
            <t>Add %v macro to ABNF grammar</t>
            <t>Replace "uric" by "unreserved"</t>
            <t>Recommend an SMTP reply code for optional permerror rejections</t>
            <t>Correct syntax in Received-SPF examples</t>
            <t>Fix unknown-modifier clause is too greedy in ABNF</t>
            <t>Correct use of empty domain-spec on exp modifier</t>
            <t>Fix minor typo errata</t>
            <t>Convert to spfbis working group draft, draft-ietf-spfbis-4408bis-00</t>
            <t>Addressed Ticket #1, RFC 4408 Section 2.5.6 - Temporary errors
               by giving the option to turn repeated SERVFAIL into permerror
               and adding RFC 2308 reference.</t>
            <t>Clarified text about IPv4 mapped addresses to resolve test suite
               ambiguity</t>
            <t>Clarified ambiguity about result when more than 10 "mx" or "ptr"
               records are returned for lookup to specify permerror.  This resolves
               one of the test suite ambiguities</t>
            <t>Made all references to result codes lower case per issue #7</t>
            <t>Adjusted section 2.2 Requirement to check mail from per issue #15</t>
            <t>Added missing "v" element in macro-letter in the collected
               ABNF per issue #16 - section 8.1 was already fixed in the
               pre-WG draft</t>
            <t>Marked ptr and "p" macro deprecated/SHOULD NOT use per issue #27</t>
            <t>Expunged lower case may from the draft per issue #8</t>
            <t>Expunged "x-" name as an obsolete concept</t>
            <t>Updated obslete references: RFC2821 to RFC5321, RFC2822 to
               RFC5322, and RFC4234 to RFC5234</t>
            <t>Refer to RFC6647 to describe greylisting instead of trying to
               describe it directly.</t>
            <t>Updated informative references to the current versions.</t>
            <t>Added definition for deprecated since there are questions.</t>
            <t>Start to rework section 9 with some RFC5598 terms.</t>
            <t>Added mention of RFC 6552 feedback reports in section 9.</t>
            <t>Added draft-ietf-spfbis-experiment as an informational reference.</t>
            <t>Drop Type SPF.</t>
            <t>Try and clarify informational nature of RFC3696</t>
            <t>Fix ABNF nits and add missing definitions per Bill's ABNF checker.</t>
            <t>Make DNS lookup time limit SHOULD instead of MAY.</t>
            <t>Reorganize and clarify processing limits.  Move hard limits to
               new section 4.6.4, Evaluation Limits.  Move advice to
               non-normative section 9.</t>
            <t>Removed paragraph in section 10.1 about limiting total data volumes
               as it is unused (and removable per the charter) and serves no purpose
               (it isn't something that actually can be implemented in any reasonable
               way).</t>
            <t>Added text and figures from Alessandro Vesely in section 9.1 to
               better explain DNS resource limits.</t>
            <t>Multiple editorial fixes from Murray Kucherawy's review.</t>
            <t>Also based on Murray's review, reworked SMTP identity definitions
               and made RFC 5598 a normative reference instead of informative.
               This is a downref that will have to be mentioned in the last
               call.</t>
            <t>Added RFC 3834 as an informative reference about backscatter.</t>
            <t>Added IDN requirements and normative reference to RFC 5890 to
               deal with the question "like DKIM did it.:</t>
            <t>Added informative reference to RFC 4632 for CIDR and use CIDR
               prefix length instead of CIDR-length to match its terminology.</t>
            <t> Added RFC 5782 informative reference on DNSxLs to support
                improving the exists description.</t>
            <t>Added text on creating a Authentication-Results header field that
               matches the Received-SPF header field information and added a
               normative reference to RFC 5451.</t>
            <t>Added informative reference to RFC 2782 due to SRV mention.</t>
            <t>Added informative reference to RFC 3464 due to DSN mention.</t>
            <t>Added informative reference to RFC 5617 for it's DNS wildcard use.</t>
            <t>Added informative reference to RFC 5782 to enhance the
               explanation of how the exists mechanism works.  Clarified the
               intended match/no-match method.</t>
            <t>Added new sections on Receiver policy for SPF pass, fail, and
               permerror.</t>
            <t>Added new section 9 discussion on treatment of bounces and the
               significance of HELO records.</t>
            <t> Added request to IANA to update the SPF modifier registry.</t>
          </list>
      </t>
    </section>
  </back>
</rfc>
<!-- vim:set sw=2 sts=2 et tw=77: -->
