<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="yes" ?>
<rfc category="std" docName="draft-ietf-keyprov-dskpp-12.txt"
     ipr="pre5378Trust200902">
  <front>
    <title abbrev="DSKPP">Dynamic Symmetric Key Provisioning Protocol
    (DSKPP)</title>

    <author fullname="Andrea Doherty" initials="A." surname="Doherty">
      <organization>RSA, The Security Division of EMC</organization>

      <address>
        <postal>
          <street>174 Middlesex Turnpike</street>

          <city>Bedford</city>

          <region>MA</region>

          <code>01730</code>

          <country>USA</country>
        </postal>

        <email>andrea.doherty@rsa.com</email>
      </address>
    </author>

    <author fullname="Mingliang Pei" initials="M." surname="Pei">
      <organization>VeriSign, Inc.</organization>

      <address>
        <postal>
          <street>487 E. Middlefield Road</street>

          <city>Mountain View</city>

          <region>CA</region>

          <code>94043</code>

          <country>USA</country>
        </postal>

        <email>mpei@verisign.com</email>
      </address>
    </author>

    <author fullname="Salah Machani" initials="S." surname="Machani">
      <organization>Diversinet Corp.</organization>

      <address>
        <postal>
          <street>2225 Sheppard Avenue East, Suite 1801</street>

          <city>Toronto</city>

          <region>Ontario</region>

          <code>M2J 5C2</code>

          <country>Canada</country>
        </postal>

        <email>smachani@diversinet.com</email>
      </address>
    </author>

    <author fullname="Magnus Nystrom" initials="M." surname="Nystrom">
      <organization>Microsoft Corp.</organization>

      <address>
        <postal>
          <street>One Microsoft Way</street>

          <city>Redmond</city>

          <region>WA</region>

          <code>98052</code>

          <country>USA</country>
        </postal>

        <email>mnystrom@microsoft.com</email>
      </address>
    </author>

    <date day="29" month="August" year="2010" />

    <area>Security Area</area>

    <workgroup>KEYPROV Working Group</workgroup>

    <abstract>
      <t>DSKPP is a client-server protocol for initialization (and
      configuration) of symmetric keys to locally and remotely accessible
      cryptographic modules. The protocol can be run with or without
      private-key capabilities in the cryptographic modules, and with or
      without an established public-key infrastructure.</t>

      <t>Two variations of the protocol support multiple usage scenarios. With
      the four-pass variant, keys are mutually generated by the provisioning
      server and cryptographic module; provisioned keys are not transferred
      over-the-wire or over-the-air. The two-pass variant enables secure and
      efficient download and installation of pre-generated symmetric keys to a
      cryptographic module.</t>
    </abstract>
  </front>

  <middle>
    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Introduction">
      <t>Symmetric key based cryptographic systems (e.g., those providing
      authentication mechanisms such as one-time passwords and
      challenge-response) offer performance and operational advantages over
      public key schemes. Such use requires a mechanism for provisioning of
      symmetric keys providing equivalent functionality to mechanisms such as
      CMP <xref target="RFC4210"></xref> and CMC <xref
      target="RFC5272"></xref> in a Public Key Infrastructure.</t>

      <t>Traditionally, cryptographic modules have been provisioned with keys
      during device manufacturing, and the keys have been imported to the
      cryptographic server using, e.g., a CD-ROM disc shipped with the
      devices. Some vendors also have proprietary provisioning protocols,
      which often have not been publicly documented (CT-KIP is one exception
      <xref target="RFC4758"></xref>).</t>

      <t>This document describes the Dynamic Symmetric Key Provisioning
      Protocol (DSKPP), a client-server protocol for provisioning symmetric
      keys between a cryptographic module (corresponding to DSKPP client) and
      a key provisioning server (corresponding to DSKPP server).</t>

      <t>DSKPP provides an open and interoperable mechanism for initializing
      and configuring symmetric keys to cryptographic modules that are
      accessible over the Internet. The description is based on the
      information contained in <xref target="RFC4758"></xref>, and contains
      specific enhancements, such as User Authentication and support for the
      <xref target="PSKC"></xref> format for transmission of keying
      material.</t>

      <t>DSKPP has two principal protocol variants. The four-pass protocol
      variant permits a symmetric key to be established that includes
      randomness contributed by both the client and the server. The two-pass
      protocol requires only one round trip instead of two and permits a
      server specified key to be established.</t>

      <section title="Key Words">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119"></xref>.</t>
      </section>

      <section title="Version Support">
        <t>There is a provision made in the syntax for an explicit version
        number. Only version "1.0" is currently specified.</t>

        <t>The purpose for versioning the protocol is to provide a mechanism
        by which changes to required cryptographic algorithms (e.g., SHA-256)
        and attributes (e.g., key size) can be deployed without disrupting
        existing implementations; likewise, out-dated implementations can be
        de-commissioned without disrupting operations involving newer protocol
        versions.</t>

        <t>The numbering scheme for DSKPP versions is
        "&lt;major&gt;.&lt;minor&gt;". The major and minor numbers MUST be
        treated as separate integers and each number MAY be incremented higher
        than a single digit. Thus, "DSKPP 2.4" would be a lower version than
        "DSKPP 2.13", which in turn would be lower than "DSKPP 12.3". Leading
        zeros (e.g., "DSKPP 6.01") MUST be ignored by recipients and MUST NOT
        be sent.</t>

        <t>The major version number should be incremented only if the data
        formats or security algorithms have changed so dramatically that an
        older version implementation would not be able to interoperate with a
        newer version (e.g., removing support for a previously
        mandatory-to-implement algorithm now found to be insecure). The minor
        version number indicates new capabilities (e.g., introducing a new
        algorithm option) and MUST be ignored by an entity with a smaller
        minor version number, but used for informational purposes by the
        entity with the larger minor version number.</t>
      </section>

      <section title="Namespace Identifiers">
        <t>This document uses Uniform Resource Identifiers <xref
        target="RFC3986"></xref> to identify resources, algorithms, and
        semantics.</t>

        <section title="Defined Identifiers">
          <t>The XML namespace <xref target="XMLNS"></xref> URI for Version
          1.0 of DSKPP protocol is:</t>

          <t>"urn:ietf:params:xml:ns:keyprov:dskpp"</t>

          <t>References to qualified elements in the DSKPP schema defined
          herein use the prefix "dskpp", but any prefix is allowed.</t>
        </section>

        <section title="Identifiers Defined in Related Specifications">
          <t>This document relies on qualified elements already defined in the
          Portable Symmetric Key Container <xref target="PSKC"></xref>
          namespace, which is represented by the prefix "pskc" and declared
          as:</t>

          <t>xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"</t>
        </section>

        <section title="Referenced Identifiers">
          <t>Finally, the DSKPP syntax presented in this document relies on
          algorithm identifiers defined in the XML Signature <xref
          target="XMLDSIG"></xref> namespace:</t>

          <t>xmlns:ds="http://www.w3.org/2000/09/xmldsig#"</t>

          <t>References to algorithm identifiers in the XML Signature
          namespace are represented by the prefix "ds".</t>
        </section>
      </section>
    </section>

    <section anchor="terms" title="Terminology">
      <section anchor="Subsection-Definitions" title="Definitions">
        <t>The definitions provided below are defined as used in this
        document. The same terms may be defined differently in other
        documents.</t>

        <t><list hangIndent="4" style="hanging">
            <t hangText="Authentication Code (AC):">User Authentication Code
            comprised of a string of hexadecimal characters known to the
            device and the server and containing at a minimum a client
            identifier and a password. This ClientID/password combination is
            used only once and may have a time limit, and then
            discarded.<vspace blankLines="1" /></t>

            <t hangText="Authentication Data (AD):">User Authentication Data
            that is derived from the Authentication Code (AC)<vspace
            blankLines="1" /></t>

            <t hangText="Client ID:">An identifier that the DSKPP Server uses
            to locate the real user name or account identifier on the server.
            It can be a short random identifier that is unrelated to any real
            usernames.<vspace blankLines="1" /></t>

            <t hangText="Cryptographic Module:">A component of an application,
            which enables symmetric key cryptographic functionality<vspace
            blankLines="1" /></t>

            <t hangText="Device:">A physical piece of hardware, or a software
            framework, that hosts symmetric key cryptographic modules<vspace
            blankLines="1" /></t>

            <t hangText="Device ID (DeviceID):">A unique identifier for the
            device that houses the cryptographic module, e.g., a mobile
            phone<vspace blankLines="1" /></t>

            <t hangText="DSKPP Client:">Manages communication between the
            symmetric key cryptographic module and the DSKPP server<vspace
            blankLines="1" /></t>

            <t hangText="DSKPP Server:">The symmetric key provisioning server
            that participates in the DSKPP protocol run<vspace
            blankLines="1" /></t>

            <t hangText="DSKPP Server ID (ServerID):">The unique identifier of
            a DSKPP server<vspace blankLines="1" /></t>

            <t hangText="Key Agreement:">A key establishment protocol whereby
            two or more parties can agree on a key in such a way that both
            influence the outcome<vspace blankLines="1" /></t>

            <t hangText="Key Confirmation:">The assurance of the rightful
            participants in a key-establishment protocol that the intended
            recipient of the shared key actually possesses the shared
            key<vspace blankLines="1" /></t>

            <t hangText="Key Issuer:">An organization that issues symmetric
            keys to end-users<vspace blankLines="1" /></t>

            <t hangText="Key Package (KP):">An object that encapsulates a
            symmetric key and its configuration data<vspace
            blankLines="1" /></t>

            <t hangText="Key ID (KeyID):">A unique identifier for the
            symmetric key<vspace blankLines="1" /></t>

            <t hangText="Key Protection Method (KPM):">The key transport
            method used during two-pass DSKPP<vspace blankLines="1" /></t>

            <t hangText="Key Protection Method List (KPML):">The list of key
            protection methods supported by a cryptographic module<vspace
            blankLines="1" /></t>

            <t hangText="Key Provisioning Server:">A lifecycle management
            system that provides a key issuer with the ability to provision
            keys to cryptographic modules hosted on end-users' devices<vspace
            blankLines="1" /></t>

            <t hangText="Key Transport:">A key establishment procedure whereby
            the DSKPP server selects and encrypts the keying material and then
            sends the material to the DSKPP client <xref
            target="NIST-SP800-57"></xref><vspace blankLines="1" /></t>

            <t hangText="Key Transport Key:">The private key that resides on
            the cryptographic module. This key is paired with the DSKPP
            client's public key, which the DSKPP server uses to encrypt keying
            material during key transport <xref
            target="NIST-SP800-57"></xref><vspace blankLines="1" /></t>

            <t hangText="Key Type:">The type of symmetric key cryptographic
            methods for which the key will be used (e.g., OATH HOTP or RSA
            SecurID authentication, AES encryption, etc.)<vspace
            blankLines="1" /></t>

            <t hangText="Key Wrapping:">A method of encrypting keys for key
            transport <xref target="NIST-SP800-57"></xref><vspace
            blankLines="1" /></t>

            <t hangText="Key Wrapping Key:">A symmetric key encrypting key
            used for key wrapping <xref target="NIST-SP800-57"></xref><vspace
            blankLines="1" /></t>

            <t hangText="Keying Material:">The data necessary (e.g., keys and
            key configuration data) necessary to establish and maintain
            cryptographic keying relationships <xref
            target="NIST-SP800-57"></xref><vspace blankLines="1" /></t>

            <t hangText="Manufacturer's Key">A unique master key pre-issued to
            a hardware device, e.g., a smart card, during the manufacturing
            process. If present, this key may be used by a cryptographic
            module to derive secret keys<vspace blankLines="1" /></t>

            <t hangText="Protocol Run:">Complete execution of the DSKPP that
            involves one exchange (2-pass) or two exchanges (4-pass)<vspace
            blankLines="1" /></t>

            <t hangText="Security Attribute List (SAL):">A payload that
            contains the DSKPP version, DSKPP variant (four- or two-pass), key
            package formats, key types, and cryptographic algorithms that the
            cryptographic module is capable of supporting<vspace
            blankLines="1" /></t>
          </list></t>
      </section>

      <section title="Notation">
        <t><list hangIndent="20" style="hanging">
            <t hangText="||">String concatenation<vspace blankLines="0" /></t>

            <t hangText="[x]">Optional element x<vspace blankLines="0" /></t>

            <t hangText="A ^ B">Exclusive-OR operation on strings A and B
            (where A and B are of equal length)<vspace blankLines="0" /></t>

            <t hangText="&lt;XMLElement&gt;">A typographical convention used
            in the body of the text<vspace blankLines="0" /></t>

            <t hangText="DSKPP-PRF(k,s,dsLen)">A keyed pseudo-random
            function<vspace blankLines="0" /></t>

            <t hangText="E(k,m)">Encryption of m with the key k<vspace
            blankLines="0" /></t>

            <t hangText="K">Key used to encrypt R_C (either K_SERVER or
            K_SHARED), or in MAC or DSKPP_PRF computations<vspace
            blankLines="0" /></t>

            <t hangText="K_AC">Secret key that is derived from the
            Authentication Code and used for user authentication
            purposes<vspace blankLines="0" /></t>

            <t hangText="K_MAC">Secret key derived during a DSKPP exchange for
            use with key confirmation<vspace blankLines="0" /></t>

            <t hangText="K_MAC'">A second secret key used for server
            authentication<vspace blankLines="0" /></t>

            <t hangText="K_PROV">A provisioning master key from which two keys
            are derived: K_TOKEN and K_MAC<vspace blankLines="0" /></t>

            <t hangText="K_SERVER">Public key of the DSKPP server; used for
            encrypting R_C in the four-pass protocol variant<vspace
            blankLines="0" /></t>

            <t hangText="K_SHARED">Secret key that is pre-shared between the
            DSKPP client and the DSKPP server; used for encrypting R_C in the
            four-pass protocol variant<vspace blankLines="0" /></t>

            <t hangText="K_TOKEN">Secret key that is established in a
            cryptographic module using DSKPP<vspace blankLines="0" /></t>

            <t hangText="R">Pseudorandom value chosen by the DSKPP client and
            used for MAC computations<vspace blankLines="0" /></t>

            <t hangText="R_C">Pseudorandom value chosen by the DSKPP client
            and used as input to the generation of K_TOKEN<vspace
            blankLines="0" /></t>

            <t hangText="R_S">Pseudorandom value chosen by the DSKPP server
            and used as input to the generation of K_TOKEN<vspace
            blankLines="0" /></t>

            <t hangText="URL_S">DSKPP server address, as a URL<vspace
            blankLines="0" /></t>
          </list></t>
      </section>

      <section title="Abbreviations">
        <t><list hangIndent="8" style="hanging">
            <t hangText="AC">Authentication Code</t>

            <t hangText="AD">Authentication Data</t>

            <t hangText="DSKPP">Dynamic Symmetric Key Provisioning
            Protocol</t>

            <t hangText="HTTP">Hypertext Transfer Protocol</t>

            <t hangText="KP">Key Package</t>

            <t hangText="KPM">Key Protection Method</t>

            <t hangText="KPML">Key Protection Method List</t>

            <t hangText="MAC">Message Authentication Code</t>

            <t hangText="PC">Personal Computer</t>

            <t hangText="PDU">Protocol Data Unit</t>

            <t hangText="PKCS">Public-Key Cryptography Standards</t>

            <t hangText="PRF">Pseudo-Random Function</t>

            <t hangText="PSKC">Portable Symmetric Key Container</t>

            <t hangText="SAL">Security Attribute List (see <xref
            target="Subsection-Definitions"></xref>)</t>

            <t hangText="TLS">Transport Layer Security</t>

            <t hangText="URL">Uniform Resource Locator</t>

            <t hangText="USB">Universal Serial Bus</t>

            <t hangText="XML">eXtensible Markup Language</t>
          </list></t>
      </section>
    </section>

    <section title="DSKPP Overview">
      <t>The following sub-sections provide a high-level view of protocol
      internals and how they interact with external provisioning applications.
      Usage scenarios are provided in <xref
      target="Section-Usage-Scenarios"></xref>.</t>

      <section title="Protocol Entities">
        <t>A DSKPP provisioning transaction has three entities:</t>

        <t><list hangIndent="4" style="hanging">
            <t hangText="Server: ">The DSKPP provisioning server.<vspace
            blankLines="1" /></t>

            <t hangText="Cryptographic Module:">The cryptographic module to
            which the symmetric keys are to be provisioned, e.g., an
            authentication token.<vspace blankLines="1" /></t>

            <t hangText="Client:">The DSKPP client which manages communication
            between the cryptographic module and the key provisioning
            server.</t>
          </list></t>

        <t>The principal syntax is XML <xref target="XML"></xref> and it is
        layered on a transport mechanism such as HTTP <xref
        target="RFC2616"></xref> and HTTP Over TLS <xref
        target="RFC2818"></xref>. While it is highly desirable for the entire
        communication between the DSKPP client and server to be protected by
        means of a transport providing confidentiality and integrity
        protection such as HTTP over Transport Layer Security (TLS), such
        protection is not sufficient to protect the exchange of the symmetric
        key data between the server and the cryptographic module and the DSKPP
        protocol is designed to permit implementations that satisfy this
        requirement.</t>

        <t>The server only communicates to the client. As far as the server is
        concerned, the client and cryptographic module may be considered to be
        a single entity.</t>

        <t>From a client-side security perspective, however, the client and
        the cryptographic module are separate logical entities and may in some
        implementations be separate physical entities as well.</t>

        <t>It is assumed that a device will host an application layered above
        the cryptographic module, and this application will manage
        communication between the DSKPP client and cryptographic module. The
        manner in which the communicating application will transfer DSKPP
        protocol elements to and from the cryptographic module is transparent
        to the DSKPP server. One method for this transfer is described in
        <xref target="CT-KIP-P11"></xref>.</t>
      </section>

      <section anchor="Subsection-BasicExchange" title="Basic DSKPP Exchange">
        <section anchor="Subsection-UserAuth" title="User Authentication">
          <t>In a DSKPP message flow, the user has obtained a new hardware or
          software device embedded with a cryptographic module. The goal of
          DSKPP is to provision the same symmetric key and related information
          to the cryptographic module and the key management server, and
          associate the key with the correct user name (or other account
          identifier) on the server. To do this, the DSKPP Server MUST
          authenticate the user to be sure he is authorized for the new
          key.</t>

          <t>User authentication occurs within the protocol itself after<spanx
          style="emph"> </spanx> the DSKPP client initiates the first message.
          In this case, the DSKPP client MUST have access to the DSKPP Server
          URL.</t>

          <t>Alternatively, a DSKPP web service or other form of web
          application can authenticate a user before<spanx style="emph">
          </spanx> the first message is exchanged. In this case, the DSKPP
          server MUST trigger the DSKPP client to initiate the first message
          in the protocol transaction.</t>
        </section>

        <section title="Protocol Initiated by the DSKPP Client">
          <t>In the following example, the DSKPP client first initiates DSKPP,
          and then the user is authenticated using a Client ID and
          Authentication Code.</t>

          <figure anchor="BasicExchangeAC" title="Basic DSKPP Exchange">
            <artwork><![CDATA[ Crypto       DSKPP                          DSKPP    Key Provisioning
 Module       Client                         Server        Server     
  |             |                              |             |                    
  |             |                              |     +---------------+
  |             |                              |     |Server creates |
  |             |                              |     |and stores     | 
  |             |                              |     |Client ID and  | 
  |             |                              |     |Auth. Code and | 
  |             |                              |     |delivers them  |
  |             |                              |     |to user out-of-|
  |             |                              |     |band.          | 
  |             |                              |     +---------------+ 
  |             |                              |             |            
  |  +----------------------+                  |             |            
  |  |User enters Client ID,|                  |             |             
  |  |Auth. Code, and URL   |                  |             |           
  |  +----------------------+                  |             |           
  |             |                              |             |            
  |             |<-- 1. TLS handshake with --->|             |         
  |             |        server auth.          |             |            
  |             |                              |             |    
  |             | 2. <KeyProvClientHello> ---->|     User -->|  
  |             |                              |     Auth.   |
  |             |<-- [3. <KeyProvServerHello>] |             |
  |             |                              |             |   
  |             | [4. <KeyProvClientNonce>] -->|             |  
  |             |                              |             |     
  |             |<- 5. <KeyProvServerFinished> |             |  
  |             |                              |             |
  |             |                              |             |
  |<-- Key      |                              |      Key -->| 
  |    Package  |                              |   Package   |
]]></artwork>
          </figure>

          <t>Before DSKPP begins:<list style="symbols">
              <t>The Authentication Code is generated by the DSKPP Server, and
              delivered to the user via an out-of-band trustworthy channel
              (e.g., a paper slip delivered by IT department staff).</t>

              <t>The user typically enters the Client ID and Authentication
              Code manually, possibly on a device with only numeric keypad.
              Thus, they are often short numeric values (for example, 8
              decimal digits). However, the DSKPP Server is free to generate
              them in any way it wishes.</t>

              <t>The DSKPP client needs the URL <xref target="RFC3986"></xref>
              of the DSKPP server (which is not user-specific or secret, and
              may be pre-configured somehow), and a set of trust anchors for
              verifying the server certificate.</t>

              <t>There must be an account for the user that has an identifier
              and long-term user name (or other account identifier) to which
              the token will be associated. The DSKPP server will use the
              Client ID to find the corresponding Authentication Code for user
              authentication.</t>
            </list></t>

          <t>In Step 1, the client establishes a TLS connection, and
          authenticates the server (that is, validates the certificate, and
          compares the host name in the URL with the certificate) as described
          in Section 3.1 of <xref target="RFC2818"></xref>.</t>

          <t>Next, the DSKPP Client and DSKPP Server exchange DSKPP messages
          (which are sent over HTTPS). In these messages:<list style="symbols">
              <t>The client and server negotiate which cryptographic
              algorithms they want to use; which algorithms are supported for
              protecting DSKPP messages, and other DSKPP protocol details.</t>

              <t>The client sends the Client ID to the server, and proves that
              it knows the corresponding Authentication Code.</t>

              <t>The client and server agree on a secret key (token key or
              K_TOKEN); depending on the negotiated protocol variant, this is
              either a fresh key derived during the DSKPP protocol run (called
              "four-pass variant", since it involves four DSKPP messages), or
              it is generated by (or pre-exists on) the server and transported
              to the client (called "two-pass variant" in the rest of this
              document, since it involves two DSKPP messages).</t>

              <t>The server sends a "key package" to the client. The package
              only includes the key itself in the case of the "two-pass
              variant"; with either variant, the key package contains
              attributes that influence how the provisioned key will be later
              used by the cryptographic module and cryptographic server. The
              exact contents depend on the cryptographic algorithm (e.g., for
              a one-time password algorithm that supports variable-length OTP
              values, the length of the OTP value would be one attribute in
              the key package).</t>
            </list></t>

          <t>After the protocol run has been successfully completed, the
          cryptographic modules stores the contents of the key package.
          Likewise, the DSKPP provisioning server stores the contents of the
          key package with the cryptographic server, and associates these with
          the correct user name. The user can now use the their device to
          perform symmetric-key based operations.</t>

          <t>The exact division of work between the cryptographic module and
          the DSKPP client -- and key Provisioning server and DSKPP server --
          are not specified in this document. The figure above shows one
          possible case, but this is intended for illustrative purposes
          only.</t>
        </section>

        <section title="Protocol Triggered by the DSKPP Server">
          <t>In the first message flow (previous section), the Client ID and
          Authentication Code were delivered to the client by some out-of-band
          means (such as paper sent to the user).</t>

          <figure anchor="BasicExchangeWBA"
                  title="DSKPP Exchange with Web-Based Authentication">
            <artwork><![CDATA[ 
Web           DSKPP                          DSKPP            Web  
Browser       Client                         Server          Server        
  |              |                              |               |
  |<-------- HTTPS browsing + some kind of user auth. --------->|
  |              |                              |               |
  | some HTTP request ----------------------------------------->|
  |              |                              |               
  |              |                              |<------------->|
  |              |                              |               |
  |<----------------------- HTTP response with <KeyProvTrigger> |
  |              |                              |               |
  | Trigger ---->|                              |               |
  |              |                              |               |
  |              |<-- 1. TLS handshake with --->|               |
  |              |        server auth.          |               |
  |              |                              |               |
  |              |     ... continues...         |               |
          ]]></artwork>
          </figure>

          <t>In the second message flow, the user first authenticates to a web
          server (for example, IT department's "self-service" Intranet page),
          using an ordinary web browser and some existing credentials.</t>

          <t>The user then requests (by clicking a link or submitting a form)
          provisioning of a new key to the cryptographic module. The web
          server will reply with a &lt;KeyProvTrigger&gt; message that
          contains the Client ID, Authentication Code, and URL of the DSKPP
          server. This information is also needed by the DSKPP server; how the
          web server and DSKPP server interact is beyond the scope of this
          document.</t>

          <t>The &lt;KeyProvTrigger&gt; message is sent in a HTTP response,
          and it is marked with MIME type "application/dskpp+xml". It is
          assumed the web browser has been configured to recognize this MIME
          type; the browser will start the DSKPP client, and provides it with
          the &lt;KeyProvTrigger&gt; message.</t>

          <t>The DSKPP client then contacts the DSKPP server, and uses the
          Client ID and Authentication Code (from the &lt;KeyProvTrigger&gt;
          message) the same way as in the first message flow.</t>
        </section>

        <section title="Variants">
          <t>As noted in the previous section, once the protocol has started,
          the client and server MAY engage in either a two-pass or four-pass
          message exchange. The four-pass and two-pass protocols are
          appropriate in different deployment scenarios. The biggest
          differentiator between the two is that the two-pass protocol
          supports transport of an existing key to a cryptographic module,
          while the four-pass involves key generation on-the-fly via key
          agreement. In either case, both protocol variants support algorithm
          agility through negotiation of encryption mechanisms and key types
          at the beginning of each protocol run.</t>

          <section title="Criteria for Using the Four-Pass Variant">
            <t>The four-pass protocol is needed under one or more of the
            following conditions:<list style="symbols">
                <t>Policy requires that both parties engaged in the protocol
                jointly contribute entropy to the key. Enforcing this policy
                mitigates the risk of exposing a key during the provisioning
                process as the key is generated through mutual agreement
                without being transferred over-the-air or over-the-wire. It
                also mitigates risk of exposure after the key is provisioned,
                as the key will not be vulnerable to a single point of attack
                in the system.</t>

                <t>A cryptographic module does not have private-key
                capabilities.</t>

                <t>The cryptographic module is hosted by a device that was
                neither pre-issued with a manufacturer's key or other form of
                pre-shared key (as might be the case with a smart card or SIM
                card) nor has a keypad that can be used for entering a
                passphrase (such as present on a mobile phone).</t>
              </list></t>
          </section>

          <section title="Criteria for Using the Two-Pass Variant">
            <t>The two-pass protocol is needed under one or more of the
            following conditions:<list style="symbols">
                <t>Pre-existing (i.e., legacy) keys must be provisioned via
                transport to the cryptographic module.</t>

                <t>The cryptographic module is hosted on a device that was
                pre-issued with a manufacturer's key (such as may exist on a
                smart card), or other form of pre-shared key (such as may
                exist on a SIM-card), and is capable of performing private-key
                operations.</t>

                <t>The cryptographic module is hosted by a device that has a
                built-in keypad with which a user may enter a passphrase,
                useful for deriving a key wrapping key for distribution of
                keying material.</t>
              </list></t>
          </section>
        </section>
      </section>

      <section title="Status Codes">
        <t>Upon transmission or receipt of a message for which the Status
        attribute's value is not "Success" or "Continue", the default
        behavior, unless explicitly stated otherwise below, is that both the
        DSKPP server and the DSKPP client MUST immediately terminate the DSKPP
        protocol run. DSKPP servers and DSKPP clients MUST delete any secret
        values generated as a result of failed runs of the DSKPP protocol.
        Session identifiers MAY be retained from successful or failed protocol
        runs for replay detection purposes, but such retained identifiers MUST
        NOT be reused for subsequent runs of the protocol.</t>

        <t>When possible, the DSKPP client SHOULD present an appropriate error
        message to the user.</t>

        <t>These status codes are valid in all DSKPP Response messages unless
        explicitly stated otherwise:<vspace blankLines="1" /><list
            hangIndent="4" style="hanging">
            <t hangText="Continue:">The DSKPP server is ready for a subsequent
            request from the DSKPP client. It cannot be sent in the server's
            final message<vspace blankLines="1" /></t>

            <t hangText="Success:">Successful completion of the DSKPP session.
            It can only be sent in the server's final message<vspace
            blankLines="1" /></t>

            <t hangText="Abort:">The DSKPP server rejected the DSKPP client's
            request for unspecified reasons<vspace blankLines="1" /></t>

            <t hangText="AccessDenied:">The DSKPP client is not authorized to
            contact this DSKPP server<vspace blankLines="1" /></t>

            <t hangText="MalformedRequest:">The DSKPP server failed to parse
            the DSKPP client's request<vspace blankLines="1" /></t>

            <t hangText="UnknownRequest:">The DSKPP client made a request that
            is unknown to the DSKPP server<vspace blankLines="1" /></t>

            <t hangText="UnknownCriticalExtension:">A DSKPP extension marked
            as "Critical" could not be interpreted by the receiving
            party.<vspace blankLines="1" /></t>

            <t hangText="UnsupportedVersion:">The DSKPP client used a DSKPP
            protocol version not supported by the DSKPP server. This error is
            only valid in the DSKPP server's first response message<vspace
            blankLines="1" /></t>

            <t hangText="NoSupportedKeyTypes:">"NoSupportedKeyTypes" indicates
            that the DSKPP client only suggested key types that are not
            supported by the DSKPP server. This error is only valid in the
            DSKPP server's first response message<vspace blankLines="1" /></t>

            <t hangText="NoSupportedEncryptionAlgorithms:">The DSKPP client
            only suggested encryption algorithms that are not supported by the
            DSKPP server. This error is only valid in the DSKPP server's first
            response message<vspace blankLines="1" /></t>

            <t hangText="NoSupportedMacAlgorithms:">The DSKPP client only
            suggested MAC algorithms that are not supported by the DSKPP
            server. This error is only valid in the DSKPP server's first
            response message<vspace blankLines="1" /></t>

            <t hangText="NoProtocolVariants:">The DSKPP client did not suggest
            a required protocol variant (either 2-pass or 4-pass). This error
            is only valid in the DSKPP server's first response message.<vspace
            blankLines="1" /></t>

            <t hangText="NoSupportedKeyPackages:">The DSKPP client only
            suggested key package formats that are not supported by the DSKPP
            server. This error is only valid in the DSKPP server's first
            response message<vspace blankLines="1" /></t>

            <t hangText="AuthenticationDataMissing:">The DSKPP client didn't
            provide authentication data that the DSKPP server required<vspace
            blankLines="1" /></t>

            <t hangText="AuthenticationDataInvalid:">The DSKPP client supplied
            user authentication data that the DSKPP server failed to
            validate<vspace blankLines="1" /></t>

            <t hangText="InitializationFailed:">The DSKPP server could not
            generate a valid key given the provided data. When this status
            code is received, the DSKPP client SHOULD try to restart DSKPP, as
            it is possible that a new run will succeed<vspace
            blankLines="1" /></t>

            <t hangText="ProvisioningPeriodExpired:">The provisioning period
            set by the DSKPP server has expired. When the status code is
            received, the DSKPP client SHOULD report the reason for key
            initialization failure to the user and the user MUST register with
            the DSKPP server to initialize a new key<vspace
            blankLines="1" /></t>
          </list></t>
      </section>

      <section title="Basic Constructs">
        <t>The following calculations are used in both DSKPP protocol
        variants.</t>

        <section anchor="Subsection-AD" title="User Authentication Data, AD">
          <t>User authentication data (AD) is derived from a Client ID and
          Authentication Code that the user enters before the first DSKPP
          message is sent.</t>

          <t>Note: The user will typically enter the Client ID and
          Authentication Code manually, possibly on a device with only numeric
          keypad. Thus, they are often short numeric values (for example, 8
          decimal digits). However, the DSKPP Server is free to generate them
          in any way it wishes.</t>

          <section title="Authentication Code Format">
            <t>AC is encoded in Type-Length-Value (TLV) format. The format
            consists of a minimum of two TLVs and a variable number of
            additional TLVs, depending on implementation.</t>

            <t>The TLV fields are defined as follows:</t>

            <t><list hangIndent="26" style="hanging">
                <t hangText="Type (1 character)">A hexadecimal character
                identifying the type of information contained in the Value
                field.<vspace blankLines="1" /></t>

                <t hangText="Length (2 characters)">Two hexadecimal characters
                indicating the length of the Value field to follow. The field
                value MAY be up to 255 characters. The Length value 00 MAY be
                used to specify custom tags without any field values.<vspace
                blankLines="1" /></t>

                <t hangText="Value (variable length)">A variable-length string
                of hexadecimal characters containing the instance-specific
                information for this TLV.</t>
              </list></t>

            <t>The following table summarizes the TLVs defined in this
            document. Optional TLVs are allowed for vendor-specific extensions
            with the constraint that the high bit MUST be set to indicate a
            vendor-specific type. Other TLVs are left for later revisions of
            this protocol.</t>

            <figure>
              <preamble></preamble>

              <artwork><![CDATA[+------+------------+-------------------------------------------+
| Type | TLV Name   | Conformance | Example Usage               |
+------+------------+-------------------------------------------+
|  1   | Client ID  | Mandatory   | { "AC00000A" }              |
+------+------------+-------------+-----------------------------+
|  2   | Password   | Mandatory   | { "3582AF0C3E" }            |
+------+------------+-------------+-----------------------------+
|  3   | Checksum   | Optional    | { "4D5" }                   |
+------+------------+-------------+-----------------------------+   ]]></artwork>

              <postamble></postamble>
            </figure>

            <t>The Client ID is a mandatory TLV that represents the
            requester's identifier of maximum length 255. The value is
            represented as a string of hexadecimal characters that identifies
            the key request. For example, suppose Client ID is set to
            "AC00000A", the Client ID TLV in the AC will be represented as
            "108AC00000A".</t>

            <t>The Password is a mandatory TLV the contains a one-time use
            shared secret known by the user and the Provisioning Server. The
            password value is unique and SHOULD be a random string to make AC
            more difficult to guess. The string MUST contain hexadecimal
            characters only. For example, suppose password is set to
            "3582AF0C3E", then the Password TLV would be "20A3582AF0C3E".</t>

            <t>The Checksum is an OPTIONAL TLV, which is generated by the
            issuing server and sent to the user as part of the AC. If the TLV
            is provided, the checksum value MUST be computed using the CRC16
            algorithm <xref target="ISO3309"></xref>. When the user enters the
            AC, the typed AC string of characters is verified with the
            checksum to ensure it is correctly entered by the user. For
            example, suppose the AC with combined Client ID tag and Password
            tag is set to "108AC00000A20A3582AF0C3E", then the CRC16
            calculation would generate a checksum of 0x356, resulting in a
            Checksum TLV of "334D5". The complete AC string in this example
            would be "108AC00000A20A3582AF0C3E3034D5".</t>

            <t>Although this specification recommends using hexadecimal
            characters only for the AC at the application's user interface
            layer and making the TLV triples non-transparent to the user as
            described in the example above; implementations MAY choose to use
            other printable Unicode characters at the application's user
            interface layer in order to meet specific local, context or
            usability requirements. When non-hexadecimal characters are
            desired at the user interface layer such as when other printable
            US-ASCII characters or international characters are used, UTF-8
            <xref target="RFC3629"></xref> MUST be used to convert user input
            to a string of hexadecimal characters and the general guidelines
            for mapping characters in <xref target="IDNA2008"></xref> MUST be
            followed. For example, if a given application allows use of any
            printable US-ASCII characters and extended ASCII characters for
            Client ID and password fields and the Client ID is set to
            "myclient!D" and associated password is set to "mYpas&amp;#rD",
            the user enters through the keyboard or other means a Client ID of
            "myclient!D" and a password of "mYpas&amp;#rD" in separate form
            fields or as instructed by the provider. The application&rsquo;s
            layer processing user input MUST then convert the values entered
            by the user to the following string for use in the protocol:
            "1146D79636C69656E74214421A6DC2A570CEB17373C2A372CEB4" (note that
            in this example the Checksum TLV is not added).</t>

            <t>The example is explained further below in detail:</t>

            <t>Assume that the raw Client ID value or the value entered by the
            use is: myclient!ID</t>

            <t>The Client ID value as characters names is:</t>

            <t><list>
                <t>U+006D LATIN SMALL LETTER M character</t>

                <t>U+0079 LATIN SMALL LETTER Y character</t>

                <t>U+0063 LATIN SMALL LETTER C character</t>

                <t>U+006C LATIN SMALL LETTER L character</t>

                <t>U+0069 LATIN SMALL LETTER I character</t>

                <t>U+0065 LATIN SMALL LETTER E character</t>

                <t>U+006E LATIN SMALL LETTER N character</t>

                <t>U+0074 LATIN SMALL LETTER T character</t>

                <t>U+0021 EXCLAMATION MARK character (!)</t>

                <t>U+0044 LATIN CAPITAL LETTER D character<vspace
                blankLines="1" /></t>
              </list>The UTF-8 conversion of the Client ID value is: 6D 79 63
            6C 69 65 6E 74 21 44</t>

            <t>The length of the Client ID value in hexadecimal characters is:
            14</t>

            <t>The TLV presentation of the Client ID field is:
            10146D79636C69656E742144</t>

            <t>The raw password value or the value entered by the user is:
            mYpas&amp;#rD</t>

            <t>The password value as character names is:</t>

            <t><list>
                <t>U+006D LATIN SMALL LETTER M character</t>

                <t>U+0059 LATIN LARGE LETTER Y character</t>

                <t>U+0070 LATIN SMALL LETTER P character</t>

                <t>U+0061 LATIN SMALL LETTER A character</t>

                <t>U+0073 LATIN SMALL LETTER S character</t>

                <t>U+0026 AMPERSAND character (&amp;)</t>

                <t>U+0023 POUND SIGN character (#)</t>

                <t>U+0072 LATIN SMALL LETTER R character</t>

                <t>U+0044 LATIN LARGE LETTER D character<vspace
                blankLines="1" /></t>
              </list>The UTF-8 conversion of the password value is: 6D 59 70
            61 73 26 23 72 44</t>

            <t>The length of the password value in hexadecimal characters is:
            12</t>

            <t>The TLV presentation of the password field is:
            2126D5970617326237244</t>

            <t>The combined Client ID and password fields value or the AC
            value is:<vspace
            blankLines="0" />1146D79636C69656E7421442126D5970617326237244</t>
          </section>

          <section anchor="Subsection-ADMAC"
                   title="User Authentication Data Calculation">
            <t>The Authentication Data consists of a Client ID (extracted from
            the AC) and a value, which is derived from AC as follows (refer to
            <xref target="DSKPP-PRF"></xref> for a description of DSKPP-PRF in
            general and <xref target="Section-PRFRealizations"></xref> for a
            description of DSKPP-PRF-AES):</t>

            <t>MAC = DSKPP-PRF(K_AC, AC-&gt;ClientID||URL_S||R_C||[R_S],
            16)</t>

            <t>In four-pass DSKPP, the cryptographic module uses R_C, R_S, and
            URL_S to calculate the MAC, where URL_S is the URL the DSKPP
            client uses when contacting the DSKPP server. In two-pass DSKPP,
            the cryptographic module does not have access to R_S, therefore
            only R_C is used in combination with URL_S to produce the MAC. In
            either case, K_AC MUST be derived from AC-&gt;password as follows
            <xref target="PKCS-5"></xref>:</t>

            <t>K_AC = PBKDF2(AC-&gt;password, R_C || K, iter_count, 16)</t>

            <t>One of the following values for K MUST be used:<vspace
            blankLines="1" /><list hangIndent="" style="format %c.">
                <t>In four-pass: <list counter="" style="symbols">
                    <t>The public key of the DSKPP server (K_SERVER), or (in
                    the pre-shared key variant) the pre-shared key between the
                    client and the server (K_SHARED)<vspace
                    blankLines="1" /></t>
                  </list></t>

                <t>In two-pass:<list style="symbols">
                    <t>The public key of the DSKPP client, or the public key
                    of the device when a device certificate is available</t>

                    <t>The pre-shared key between the client and the server
                    (K_SHARED)</t>

                    <t>A passphrase-derived key</t>
                  </list></t>
              </list><vspace blankLines="1" />The iteration count, iter_count,
            MUST be set to at least 100,000 except in the last two two-pass
            cases (where K is set to K_SHARED or a passphrase-derived key), in
            which case iter_count MUST be set to 1.</t>
          </section>
        </section>

        <section anchor="DSKPP-PRF"
                 title="The DSKPP One-Way Pseudorandom Function, DSKPP-PRF">
          <t>Regardless of the protocol variant employed, there is a
          requirement for a cryptographic primitive that provides a
          deterministic transformation of a secret key k and a varying length
          octet string s to a bit string of specified length dsLen.</t>

          <t>This primitive must meet the same requirements as for a keyed
          hash function: It MUST take an arbitrary length input, and generate
          an output that is one-way and collision-free (for a definition of
          these terms, see, e.g., <xref target="FAQ"></xref>). Further, its
          output MUST be unpredictable even if other outputs for the same key
          are known.</t>

          <t>From the point of view of this specification, DSKPP-PRF is a
          "black-box" function that, given the inputs, generates a
          pseudorandom value and MAY be realized by any appropriate and
          competent cryptographic technique. <xref
          target="Section-PRFRealizations"></xref> contains two example
          realizations of DSKPP-PRF.</t>

          <t>DSKPP-PRF(k, s, dsLen)</t>

          <t>Input:</t>

          <t><list hangIndent="6" style="hanging">
              <t hangText="k">secret key in octet string format</t>

              <t hangText="s">octet string of varying length consisting of
              variable data distinguishing the particular string being
              derived</t>

              <t hangText="dsLen">desired length of the output</t>
            </list></t>

          <t>Output:</t>

          <t><list hangIndent="6" style="hanging">
              <t hangText="DS">pseudorandom string, dsLen-octets long</t>
            </list></t>

          <t>For the purposes of this document, the secret key k MUST be at
          least 16 octets long.</t>
        </section>

        <section anchor="Subsection-MsgHashAlg"
                 title="The DSKPP Message Hash Algorithm">
          <t>When sending its last message in a protocol run, the DSKPP server
          generates a MAC that is used by the client for key confirmation.
          Computation of the MAC MUST include a hash of all DSKPP messages
          sent by the client and server during the transaction. To compute a
          message hash for the MAC given a sequence of DSKPP messages msg_1,
          ..., msg_n, the following operations MUST be carried out:<vspace
          blankLines="1" /><list hangIndent="" style="format %c.">
              <t>The sequence of messages contains all DSKPP Request and
              Response messages up to but not including this message.<vspace
              blankLines="0" /></t>

              <t>Re-transmitted messages are removed from the sequence of
              messages.<vspace blankLines="0" />Note: The resulting sequence
              of messages MUST be an alternating sequence of DSKPP Request and
              DSKPP Response messages<vspace blankLines="0" /></t>

              <t>The contents of each message is concatenated together.<vspace
              blankLines="0" /></t>

              <t>The resultant string is hashed using SHA-256 in accordance
              with <xref target="FIPS180-SHA"></xref>.</t>
            </list></t>
        </section>
      </section>
    </section>

    <section anchor="Subsection-FourPassUsage"
             title="Four-Pass Protocol Usage">
      <t>This section describes the methods and message flow that comprise the
      four-pass protocol variant. Four-pass DSKPP depends on a client-server
      key agreement mechanism.</t>

      <section title="The Key Agreement Mechanism">
        <t>With 4-pass DSKPP, the symmetric key that is the target of
        provisioning, is generated on-the-fly without being transferred
        between the DSKPP client and DSKPP server. The data flow and
        computation are described below.</t>

        <section anchor="Subsection-FourPassDataFlow" title="Data Flow">
          <t>A sample data flow showing key generation during the 4-pass
          protocol is shown in <xref target="keygen"></xref>.</t>

          <figure anchor="keygen"
                  title="Principal data flow for DSKPP key generation             - using public server key">
            <artwork><![CDATA[+----------------------+                  +----------------------+
|    +------------+    |                  |                      |
|    | Server key |    |                  |                      |
| +<-|  Public    |------>------------->-------------+---------+ |
| |  |  Private   |    |                  |          |         | |
| |  +------------+    |                  |          |         | |
| |        |           |                  |          |         | |
| V        V           |                  |          V         V |
| |   +---------+      |                  |        +---------+ | |     
| |   | Decrypt |<-------<-------------<-----------| Encrypt | | |
| |   +---------+      |                  |        +---------+ | |
| |      |  +--------+ |                  |            ^       | |
| |      |  | Server | |                  |            |       | |
| |      |  | Random |--->------------->------+  +----------+  | |
| |      |  +--------+ |                  |   |  | Client   |  | |
| |      |      |      |                  |   |  | Random   |  | |
| |      |      |      |                  |   |  +----------+  | |
| |      |      |      |                  |   |        |       | |
| |      V      V      |                  |   V        V       | |
| |   +------------+   |                  | +------------+     | |
| +-->|  DSKPP PRF |   |                  | |  DSKPP PRF |<----+ |
|     +------------+   |                  | +------------+       |
|           |          |                  |       |              |
|           V          |                  |       V              |
|       +-------+      |                  |   +-------+          |
|       |  Key  |      |                  |   |  Key  |          |
|       +-------+      |                  |   +-------+          |
|       +-------+      |                  |   +-------+          |
|       |Key Id |-------->------------->------|Key Id |          |
|       +-------+      |                  |   +-------+          |
+----------------------+                  +----------------------+
      DSKPP Server                              DSKPP Client
               ]]></artwork>
          </figure>

          <t>The inclusion of the two random nonces (R_S and R_C) in the key
          generation provides assurance to both sides (the cryptographic
          module and the DSKPP server) that they have contributed to the key's
          randomness and that the key is unique. The inclusion of the
          encryption key (K) ensures that no man-in-the-middle may be present,
          or else the cryptographic module will end up with a key different
          from the one stored by the legitimate DSKPP server.</t>

          <t>Conceptually, although R_C is one pseudorandom string, it may be
          viewed as consisting of two components, R_C1 and R_C2, where R_C1 is
          generated during the protocol run, and R_C2 can be pre-generated and
          loaded on the cryptographic module before the device is issued to
          the user. In that case, the latter string, R_C2, SHOULD be unique
          for each cryptographic module.</t>

          <t>A man-in-the-middle (in the form of corrupt client software or a
          mistakenly contacted server) may present his own public key to the
          cryptographic module. This will enable the attacker to learn the
          client's version of K_TOKEN. However, the attacker is not able to
          persuade the legitimate server to derive the same value for K_TOKEN,
          since K_TOKEN is a function of the public key involved, and the
          attacker's public key must be different than the correct server's
          (or else the attacker would not be able to decrypt the information
          received from the client). Therefore, once the attacker is no longer
          "in the middle," the client and server will detect that they are
          "out of sync" when they try to use their keys. In the case of
          encrypting R_C with K_SERVER, it is therefore important to verify
          that K_SERVER really is the legitimate server's key. One way to do
          this is to independently validate a newly generated K_TOKEN against
          some validation service at the server (e.g., using a connection
          independent from the one used for the key generation).</t>
        </section>

        <section anchor="Subsection-4PassKeyGen" title="Computation">
          <t>In DSKPP, the client and server both generate K_TOKEN and K_MAC
          by deriving them from a provisioning key (K_PROV) using the
          DSKPP-PRF function (refer to <xref target="DSKPP-PRF"></xref>) as
          follows:</t>

          <t>K_PROV = DSKPP-PRF(k,s,dsLen), where<vspace
          blankLines="1" /><list hangIndent="4">
              <t>k = R_C (i.e., the secret random value chosen by the DSKPP
              client)<vspace blankLines="1" /></t>

              <t>s = "Key generation" || K || R_S (where K is the key used to
              encrypt R_C and R_S is the random value chosen by the DSKPP
              server)<vspace blankLines="1" /></t>

              <t>dsLen = (desired length of K_PROV whose first half
              constitutes K_MAC and second half constitutes K_TOKEN)</t>
            </list></t>

          <t>Then K_TOKEN and K_MAC are derived from K_PROV, where<vspace
          blankLines="1" /><list hangIndent="4">
              <t>K_PROV = K_MAC || K_TOKEN</t>
            </list></t>

          <t>When computing K_PROV, the derived keys, K_MAC and K_TOKEN, MAY
          be subject to an algorithm-dependent transform before being adopted
          as a key of the selected type. One example of this is the need for
          parity in DES keys.</t>
        </section>
      </section>

      <section anchor="Subsection-4PassFlow" title="Message Flow">
        <t>The four-pass protocol flow consists of two message exchanges:<list
            style="format %d:">
            <t>Pass 1 = &lt;KeyProvClientHello&gt;, Pass 2 =
            &lt;KeyProvServerHello&gt;</t>

            <t>Pass 3 = &lt;KeyProvClientNonce&gt;, Pass 4 =
            &lt;KeyProvServerFinished&gt;</t>
          </list></t>

        <t>The first pair of messages negotiate cryptographic algorithms and
        exchange nonces. The second pair of messages establishes a symmetric
        key using mutually authenticated key agreement.</t>

        <t>The purpose and content of each message are described below. XML
        format and examples are in <xref target="Section-Schema"></xref> and
        <xref target="Section-Examples"></xref>.</t>

        <section anchor="Subsection-Trigger" title="KeyProvTrigger">
          <figure>
            <preamble></preamble>

            <artwork><![CDATA[        DSKPP Client                         DSKPP Server
        ------------                         ------------
                             [<---]       AD, [DeviceID],
                                         [KeyID], [URL_S] ]]></artwork>

            <postamble></postamble>
          </figure>

          <t>When this message is sent:<list style="empty">
              <t>The "trigger" message is optional. The DSKPP server sends
              this message after the following out-of-band steps are
              performed:<list style="format %d.">
                  <t>A user directed their browser to a key provisioning web
                  application and signs in (i.e., authenticates)</t>

                  <t>The user requests a key</t>

                  <t>The web application processes the request and returns an
                  authentication code to the user, e.g., in response to an
                  enrollment request via a secure web session</t>

                  <t>The web application retrieves the authentication code
                  from the user (possibly by asking the user to enter it using
                  a web form, or alternatively by the user selecting a URL in
                  which the authentication code is embedded)</t>

                  <t>The web application derives authentication data (AD) from
                  the authentication code as described in <xref
                  target="Subsection-AD"></xref></t>

                  <t>The web application passes AD, and possibly a DeviceID
                  (identifies a particular device to which the key is to be
                  provisioned) and/or KeyID (identifies a key that will be
                  replaced) to the DSKPP server</t>
                </list></t>
            </list></t>

          <t>Purpose of this message:<list style="empty">
              <t>To start a DSKPP session: The DSKPP server uses this message
              to trigger a client-side application to send the first DSKPP
              message.<vspace blankLines="1" /></t>

              <t>To provide a way for the key provisioning system to get the
              DSKPP server URL to the DSKPP client.<vspace blankLines="1" />So
              the key provisioning system can point the DSKPP client to a
              particular cryptographic module that was pre-configured in the
              DSKPP provisioning server.<vspace blankLines="1" />In the case
              of key renewal, to identify the key to be replaced.</t>
            </list></t>

          <t>What is contained in this message:<list style="empty">
              <t>AD MUST be provided to allow the DSKPP server to authenticate
              the user before completing the protocol run.<vspace
              blankLines="1" />A DeviceID MAY be included to allow a key
              provisioning application to bind the provisioned key to a
              specific device.<vspace blankLines="1" />A KeyID MAY be included
              to allow the key provisioning application to identify a key to
              be replaced, e.g., in the case of key renewal.<vspace
              blankLines="1" />The Server URL MAY be included to allow the key
              provisioning application to inform the DSKPP client of which
              server to contact</t>
            </list></t>
        </section>

        <section title="KeyProvClientHello">
          <figure>
            <artwork><![CDATA[
        DSKPP Client                         DSKPP Server    
        ------------                         ------------    
        SAL, [AD], 
        [DeviceID], [KeyID]     --->                         ]]></artwork>

            <postamble></postamble>
          </figure>

          <t>When this message is sent:<list style="empty">
              <t>When a DSKPP client first connects to a DSKPP server, it is
              required to send the &lt;KeyProvClientHello&gt; as its first
              message. The client can also send a &lt;KeyProvClientHello&gt;
              in response to a &lt;KeyProvTrigger&gt;.</t>
            </list></t>

          <t>What is contained in this message:<list style="empty">
              <t>The Security Attribute List (SAL) included with
              &lt;KeyProvClientHello&gt; contains the combinations of DSKPP
              versions, variants, key package formats, key types, and
              cryptographic algorithms that the DSKPP client supports in order
              of the client's preference (favorite choice first). <vspace
              blankLines="1" />If &lt;KeyProvClientHello&gt; was preceded by a
              &lt;KeyProvTrigger&gt;, then this message MUST also include the
              Authentication (AD), DeviceID, and/or KeyID that was provided
              with the trigger. <vspace blankLines="1" />If
              &lt;KeyProvClientHello&gt; was not preceded by a
              &lt;KeyProvTrigger&gt;, then this message MAY contain a device
              ID that was pre-shared with the DSKPP server, and a key ID
              associated with a key previously provisioned by the DSKPP
              provisioning server.</t>
            </list></t>

          <t>Application note:<list>
              <t>If this message is preceded by trigger message
              &lt;KeyProvTrigger&gt;, then the application will already have
              AD available (see <xref target="Subsection-Trigger"></xref>).
              However, if this message was not preceded by
              &lt;KeyProvTrigger&gt;, then the application MUST retrieve the
              user authentication code, possibly by prompting the user to
              manually enter their authentication code, e.g., on a device with
              only a numeric keypad.<vspace blankLines="1" /></t>

              <t>The application MUST also derive Authentication Data (AD)
              from the authentication code, as described in <xref
              target="Subsection-AD"></xref>, and save it for use in its next
              message, &lt;KeyProvClientNonce&gt;.</t>
            </list></t>

          <t>How the DSKPP server uses this message:<list>
              <t>The DSKPP server will look for an acceptable combination of
              DSKPP version, variant (in this case, four-pass), key package
              format, key type, and cryptographic algorithms. If the DSKPP
              Client's SAL does not match the capabilities of the DSKPP
              Server, or does not comply with key provisioning policy, then
              the DSKPP Server will set the Status attribute to something
              other than "Continue". Otherwise, Status will be set to
              "Continue".<vspace blankLines="1" /></t>

              <t>If included in &lt;KeyProvClientHello&gt;, the DSKPP server
              will validate the Authentication Data (AD), DeviceID, and KeyID.
              The DSKPP server MUST NOT accept the DeviceID unless the server
              sent the DeviceID in a preceding trigger message. Note that it
              is also legitimate for a DSKPP client to initiate the DSKPP
              protocol run without having received a &lt;KeyProvTrigger&gt;
              message from a server, but in this case any provided DeviceID
              MUST NOT be accepted by the DSKPP server unless the server has
              access to a unique key for the identified device and that key
              will be used in the protocol.</t>
            </list></t>
        </section>

        <section anchor="Subsection-ServerHello" title="KeyProvServerHello">
          <figure>
            <preamble></preamble>

            <artwork><![CDATA[        DSKPP Client                         DSKPP Server
        ------------                         ------------
                              <---    SAL, R_S, [K], [MAC]]]></artwork>

            <postamble></postamble>
          </figure>

          <t>When this message is sent:<list style="empty">
              <t>The DSKPP server will send this message in response to a
              &lt;KeyProvClientHello&gt; message after it looks for an
              acceptable combination of DSKPP version, variant (in this case,
              four-pass), key package format, key type, and set of
              cryptographic algorithms. If it could not find an acceptable
              combination, then it will still send the message, but with a
              failure status.</t>
            </list></t>

          <t>Purpose of this message:<list>
              <t>With this message, the context for the protocol run is set.
              Furthermore, the DSKPP server uses this message to transmit a
              random nonce, which is required for each side to agree upon the
              same symmetric key (K_TOKEN).</t>
            </list></t>

          <t>What is contained in this message:<list style="empty">
              <t>A status attribute equivalent to the server's return code to
              &lt;KeyProvClientHello&gt;. If the server found an acceptable
              set of attributes from the client's SAL, then it sets status to
              Continue and returns an SAL (selected from the SAL that it
              received in &lt;KeyProvClientHello&gt;). The Server's SAL
              specifies the DSKPP version and variant (in this case,
              four-pass), key type, cryptographic algorithms, and key package
              format that the DSKPP Client MUST use for the remainder of the
              protocol run.<vspace blankLines="1" /></t>

              <t>A random nonce (R_S) for use in generating a symmetric key
              through key agreement; the length of R_S may depend on the
              selected key type. <vspace blankLines="1" /></t>

              <t>A key (K) for the DSKPP Client to use for encrypting the
              client nonce included with &lt;KeyProvClientNonce&gt;. K
              represents the server's public key (K_SERVER) or a pre-shared
              secret key (K_SHARED).<vspace blankLines="1" />A MAC MUST be
              present if a key is being renewed so that the DSKPP client can
              confirm that the replacement key came from a trusted server.
              This MAC MUST be computed using DSKPP-PRF (see <xref
              target="DSKPP-PRF"></xref>), where the input parameter k MUST be
              set to the existing MAC key K_MAC' (i.e., the value of the MAC
              key that existed before this protocol run; the implementation
              MAY specify K_MAC' to be the value of the K_TOKEN that is being
              replaced), and input parameter dsLen MUST be set to the length
              of R_S.</t>
            </list></t>

          <t>How the DSKPP client uses this message:<list style="empty">
              <t>When the Status attribute is not set to "Continue", this
              indicates failure and the DSKPP client MUST abort the
              protocol.<vspace blankLines="1" /></t>

              <t>If successful execution of the protocol will result in the
              replacement of an existing key with a newly generated one, the
              DSKPP client MUST verify the MAC provided in
              &lt;KeyProvServerHello&gt;. The DSKPP client MUST terminate the
              DSKPP session if the MAC does not verify, and MUST delete any
              nonces, keys, and/or secrets associated with the failed
              run.<vspace blankLines="1" /></t>

              <t>If Status is set to "Continue" the cryptographic module
              generates a random nonce (R_C) using the cryptographic algorithm
              specified in the SAL. The length of the nonce R_C will depend on
              the selected key type.<vspace blankLines="1" /></t>

              <t>Encrypt R_C using K and the encryption algorithm included in
              the SAL.</t>
            </list></t>

          <t>The method the DSKPP client MUST use to encrypt R_C:<list>
              <t>If K is equivalent to K_SERVER (i.e., the public key of the
              DSKPP server), then an RSA encryption scheme from PKCS #1 <xref
              target="PKCS-1"></xref> MAY be used. If K is equivalent to
              K_SERVER, then the cryptographic module SHOULD verify the
              server's certificate before using it to encrypt R_C as described
              in <xref target="RFC2818"></xref>, Section 3.1, and <xref
              target="RFC5280"></xref>.<vspace blankLines="1" />If K is
              equivalent to K_SHARED, the DSKPP client MAY use the DSKPP-PRF
              function to avoid dependence on other algorithms. In this case,
              the client uses K_SHARED as input parameter k (K_SHARED SHOULD
              be used solely for this purpose) as follows:<vspace
              blankLines="1" />dsLen = len(R_C), where "len" is the length of
              R_C<vspace blankLines="0" />DS = DSKPP-PRF(K_SHARED,
              "Encryption" || R_S, dsLen)<vspace blankLines="1" />This will
              produce a pseudorandom string DS of length equal to R_C.
              Encryption of R_C MAY then be achieved by XOR-ing DS with
              R_C:<vspace blankLines="1" />E(DS, R_C) = DS ^ R_C<vspace
              blankLines="1" />The DSKPP server will then perform the reverse
              operation to extract R_C from E(DS, R_C).</t>
            </list></t>
        </section>

        <section anchor="Subsection-Enc" title="KeyProvClientNonce">
          <figure>
            <preamble></preamble>

            <artwork><![CDATA[        DSKPP Client                         DSKPP Server
        ------------                         ------------
        E(K,R_C), AD          --->                    ]]></artwork>

            <postamble></postamble>
          </figure>

          <t>When this message is sent:<list style="empty">
              <t>The DSKPP client will send this message immediately following
              a &lt;KeyProvServerHello&gt; message whose status was set to
              "Continue".</t>
            </list></t>

          <t>Purpose of this message:<list>
              <t>With this message the DSKPP client transmits user
              authentication data (AD) and a random nonce encrypted with the
              DSKPP server's key (K). The client's random nonce is required
              for each side to agree upon the same symmetric key
              (K_TOKEN).</t>
            </list></t>

          <t>What is contained in this message:<list style="empty">
              <t>Authentication Data (AD) that was derived from an
              authentication code entered by the user before
              &lt;KeyProvClientHello&gt; was sent (refer to <xref
              target="Subsection-BasicExchange"></xref>).<vspace
              blankLines="1" /></t>

              <t>The DSKPP client's random nonce (R_C), which was encrypted as
              described in <xref target="Subsection-ServerHello"></xref>.</t>
            </list></t>

          <t>How the DSKPP server uses this message:<list>
              <t>The DSKPP server MUST use AD to authenticate the user. If
              authentication fails, then the DSKPP server MUST set the return
              code to a failure status. <vspace blankLines="1" />If user
              authentication passes, the DSKPP server decrypts R_C using its
              key (K). The decryption method is based on whether K that was
              transmitted to the client in &lt;KeyProvServerHello&gt; was
              equal to the server's public key (K_SERVER) or a pre-shared key
              (K_SHARED) (refer to <xref
              target="Subsection-ServerHello"></xref> for a description of how
              the DSKPP client encrypts R_C).<vspace blankLines="1" /></t>

              <t>After extracting R_C, the DSKPP server computes K_TOKEN using
              a combination of the two random nonces R_S and R_C and its
              encryption key, K, as described in <xref
              target="Subsection-4PassKeyGen"></xref>. The particular
              realization of DSKPP-PRF (e.g., those defined in <xref
              target="Section-PRFRealizations"></xref> depends on the MAC
              algorithm contained in the &lt;KeyProvServerHello&gt; message.
              The DSKPP server then generates a key package that contains key
              usage attributes such as expiry date and length. The key package
              MUST NOT include K_TOKEN since in the four-pass variant K_TOKEN
              is never transmitted between the DSKPP server and client. The
              server stores K_TOKEN and the key package with the user's
              account on the cryptographic server.</t>

              <t><vspace blankLines="0" />Finally, the server generates a key
              confirmation MAC that the client will use to avoid a false
              "Commit" message that would cause the cryptographic module to
              end up in state in which the server does not recognize the
              stored key.</t>
            </list></t>

          <t>The MAC used for key confirmation MUST be calculated as follows:
          <list>
              <t>msg_hash = SHA-256(msg_1, ..., msg_n)<vspace
              blankLines="1" /></t>

              <t>dsLen = len(msg_hash)<vspace blankLines="1" /></t>

              <t>MAC = DSKPP-PRF (K_MAC, "MAC 1 computation" || msg_hash,
              dsLen)<vspace blankLines="1" /></t>

              <t>where<vspace blankLines="1" /><list hangIndent="4"
                  style="hanging">
                  <t hangText="MAC">The DSKPP Pseudo-Random Function defined
                  in <xref target="DSKPP-PRF"></xref> is used to compute the
                  MAC. The particular realization of DSKPP-PRF (e.g., those
                  defined in <xref target="Section-PRFRealizations"></xref>)
                  depends on the MAC algorithm contained in the
                  &lt;KeyProvServerHello&gt; message. The MAC MUST be computed
                  using the existing MAC key (K_MAC), and a string that is
                  formed by concatenating the (ASCII) string "MAC 1
                  computation" and a msg_hash<vspace blankLines="1" /></t>

                  <t hangText="K_MAC">The key derived from K_PROV, as
                  described in <xref
                  target="Subsection-4PassKeyGen"></xref>.<vspace
                  blankLines="1" /></t>

                  <t hangText="msg_hash">The message hash (defined in <xref
                  target="Subsection-MsgHashAlg"></xref>) of messages msg_1,
                  ..., msg_n.</t>
                </list></t>
            </list></t>
        </section>

        <section title="KeyProvServerFinished">
          <figure>
            <preamble></preamble>

            <artwork><![CDATA[        DSKPP Client                         DSKPP Server
        ------------                         ------------
                               <---               KP, MAC]]></artwork>

            <postamble></postamble>
          </figure>

          <t>When this message is sent:<list>
              <t>The DSKPP server will send this message after authenticating
              the user and, if authentication passed, generating K_TOKEN and a
              key package, and associating them with the user's account on the
              cryptographic server.</t>
            </list></t>

          <t>Purpose of this message:<list>
              <t>With this message the DSKPP server confirms generation of the
              key (K_TOKEN), and transmits the associated identifier and
              application-specific attributes, but not the key itself, in a
              key package to the client for protocol completion.</t>
            </list></t>

          <t>What is contained in this message:<list>
              <t>A status attribute equivalent to the server's return code to
              &lt;KeyProvClientNonce&gt;. If user authentication passed, and
              the server successfully computed K_TOKEN, generated a key
              package, and associated them with the user's account on the
              cryptographic server, then it sets Status to Success.<vspace
              blankLines="1" /></t>

              <t>If status is Success, then this message acts as a "commit"
              message, instructing the cryptographic module to store the
              generated key (K_TOKEN) and associate the given key identifier
              with this key. As such, a key package (KP) MUST be included in
              this message, which holds an identifier for the generated key
              (but not the key itself) and additional configuration, e.g., the
              identity of the DSKPP server, key usage attributes, etc. The
              default symmetric key package format MUST be based on the
              Portable Symmetric Key Container (PSKC) defined in <xref
              target="PSKC"></xref>. Alternative formats MAY include <xref
              target="SKPC-ASN.1"></xref>, PKCS#12 <xref
              target="PKCS-12"></xref>, or PKCS#5 XML <xref
              target="PKCS-5-XML"></xref> format. <vspace
              blankLines="1" />With KP, the server includes a key confirmation
              MAC that the client uses to avoid a false "Commit". The MAC
              algorithm is the same DSKPP-PRF that was sent in the
              &lt;KeyProvServerHello&gt; message.</t>
            </list></t>

          <t>How the DSKPP client uses this message:<list style="empty">
              <t>When the Status attribute is not set to "Success", this
              indicates failure and the DSKPP client MUST abort the
              protocol.<vspace blankLines="1" /></t>

              <t>After receiving a &lt;KeyProvServerFinished&gt; message with
              Status = "Success", the DSKPP client MUST verify the key
              confirmation MAC that was transmitted with this message. The
              DSKPP client MUST terminate the DSKPP session if the MAC does
              not verify, and MUST, in this case, also delete any nonces,
              keys, and/or secrets associated with the failed run of the
              protocol. <vspace blankLines="1" /></t>

              <t>If &lt;KeyProvServerFinished&gt; has Status = "Success" and
              the MAC was verified, then the DSKPP client MUST calculate
              K_TOKEN from the combination of the two random nonces R_S and
              R_C and the server's encryption key, K, as described in <xref
              target="Subsection-4PassKeyGen"></xref>. The DSKPP-PRF is the
              same one used for MAC computation. The DSKPP client associates
              the key package contained in &lt;KeyProvServerFinished&gt; with
              the generated key, K_TOKEN, and stores this data permanently on
              the cryptographic module. <vspace blankLines="1" /></t>

              <t>After this operation, it MUST NOT be possible to overwrite
              the key unless knowledge of an authorizing key is proven through
              a MAC on a later &lt;KeyProvServerHello&gt; (and
              &lt;KeyProvServerFinished&gt;) message.</t>
            </list></t>
        </section>
      </section>
    </section>

    <section anchor="Subsecton-TwoPass" title="Two-Pass Protocol Usage">
      <t>This section describes the methods and message flow that comprise the
      two-pass protocol variant. Two-pass DSKPP is essentially a transport of
      keying material from the DSKPP server to the DSKPP client. The DSKPP
      server transmits keying material in a key package formatted in
      accordance with <xref target="PSKC"></xref>, <xref
      target="SKPC-ASN.1"></xref>, PKCS#12 <xref target="PKCS-12"></xref>, or
      PKCS#5 XML <xref target="PKCS-5-XML"></xref>.</t>

      <t>The keying material includes a provisioning master key, K_PROV, from
      which the DSKPP client derives two keys: the symmetric key to be
      established in the cryptographic module, K_TOKEN, and a key, K_MAC, used
      for server authentication (in the case of key renewal) and key
      confirmation. The keying material also includes key usage attributes,
      such as expiry date and length.</t>

      <t>The DSKPP server encrypts K_PROV to ensure that it is not exposed to
      any other entity than the DSKPP server and the cryptographic module
      itself. The DSKPP server uses any of three key protection methods to
      encrypt K_PROV: Key Transport, Key Wrap, and Passphrase-Based Key Wrap
      Key Protection Methods.</t>

      <t>While the DSKPP client and server may negotiate the key protection
      method to use, the actual key protection is carried out in the
      KeyPackage. The format of a KeyPackage specifies how a key should be
      protected using the three key protection methods. The following
      KeyPackage formats are defined for DSKPP:</t>

      <t><list style="symbols">
          <t>PSKC Key Container <xref target="PSKC"></xref> at <vspace
          blankLines="0" />urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container<vspace
          blankLines="1" /></t>

          <t>SKPC Key Container <xref target="SKPC-ASN.1"></xref> at <vspace
          blankLines="0" />urn:ietf:params:xml:ns:keyprov:dskpp:skpc-key-container<vspace
          blankLines="1" /></t>

          <t>PKCS12 Key Container <xref target="PKCS-12"></xref> at<vspace
          blankLines="0" />urn:ietf:params:xml:ns:keyprov:dskpp:pkcs12-key-container<vspace
          blankLines="1" /></t>

          <t>PKCS5-XML Key Container <xref target="PKCS-5-XML"></xref>
          at<vspace
          blankLines="0" />urn:ietf:params:xml:ns:keyprov:dskpp:pkcs5-xml-key-container<vspace
          blankLines="1" /></t>
        </list>Each of the key protection methods is described below.</t>

      <section anchor="SubSec-KPMethods" title="Key Protection Methods">
        <t>This section introduces three key protection methods for the
        two-pass variant. Additional methods MAY be defined by external
        entities or through the IETF process.</t>

        <section title="Key Transport">
          <t>Purpose of this method:<list>
              <t>This method is intended for PKI-capable devices. The DSKPP
              server encrypts keying material and transports it to the DSKPP
              client. The server encrypts the keying material using the public
              key of the DSKPP client, whose private key part resides in the
              cryptographic module. The DSKPP client decrypts the keying
              material and uses it to derive the symmetric key, K_TOKEN.</t>
            </list></t>

          <t>This method is identified with the following URN: <list>
              <t>urn:ietf:params:xml:schema:keyprov:dskpp:transport</t>
            </list></t>

          <t>The DSKPP server and client MUST support the following
          mechanism:<list>
              <t>http://www.w3.org/2001/04/xmlenc#rsa-1_5 encryption mechanism
              defined in <xref target="XMLENC"></xref>.</t>
            </list></t>
        </section>

        <section title="Key Wrap">
          <t>Purpose of this method:<list>
              <t>This method is ideal for pre-keyed devices, e.g., SIM cards.
              The DSKPP server encrypts keying material using a pre-shared key
              wrapping key and transports it to the DSKPP client. The DSKPP
              client decrypts the keying material, and uses it to derive the
              symmetric key, K_TOKEN.</t>
            </list></t>

          <t>This method is identified with the following URN: <list>
              <t>urn:ietf:params:xml:schema:keyprov:dskpp:wrap</t>
            </list></t>

          <t>The DSKPP server and client MUST support all of the following key
          wrapping mechanisms:<vspace blankLines="1" /><list hangIndent="4"
              style="hanging">
              <t hangText="AES128 KeyWrap"><vspace blankLines="0" />Refer to
              id-aes128-wrap in <xref target="RFC3394"></xref> and
              http://www.w3.org/2001/04/xmlenc#kw-aes128 in <xref
              target="XMLENC"></xref><vspace blankLines="1" /></t>

              <t hangText="AES128 KeyWrap with Padding"><vspace
              blankLines="0" />Refer to id-aes128-wrap-pad in <xref
              target="RFC5649"></xref> and
              http://www.w3.org/2001/04/xmlenc#kw-aes128 in <xref
              target="XMLENC"></xref><vspace blankLines="1" /></t>

              <t hangText="AES-CBC-128"><vspace blankLines="0" />Refer to
              <xref target="FIPS197-AES"></xref> and
              http://www.w3.org/2001/04/xmlenc#aes128-cbc in <xref
              target="XMLENC"></xref></t>
            </list></t>
        </section>

        <section title="Passphrase-Based Key Wrap">
          <t>Purpose of this method:<list>
              <t>This method is a variation of the Key Wrap Method that is
              applicable to constrained devices with keypads, e.g., mobile
              phones. The DSKPP server encrypts keying material using a
              wrapping key derived from a user-provided passphrase, and
              transports the encrypted material to the DSKPP client. The DSKPP
              client decrypts the keying material, and uses it to derive the
              symmetric key, K_TOKEN. <vspace blankLines="1" /></t>

              <t>To preserve the property of not exposing K_TOKEN to any other
              entity than the DSKPP server and the cryptographic module
              itself, the method SHOULD be employed only when the device
              contains facilities (e.g. a keypad) for direct entry of the
              passphrase.</t>
            </list></t>

          <t>This method is identified with the following URN: <list>
              <t>urn:ietf:params:xml:schema:keyprov:dskpp:passphrase-wrap</t>
            </list></t>

          <t>The DSKPP server and client MUST support the following:<list
              hangIndent="" style="empty">
              <t><list style="symbols">
                  <t>The PBES2 password-based encryption scheme defined in
                  <xref target="PKCS-5"></xref> (and identified as
                  http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2
                  in <xref target="PKCS-5-XML"></xref>)<vspace
                  blankLines="1" /></t>

                  <t>The PBKDF2 passphrase-based key derivation function also
                  defined in <xref target="PKCS-5"></xref> (and identified as
                  http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2
                  in <xref target="PKCS-5-XML"></xref>)<vspace
                  blankLines="1" /></t>

                  <t>All of the following key wrapping mechanisms:<vspace
                  blankLines="1" /><list hangIndent="4" style="hanging">
                      <t hangText="AES128 KeyWrap"><vspace
                      blankLines="0" />Refer to id-aes128-wrap in <xref
                      target="RFC3394"></xref> and
                      http://www.w3.org/2001/04/xmlenc#kw-aes128 in <xref
                      target="XMLENC"></xref><vspace blankLines="1" /></t>

                      <t hangText="AES128 KeyWrap with Padding"><vspace
                      blankLines="0" />Refer to id-aes128-wrap-pad in <xref
                      target="RFC5649"></xref> and
                      http://www.w3.org/2001/04/xmlenc#kw-aes128 in <xref
                      target="XMLENC"></xref><vspace blankLines="1" /></t>

                      <t hangText="AES-CBC-128"><vspace blankLines="0" />Refer
                      to <xref target="FIPS197-AES"></xref> and
                      http://www.w3.org/2001/04/xmlenc#aes128-cbc in <xref
                      target="XMLENC"></xref></t>
                    </list></t>
                </list></t>
            </list></t>
        </section>
      </section>

      <section anchor="Subsection-2PassFlow" title="Message Flow">
        <t>The two-pass protocol flow consists of one exchange:<list
            style="format %d:">
            <t>Pass 1 = &lt;KeyProvClientHello&gt;, Pass 2 =
            &lt;KeyProvServerFinished&gt;</t>
          </list></t>

        <t>Although there is no exchange of the &lt;ServerHello&gt; message or
        the &lt;ClientNonce&gt; message, the DSKPP client is still able to
        specify algorithm preferences and supported key types in the
        &lt;KeyProvClientHello&gt; message.</t>

        <t>The purpose and content of each message are described below. XML
        format and examples are in <xref target="Section-Schema"></xref> and
        <xref target="Section-Examples"></xref>.</t>

        <section title="KeyProvTrigger">
          <t>The trigger message is used in exactly the same way for the
          two-pass variant as for the four-pass variant; refer to <xref
          target="Subsection-Trigger"></xref>.</t>
        </section>

        <section anchor="SubSecClientHello" title="KeyProvClientHello">
          <figure>
            <preamble></preamble>

            <artwork><![CDATA[        DSKPP Client                         DSKPP Server
        ------------                         ------------
        SAL, AD, R_C,
        [DeviceID], [KeyID],
        KPML                   --->    ]]></artwork>
          </figure>

          <t>When this message is sent:<list style="empty">
              <t>When a DSKPP client first connects to a DSKPP server, it is
              required to send the &lt;KeyProvClientHello&gt; as its first
              message. The client can also send &lt;KeyProvClientHello&gt; in
              response to a &lt;KeyProvTrigger&gt; message.</t>
            </list></t>

          <t>Purpose of this message:<list>
              <t>With this message, the DSKPP client specifies its algorithm
              preferences and supported key types as well as which DSKPP
              versions, protocol variants (in this case "two-pass"), key
              package formats, and key protection methods that it supports.
              Furthermore, the DSKPP client facilitates user authentication by
              transmitting the authentication data (AD) that was provided by
              the user before the first DSKPP message was sent.</t>
            </list></t>

          <t>Application note:<list>
              <t>This message MUST send user authentication data (AD) to the
              DSKPP server. If this message is preceded by trigger message
              &lt;KeyProvTrigger&gt;, then the application will already have
              AD available (see <xref target="Subsection-Trigger"></xref>).
              However, if this message was not preceded by
              &lt;KeyProvTrigger&gt;, then the application MUST retrieve the
              user authentication code, possibly by prompting the user to
              manually enter their authentication code, e.g., on a device with
              only a numeric keypad. The application MUST also derive
              Authentication Data (AD) from the authentication code, as
              described in <xref target="Subsection-AD"></xref>, and save it
              for use in its next message, &lt;KeyProvClientNonce&gt;.</t>
            </list></t>

          <t>What is contained in this message:<list style="empty">
              <t>The Security Attribute List (SAL) included with
              &lt;KeyProvClientHello&gt; contains the combinations of DSKPP
              versions, variants, key package formats, key types, and
              cryptographic algorithms that the DSKPP client supports in order
              of the client's preference (favorite choice first). <vspace
              blankLines="1" />Authentication Data (AD) that was either
              included with &lt;KeyProvTrigger&gt;, or generated as described
              in the "Application Note" above<vspace blankLines="1" />The
              DSKPP client's random nonce (R_C), which was used by the client
              when generating AD. By inserting R_C into the DSKPP session, the
              DSKPP client is able to ensure the DSKPP server is live before
              committing the key. <vspace blankLines="1" />If
              &lt;KeyProvClientHello&gt; was preceded by a
              &lt;KeyProvTrigger&gt;, then this message MUST also include the
              DeviceID and/or KeyID that was provided with the trigger.
              Otherwise, if a trigger message did not precede
              &lt;KeyProvClientHello&gt;, then this message MAY include a
              device ID that was pre-shared with the DSKPP server, and MAY
              contain a key ID associated with a key previously provisioned by
              the DSKPP provisioning server.</t>

              <t><vspace blankLines="0" />The list of key protection methods
              (KPML) that the DSKPP client supports. Each item in the list MAY
              include an encryption key "payload" for the DSKPP server to use
              to protect keying material that it sends back to the client. The
              payload MUST be of type &lt;ds:KeyInfoType&gt; (<xref
              target="XMLDSIG"></xref>). For each key protection method, the
              allowable choices for &lt;ds:KeyInfoType&gt; are:<vspace
              blankLines="1" /><list style="symbols">
                  <t>Key Transport<vspace blankLines="0" />Only those choices
                  of &lt;ds:KeyInfoType&gt; that identify a public key (i.e.,
                  &lt;ds:KeyName&gt;, &lt;ds:KeyValue&gt;,
                  &lt;ds:X509Data&gt;, or &lt;ds:PGPData&gt;). The
                  &lt;ds:X509Certificate&gt; option of the &lt;ds:X509Data&gt;
                  alternative is RECOMMENDED when the public key corresponding
                  to the private key on the cryptographic module has been
                  certified.<vspace blankLines="1" /></t>

                  <t>Key Wrap<vspace blankLines="0" />Only those choices of
                  &lt;ds:KeyInfoType&gt; that identify a symmetric key (i.e.,
                  &lt;ds:KeyName&gt; and &lt;ds:KeyValue&gt;). The
                  &lt;ds:KeyName&gt; alternative is RECOMMENDED.<vspace
                  blankLines="1" /></t>

                  <t>Passphrase-Based Key Wrap<vspace blankLines="0" />The
                  &lt;ds:KeyName&gt; option MUST be used and the key name MUST
                  identify the passphrase that will be used by the server to
                  generate the key wrapping key. The identifier and passphrase
                  components of &lt;ds:KeyName&gt; MUST be set to the Client
                  ID and authentication code components of AD (same AD as
                  contained in this message).</t>
                </list></t>
            </list></t>

          <t>How the DSKPP server uses this message:<list>
              <t>The DSKPP server will look for an acceptable combination of
              DSKPP version, variant (in this case, two-pass), key package
              format, key type, and cryptographic algorithms. If the DSKPP
              Client's SAL does not match the capabilities of the DSKPP
              Server, or does not comply with key provisioning policy, then
              the DSKPP Server will set the Status attribute to something
              other than "Success". Otherwise, Status will be set to
              "Success".<vspace blankLines="1" /></t>

              <t>The DSKPP server will validate the DeviceID and KeyID if
              included in &lt;KeyProvClientHello&gt;. The DSKPP server MUST
              NOT accept the DeviceID unless the server sent the DeviceID in a
              preceding trigger message. Note that it is also legitimate for a
              DSKPP client to initiate the DSKPP protocol run without having
              received a &lt;KeyProvTrigger&gt; message from a server, but in
              this case any provided DeviceID MUST NOT be accepted by the
              DSKPP server unless the server has access to a unique key for
              the identified device and that key will be used in the
              protocol.<vspace blankLines="1" />The DSKPP server MUST use AD
              to authenticate the user. If authentication fails, then the
              DSKPP server MUST set the return code to a failure status, and
              MUST, in this case, also delete any nonces, keys, and/or secrets
              associated with the failed run of the protocol.<vspace
              blankLines="1" />If user authentication passes, the DSKPP server
              generates a key K_PROV. Note that K_PROV is not derived from the
              formula in <xref target="Subsection-4PassKeyGen"></xref> that
              pertains to four-pass protocol usage. In the two-pass case,
              K_PROV is randomly generated solely by the DSKPP server wherein
              K_PROV MUST consist of two parts of equal length, i.e.,<vspace
              blankLines="1" /><list>
                  <t>K_PROV = K_MAC || K_TOKEN<vspace blankLines="1" /></t>
                </list></t>

              <t>The length of K_TOKEN (and hence also the length of K_MAC) is
              determined by the type of K_TOKEN, which MUST be one of the key
              types supported by the DSKPP client. In cases where the desired
              key length for K_TOKEN is different from the length of K_MAC for
              the underlying MAC algorithm, the greater length of the two MUST
              be chosen to generate K_PROV. The actual MAC key is truncated
              from the resulting K_MAC when it is used in the MAC algorithm
              when K_MAC is longer than necessary in order to match the
              desired K_TOKEN length. If K_TOKEN is longer than needed in
              order to match the K_MAC length, the provisioning server and the
              receiving client must determine the actual secret key length
              from the target key algorithm and store only the truncated
              portion of the K_TOKEN. The truncation MUST take the beginning
              bytes of the desired length from K_TOKEN or K_MAC for the actual
              key. For example, when a provisioning server provisions an event
              based HOTP secret key with length 20 and MAC algorithm
              DSKPP-PRF-SHA256 (<xref
              target="Section-PRFRealizations"></xref>), K_PROV length will be
              64. The derived K_TOKEN and K_MAC will each consist of 32 bytes.
              The actual HOTP key should be the first 20 bytes of the
              K_TOKEN.<vspace blankLines="1" />Once K_PROV is computed, the
              DSKPP server selects one of the key protection methods from the
              DSKPP client's KPML, and uses that method and corresponding
              payload to encrypt K_PROV.</t>

              <!--
              The result of the operation MUST be of type
              &lt;xenc:EncryptedKeyType&gt; (<xref target="XMLENC"></xref>).
              For all three key protection methods, the Type attribute of the
              &lt;xenc:EncryptedKeyType&gt; MUST be present and MUST identify
              the type of the encrypted key. &lt;xenc:CarriedKeyName&gt; MAY
              also be present, but MUST, when present, contain the same value
              as the &lt;KeyID&gt; element of the
              &lt;KeyProvServerFinished&gt; message. For each key protection
              method, the following encryption method and key info values are
              allowed:<vspace blankLines="1" /><list style="symbols">
                  <t>Key Transport<list hangIndent="22" style="hanging">
                      <t hangText="&lt;xenc:EncryptMethod&gt;">Only those
                      encryption methods that utilize a public key and are
                      supported by the DSKPP client</t>

                      <t hangText="&lt;ds:KeyInfo&gt;">This element MUST
                      identify the same public key as the key protection
                      "payload" that was received in
                      &lt;KeyProvClientHello&gt;<vspace blankLines="1" /></t>
                    </list></t>

                  <t>Key Wrap<list hangIndent="22" style="hanging">
                      <t hangText="&lt;xenc:EncryptMethod&gt;">Only those
                      encryption methods that utilize a symmetric key and are
                      supported by the DSKPP client</t>

                      <t hangText="&lt;ds:KeyInfo&gt;">This element MUST
                      identify the same symmetric key as the key protection
                      "payload" that was received in
                      &lt;KeyProvClientHello&gt;<vspace blankLines="1" /></t>
                    </list></t>

                  <t>Passphrase-Based Key Wrap<list hangIndent="22"
                      style="hanging">
                      <t hangText="&lt;xenc:EncryptMethod&gt;">Only those
                      encryption methods that utilize a passphrase to derive
                      the key wrapping key and are supported by the DSKPP
                      client</t>

                      <t hangText="&lt;ds:KeyInfo&gt;">This element MUST
                      identify the same symmetric key as the key protection
                      "payload" that was received in
                      &lt;KeyProvClientHello&gt;<vspace blankLines="1" /></t>
                    </list></t>
                </list></t>-->

              <t>The DSKPP server generates a key package to transport the key
              encryption method information and the encrypted provisioning key
              (K_PROV). The encrypted data format is subject to the choice
              supported by the selected key package. The key package MUST
              specify and use the selected key protection method and the key
              information that was received in
              &lt;KeyProvClientHello&gt;.<vspace blankLines="1" /></t>

              <t>The key package also includes key usage attributes such as
              expiry date and length. The server stores the key package and
              K_TOKEN with a user account on the cryptographic server.<vspace
              blankLines="1" /></t>

              <t>The server generates a MAC for key confirmation, which the
              client will use to avoid a false "Commit" message that would
              cause the cryptographic module to end up in state in which the
              server does not recognize the stored key. In addition, the
              server generates a second MAC if an existing key is being
              renewed so that the DSKPP client will use to confirm that the
              replacement key came from a trusted server.</t>
            </list></t>

          <t>The method the DSKPP server MUST use to calculate the key
          confirmation MAC:<list>
              <t>msg_hash = SHA-256(msg_1, ..., msg_n)<vspace
              blankLines="1" /></t>

              <t>dsLen = len(msg_hash)<vspace blankLines="1" /></t>

              <t>MAC = DSKPP-PRF (K_MAC, "MAC 1 computation" || msg_hash ||
              ServerID, dsLen)<vspace blankLines="1" /></t>

              <t>where</t>

              <t><list hangIndent="12" style="hanging">
                  <t hangText="MAC">The MAC MUST be calculated using the
                  already established MAC algorithm and MUST be computed on
                  the (ASCII) string "MAC 1 computation", msg_hash, and
                  ServerID using the existing the MAC key K_MAC.<vspace
                  blankLines="1" /></t>

                  <t hangText="K_MAC">The key, along with K_TOKEN, that is
                  derived from K_PROV which the DSKPP server MUST provide to
                  the cryptographic module.<vspace blankLines="1" /></t>

                  <t hangText="msg_hash">The message hash, defined in <xref
                  target="Subsection-MsgHashAlg"></xref>, of messages msg_1,
                  ..., msg_n.<vspace blankLines="1" /></t>

                  <t hangText="ServerID">The identifier that the DSKPP server
                  MUST include in the &lt;KeyPackage&gt; element of
                  &lt;KeyProvServerFinished&gt;.<vspace blankLines="1" /></t>
                </list></t>

              <t>If DSKPP-PRF (defined in <xref target="DSKPP-PRF"></xref>) is
              used as the MAC algorithm, then the input parameter s MUST
              consist of the concatenation of the (ASCII) string "MAC 1
              computation", msg_hash, and ServerID, and the parameter dsLen
              MUST be set to the length of msg_hash.</t>
            </list></t>

          <t>The method the DSKPP server MUST use to calculate the server
          authentication MAC:<list>
              <t>The MAC MUST be computed on the (ASCII) string "MAC 2
              computation", the server identifier ServerID, and R, using a
              pre-existing MAC key K_MAC' (the MAC key that existed before
              this protocol run). Note that the implementation may specify
              K_MAC' to be the value of the K_TOKEN that is being
              replaced.<vspace blankLines="1" /></t>

              <t>If DSKPP-PRF is used as the MAC algorithm, then the input
              parameter s MUST consist of the concatenation of the (ASCII)
              string "MAC 2 computation" ServerID, and R. The parameter dsLen
              MUST be set to at least 16 (i.e. the length of the MAC MUST be
              at least 16 octets):<vspace blankLines="1" /></t>

              <t>dsLen &gt;= 16<vspace blankLines="1" /></t>

              <t>MAC = DSKPP-PRF (K_MAC', "MAC 2 computation" || ServerID ||
              R, dsLen)<vspace blankLines="1" /></t>

              <t>The MAC algorithm MUST be the same as the algorithm used by
              the DSKPP server to calculate the key confirmation MAC.</t>
            </list></t>
        </section>

        <section title="KeyProvServerFinished">
          <figure>
            <preamble></preamble>

            <artwork><![CDATA[       DSKPP Client                         DSKPP Server
        ------------                         ------------
                               <---           KP, MAC, AD 
]]></artwork>

            <postamble></postamble>
          </figure>

          <t>When this message is sent:<list>
              <t>The DSKPP server will send this message after authenticating
              the user and, if authentication passed, generating K_TOKEN and a
              key package, and associating them with the user's account on the
              cryptographic server.</t>
            </list></t>

          <t>Purpose of this message:<list>
              <t>With this message the DSKPP server transports a key package
              containing the encrypted provisioning key (K_PROV) and key usage
              attributes.</t>
            </list></t>

          <t>What is contained in this message:<list>
              <t>A status attribute equivalent to the server's return code to
              &lt;KeyProvClientHello&gt;. If the server found an acceptable
              set of attributes from the client's SAL, then it sets status to
              Success.<vspace blankLines="1" />The confirmation message MUST
              include the Key Package (KP) that holds the DSKPP Server's ID,
              key ID, key type, encrypted provisioning key (K_PROV),
              encryption method, and additional configuration information. The
              default symmetric key package format MUST be based on the
              Portable Symmetric Key Container (PSKC) defined in <xref
              target="PSKC"></xref>. Alternative formats MAY include <xref
              target="SKPC-ASN.1"></xref>, PKCS#12 <xref
              target="PKCS-12"></xref>, or PKCS#5 XML <xref
              target="PKCS-5-XML"></xref>. <vspace blankLines="1" />This
              message MUST include a MAC that the DSKPP client will use for
              key confirmation. This key confirmation MAC is calculated using
              the "MAC 1 computation" as described in the previous section.
              <vspace blankLines="1" /></t>

              <t>Finally, if an existing key is being replaced, then this
              message MUST also include a server authentication MAC
              (calculated using the "MAC 2 computation" as described in the
              previous section), which is passed as AD to the DSKPP
              client.</t>
            </list></t>

          <t>How the DSKPP client uses this message:<list>
              <t>After receiving a &lt;KeyProvServerFinished&gt; message with
              Status = "Success", the DSKPP client MUST verify both MACs (MAC
              and AD). The DSKPP client MUST terminate the DSKPP protocol run
              if either MAC does not verify, and MUST, in this case, also
              delete any nonces, keys, and/or secrets associated with the
              failed run of the protocol. <vspace blankLines="1" />If
              &lt;KeyProvServerFinished&gt; has Status = "Success" and the
              MACs were verified, then the DSKPP client MUST extract K_PROV
              from the provided key package, and derive K_TOKEN. Finally, the
              DSKPP client initializes the cryptographic module with K_TOKEN
              and the corresponding key usage attributes. After this
              operation, it MUST NOT be possible to overwrite the key unless
              knowledge of an authorizing key is proven through a MAC on a
              later &lt;KeyProvServerFinished&gt; message.</t>
            </list></t>
        </section>
      </section>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-ProtocolExts" title="Protocol Extensions">
      <t>DSKPP has been designed to be extensible. The sub-sections below
      define two extensions that are included with the DSKPP schema. Since it
      is possible that the use of extensions will harm interoperability,
      protocol designers are advised to carefully consider the use of
      extensions. For example, if a particular implementation relies on the
      presence of a proprietary extension, then it may not be able to
      interoperate with independent implementations that have no knowledge of
      this extension.</t>

      <t>Extensions may be sent with any DSKPP message using the
      ExtensionsType. The ExtensionsType type is a list of Extensions
      containing type-value pairs that define optional features supported by a
      DSKPP client or server. Each extension MAY be marked as Critical by
      setting the "Critical" attribute of the Extension to "true". Unless an
      extension is marked as Critical, a receiving party need not be able to
      interpret it; a receiving party is always free to disregard any
      (non-critical) extensions.</t>

      <section title="The ClientInfoType Extension">
        <t>The ClientInfoType extension MAY contain any client-specific data
        required of an application. This extension MAY be present in a
        &lt;KeyProvClientHello&gt; or &lt;KeyProvClientNonce&gt; message. When
        present, this extension MUST NOT be marked as Critical.</t>

        <t>DSKPP servers MUST support this extension. DSKPP servers MUST NOT
        attempt to interpret the data it carries and, if received, MUST
        include it unmodified in the current protocol run's next server
        response. DSKPP servers need not retain the ClientInfoType data.</t>
      </section>

      <section title="The ServerInfoType Extension">
        <t>The ServerInfoType extension MAY contain any server-specific data
        required of an application, e.g., state information. This extension is
        only valid in &lt;KeyProvServerHello&gt; messages for which the Status
        attribute is set to "Continue". When present, this extension MUST NOT
        be marked as Critical.</t>

        <t>DSKPP clients MUST support this extension. DSKPP clients MUST NOT
        attempt to interpret the data it carries and, if received, MUST
        include it unmodified in the current protocol run's next client
        request (i.e., the &lt;KeyProvClientNonce&gt; message). DSKPP clients
        need not retain the ServerInfoType data.</t>
      </section>
    </section>

    <section anchor="Section-Bindings" title="Protocol Bindings">
      <section title="General Requirements">
        <t>DSKPP assumes a reliable transport.</t>
      </section>

      <section anchor="SubSec-HTTP1.1" title="HTTP/1.1 Binding for DSKPP">
        <t>This section presents a binding of the previous messages to
        HTTP/1.1 <xref target="RFC2616"></xref>. This HTTP binding is
        mandatory-to-implement, although newer versions of the specification
        might define additional bindings in the future. Note that the HTTP
        client will normally be different from the DSKPP client (i.e., the
        HTTP client will "proxy" DSKPP messages from the DSKPP client to the
        DSKPP server). Likewise, on the HTTP server side, the DSKPP server MAY
        receive DSKPP message from a "front-end" HTTP server. The DSKPP server
        will be identified by a specific URL, which may be pre-configured, or
        provided to the client during initialization.</t>

        <section anchor="Subsection-Identification"
                 title="Identification of DSKPP Messages">
          <t>The MIME-type for all DSKPP messages MUST be</t>

          <t>application/dskpp+xml</t>
        </section>

        <section title="HTTP Headers">
          <t>In order to avoid caching of responses carrying DSKPP messages by
          proxies, the following holds:</t>

          <t><list style="symbols">
              <t>When using HTTP/1.1, requesters SHOULD:<list>
                  <t>Include a Cache-Control header field set to "no-cache,
                  no-store".</t>

                  <t>Include a Pragma header field set to "no-cache".<vspace
                  blankLines="1" /></t>
                </list></t>

              <t>When using HTTP/1.1, responders SHOULD:<list>
                  <t>Include a Cache-Control header field set to "no-cache,
                  no-must-revalidate, private".</t>

                  <t>Include a Pragma header field set to "no-cache".</t>

                  <t>NOT include a Validator, such as a Last-Modified or ETag
                  header.</t>
                </list></t>
            </list></t>

          <t>To handle content negotiation, HTTP requests MAY include an HTTP
          Accept header field. This header field SHOULD should be identified
          using the MIME type specified in <xref
          target="Subsection-Identification"></xref>. The Accept header MAY
          include additional content types defined by future versions of this
          protocol.</t>

          <t>There are no other restrictions on HTTP headers, besides the
          requirement to set the Content-Type header value to the MIME type
          specified in <xref target="Subsection-Identification"></xref>.</t>
        </section>

        <section title="HTTP Operations">
          <t>Persistent connections as defined in HTTP/1.1 are OPTIONAL. DSKPP
          requests are mapped to HTTP requests with the POST method. DSKPP
          responses are mapped to HTTP responses.</t>

          <t>For the 4-pass DSKPP, messages within the protocol run are bound
          together. In particular, &lt;KeyProvServerHello&gt; is bound to the
          preceding &lt;KeyProvClientHello&gt; by being transmitted in the
          corresponding HTTP response. &lt;KeyProvServerHello&gt; MUST have a
          SessionID attribute, and the SessionID attribute of the subsequent
          &lt;KeyProvClientNonce&gt; message MUST be identical.
          &lt;KeyProvServerFinished&gt; is then once again bound to the rest
          through HTTP (and possibly through a SessionID).</t>
        </section>

        <section title="HTTP Status Codes">
          <t>A DSKPP HTTP responder that refuses to perform a message exchange
          with a DSKPP HTTP requester SHOULD return a 403 (Forbidden)
          response. In this case, the content of the HTTP body is not
          significant. In the case of an HTTP error while processing a DSKPP
          request, the HTTP server MUST return a 500 (Internal Server Error)
          response. This type of error SHOULD be returned for HTTP-related
          errors detected before control is passed to the DSKPP processor, or
          when the DSKPP processor reports an internal error (for example, the
          DSKPP XML namespace is incorrect, or the DSKPP schema cannot be
          located). If a request is received that is not a DSKPP client
          message, the DSKPP responder MUST return a 400 (Bad request)
          response.</t>

          <t>In these cases (i.e., when the HTTP response code is 4xx or 5xx),
          the content of the HTTP body is not significant.</t>

          <t>Redirection status codes (3xx) apply as usual.</t>

          <t>Whenever the HTTP POST is successfully invoked, the DSKPP HTTP
          responder MUST use the 200 status code and provide a suitable DSKPP
          message (possibly with DSKPP error information included) in the HTTP
          body.</t>
        </section>

        <section title="HTTP Authentication">
          <t>No support for HTTP/1.1 authentication is assumed.</t>
        </section>

        <section anchor="Section-InitDSKPP" title="Initialization of DSKPP">
          <t>If a user requests key initialization in a browsing session, and
          if that request has an appropriate Accept header (e.g., to a
          specific DSKPP server URL), the DSKPP server MAY respond by sending
          a DSKPP initialization message in an HTTP response with Content-Type
          set according to <xref target="Subsection-Identification"></xref>
          and response code set to 200 (OK). The initialization message MAY
          carry data in its body, such as the URL for the DSKPP client to use
          when contacting the DSKPP server. If the message does carry data,
          the data MUST be a valid instance of a &lt;KeyProvTrigger&gt;
          element.</t>

          <t>Note that if the user's request was directed to some other
          resource, the DSKPP server MUST NOT respond by combining the DSKPP
          content type with response code 200. In that case, the DSKPP server
          SHOULD respond by sending a DSKPP initialization message in an HTTP
          response with Content-Type set according to <xref
          target="Subsection-Identification"></xref> and response code set to
          406 (Not Acceptable).</t>
        </section>

        <section title="Example Messages">
          <t hangText=""><list counter="Examples" hangIndent="0"
              style="format %c.">
              <t>Initialization from DSKPP server:</t>
            </list> <list hangIndent="4" style="empty">
              <t hangText="">HTTP/1.1 200 OK<vspace
              blankLines="1" />Cache-Control: no-store<vspace
              blankLines="0" />Content-Type: application/dskpp+xml<vspace
              blankLines="0" />Content-Length: &lt;some value&gt;<vspace
              blankLines="1" />DSKPP initialization data in XML form...</t>
            </list></t>

          <t><list counter="Examples" hangIndent="0" style="format %c.">
              <t>Initial request from DSKPP client:</t>
            </list> <list hangIndent="4" style="empty">
              <t>POST http://example.com/cgi-bin/DSKPP-server HTTP/1.1<vspace
              blankLines="1" />Cache-Control: no-cache, no-store<vspace
              blankLines="0" />Pragma: no-cache<vspace blankLines="0" />Host:
              www.example.com<vspace blankLines="0" />Content-Type:
              application/dskpp+xml<vspace blankLines="0" />Content-Length:
              &lt;some value&gt;<vspace blankLines="1" />DSKPP data in XML
              form (supported version, supported algorithms...)</t>
            </list></t>

          <t hangText=""><list counter="Examples" hangIndent="0"
              style="format %c.">
              <t>Initial response from DSKPP server:</t>
            </list> <list hangIndent="4" style="empty">
              <t hangText="">HTTP/1.1 200 OK<vspace
              blankLines="1" />Cache-Control: no-cache, no-must-revalidate,
              private<vspace blankLines="0" />Pragma: no-cache<vspace
              blankLines="0" />Content-Type: application/dskpp+xml<vspace
              blankLines="0" />Content-Length: &lt;some value&gt;<vspace
              blankLines="1" />DSKPP data in XML form (server random nonce,
              server public key, ...)</t>
            </list></t>
        </section>
      </section>
    </section>

    <!-- //////////////////////////////////////////////////////////////////////////////////-->

    <section anchor="Section-Schema" title="DSKPP XML Schema">
      <section title="General Processing Requirements">
        <t>Some DSKPP elements rely on the parties being able to compare
        received values with stored values. Unless otherwise noted, all
        elements that have the XML Schema "xs:string" type, or a type derived
        from it, MUST be compared using an exact binary comparison. In
        particular, DSKPP implementations MUST NOT depend on case-insensitive
        string comparisons, normalization or trimming of white space, or
        conversion of locale-specific formats such as numbers.</t>

        <t>Implementations that compare values that are represented using
        different character encodings MUST use a comparison method that
        returns the same result as converting both values to the Unicode
        character encoding and then performing an exact binary comparison.</t>

        <t>No collation or sorting order for attributes or element values is
        defined. Therefore, DSKPP implementations MUST NOT depend on specific
        sorting orders for values.</t>
      </section>

      <section title="Schema">
        <t></t>

        <figure>
          <artwork><![CDATA[   <?xml version="1.0" encoding="utf-8"?>
   <xs:schema 
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp" 
      xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc" 
      xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
      targetNamespace="urn:ietf:params:xml:ns:keyprov:dskpp"
      elementFormDefault="qualified" attributeFormDefault="unqualified"
         version="1.0">
      <xs:import namespace="http://www.w3.org/2000/09/xmldsig#"
         schemaLocation=
         "http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/
         xmldsig-core-schema.xsd"/>
      <xs:import namespace="urn:ietf:params:xml:ns:keyprov:pskc" 
         schemaLocation="keyprov-pskc-1.0.xsd"/>
      <xs:complexType name="AbstractRequestType" abstract="true">
         <xs:annotation>
            <xs:documentation> Basic types </xs:documentation>
         </xs:annotation>
         <xs:attribute name="Version" type="dskpp:VersionType" 
            use="required"/>
      </xs:complexType>

      <xs:complexType name="AbstractResponseType" abstract="true">
         <xs:annotation>
            <xs:documentation> Basic types </xs:documentation>
         </xs:annotation>
         <xs:attribute name="Version" type="dskpp:VersionType" 
            use="required"/>
         <xs:attribute name="SessionID" type="dskpp:IdentifierType" />
         <xs:attribute name="Status" type="dskpp:StatusCode" 
            use="required"/>
      </xs:complexType>

      <xs:simpleType name="VersionType">
         <xs:restriction base="xs:string">
            <xs:pattern value="\d{1,2}\.\d{1,3}" />
         </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="IdentifierType">
         <xs:restriction base="xs:string">
            <xs:maxLength value="128" />
         </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="StatusCode">
         <xs:restriction base="xs:string">
            <xs:enumeration value="Continue" />
            <xs:enumeration value="Success" />
            <xs:enumeration value="Abort" />
            <xs:enumeration value="AccessDenied" />
            <xs:enumeration value="MalformedRequest" />
            <xs:enumeration value="UnknownRequest" />
            <xs:enumeration value="UnknownCriticalExtension" />
            <xs:enumeration value="UnsupportedVersion" />
            <xs:enumeration value="NoSupportedKeyTypes" />
            <xs:enumeration value="NoSupportedEncryptionAlgorithms" />
            <xs:enumeration value="NoSupportedMacAlgorithms" />
            <xs:enumeration value="NoProtocolVariants" />
            <xs:enumeration value="NoSupportedKeyPackages" />
            <xs:enumeration value="AuthenticationDataMissing" />
            <xs:enumeration value="AuthenticationDataInvalid" />
            <xs:enumeration value="InitializationFailed" />
            <xs:enumeration value="ProvisioningPeriodExpired" />
         </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="DeviceIdentifierDataType">
         <xs:choice>
            <xs:element name="DeviceId" type="pskc:DeviceInfoType" />
            <xs:any namespace="##other" processContents="strict" />
         </xs:choice>
      </xs:complexType>

      <xs:simpleType name="PlatformType">
         <xs:restriction base="xs:string">
            <xs:enumeration value="Hardware" />
            <xs:enumeration value="Software" />
            <xs:enumeration value="Unspecified" />
         </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="TokenPlatformInfoType">
         <xs:attribute name="KeyLocation" 
            type="dskpp:PlatformType"/>
         <xs:attribute name="AlgorithmLocation" 
            type="dskpp:PlatformType"/>
      </xs:complexType>

      <xs:simpleType name="NonceType">
         <xs:restriction base="xs:base64Binary">
            <xs:minLength value="16" />
         </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="AlgorithmsType">
         <xs:sequence maxOccurs="unbounded">
            <xs:element name="Algorithm" type="dskpp:AlgorithmType"/>
         </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="AlgorithmType">
         <xs:restriction base="xs:anyURI" />
      </xs:simpleType>

      <xs:complexType name="ProtocolVariantsType">
         <xs:sequence>
            <xs:element name="FourPass" minOccurs="0" />
            <xs:element name="TwoPass" 
               type="dskpp:KeyProtectionDataType" minOccurs="0"/>      
         </xs:sequence>
      </xs:complexType>

      <xs:complexType name="KeyProtectionDataType">
         <xs:annotation>
            <xs:documentation xml:lang="en">
               This element is only valid for two-pass DSKPP.
            </xs:documentation>
         </xs:annotation>
         <xs:sequence maxOccurs="unbounded">
           <xs:element name="SupportedKeyProtectionMethod" 
              type="xs:anyURI"/>
           <xs:element name="Payload" 
              type="dskpp:PayloadType" minOccurs="0"/>
         </xs:sequence>
      </xs:complexType>

      <xs:complexType name="PayloadType">
         <xs:choice>
            <xs:element name="Nonce" type="dskpp:NonceType" />
            <xs:any namespace="##other" processContents="strict"/>
         </xs:choice>
      </xs:complexType>

      <xs:complexType name="KeyPackagesFormatType">
         <xs:sequence maxOccurs="unbounded">
            <xs:element name="KeyPackageFormat" 
               type="dskpp:KeyPackageFormatType"/>
         </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="KeyPackageFormatType">
         <xs:restriction base="xs:anyURI" />
      </xs:simpleType>

      <xs:complexType name="AuthenticationDataType">
         <xs:annotation>
            <xs:documentation xml:lang="en">
               Authentication data contains a MAC.
            </xs:documentation>
         </xs:annotation>
         <xs:sequence>
            <xs:element name="ClientID" 
               type="dskpp:IdentifierType" minOccurs="0"/>
            <xs:choice>
               <xs:element name="AuthenticationCodeMac" 
                  type="dskpp:AuthenticationMacType"/>
               <xs:any namespace="##other" processContents="strict" />
            </xs:choice>
         </xs:sequence>
      </xs:complexType>

      <xs:complexType name="AuthenticationMacType">
         <xs:sequence>
            <xs:element minOccurs="0" name="Nonce" 
               type="dskpp:NonceType"/>
            <xs:element minOccurs="0" name="IterationCount" 
               type="xs:int"/>
            <xs:element name="Mac" type="dskpp:MacType" />
         </xs:sequence>
      </xs:complexType>

      <xs:complexType name="MacType">
         <xs:simpleContent>
            <xs:extension base="xs:base64Binary">
               <xs:attribute name="MacAlgorithm" type="xs:anyURI"/>
            </xs:extension>
         </xs:simpleContent>
      </xs:complexType>

      <xs:complexType name="KeyPackageType">
         <xs:sequence>
            <xs:element minOccurs="0" name="ServerID" 
               type="xs:anyURI"/>
            <xs:element minOccurs="0" name="KeyProtectionMethod" 
               type="xs:anyURI" />
            <xs:choice>
               <xs:element name="KeyContainer" 
                  type="pskc:KeyContainerType"/>
               <xs:any namespace="##other" processContents="strict"/>
            </xs:choice>
         </xs:sequence>
      </xs:complexType>

      <xs:complexType name="InitializationTriggerType">
         <xs:sequence>
            <xs:element minOccurs="0" name="DeviceIdentifierData" 
               type="dskpp:DeviceIdentifierDataType" />
            <xs:element minOccurs="0" name="KeyID" 
               type="xs:base64Binary"/>
            <xs:element minOccurs="0" name="TokenPlatformInfo" 
               type="dskpp:TokenPlatformInfoType" />
            <xs:element name="AuthenticationData" 
               type="dskpp:AuthenticationDataType" />
            <xs:element minOccurs="0" name="ServerUrl" 
               type="xs:anyURI"/>
            <xs:any minOccurs="0" namespace="##other" 
               processContents="strict" />
         </xs:sequence>
      </xs:complexType>

      <xs:complexType name="ExtensionsType">
         <xs:annotation>
            <xs:documentation> Extension types </xs:documentation>
         </xs:annotation>
         <xs:sequence maxOccurs="unbounded">
            <xs:element name="Extension" 
               type="dskpp:AbstractExtensionType"/>
         </xs:sequence>
      </xs:complexType>
  
      <xs:complexType name="AbstractExtensionType" abstract="true">
         <xs:attribute name="Critical" type="xs:boolean" />
      </xs:complexType>

      <xs:complexType name="ClientInfoType">
         <xs:complexContent mixed="false">
            <xs:extension base="dskpp:AbstractExtensionType">
               <xs:sequence>
                  <xs:element name="Data" type="xs:base64Binary"/>
               </xs:sequence>
            </xs:extension>
         </xs:complexContent>
      </xs:complexType>

      <xs:complexType name="ServerInfoType">
         <xs:complexContent mixed="false">
            <xs:extension base="dskpp:AbstractExtensionType">
               <xs:sequence>
                  <xs:element name="Data" type="xs:base64Binary"/>
               </xs:sequence>
            </xs:extension>
         </xs:complexContent>
      </xs:complexType>

      <xs:element name="KeyProvTrigger" 
         type="dskpp:KeyProvTriggerType">
         <xs:annotation>
            <xs:documentation> DSKPP PDUs </xs:documentation>
         </xs:annotation>
      </xs:element>
      <xs:complexType name="KeyProvTriggerType">
         <xs:annotation>
         <xs:documentation xml:lang="en">
            Message used to trigger the device to initiate a
            DSKPP protocol run.
         </xs:documentation>
         </xs:annotation>
         <xs:sequence>
            <xs:choice>
               <xs:element name="InitializationTrigger" 
                  type="dskpp:InitializationTriggerType" />
               <xs:any namespace="##other" processContents="strict"/>
            </xs:choice>
         </xs:sequence>
         <xs:attribute name="Version" type="dskpp:VersionType"/>
      </xs:complexType>

      <xs:element name="KeyProvClientHello" 
         type="dskpp:KeyProvClientHelloPDU">
         <xs:annotation>
            <xs:documentation>KeyProvClientHello PDU</xs:documentation>
         </xs:annotation>
      </xs:element>
      <xs:complexType name="KeyProvClientHelloPDU">
         <xs:annotation>
            <xs:documentation xml:lang="en">
               Message sent from DSKPP client to DSKPP server to 
               initiate a DSKPP session.
            </xs:documentation>
         </xs:annotation>
         <xs:complexContent mixed="false">
            <xs:extension base="dskpp:AbstractRequestType">
               <xs:sequence>
                  <xs:element minOccurs="0" name="DeviceIdentifierData"
                     type="dskpp:DeviceIdentifierDataType" />
                  <xs:element minOccurs="0" name="KeyID" 
                     type="xs:base64Binary" />
                  <xs:element minOccurs="0" name="ClientNonce" 
                     type="dskpp:NonceType" />
                  <xs:element name="SupportedKeyTypes" 
                     type="dskpp:AlgorithmsType" />
                  <xs:element name="SupportedEncryptionAlgorithms" 
                     type="dskpp:AlgorithmsType" />
                  <xs:element name="SupportedMacAlgorithms" 
                     type="dskpp:AlgorithmsType" />
                  <xs:element minOccurs="0" 
                     name="SupportedProtocolVariants" 
                     type="dskpp:ProtocolVariantsType" />
                  <xs:element minOccurs="0" name="SupportedKeyPackages"
                     type="dskpp:KeyPackagesFormatType" />
                  <xs:element minOccurs="0" name="AuthenticationData" 
                     type="dskpp:AuthenticationDataType" />
                  <xs:element minOccurs="0" name="Extensions" 
                     type="dskpp:ExtensionsType" />
               </xs:sequence>
            </xs:extension>
         </xs:complexContent>
      </xs:complexType>

      <xs:element name="KeyProvServerHello" 
         type="dskpp:KeyProvServerHelloPDU">
         <xs:annotation>
            <xs:documentation>KeyProvServerHello PDU</xs:documentation>
         </xs:annotation>
      </xs:element>
      <xs:complexType name="KeyProvServerHelloPDU">
         <xs:annotation>
            <xs:documentation xml:lang="en">
               Response message sent from DSKPP server to DSKPP client
               in four-pass DSKPP.
            </xs:documentation>
         </xs:annotation>
         <xs:complexContent mixed="false">
            <xs:extension base="dskpp:AbstractResponseType">
               <xs:sequence minOccurs="0">
                  <xs:element name="KeyType" 
                     type="dskpp:AlgorithmType"/>
                  <xs:element name="EncryptionAlgorithm" 
                     type="dskpp:AlgorithmType" />
                  <xs:element name="MacAlgorithm" 
                     type="dskpp:AlgorithmType"/>
                  <xs:element name="EncryptionKey" 
                     type="ds:KeyInfoType"/>
                  <xs:element name="KeyPackageFormat" 
                     type="dskpp:KeyPackageFormatType" />
                  <xs:element name="Payload" type="dskpp:PayloadType"/>
                  <xs:element minOccurs="0" name="Extensions" 
                     type="dskpp:ExtensionsType" />
                  <xs:element minOccurs="0" name="Mac" 
                     type="dskpp:MacType"/>
               </xs:sequence>
            </xs:extension>
         </xs:complexContent>
      </xs:complexType>

      <xs:element name="KeyProvClientNonce" 
         type="dskpp:KeyProvClientNoncePDU">
         <xs:annotation>
            <xs:documentation>KeyProvClientNonce PDU</xs:documentation>
         </xs:annotation>
      </xs:element>
      <xs:complexType name="KeyProvClientNoncePDU">
         <xs:annotation>
            <xs:documentation xml:lang="en">
               Response message sent from DSKPP client to
               DSKPP server in a four-pass DSKPP session.
            </xs:documentation>
         </xs:annotation>
         <xs:complexContent mixed="false">
            <xs:extension base="dskpp:AbstractRequestType">
               <xs:sequence>
                  <xs:element name="EncryptedNonce" 
                     type="xs:base64Binary"/>
                  <xs:element minOccurs="0" name="AuthenticationData" 
                     type="dskpp:AuthenticationDataType" />
                  <xs:element minOccurs="0" name="Extensions" 
                     type="dskpp:ExtensionsType" />
               </xs:sequence>
               <xs:attribute name="SessionID" 
                  type="dskpp:IdentifierType" use="required"/>
            </xs:extension>
         </xs:complexContent>
      </xs:complexType>

      <xs:element name="KeyProvServerFinished" 
         type="dskpp:KeyProvServerFinishedPDU">
         <xs:annotation>
            <xs:documentation>
               KeyProvServerFinished PDU
            </xs:documentation>
         </xs:annotation>
      </xs:element>
      <xs:complexType name="KeyProvServerFinishedPDU">
         <xs:annotation>
            <xs:documentation xml:lang="en">
               Final message sent from DSKPP server to DSKPP client in
               a DSKPP session. A MAC value serves for key 
               confirmation, and optional AuthenticationData serves for
               server authentication.
            </xs:documentation>
         </xs:annotation>
         <xs:complexContent mixed="false">
            <xs:extension base="dskpp:AbstractResponseType">
               <xs:sequence minOccurs="0">
                  <xs:element name="KeyPackage" 
                     type="dskpp:KeyPackageType" />
                  <xs:element minOccurs="0" name="Extensions" 
                     type="dskpp:ExtensionsType" />
                  <xs:element name="Mac" type="dskpp:MacType" />
                  <xs:element minOccurs="0" name="AuthenticationData" 
                     type="dskpp:AuthenticationMacType" />
               </xs:sequence>
            </xs:extension>
         </xs:complexContent>
      </xs:complexType>
    </xs:schema>    ]]></artwork>

          <postamble></postamble>
        </figure>
      </section>
    </section>

    <!-- ////////////////////////////////////////////////////////// -->

    <!-- ////////////////////////////////////////////////////////// -->

    <section title="Conformance Requirements" toc="default">
      <t>In order to assure that all implementations of DSKPP can
      interoperate, the DSKPP server:</t>

      <t><list style="format %c.">
          <t>MUST implement the four-pass variation of the protocol (<xref
          target="Subsection-FourPassUsage"></xref>)<vspace
          blankLines="1" /></t>

          <t>MUST implement the two-pass variation of the protocol (<xref
          target="Subsecton-TwoPass"></xref>)<vspace blankLines="1" /></t>

          <t>MUST support user authentication (<xref
          target="Subsection-UserAuth"></xref>)<vspace blankLines="1" /></t>

          <t>MUST support the following key derivation functions:<list
              style="symbols">
              <t>DSKPP-PRF-AES DSKPP-PRF realization (<xref
              target="Section-PRFRealizations"></xref>)</t>

              <t>DSKPP-PRF-SHA256 DSKPP-PRF realization (<xref
              target="Section-PRFRealizations"></xref>)<vspace
              blankLines="1" /></t>
            </list></t>

          <t>MUST support the following encryption mechanisms for protection
          of the client nonce in the four-pass protocol:<list style="symbols">
              <t>Mechanism described in <xref
              target="Subsection-Enc"></xref><vspace blankLines="1" /></t>
            </list></t>

          <t>MUST support one of the following encryption algorithms for
          symmetric key operations, e.g., key wrap:<list style="symbols">
              <t>KW-AES128 without padding; refer to
              http://www.w3.org/2001/04/xmlenc#kw-aes128 in <xref
              target="XMLENC"></xref></t>

              <t>KW-AES128 with padding; refer to
              http://www.w3.org/2001/04/xmlenc#kw-aes128 in <xref
              target="XMLENC"></xref> and <xref target="RFC5649"></xref></t>

              <t>AES-CBC-128; refer to <xref
              target="FIPS197-AES"></xref><vspace blankLines="1" /></t>
            </list></t>

          <t>MUST support the following encryption algorithms for asymmetric
          key operations, e.g., key transport:<list style="symbols">
              <t>RSA Encryption Scheme <xref target="PKCS-1"></xref><vspace
              blankLines="1" /></t>
            </list></t>

          <t>MUST support the following integrity/KDF MAC functions:<list
              style="symbols">
              <t>DSKPP-PRF-AES (<xref
              target="Section-PRFRealizations"></xref>)</t>

              <t>DSKPP-PRF-SHA256 (<xref
              target="Section-PRFRealizations"></xref>)<vspace
              blankLines="1" /></t>

              <!--
              <t>HMAC-SHA256 <xref target="FIPS180-SHA"></xref></t>

              <t>AES-CMAC-128 <xref target="FIPS197-AES"></xref><vspace
              blankLines="1" /></t>
-->
            </list></t>

          <t>MUST support the PSKC key package <xref target="PSKC"></xref>;
          all three PSKC key protection methods (Key Transport, Key Wrap, and
          Passphrase-Based Key Wrap) MUST be implemented<vspace
          blankLines="1" /></t>

          <t>MAY support the ASN.1 key package as defined in <xref
          target="SKPC-ASN.1"></xref></t>
        </list></t>

      <t>DSKPP clients MUST support either the two-pass or the four-pass
      variant of the protocol. DSKPP clients MUST fulfill all requirements
      listed in item (c) - (j).</t>

      <t>Finally, implementations of DSKPP MUST bind DSKPP messages to
      HTTP/1.1 as described in <xref target="SubSec-HTTP1.1"></xref>.</t>

      <t>Of course, DSKPP is a security protocol, and one of its major
      functions is to allow only authorized parties to successfully initialize
      a cryptographic module with a new symmetric key. Therefore, a particular
      implementation may be configured with any of a number of restrictions
      concerning algorithms and trusted authorities that will prevent
      universal interoperability.</t>
    </section>

    <section anchor="Section-Security" title="Security Considerations">
      <section title="General">
        <t>DSKPP is designed to protect generated keying material from
        exposure. No other entities than the DSKPP server and the
        cryptographic module will have access to a generated K_TOKEN if the
        cryptographic algorithms used are of sufficient strength and, on the
        DSKPP client side, generation and encryption of R_C and generation of
        K_TOKEN take place as specified in the cryptographic module. This
        applies even if malicious software is present in the DSKPP client.
        However, as discussed in the following sub-sections, DSKPP does not
        protect against certain other threats resulting from man-in-the-middle
        attacks and other forms of attacks. DSKPP MUST, therefore, be run over
        a transport providing confidentiality and integrity, such as HTTP over
        Transport Layer Security (TLS) with a suitable ciphersuite, when such
        threats are a concern. Note that TLS ciphersuites with anonymous key
        exchanges are not suitable in those situations.</t>
      </section>

      <section title="Active Attacks">
        <section title="Introduction">
          <t>An active attacker MAY attempt to modify, delete, insert, replay,
          or reorder messages for a variety of purposes including service
          denial and compromise of generated keying material.</t>
        </section>

        <section anchor="Subsection-Messages" title="Message Modifications">
          <t>Modifications to a &lt;KeyProvTrigger&gt; message will either
          cause denial-of-service (modifications of any of the identifiers or
          the authentication code) or will cause the DSKPP client to contact
          the wrong DSKPP server. The latter is in effect a man-in-the-middle
          attack and is discussed further in <xref
          target="Subsection-MITM"></xref>.</t>

          <t>An attacker may modify a &lt;KeyProvClientHello&gt; message. This
          means that the attacker could indicate a different key or device
          than the one intended by the DSKPP client, and could also suggest
          other cryptographic algorithms than the ones preferred by the DSKPP
          client, e.g., cryptographically weaker ones. The attacker could also
          suggest earlier versions of the DSKPP protocol, in case these
          versions have been shown to have vulnerabilities. These
          modifications could lead to an attacker succeeding in initializing
          or modifying another cryptographic module than the one intended
          (i.e., the server assigning the generated key to the wrong module),
          or gaining access to a generated key through the use of weak
          cryptographic algorithms or protocol versions. DSKPP implementations
          MAY protect against the latter by having strict policies about what
          versions and algorithms they support and accept. The former threat
          (assignment of a generated key to the wrong module) is not possible
          when the shared-key variant of DSKPP is employed (assuming existing
          shared keys are unique per cryptographic module), but is possible in
          the public-key variation. Therefore, DSKPP servers MUST NOT accept
          unilaterally provided device identifiers in the public-key
          variation. This is also indicated in the protocol description. In
          the shared-key variation, however, an attacker may be able to
          provide the wrong identifier (possibly also leading to the incorrect
          user being associated with the generated key) if the attacker has
          real-time access to the cryptographic module with the identified
          key. The result of this attack could be that the generated key is
          associated with the correct cryptographic module but the module is
          associated with the incorrect user. See further <xref
          target="Subsection-Interactions"></xref> for a discussion of this
          threat and possible countermeasures.</t>

          <t>An attacker may also modify a &lt;KeyProvServerHello&gt; message.
          This means that the attacker could indicate different key types,
          algorithms, or protocol versions than the legitimate server would,
          e.g., cryptographically weaker ones. The attacker may also provide a
          different nonce than the one sent by the legitimate server. Clients
          MAY protect against the former through strict adherence to policies
          regarding permissible algorithms and protocol versions. The latter
          (wrong nonce) will not constitute a security problem, as a generated
          key will not match the key generated on the legitimate server. Also,
          whenever the DSKPP run would result in the replacement of an
          existing key, the &lt;Mac&gt; element protects against modifications
          of R_S.</t>

          <t>Modifications of &lt;KeyProvClientNonce&gt; messages are also
          possible. If an attacker modifies the SessionID attribute, then, in
          effect, a switch to another session will occur at the server,
          assuming the new SessionID is valid at that time on the server. It
          still will not allow the attacker to learn a generated K_TOKEN since
          R_C has been wrapped for the legitimate server. Modifications of the
          &lt;EncryptedNonce&gt; element, e.g., replacing it with a value for
          which the attacker knows an underlying R'C, will not result in the
          client changing its pre-DSKPP state, since the server will be unable
          to provide a valid MAC in its final message to the client. The
          server MAY, however, end up storing K'TOKEN rather than K_TOKEN. If
          the cryptographic module has been associated with a particular user,
          then this could constitute a security problem. For a further
          discussion about this threat, and a possible countermeasure, see
          <xref target="Subsection-Interactions"></xref> below. Note that use
          of TLS does not protect against this attack if the attacker has
          access to the DSKPP client (e.g., through malicious software,
          "Trojans").</t>

          <t>Finally, attackers may also modify the
          &lt;KeyProvServerFinished&gt; message. Replacing the &lt;Mac&gt;
          element will only result in denial-of-service. Replacement of any
          other element may cause the DSKPP client to associate, e.g., the
          wrong service with the generated key. DSKPP SHOULD be run over a
          transport providing confidentiality and integrity when this is a
          concern.</t>
        </section>

        <section title="Message Deletion">
          <t>Message deletion will not cause any other harm than
          denial-of-service, since a cryptographic module MUST NOT change its
          state (i.e., "commit" to a generated key) until it receives the
          final message from the DSKPP server and successfully has processed
          that message, including validation of its MAC. A deleted
          &lt;KeyProvServerFinished&gt; message will not cause the server to
          end up in an inconsistent state vis-a-vis the cryptographic module
          if the server implements the suggestions in <xref
          target="Subsection-Interactions"></xref>.</t>
        </section>

        <section title="Message Insertion">
          <t>An active attacker may initiate a DSKPP run at any time, and
          suggest any device identifier. DSKPP server implementations MAY
          receive some protection against inadvertently initializing a key or
          inadvertently replacing an existing key or assigning a key to a
          cryptographic module by initializing the DSKPP run by use of the
          &lt;KeyProvTrigger&gt;. The &lt;AuthenticationData&gt; element
          allows the server to associate a DSKPP protocol run with, e.g., an
          earlier user-authenticated session. The security of this method,
          therefore, depends on the ability to protect the
          &lt;AuthenticationData&gt; element in the DSKPP initialization
          message. If an eavesdropper is able to capture this message, he may
          race the legitimate user for a key initialization. DSKPP over a
          transport providing confidentiality and integrity, coupled with the
          recommendations in <xref target="Subsection-Interactions"></xref>,
          is RECOMMENDED when this is a concern.</t>

          <t>Insertion of other messages into an existing protocol run is seen
          as equivalent to modification of legitimately sent messages.</t>
        </section>

        <section title="Message Replay">
          <t>During 4-pass DSKPP, attempts to replay a previously recorded
          DSKPP message will be detected, as the use of nonces ensures that
          both parties are live. For example, a DSKPP client knows that a
          server it is communicating with is "live" since the server MUST
          create a MAC on information sent by the client.</t>

          <t>The same is true for 2-pass DSKPP thanks to the requirement that
          the client sends R in the &lt;KeyProvClientHello&gt; message and
          that the server includes R in the MAC computation.</t>
        </section>

        <section title="Message Reordering">
          <t>An attacker may attempt to re-order 4-pass DSKPP messages but
          this will be detected, as each message is of a unique type. Note:
          Message re-ordering attacks cannot occur in 2-pass DSKPP since each
          party sends at most one message each.</t>
        </section>

        <section anchor="Subsection-MITM" title="Man-in-the-Middle">
          <t>In addition to other active attacks, an attacker posing as a
          man-in-the-middle may be able to provide his own public key to the
          DSKPP client. This threat and countermeasures to it are discussed in
          <xref target="Subsection-FourPassDataFlow"></xref>. An attacker
          posing as a man-in-the-middle may also be acting as a proxy and,
          hence, may not interfere with DSKPP runs but still learn valuable
          information; see <xref target="Subsection-Passive"></xref>.</t>
        </section>
      </section>

      <section anchor="Subsection-Passive" title="Passive Attacks">
        <t>Passive attackers may eavesdrop on DSKPP runs to learn information
        that later on may be used to impersonate users, mount active attacks,
        etc.</t>

        <t>If DSKPP is not run over a transport providing confidentiality, a
        passive attacker may learn:<list hangIndent="0" style="symbols">
            <t>What cryptographic modules a particular user is in possession
            of</t>

            <t>The identifiers of keys on those cryptographic modules and
            other attributes pertaining to those keys, e.g., the lifetime of
            the keys</t>

            <t>DSKPP versions and cryptographic algorithms supported by a
            particular DSKPP client or server</t>

            <t>Any value present in an &lt;extension&gt; that is part of
            &lt;KeyProvClientHello&gt;</t>
          </list></t>

        <t>Whenever the above is a concern, DSKPP SHOULD be run over a
        transport providing confidentiality. If man-in-the-middle attacks for
        the purposes described above are a concern, the transport MUST also
        offer server-side authentication.</t>
      </section>

      <section title="Cryptographic Attacks">
        <t>An attacker with unlimited access to an initialized cryptographic
        module may use the module as an "oracle" to pre-compute values that
        later on may be used to impersonate the DSKPP server. <xref
        target="Subsection-FourPassDataFlow"></xref> contains a discussion of
        this threat and steps RECOMMENDED to protect against it.</t>

        <t>Implementers are advised that cryptographic algorithms become
        weaker with time. As new cryptographic techniques are developed and
        computing performance improves, the work factor to break a particular
        cryptographic algorithm will reduce. Therefore, cryptographic
        algorithm implementations SHOULD be modular allowing new algorithms to
        be readily inserted. That is, implementers SHOULD be prepared to
        regularly update the algorithms in their implementations.</t>
      </section>

      <section anchor="Subsection-Interactions"
               title="Attacks on the Interaction between DSKPP and User Authentication">
        <t>If keys generated in DSKPP will be associated with a particular
        user at the DSKPP server (or a server trusted by, and communicating
        with the DSKPP server), then in order to protect against threats where
        an attacker replaces a client-provided encrypted R_C with his own R'C
        (regardless of whether the public-key variation or the shared-secret
        variation of DSKPP is employed to encrypt the client nonce), the
        server SHOULD NOT commit to associate a generated K_TOKEN with the
        given cryptographic module until the user simultaneously has proven
        both possession of the device that hosts the cryptographic module
        containing K_TOKEN and some out-of-band provided authenticating
        information (e.g., an authentication code). For example, if the
        cryptographic module is a one-time password token, the user could be
        required to authenticate with both a one-time password generated by
        the cryptographic module and an out-of-band provided authentication
        code in order to have the server "commit" to the generated OTP value
        for the given user. Preferably, the user SHOULD perform this operation
        from another host than the one used to initialize keys on the
        cryptographic module, in order to minimize the risk of malicious
        software on the client interfering with the process.</t>

        <t>Note: This scenario, wherein the attacker replaces a
        client-provided R_C with his own R'C, does not apply to 2-pass DSKPP
        as the client does not provide any entropy to K_TOKEN. The attack as
        such (and its countermeasures) still applies to 2-pass DSKPP, however,
        as it essentially is a man-in-the-middle attack.</t>

        <t>Another threat arises when an attacker is able to trick a user to
        authenticate to the attacker rather than to the legitimate service
        before the DSKPP protocol run. If successful, the attacker will then
        be able to impersonate the user towards the legitimate service, and
        subsequently receive a valid DSKPP trigger. If the public-key variant
        of DSKPP is used, this may result in the attacker being able to (after
        a successful DSKPP protocol run) impersonate the user. Ordinary
        precautions MUST, therefore, be in place to ensure that users
        authenticate only to legitimate services.</t>
      </section>

      <section title="Miscellaneous Considerations">
        <section title="Client Contributions to K_TOKEN Entropy">
          <t>In 4-pass DSKPP, both the client and the server provide
          randomizing material to K_TOKEN, in a manner that allows both
          parties to verify that they did contribute to the resulting key. In
          the 2-pass DSKPP version defined herein, only the server contributes
          to the entropy of K_TOKEN. This means that a broken or compromised
          (pseudo-)random number generator in the server may cause more damage
          than it would in the 4-pass variant. Server implementations SHOULD
          therefore take extreme care to ensure that this situation does not
          occur.</t>
        </section>

        <section title="Key Confirmation">
          <t>4-pass DSKPP servers provide key confirmation through the MAC on
          R_C in the &lt;KeyProvServerFinished&gt; message. In the 2-pass
          DSKPP variant described herein, key confirmation is provided by the
          MAC including R, using K_MAC.</t>
        </section>

        <section anchor="Subsection-ServerAuth" title="Server Authentication">
          <t>DSKPP servers MUST authenticate themselves whenever a successful
          DSKPP 2-pass protocol run would result in an existing K_TOKEN being
          replaced by a K_TOKEN', or else a denial-of-service attack where an
          unauthorized DSKPP server replaces a K_TOKEN with another key would
          be possible. In 2-pass DSKPP, servers authenticate by including the
          AuthenticationDataType extension containing a MAC as described in
          <xref target="Subsecton-TwoPass"></xref> for two-pass DSKPP.</t>

          <t>Whenever a successful DSKPP 2-pass protocol run would result in
          an existing K_TOKEN being replaced by a K_TOKEN', the DSKPP client
          and server MUST do the following to prevent a denial-of-service
          attack where an unauthorized DSKPP server replaces a K_TOKEN with
          another key:<list style="symbols">
              <t>The DSKPP server MUST use the AuthenticationDataType
              extension to transmit a second MAC, calculated as described in
              <xref target="SubSecClientHello"></xref>.</t>

              <t>The DSKPP client MUST authenticate the server using the MAC
              contained in the AuthenticationDataType extension received from
              the DSKPP server to which it is connected.</t>
            </list></t>
        </section>

        <section title="User Authentication">
          <t>A DSKPP server MUST authenticate a client to ensure that K_TOKEN
          is delivered to the intended device. The following measures SHOULD
          be considered:</t>

          <t><list style="symbols">
              <t>When an Authentication Code is used for client
              authentication, a password dictionary attack on the
              authentication data is possible.</t>

              <t>The length of the Authentication Code when used over a
              non-secure channel SHOULD be longer than what is used over a
              secure channel. When a device, e.g., some mobile phones with
              small screens, cannot handle a long Authentication Code in a
              user-friendly manner, DSKPP SHOULD rely on a secure channel for
              communication.</t>

              <t>In the case that a non-secure channel has to be used, the
              Authentication Code SHOULD be sent to the server MAC'd as
              specified in <xref target="Subsection-AD"></xref>. The
              Authentication Code and nonce value MUST be strong enough to
              prevent offline brute-force recovery of the Authentication Code
              from the HMAC data. Given that the nonce value is sent in
              plaintext format over a non-secure transport, the cryptographic
              strength of the Authentication Data depends more on the quality
              of the Authentication Code.</t>

              <t>When the Authentication Code is sent from the DSKPP server to
              the device in a DSKPP initialization trigger message, an
              eavesdropper may be able to capture this message and race the
              legitimate user for a key initialization. To prevent this, the
              transport layer used to send the DSKPP trigger MUST provide
              confidentiality and integrity, e.g. a secure browser
              session.</t>
            </list></t>
        </section>

        <section title="Key Protection in Two-Pass DSKPP">
          <t>Three key protection methods are defined for the different usages
          of 2-pass DSKPP, which MUST be supported by a key package format,
          such as <xref target="PSKC"></xref> and <xref
          target="SKPC-ASN.1"></xref>. Therefore, key protection in the
          two-pass DSKPP is dependent upon the security of the key package
          format selected for a protocol run. Some considerations for the
          Passphrase-Based Key Wrap method follow.</t>

          <t>The passphrase-based key wrap method SHOULD depend upon the
          PBKDF2 function from <xref target="PKCS-5"></xref> to generate an
          encryption key from a passphrase and salt string. It is important to
          note that passphrase-based encryption is generally limited in the
          security that it provides despite the use of salt and iteration
          count in PBKDF2 to increase the complexity of attack.
          Implementations SHOULD therefore take additional measures to
          strengthen the security of the passphrase-based key wrap method. The
          following measures SHOULD be considered where applicable:</t>

          <t><list style="symbols">
              <t>The passphrase is the same as the one-time password component
              of the authentication code (see <xref
              target="Subsection-AD"></xref>) for a description of the AC
              format). The passphrase SHOULD be selected well, and usage
              guidelines such as the ones in <xref target="NIST-PWD"></xref>
              SHOULD be taken into account.</t>

              <t>A different passphrase SHOULD be used for every key
              initialization wherever possible (the use of a global passphrase
              for a batch of cryptographic modules SHOULD be avoided, for
              example). One way to achieve this is to use randomly-generated
              passphrases.</t>

              <t>The passphrase SHOULD be protected well if stored on the
              server and/or on the cryptographic module and SHOULD be
              delivered to the device's user using secure methods.</t>

              <t>User pre-authentication SHOULD be implemented to ensure that
              K_TOKEN is not delivered to a rogue recipient.</t>

              <t>The iteration count in PBKDF2 SHOULD be high to impose more
              work for an attacker using brute-force methods (see <xref
              target="PKCS-5"></xref> for recommendations). However, it MUST
              be noted that the higher the count, the more work is required on
              the legitimate cryptographic module to decrypt the newly
              delivered K_TOKEN. Servers MAY use relatively low iteration
              counts to accommodate devices with limited processing power such
              as some PDA and cell phones when other security measures are
              implemented and the security of the passphrase-based key wrap
              method is not weakened.</t>

              <t>Transport level security (e.g. TLS) SHOULD be used where
              possible to protect a two-pass protocol run. Transport level
              security provides a second layer of protection for the newly
              generated K_TOKEN.</t>
            </list></t>
        </section>

        <section title="Algorithm Agility">
          <t>Many protocols need to be algorithm agile. One reason for this is
          that in the past many protocols had fixed sized fields for
          information such as hash outputs, keys, etc. This is not the case
          for DSKPP, except for the key size in the computation of DSKPP-PRF.
          Another reason was that protocols did not support algorithm
          negotiation. This is also not the case for DSKPP, except for the use
          of SHA-256 in the MAC confirmation message. Updating the key size
          for DSKPP-PRF or the MAC confirmation message algorithm will require
          a new version of the protocol, which is supported with the Version
          attribute.</t>
        </section>
      </section>
    </section>

    <section title="Internationalization Considerations">
      <t>The DSKPP protocol is meant for machine-to-machine communications; as
      such, its elements are tokens not meant for direct human consumption.
      DSKPP exchanges information using XML. All XML processors are required
      to understand UTF-8 <xref target="RFC3629"></xref> encoding, and
      therefore all DSKPP clients and servers MUST understand UTF-8 encoded
      XML. Additionally, DSKPP servers and clients MUST NOT encode XML with
      encodings other than UTF-8.</t>
    </section>

    <section title="IANA Considerations">
      <t>This document requires several IANA registrations, detailed
      below.</t>

      <section title="URN Sub-Namespace Registration">
        <t>This section registers a new XML namespace,
        "urn:ietf:params:xml:ns:keyprov:dskpp" per the guidelines in <xref
        target="RFC3688"></xref>:</t>

        <t><list hangIndent="2" style="hanging">
            <t hangText="URI:">urn:ietf:params:xml:ns:keyprov:dskpp</t>

            <t hangText="Registrant Contact:"><vspace blankLines="0" />IETF,
            KEYPROV Working Group (keyprov@ietf.org), Andrea Doherty
            (andrea.doherty@rsa.com)</t>

            <t hangText="XML:"><vspace blankLines="0" /></t>
          </list></t>

        <figure>
          <artwork><![CDATA[   BEGIN
      <?xml version="1.0"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
      <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
      <head>
         <title>DSKPP Messsages</title>
      </head>
      <body>
         <h1>Namespace for DSKPP Messages</h1>
         <h2>urn:ietf:params:xml:ns:keyprov:dskpp</h2>
         [NOTE TO IANA/RFC-EDITOR: Please replace XXXX below
         with the RFC number for this specification.]
         <p>See RFCXXXX</p>
      </body>
      </html>
   END

          ]]></artwork>
        </figure>
      </section>

      <section title="XML Schema Registration">
        <t>This section registers an XML schema as per the guidelines in <xref
        target="RFC3688"></xref>.</t>

        <t><list hangIndent="2" style="hanging">
            <t hangText="URI:">urn:ietf:params:xml:ns:keyprov:dskpp</t>

            <t hangText="Registrant Contact:"><vspace blankLines="0" />IETF,
            KEYPROV Working Group (keyprov@ietf.org), Andrea Doherty
            (andrea.doherty@rsa.com)</t>

            <t hangText="Schema:"><vspace blankLines="0" />The XML for this
            schema can be found as the entirety of <xref
            target="Section-Schema"></xref> of this document.</t>
          </list></t>
      </section>

      <section title="MIME Media Type Registration">
        <t>This section registers the "application/dskpp+xml" MIME type:</t>

        <t><list counter="" hangIndent="2" style="hanging">
            <t hangText="To:">ietf-types@iana.org</t>

            <t hangText="Subject:">Registration of MIME media type
            application/dskpp+xml</t>

            <t hangText="MIME media type name:">application</t>

            <t hangText="MIME subtype name:">dskpp+xml</t>

            <t hangText="Required parameters:">(none)</t>

            <t hangText="Optional parameters:">charset<vspace
            blankLines="0" />Indicates the character encoding of enclosed
            XML.</t>

            <t hangText="Encoding considerations:">Uses XML, which can employ
            8-bit characters, depending on the character encoding used. See
            <xref target="RFC3203"></xref>, Section 3.2. Implementations need
            to support both <xref target="RFC3629"></xref>.</t>

            <t hangText="Security considerations:">This content type is
            designed to carry protocol data related to key management.
            Security mechanisms are built into the protocol to ensure that
            various threats are dealt with. Refer to <xref
            target="Section-Security"></xref> of the Published Specification
            for more details</t>

            <t hangText="Interoperability considerations:">None</t>

            <t hangText="Published specification:">RFC XXXX [NOTE TO
            IANA/RFC-EDITOR: Please replace XXXX with the RFC number for this
            specification.]</t>

            <t hangText="Applications which use this media type:">Protocol for
            key exchange.</t>

            <t hangText="Additional information:"><vspace
            blankLines="0" />Magic Number(s): (none)<vspace
            blankLines="0" />File extension(s): .xmls<vspace
            blankLines="0" />Macintosh File Type Code(s): (none)</t>

            <t
            hangText="Person &amp; email address to contact for further information:"><vspace
            blankLines="0" />Andrea Doherty (andrea.doherty@rsa.com)</t>

            <t hangText="Intended usage:">LIMITED USE</t>

            <t hangText="Author/Change controller:">The IETF</t>

            <t hangText="Other information:">This media type is a
            specialization of application/xml <xref target="RFC3203"></xref>,
            and many of the considerations described there also apply to
            application/dskpp+xml.</t>
          </list></t>
      </section>

      <section title="Status Code Registration">
        <t>This section registers status codes included in each DSKPP response
        message. The status codes are defined in the schema in the
        &lt;StatusCode&gt; type definition contained in the XML schema in
        <xref target="Section-Schema"></xref>. The following summarizes the
        registry:</t>

        <t><list hangIndent="2" style="hanging">
            <t hangText="Related Registry:"><vspace blankLines="0" />KEYPROV
            DSKPP Registries, Status codes for DSKPP<vspace
            blankLines="1" /></t>

            <t hangText="Defining RFC:"><vspace blankLines="0" />RFC XXXX
            [NOTE TO IANA/RFC-EDITOR: Please replace XXXX with the RFC number
            for this specification.]<vspace blankLines="1" /></t>

            <t hangText="Registration/Assignment Procedures:"><vspace
            blankLines="0" />Following the policies outlined in <xref
            target="RFC3575"></xref>, the IANA policy for assigning new values
            for the status codes for DSKPP MUST be "Specification Required"
            and their meanings MUST be documented in an RFC or in some other
            permanent and readily available reference, in sufficient detail
            that interoperability between independent implementations is
            possible. No mechanism to mark entries as "deprecated" is
            envisioned. It is possible to update entries from the
            registry.<vspace blankLines="1" /></t>

            <t hangText="Registrant Contact:"><vspace blankLines="0" />IETF,
            KEYPROV working group (keyprov@ietf.org),<vspace
            blankLines="0" />Andrea Doherty (andrea.doherty@rsa.com)</t>
          </list></t>
      </section>

      <section title="DSKPP Version Registration">
        <t>This section registers DSKPP version numbers. The registry has the
        following structure:</t>

        <figure>
          <artwork><![CDATA[+-------------------------------------------+
|  DSKPP Version    | Specification         |
+-------------------------------------------+
|  1.0              | [This document]       |
+-------------------------------------------+]]></artwork>

          <postamble></postamble>
        </figure>

        <t>Standards action is required to define new versions of DSKPP. It is
        not envisioned to deprecate, delete, or modify existing DSKPP
        versions.</t>
      </section>

      <section title="PRF Algorithm ID Sub-Registry">
        <t>This specification relies on a cryptographic primitive, called
        "DSKPP-PRF" that provides a deterministic transformation of a secret
        key k and a varying length octet string s to a bit string of specified
        length dsLen. From the point of view of this specification, DSKPP-PRF
        is a "black-box" function that, given the inputs, generates a
        pseudorandom value that can be realized by any appropriate and
        competent cryptographic technique. . <xref target="DSKPP-PRF"></xref>
        provides two realizations of DSKPP-PRF, DSKPP-PRF-AES and
        DSKPP-PRF-SHA256. This section registers the identifiers associated
        with these realizations.</t>

        <section title="DSKPP-PRF-AES">
          <t><list hangIndent="2" style="hanging">
              <t hangText="Common Name:"><vspace
              blankLines="0" />DSKPP-PRF-AES<vspace blankLines="1" /></t>

              <t hangText="URI:"><vspace
              blankLines="0" />urn:ietf:params:xml:ns:keyprov:dskpp:prf-aes-128<vspace
              blankLines="1" /></t>

              <t hangText="Identifier Definition:"><vspace
              blankLines="0" />The DSKPP-PRF-AES algorithm realization is
              defined in <xref target="AppD.2.2"></xref> of this
              document.<vspace blankLines="1" /></t>

              <t hangText="Registrant Contact:"><vspace blankLines="0" />IETF,
              KEYPROV working group (keyprov@ietf.org),<vspace
              blankLines="0" />Andrea Doherty (andrea.doherty@rsa.com)</t>
            </list></t>
        </section>

        <section title="DSKPP-PRF-SHA256">
          <t><list hangIndent="2" style="hanging">
              <t hangText="Common Name:"><vspace
              blankLines="0" />DSKPP-PRF-SHA256<vspace blankLines="1" /></t>

              <t hangText="URI:"><vspace
              blankLines="0" />urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256<vspace
              blankLines="1" /></t>

              <t hangText="Identifier Definition:"><vspace
              blankLines="0" />The DSKPP-PRF-SHA256 algorithm realization is
              defined in <xref target="AppD.3.2"></xref> of this
              document.<vspace blankLines="1" /></t>

              <t hangText="Registrant Contact:"><vspace blankLines="0" />IETF,
              KEYPROV working group (keyprov@ietf.org),<vspace
              blankLines="0" />Andrea Doherty (andrea.doherty@rsa.com)</t>
            </list></t>
        </section>
      </section>

      <section title="Key Container Registration">
        <t>This section registers the Key Container type.</t>

        <t><list counter="" hangIndent="2" style="hanging">
            <t hangText="Key Container:"><vspace blankLines="0" />The
            registration name for the Key Container.<vspace
            blankLines="1" /></t>

            <t hangText="Specification:"><vspace blankLines="0" />Key
            Container defines a key package format that specifies how a key
            should be protected using the three key protection methods
            provided in <xref target="SubSec-KPMethods"></xref>.<vspace
            blankLines="1" /></t>

            <t hangText="Deprecated:"><vspace blankLines="0" />TRUE if based
            on expert approval this entry has been deprecated and SHOULD NOT
            be used in any new implementations. Otherwise FALSE.<vspace
            blankLines="1" /></t>

            <t hangText="Identifiers:"><vspace blankLines="0" />The initial
            URIs for the Key Container defined for this version of the
            document are listed here:<vspace blankLines="1" /><list
                hangIndent="2" style="hanging">
                <t hangText="Name:">PSKC Key Container</t>

                <t
                hangText="URI:">urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container</t>

                <t hangText="Specification:"><xref target="PSKC"></xref></t>

                <t hangText="Deprecated:">FALSE</t>
              </list><vspace blankLines="1" /><list hangIndent="2"
                style="hanging">
                <t hangText="Name:">SKPC Key Container</t>

                <t
                hangText="URI:">urn:ietf:params:xml:ns:keyprov:dskpp:skpc-key-container</t>

                <t hangText="Specification:"><xref
                target="SKPC-ASN.1"></xref></t>

                <t hangText="Deprecated:">FALSE</t>
              </list><vspace blankLines="1" /><list hangIndent="2"
                style="hanging">
                <t hangText="Name:">PKCS12 Key Container</t>

                <t
                hangText="URI:">urn:ietf:params:xml:ns:keyprov:dskpp:pkcs12-key-container</t>

                <t hangText="Specification:"><xref
                target="PKCS-12"></xref></t>

                <t hangText="Deprecated:">FALSE</t>
              </list><vspace blankLines="1" /><list hangIndent="2"
                style="hanging">
                <t hangText="Name:">PKCS5-XML Key Container</t>

                <t
                hangText="URI:">urn:ietf:params:xml:ns:keyprov:dskpp:pkcs5-xml-key-container</t>

                <t hangText="Specification:"><xref
                target="PKCS-5-XML"></xref></t>

                <t hangText="Deprecated:">FALSE<vspace blankLines="1" /></t>
              </list></t>

            <t hangText="Registrant Contact:"><vspace blankLines="0" />IETF,
            KEYPROV working group (keyprov@ietf.org),<vspace
            blankLines="0" />Andrea Doherty (andrea.doherty@rsa.com)</t>
          </list></t>
      </section>
    </section>

    <!--////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-IPR" title="Intellectual Property Considerations">
      <t>RSA and RSA Security are registered trademarks or trademarks of RSA
      Security Inc. in the United States and/or other countries. The names of
      other products and services mentioned may be the trademarks of their
      respective owners.</t>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Contributors">
      <t>This work is based on information contained in <xref
      target="RFC4758"></xref>, authored by Magnus Nystrom, with enhancements
      borrowed from an individual Internet-Draft co-authored by Mingliang Pei
      and Salah Machani (e.g., User Authentication, and support for multiple
      key package formats).</t>

      <t>We would like to thank Philip Hoyer for his work in aligning DSKPP
      and PSKC schemas.</t>

      <t>We would also like to thank Hannes Tschofenig and Phillip
      Hallam-Baker for their draft reviews, feedback, and text
      contributions.</t>
    </section>

    <section anchor="Section-Acknowledgements" title="Acknowledgements">
      <t>We would like to thank the following for review of previous DSKPP
      document versions:<vspace blankLines="1" /><list style="symbols">
          <t>Dr. Ulrike Meyer (Review June 2007)<vspace blankLines="0" /></t>

          <t>Niklas Neumann (Review June 2007)<vspace blankLines="0" /></t>

          <t>Shuh Chang (Review June 2007)<vspace blankLines="0" /></t>

          <t>Hannes Tschofenig (Review June 2007 and again in August
          2007)<vspace blankLines="0" /></t>

          <t>Sean Turner (Reviews August 2007 and again in July 2008)<vspace
          blankLines="0" /></t>

          <t>John Linn (Review August 2007)<vspace blankLines="0" /></t>

          <t>Philip Hoyer (Review September 2007)<vspace blankLines="0" /></t>

          <t>Thomas Roessler (Review November 2007)<vspace
          blankLines="0" /></t>

          <t>Lakshminath Dondeti (Comments December 2007)<vspace
          blankLines="0" /></t>

          <t>Pasi Eronen (Comments December 2007)<vspace blankLines="0" /></t>

          <t>Phillip Hallam-Baker (Review and Edits November 2008 and again in
          January 2009)<vspace blankLines="0" /></t>

          <t>Alexey Melnikov (Review May 2010)<vspace blankLines="0" /></t>

          <t>Peter Saint-Andre (Review May 2010)</t>
        </list></t>

      <t>We would also like to thank the following for their input to selected
      design aspects of the DSKPP protocol:<vspace blankLines="1" /><list
          style="symbols">
          <t>Anders Rundgren (Key Package Format and Client Authentication
          Data)<vspace blankLines="0" /></t>

          <t>Thomas Roessler (HTTP Binding)<vspace blankLines="0" /></t>

          <t>Hannes Tschofenig (HTTP Binding)<vspace blankLines="0" /></t>

          <t>Phillip Hallam-Baker (Registry for Algorithms)<vspace
          blankLines="0" /></t>

          <t>N. Asokan (original observation of weakness in Authentication
          Data)</t>
        </list></t>

      <t>Finally, we would like to thank Robert Griffin for opening
      communication channels for us with the IEEE P1619.3 Key Management
      Group, and facilitating our groups in staying informed of potential
      areas (esp. key provisioning and global key identifiers of
      collaboration) of collaboration.</t>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->
  </middle>

  <back>
    <references title="Normative references">
      <reference anchor="FIPS180-SHA"
                 target="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">
        <front>
          <title>Secure Hash Standard</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="February" year="2004" />
        </front>

        <seriesInfo name="FIPS" value="180-2" />
      </reference>

      <reference anchor="FIPS197-AES"
                 target="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">
        <front>
          <title>Specification for the Advanced Encryption Standard
          (AES)</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="November" year="2001" />
        </front>

        <seriesInfo name="FIPS" value="197" />
      </reference>

      <reference anchor="IDNA2008"
                 target="http://www.rfc-editor.org/internet-drafts/draft-resman-idna2008-mappings-01.txt">
        <front>
          <title>Mapping Characters in IDNA2008</title>

          <author initials="P." surname="Resnick">
            <organization>Qualcomm Incorporated</organization>
          </author>

          <author initials="P." surname="Hoffman">
            <organization>VPN Consortium</organization>
          </author>

          <date day="19" month="April" year="2010" />
        </front>
      </reference>

      <reference anchor="ISO3309">
        <front>
          <title>ISO Information Processing Systems - Data Communication -
          High-Level Data Link Control Procedure - Frame Structure</title>

          <author>
            <organization></organization>
          </author>

          <date month="October" year="1984" />
        </front>

        <seriesInfo name="IS" value="3309, 3rd Edition" />
      </reference>

      <reference anchor="PKCS-1"
                 target="http://www.rsasecurity.com/rsalabs/pkcs/">
        <front>
          <title>RSA Cryptography Standard</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="June" year="2002" />
        </front>

        <seriesInfo name="PKCS" value="#1 Version 2.1" />
      </reference>

      <reference anchor="PKCS-5"
                 target="http://www.rsasecurity.com/rsalabs/pkcs/">
        <front>
          <title>Password-Based Cryptography Standard</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="March" year="1999" />
        </front>

        <seriesInfo name="PKCS" value="#5 Version 2.0" />
      </reference>

      <reference anchor="PKCS-5-XML"
                 target="http://www.rsasecurity.com/rsalabs/pkcs/">
        <front>
          <title>XML Schema for PKCS #5 Version 2.0</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="October" year="2006" />
        </front>

        <seriesInfo name="PKCS" value="#5 Version 2.0 Amd.1 (FINAL DRAFT)" />
      </reference>

      <reference anchor="PSKC"
                 target="http://tools.ietf.org/html/draft-ietf-keyprov-pskc-09">
        <front>
          <title>Portable Symmetric Key Container</title>

          <author fullname="">
            <organization></organization>
          </author>

          <date year="2010" />
        </front>
      </reference>

      <reference anchor="RFC2104" target="http://www.ietf.org/rfc/rfc2104.txt">
        <front>
          <title>HMAC: Keyed-Hashing for Message Authentication</title>

          <author initials="H." surname="Krawzcyk">
            <organization></organization>
          </author>

          <author initials="M." surname="Bellare">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="R." surname="Canetti">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="February" year="1997" />
        </front>

        <seriesInfo name="RFC" value="2104" />
      </reference>

      <reference anchor="RFC2119" target="http://www.ietf.org/rfc/rfc2119.txt">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement
          Levels</title>

          <author fullname="">
            <organization></organization>
          </author>

          <date month="March" year="1997" />
        </front>

        <seriesInfo name="BCP" value="14" />

        <seriesInfo name="RFC" value="2119" />
      </reference>

      <reference anchor="RFC2616" target="http://www.ietf.org/rfc/rfc2616.txt">
        <front>
          <title>Hypertext Transfer Protocol -- HTTP/1.1</title>

          <author initials="R." surname="Fielding">
            <organization></organization>
          </author>

          <author initials="J." surname="Gettys">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="J." surname="Mogul">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="H." surname="Frystyk">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="L." surname="Masinter">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="P." surname="Leach">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="T." surname="Berners-Lee">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="June" year="1999" />
        </front>

        <seriesInfo name="RFC" value="2616" />
      </reference>

      <reference anchor="RFC3394" target="http://www.ietf.org/rfc/rfc3394.txt">
        <front>
          <title>Advanced Encryption Standard (AES) Key Wrap Algorithm</title>

          <author initials="J." surname="Schaad ">
            <organization>Soaring Hawk Consulting</organization>
          </author>

          <author initials="R." surname="Housley">
            <organization>RSA Laboratories</organization>
          </author>

          <date month="September" year="2002" />
        </front>

        <seriesInfo name="RFC" value="3394" />
      </reference>

      <reference anchor="RFC3629" target="http://www.ietf.org/rfc/rfc3629.txt">
        <front>
          <title>UTF-8, a transformation format of ISO10646</title>

          <author fullname="F. Yergeau" initials="F." surname="Yergeau">
            <organization>Alis Technologies</organization>
          </author>

          <date month="November" year="2003" />
        </front>

        <seriesInfo name="STD" value="63" />

        <seriesInfo name="RFC" value="3629" />
      </reference>

      <reference anchor="RFC4210" target="http://www.ietf.org/rfc/rfc4210.txt">
        <front>
          <title>Internet X.509 Public Key Infrastructure Certificate
          Management Protocol (CMP)</title>

          <author fullname="C. Adams" initials="C." surname="Adams">
            <organization></organization>
          </author>

          <author fullname="S. Farrell" initials="S." surname="Farrell">
            <organization></organization>
          </author>

          <author fullname="T. Kause" initials="T." surname="Kause">
            <organization></organization>
          </author>

          <author fullname="T. Mononen" initials="T." surname="Mononen">
            <organization></organization>
          </author>

          <date month="September" year="2005" />

          <abstract>
            <t>This document describes the Internet X.509 Public Key
            Infrastructure (PKI) Certificate Management Protocol (CMP).
            Protocol messages are defined for X.509v3 certificate creation and
            management. CMP provides on-line interactions between PKI
            components, including an exchange between a Certification
            Authority (CA) and a client system. [STANDARDS TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="4210" />

        <format octets="212013"
                target="ftp://ftp.isi.edu/in-notes/rfc4210.txt" type="TXT" />
      </reference>

      <reference anchor="RFC5272" target="http://www.ietf.org/rfc/rfc5272.txt">
        <front>
          <title>Certificate Management over CMS (CMC)</title>

          <author fullname="J. Schaad" initials="J." surname="Schaad">
            <organization></organization>
          </author>

          <author fullname="M. Myers" initials="M." surname="Myers">
            <organization></organization>
          </author>

          <date month="June" year="2008" />

          <abstract>
            <t>This document defines the base syntax for CMC, a Certificate
            Management protocol using the Cryptographic Message Syntax (CMS).
            This protocol addresses two immediate needs within the Internet
            Public Key Infrastructure (PKI) community:&lt;/t&gt;&lt;t&gt; 1.
            The need for an interface to public key certification products and
            services based on CMS and PKCS #10 (Public Key Cryptography
            Standard), and&lt;/t&gt;&lt;t&gt; 2. The need for a PKI enrollment
            protocol for encryption only keys due to algorithm or hardware
            design.&lt;/t&gt;&lt;t&gt; CMC also requires the use of the
            transport document and the requirements usage document along with
            this document for a full definition. [STANDARDS TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="5272" />

        <format octets="167138"
                target="ftp://ftp.isi.edu/in-notes/rfc5272.txt" type="TXT" />
      </reference>

      <reference anchor="RFC5280" target="http://www.ietf.org/rfc/rfc5280.txt">
        <front>
          <title>Internet X.509 Public Key Infrastructure Certificate and
          Certificate Revocation List (CRL) Profile</title>

          <author initials="D." surname="Cooper">
            <organization>NIST</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="S." surname="Santesson">
            <organization>Microsoft</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="S." surname="Farrell">
            <organization>Trinity College Dublin</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="S." surname="Boeyen">
            <organization>Entrust</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="R." surname="Housley">
            <organization>Vigil Security</organization>
          </author>

          <author initials="W." surname="Polk">
            <organization>NIST</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="May" year="2008" />
        </front>

        <seriesInfo name="RFC" value="5280" />
      </reference>

      <reference anchor="RFC5649" target="http://www.ietf.org/rfc/rfc5649.txt">
        <front>
          <title>Advanced Encryption Standard (AES) Key Wrap with Padding
          Algorithm</title>

          <author initials="R." surname="Housley">
            <organization>Vigil Security</organization>
          </author>

          <author initials="M." surname="Dworkin ">
            <organization>NIST</organization>
          </author>

          <date month="August" year="2009" />
        </front>

        <seriesInfo name="RFC" value="5649" />
      </reference>

      <reference anchor="XML"
                 target="http://www.w3.org/TR/2006/REC-xml-20060816/">
        <front>
          <title>Extensible Markup Language (XML) 1.0 (Fifth Edition)</title>

          <author>
            <organization>W3C</organization>
          </author>

          <date day="26" month="November" year="2008" />
        </front>

        <seriesInfo name="W3C" value="Recommendation" />
      </reference>

      <reference anchor="XMLDSIG"
                 target="http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/">
        <front>
          <title>XML Signature Syntax and Processing</title>

          <author>
            <organization>W3C</organization>
          </author>

          <date month="February" year="2002" />
        </front>

        <seriesInfo name="W3C" value="Recommendation" />
      </reference>

      <reference anchor="XMLENC"
                 target="http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/">
        <front>
          <title>XML Encryption Syntax and Processing</title>

          <author>
            <organization>W3C</organization>
          </author>

          <date month="December" year="2002" />
        </front>

        <seriesInfo name="W3C" value="Recommendation" />
      </reference>
    </references>

    <references title="Informative references">
      <reference anchor="CT-KIP-P11"
                 target="http://www.rsasecurity.com/rsalabs/pkcs/">
        <front>
          <title>PKCS #11 Mechanisms for the Cryptographic Token Key
          Initialization Protocol</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="December" year="2005" />
        </front>

        <seriesInfo name="PKCS" value="#11 Version 2.20 Amd.2" />
      </reference>

      <reference anchor="FAQ">
        <front>
          <title>Frequently Asked Questions About Today's Cryptography</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="" year="2000" />
        </front>

        <seriesInfo name="" value="Version 4.1" />
      </reference>

      <reference anchor="NIST-PWD"
                 target="http://www.itl.nist.gov/fipspubs/fip112.htm">
        <front>
          <title>Password Usage</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="May" year="1985" />
        </front>

        <seriesInfo name="FIPS" value="112" />
      </reference>

      <reference anchor="NIST-SP800-38B"
                 target="http://csrc.nist.gov/publications/nistpubs/800-38B/SP_800-38B.pdf">
        <front>
          <title>Recommendations for Block Cipher Modes of Operation: The CMAC
          Mode for Authentication</title>

          <author initials="" surname="">
            <organization>International Organization for
            Standardization</organization>
          </author>

          <date month="May" year="2005" />
        </front>

        <seriesInfo name="NIST" value="SP800-38B" />
      </reference>

      <reference anchor="NIST-SP800-57"
                 target="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf">
        <front>
          <title>Recommendation for Key Management - Part I: General
          (Revised)</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="March" year="2007" />
        </front>

        <seriesInfo name="NIST" value="800-57" />
      </reference>

      <reference anchor="PKCS-11"
                 target="http://www.rsasecurity.com/rsalabs/pkcs/">
        <front>
          <title>Cryptographic Token Interface Standard</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="June" year="2004" />
        </front>

        <seriesInfo name="PKCS" value="#11 Version 2.20" />
      </reference>

      <reference anchor="PKCS-12"
                 target="ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12v1.pdf">
        <front>
          <title>Personal Information Exchange Syntax Standard</title>

          <author fullname="">
            <organization></organization>
          </author>

          <date year="2005" />
        </front>

        <seriesInfo name="PKCS" value="#12 Version 1.0" />
      </reference>

      <reference anchor="RFC2818" target="http://www.ietf.org/rfc/rfc2818.txt">
        <front>
          <title>HTTP Over TLS</title>

          <author initials="E." surname="Rescorla">
            <organization>RTFM, Inc.</organization>
          </author>

          <date month="May" year="2000" />
        </front>

        <seriesInfo name="RFC" value="2818" />
      </reference>

      <reference anchor="RFC3203" target="http://www.ietf.org/rfc/rfc3203.txt">
        <front>
          <title>XML Media Types</title>

          <author initials="M." surname="Murata">
            <organization></organization>
          </author>

          <author initials="S." surname="St. Laurent">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="D." surname="Kohn">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="January" year="2001" />
        </front>

        <seriesInfo name="RFC" value="3203" />
      </reference>

      <reference anchor="RFC3575" target="http://www.ietf.org/rfc/rfc3575.txt">
        <front>
          <title>IANA Considerations for RADIUS</title>

          <author initials="B." surname="Aboba">
            <organization>VeriSign</organization>
          </author>

          <date month="July" year="2003" />
        </front>

        <seriesInfo name="RFC" value="3575" />
      </reference>

      <reference anchor="RFC3688" target="http://www.ietf.org/rfc/rfc3688.txt">
        <front>
          <title>The IETF XML Registry</title>

          <author initials="M." surname="Mealling">
            <organization>VeriSign</organization>
          </author>

          <date month="January" year="2004" />
        </front>

        <seriesInfo name="RFC" value="3688" />

        <seriesInfo name="BCP" value="81" />
      </reference>

      <reference anchor="RFC3986" target="http://www.ietf.org/rfc/rfc3986.txt">
        <front>
          <title>Uniform Resource Identifier (URI): Generic Syntax</title>

          <author initials="T." surname="Berners-Lee">
            <organization>W3C/MIT</organization>
          </author>

          <author initials="R." surname="Fielding">
            <organization>Day Software</organization>
          </author>

          <author initials="L." surname="Masinter">
            <organization>Adobe Systems</organization>
          </author>

          <date month="January" year="2005" />
        </front>

        <seriesInfo name="RFC" value="3986" />

        <seriesInfo name="STD" value="66" />
      </reference>

      <reference anchor="RFC4758" target="http://www.ietf.org/rfc/rfc4758.txt">
        <front>
          <title>Cryptographic Token Key Initialization Protocol
          (CT-KIP)</title>

          <author fullname="Magnus Nystrom">
            <organization>RSA, The Security Division of EMC</organization>
          </author>

          <date month="November" year="2006" />
        </front>

        <seriesInfo name="RFC" value="4758" />
      </reference>

      <reference anchor="SKPC-ASN.1"
                 target="http://www.ietf.org/internet-drafts/draft-ietf-keyprov-symmetrickeyformat-01.txt">
        <front>
          <title>Symmetric Key Package Content Type</title>

          <author>
            <organization></organization>
          </author>

          <date year="2007" />
        </front>
      </reference>

      <reference anchor="XMLNS"
                 target="http://www.w3.org/TR/2009/REC-xml-names-20091208">
        <front>
          <title>Namespaces in XML</title>

          <author>
            <organization>W3C</organization>
          </author>

          <date month="January" year="1999" />
        </front>

        <seriesInfo name="W3C" value="Recommendation" />
      </reference>
    </references>

    <section anchor="Section-Usage-Scenarios" title="Usage Scenarios">
      <t>DSKPP is expected to be used to provision symmetric keys to
      cryptographic modules in a number of different scenarios, each with its
      own special requirements, as described below. This appendix forms an
      informative part of the document.</t>

      <section anchor="UC1" title="Single Key Request">
        <t>The usual scenario is that a cryptographic module makes a request
        for a symmetric key from a provisioning server that is located on the
        local network or somewhere on the Internet. Depending upon the
        deployment scenario, the provisioning server may generate a new key
        on-the-fly or use a pre-generated key, e.g., one provided by a legacy
        back-end issuance server. The provisioning server assigns a unique key
        ID to the symmetric key and provisions it to the cryptographic
        module.</t>
      </section>

      <section title="Multiple Key Requests">
        <t>A cryptographic module makes multiple requests for symmetric keys
        from the same provisioning server. The symmetric keys need not be of
        the same type, i.e., the keys may be used with different symmetric key
        cryptographic algorithms, including one-time password authentication
        algorithms, and the AES encryption algorithm.</t>
      </section>

      <section title="User Authentication">
        <t>In some deployment scenarios, a key issuer may rely on a third
        party provisioning service. In this case, the issuer directs
        provisioning requests from the cryptographic module to the
        provisioning service. As such, it is the responsibility of the issuer
        to authenticate the user through some out-of-band means before
        granting him rights to acquire keys. Once the issuer has granted those
        rights, the issuer provides an authentication code to the user and
        makes it available to the provisioning service, so that the user can
        prove that he is authorized to acquire keys.</t>
      </section>

      <section title="Provisioning Time-Out Policy">
        <t>An issuer may provide a time-limited authentication code to a user
        during registration, which the user will input into the cryptographic
        module to authenticate themselves with the provisioning server. The
        server will allow a key to be provisioned to the cryptographic module
        hosted by the user's device when user authentication is required only
        if the user inputs a valid authentication code within the fixed time
        period established by the issuer.</t>
      </section>

      <section title="Key Renewal">
        <t>A cryptographic module requests renewal of the symmetric key
        material attached to a key ID, as opposed to keeping the key value
        constant and refreshing the metadata. Such a need may occur in the
        case when a user wants to upgrade her device that houses the
        cryptographic module or when a key has expired. When a user uses the
        same cryptographic module to, for example, perform strong
        authentication at multiple Web login sites, keeping the same key ID
        removes the need for the user to register a new key ID at each
        site.</t>
      </section>

      <section title="Pre-Loaded Key Replacement">
        <t>This scenario represents a special case of symmetric key renewal in
        which a local administrator can authenticate the user procedurally
        before initiating the provisioning process. It also allows for a
        device issuer to pre-load a key onto a cryptographic module with a
        restriction that the key is replaced with a new key prior to use of
        the cryptographic module. Another variation of this scenario is the
        organization who recycles devices. In this case, a key issuer would
        provision a new symmetric key to a cryptographic module hosted on a
        device that was previously owned by another user.</t>

        <t>Note that this usage scenario is essentially the same as the
        previous scenario wherein the same key ID is used for renewal.</t>
      </section>

      <section title="Pre-Shared Manufacturing Key">
        <t>A cryptographic module is loaded onto a smart card after the card
        is issued to a user. The symmetric key for the cryptographic module
        will then be provisioned using a secure channel mechanism present in
        many smart card platforms. This allows a direct secure channel to be
        established between the smart card chip and the provisioning server.
        For example, the card commands (i.e., Application Protocol Data Units,
        or APDUs) are encrypted with a pre-issued card manufacturer's key and
        sent directly to the smart card chip, allowing secure post-issuance
        in-the-field provisioning. This secure flow can pass Transport Layer
        Security (TLS) and other transport security boundaries.</t>

        <t>Note that two pre-conditions for this usage scenario are for the
        protocol to be tunneled and the provisioning server to know the
        correct pre-established manufacturer's key.</t>
      </section>

      <section title="End-to-End Protection of Key Material">
        <t>In this scenario, transport layer security does not provide
        end-to-end protection of keying material transported from the
        provisioning server to the cryptographic module. For example, TLS may
        terminate at an application hosted on a PC rather than at the
        cryptographic module (i.e., the endpoint) located on a data storage
        device. Mutually authenticated key agreement provides end-to-end
        protection, which TLS cannot provide.</t>
      </section>
    </section>

    <section anchor="Section-Examples" title="Examples">
      <t>This appendix contains example messages that illustrate parameters,
      encoding, and semantics in four-and two- pass DSKPP exchanges. The
      examples are written using XML, and are syntactically correct. MAC and
      cipher values are fictitious however. This appendix forms an informative
      part of the document.</t>

      <section title="Trigger Message">
        <figure>
          <preamble></preamble>

          <artwork><![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<dskpp:KeyProvTrigger Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp" 
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc">
  <dskpp:InitializationTrigger>
    <dskpp:DeviceIdentifierData>
        <dskpp:DeviceId>
            <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>
            <pskc:SerialNo>987654321</pskc:SerialNo>
            <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate>
            <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate>
        </dskpp:DeviceId>
    </dskpp:DeviceIdentifierData>
    <dskpp:KeyID>SE9UUDAwMDAwMDAx</dskpp:KeyID>
    <dskpp:TokenPlatformInfo KeyLocation="Hardware" 
      AlgorithmLocation="Software"/>
    <dskpp:AuthenticationData>
      <dskpp:ClientID>31300257</dskpp:ClientID>
      <dskpp:AuthenticationCodeMac>
        <dskpp:IterationCount>512</dskpp:IterationCount>
        <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>
      </dskpp:AuthenticationCodeMac>
    </dskpp:AuthenticationData>
    <dskpp:ServerUrl>https://www.somekeyprovservice.com/
      </dskpp:ServerUrl>
  </dskpp:InitializationTrigger>
</dskpp:KeyProvTrigger>  ]]></artwork>

          <postamble></postamble>
        </figure>
      </section>

      <section title="Four-Pass Protocol">
        <section title="&lt;KeyProvClientHello&gt; Without a Preceding Trigger">
          <figure>
            <preamble></preamble>

            <artwork><![CDATA[   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <dskpp:KeyProvClientHello 
       xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc" 
       xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp" 
       xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" 
       xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
       Version="1.0">
       <dskpp:DeviceIdentifierData>
           <dskpp:DeviceId>
               <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>
               <pskc:SerialNo>987654321</pskc:SerialNo>
               <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate>
               <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate>
           </dskpp:DeviceId>
       </dskpp:DeviceIdentifierData>
       <dskpp:SupportedKeyTypes>
           <dskpp:Algorithm>
               urn:ietf:params:xml:ns:keyprov:pskc:hotp
           </dskpp:Algorithm>
           <dskpp:Algorithm>
   http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
           </dskpp:Algorithm>
       </dskpp:SupportedKeyTypes>
       <dskpp:SupportedEncryptionAlgorithms>
           <dskpp:Algorithm>
               http://www.w3.org/2001/04/xmlenc#aes128-cbc
           </dskpp:Algorithm>
       </dskpp:SupportedEncryptionAlgorithms>
       <dskpp:SupportedMacAlgorithms>
           <dskpp:Algorithm>
               urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256
           </dskpp:Algorithm>
       </dskpp:SupportedMacAlgorithms>
       <dskpp:SupportedProtocolVariants>
           <dskpp:FourPass/>
       </dskpp:SupportedProtocolVariants>
       <dskpp:SupportedKeyPackages>
           <dskpp:KeyPackageFormat>
               urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container
           </dskpp:KeyPackageFormat>
       </dskpp:SupportedKeyPackages>
   </dskpp:KeyProvClientHello>    ]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="&lt;KeyProvClientHello&gt; Assuming a Preceding Trigger">
          <figure>
            <preamble></preamble>

            <artwork><![CDATA[   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <dskpp:KeyProvClientHello 
       xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc" 
       xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp" 
       xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" 
       xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
       Version="1.0">
       <dskpp:DeviceIdentifierData>
           <dskpp:DeviceId>
               <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>
               <pskc:SerialNo>987654321</pskc:SerialNo>
               <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate>
               <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate>
           </dskpp:DeviceId>
       </dskpp:DeviceIdentifierData>
       <dskpp:KeyID>SE9UUDAwMDAwMDAx</dskpp:KeyID>
       <dskpp:SupportedKeyTypes>
           <dskpp:Algorithm>
               urn:ietf:params:xml:ns:keyprov:pskc:hotp
           </dskpp:Algorithm>
           <dskpp:Algorithm>
   http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
           </dskpp:Algorithm>
       </dskpp:SupportedKeyTypes>
       <dskpp:SupportedEncryptionAlgorithms>
           <dskpp:Algorithm>
               http://www.w3.org/2001/04/xmlenc#aes128-cbc
           </dskpp:Algorithm>
       </dskpp:SupportedEncryptionAlgorithms>
       <dskpp:SupportedMacAlgorithms>
           <dskpp:Algorithm>
               urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256
           </dskpp:Algorithm>
       </dskpp:SupportedMacAlgorithms>
       <dskpp:SupportedProtocolVariants>
         <dskpp:FourPass/>
       </dskpp:SupportedProtocolVariants>
       <dskpp:SupportedKeyPackages>
           <dskpp:KeyPackageFormat>
               urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container
           </dskpp:KeyPackageFormat>
       </dskpp:SupportedKeyPackages>
   </dskpp:KeyProvClientHello>         ]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="&lt;KeyProvServerHello&gt; Without a Preceding Trigger">
          <figure>
            <preamble></preamble>

            <artwork><![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<dskpp:KeyProvServerHello 
    xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc" 
    xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp" 
    xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" 
    xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
    Version="1.0" 
    Status="Continue" 
    SessionID="4114">
    <dskpp:KeyType>
        urn:ietf:params:xml:ns:keyprov:pskc:hotp
    </dskpp:KeyType>
    <dskpp:EncryptionAlgorithm>
        http://www.w3.org/2001/04/xmlenc#aes128-cbc
    </dskpp:EncryptionAlgorithm>
    <dskpp:MacAlgorithm>
        urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256
    </dskpp:MacAlgorithm>
    <dskpp:EncryptionKey>
      <ds:KeyName>Example-Key1</ds:KeyName>
    </dskpp:EncryptionKey>
    <dskpp:KeyPackageFormat>
        urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container
    </dskpp:KeyPackageFormat>
    <dskpp:Payload>
        <dskpp:Nonce>EjRWeJASNFZ4kBI0VniQEg==</dskpp:Nonce>
    </dskpp:Payload>
</dskpp:KeyProvServerHello>    ]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="&lt;KeyProvServerHello&gt; Assuming Key Renewal">
          <figure>
            <preamble></preamble>

            <artwork><![CDATA[   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <dskpp:KeyProvServerHello 
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp" 
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"
     xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" 
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     Version="1.0"  
     SessionID="4114" 
     Status="Continue">
     <dskpp:KeyType>
       urn:ietf:params:xml:schema:keyprov:otpalg#SecurID-AES
     </dskpp:KeyType>
     <dskpp:EncryptionAlgorithm>
        http://www.w3.org/2001/04/xmlenc#aes128-cbc
     </dskpp:EncryptionAlgorithm>
     <dskpp:MacAlgorithm>
        urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256
     </dskpp:MacAlgorithm>
     <dskpp:EncryptionKey>
       <ds:KeyName>Example-Key1</ds:KeyName>
     </dskpp:EncryptionKey>
     <dskpp:KeyPackageFormat>
       urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container
     </dskpp:KeyPackageFormat>
     <dskpp:Payload>
       <dskpp:Nonce>qw2ewasde312asder394jw==</dskpp:Nonce>
     </dskpp:Payload>
     <dskpp:Mac 
       MacAlgorithm="urn:ietf:params:xml:ns:keyprov:dskpp:prf-aes-128">
       cXcycmFuZG9tMzEyYXNkZXIzOTRqdw==
     </dskpp:Mac>
   </dskpp:KeyProvServerHello>      ]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="&lt;KeyProvClientNonce&gt; Using Default Encryption">
          <t>This message contains the nonce chosen by the cryptographic
          module, R_C, encrypted by the specified encryption key and
          encryption algorithm.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <dskpp:KeyProvClientNonce 
       xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc" 
       xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp" 
       xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" 
       xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
       SessionID="4114" 
       Version="1.0">
       <dskpp:EncryptedNonce>
           oTvo+S22nsmS2Z/RtcoF8CTwadRa1PVsRXkZnCihHkU1rPueggrd0NpEWVZR
           16Rg16+FHuTg33GK1wH3wffDZQ==
       </dskpp:EncryptedNonce>
   </dskpp:KeyProvClientNonce>]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="&lt;KeyProvServerFinished&gt; Using Default Encryption">
          <figure>
            <preamble></preamble>

            <artwork><![CDATA[   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <dskpp:KeyProvServerFinished 
       xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc" 
       xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp" 
       xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" 
       xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
       Version="1.0" 
       Status="Success" 
       SessionID="4114">
       <dskpp:KeyPackage>
           <dskpp:KeyContainer Version="1.0" Id="KC0001">
               <pskc:KeyPackage>
                   <pskc:DeviceInfo>
                       <pskc:Manufacturer>
                          TokenVendorAcme
                       </pskc:Manufacturer>
                       <pskc:SerialNo>
                          987654321
                       </pskc:SerialNo>
                       <pskc:StartDate>
                          2009-09-01T00:00:00Z
                       </pskc:StartDate>
                       <pskc:ExpiryDate>
                          2014-09-01T00:00:00Z
                       </pskc:ExpiryDate>
                   </pskc:DeviceInfo>
                   <pskc:CryptoModuleInfo>
                       <pskc:Id>CM_ID_001</pskc:Id>
                   </pskc:CryptoModuleInfo>
                   <pskc:Key 
                      Id="MBK000000001" 
                      Algorithm=
                         "urn:ietf:params:xml:ns:keyprov:pskc:hotp">
                      <pskc:Issuer>Example-Issuer</pskc:Issuer>
                      <pskc:AlgorithmParameters>
                          <pskc:ResponseFormat Length="6" 
                             Encoding="DECIMAL"/>
                       </pskc:AlgorithmParameters>
                       <pskc:Data>
                           <pskc:Counter>
                               <pskc:PlainValue>0</pskc:PlainValue>
                           </pskc:Counter>
                       </pskc:Data>
                       <pskc:Policy>
                           <pskc:KeyUsage>OTP</pskc:KeyUsage>
                       </pskc:Policy>
                   </pskc:Key>
               </pskc:KeyPackage>
           </dskpp:KeyContainer>
       </dskpp:KeyPackage>
       <dskpp:Mac 
           MacAlgorithm=
              "urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256">
           151yAR2NqU5dJzETK+SGYqN6sq6DEH5AgHohra3Jpp4=
       </dskpp:Mac>
   </dskpp:KeyProvServerFinished>        ]]></artwork>

            <postamble></postamble>
          </figure>
        </section>
      </section>

      <section title="Two-Pass Protocol">
        <section anchor="Example-TwoPass-1"
                 title="Example Using the Key Transport Method">
          <t>The client indicates support for all the Key Transport, Key Wrap,
          and Passphrase-Based Key Wrap key protection methods:</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <dskpp:KeyProvClientHello 
       xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc" 
       xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp" 
       xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" 
       xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
       Version="1.0">
       <dskpp:DeviceIdentifierData>
           <dskpp:DeviceId>
               <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>
               <pskc:SerialNo>987654321</pskc:SerialNo>
               <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate>
               <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate>
           </dskpp:DeviceId>
       </dskpp:DeviceIdentifierData>
       <dskpp:SupportedKeyTypes>
           <dskpp:Algorithm>
               urn:ietf:params:xml:ns:keyprov:pskc:hotp
           </dskpp:Algorithm>
           <dskpp:Algorithm>
   http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
           </dskpp:Algorithm>
       </dskpp:SupportedKeyTypes>
       <dskpp:SupportedEncryptionAlgorithms>
           <dskpp:Algorithm>
               http://www.w3.org/2001/04/xmlenc#rsa_1_5
           </dskpp:Algorithm>
       </dskpp:SupportedEncryptionAlgorithms>
       <dskpp:SupportedMacAlgorithms>
           <dskpp:Algorithm>
               urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256
           </dskpp:Algorithm>
       </dskpp:SupportedMacAlgorithms>
       <dskpp:SupportedProtocolVariants>
           <dskpp:TwoPass>
               <dskpp:SupportedKeyProtectionMethod>
                   urn:ietf:params:xml:schema:keyprov:dskpp:transport
               </dskpp:SupportedKeyProtectionMethod>
               <dskpp:Payload>
                   <ds:KeyInfo>
                       <ds:X509Data>
                           <ds:X509Certificate>
   MIIB5zCCAVCgAwIBAgIESZp/vDANBgkqhkiG9w0BAQUFADA4MQ0wCwYDVQQKEwRJRVRGM
   RMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwHhcNMDkwMjE3MD
   kxMzMyWhcNMTEwMjE3MDkxMzMyWjA4MQ0wCwYDVQQKEwRJRVRGMRMwEQYDVQQLEwpLZXl
   Qcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ
   AoGBALCWLDa2ItYJ6su80hd1gL4cggQYdyyKK17btt/aS6Q/eDsKjsPyFIODsxeKVV/uA
   3wLT4jQJM5euKJXkDajzGGOy92+ypfzTX4zDJMkh61SZwlHNJxBKilAM5aW7C+BQ0RvCx
   vdYtzx2LTdB+X/KMEBA7uIYxLfXH2Mnub3WIh1AgMBAAEwDQYJKoZIhvcNAQEFBQADgYE
   Ae875m84sYUJ8qPeZ+NG7REgTvlHTmoCdoByU0LBBLotUKuqfrnRuXJRMeZXaaEGmzY1k
   LonVjQGzjAkU4dJ+RPmiDlYuHLZS41Pg6VMwY+03lhk6I5A/w4rnqdkmwZX/NgXg06aln
   c2pBsXWhL4O7nk0S2ZrLMsQZ6HcsXgdmHo=
                           </ds:X509Certificate>
                       </ds:X509Data>
                   </ds:KeyInfo>
               </dskpp:Payload>
           </dskpp:TwoPass>
       </dskpp:SupportedProtocolVariants>
       <dskpp:SupportedKeyPackages>
           <dskpp:KeyPackageFormat>
               urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container
           </dskpp:KeyPackageFormat>
       </dskpp:SupportedKeyPackages>
       <dskpp:AuthenticationData>
           <dskpp:ClientID>AC00000A</dskpp:ClientID>
           <dskpp:AuthenticationCodeMac>
               <dskpp:Nonce>
                   ESIzRFVmd4iZqrvM3e7/ESIzRFVmd4iZqrvM3e7/ESI=
               </dskpp:Nonce>
               <dskpp:IterationCount>100000</dskpp:IterationCount>
               <dskpp:Mac 
                   MacAlgorithm=
                   "urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256">
                   3eRz51ILqiG+dJW2iLcjuA==
               </dskpp:Mac>
           </dskpp:AuthenticationCodeMac>
       </dskpp:AuthenticationData>
   </dskpp:KeyProvClientHello>        ]]></artwork>

            <postamble></postamble>
          </figure>

          <t>In this example, the server responds to the previous request by
          returning a key package in which the provisioning key was encrypted
          using the Key Transport key protection method.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <dskpp:KeyProvServerFinished 
       xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc" 
       xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp" 
       xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" 
       xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
       xmlns:dkey="http://www.w3.org/2009/xmlsec-derivedkey#" 
       xmlns:pkcs5=
          "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"
       Version="1.0" 
       Status="Success" 
       SessionID="4114">
       <dskpp:KeyPackage>
           <dskpp:KeyContainer Version="1.0" Id="KC0001">
               <pskc:EncryptionKey>
                   <ds:X509Data>
                       <ds:X509Certificate>
   MIIB5zCCAVCgAwIBAgIESZp/vDANBgkqhkiG9w0BAQUFADA4MQ0wCwYDVQQKEwRJRVRGM
   RMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwHhcNMDkwMjE3MD
   kxMzMyWhcNMTEwMjE3MDkxMzMyWjA4MQ0wCwYDVQQKEwRJRVRGMRMwEQYDVQQLEwpLZXl
   Qcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ
   AoGBALCWLDa2ItYJ6su80hd1gL4cggQYdyyKK17btt/aS6Q/eDsKjsPyFIODsxeKVV/uA
   3wLT4jQJM5euKJXkDajzGGOy92+ypfzTX4zDJMkh61SZwlHNJxBKilAM5aW7C+BQ0RvCx
   vdYtzx2LTdB+X/KMEBA7uIYxLfXH2Mnub3WIh1AgMBAAEwDQYJKoZIhvcNAQEFBQADgYE
   Ae875m84sYUJ8qPeZ+NG7REgTvlHTmoCdoByU0LBBLotUKuqfrnRuXJRMeZXaaEGmzY1k
   LonVjQGzjAkU4dJ+RPmiDlYuHLZS41Pg6VMwY+03lhk6I5A/w4rnqdkmwZX/NgXg06aln
   c2pBsXWhL4O7nk0S2ZrLMsQZ6HcsXgdmHo=
                       </ds:X509Certificate>
                   </ds:X509Data>
               </pskc:EncryptionKey>
               <pskc:KeyPackage>
                   <pskc:DeviceInfo>
                       <pskc:Manufacturer>
                          TokenVendorAcme
                       </pskc:Manufacturer>
                       <pskc:SerialNo>
                          987654321
                       </pskc:SerialNo>
                       <pskc:StartDate>
                          2009-09-01T00:00:00Z
                       </pskc:StartDate>
                       <pskc:ExpiryDate>
                          2014-09-01T00:00:00Z
                       </pskc:ExpiryDate>
                   </pskc:DeviceInfo>
                   <pskc:Key 
                       Id="MBK000000001" 
                       Algorithm=
                          "urn:ietf:params:xml:ns:keyprov:pskc:hotp">
                       <pskc:Issuer>Example-Issuer</pskc:Issuer>
                       <pskc:AlgorithmParameters>
                           <pskc:ResponseFormat Length="6" 
                              Encoding="DECIMAL"/>
                       </pskc:AlgorithmParameters>
                       <pskc:Data>
                           <pskc:Secret>
                               <pskc:EncryptedValue>
                                   <xenc:EncryptionMethod 
                                    Algorithm=
                            "http://www.w3.org/2001/04/xmlenc#rsa_1_5"/>
                                   <xenc:CipherData>
                                       <xenc:CipherValue>
   eyjr23WMy9S2UdKgGnQEbs44T1jmX1TNWEBq48xfS20PK2VWF4ZK1iSctHj/u3uk+7+y8
   uKrAzHEm5mujKPAU4DCbb5mSibXMnAbbIoAi2cJW60/l8FlzwaU4EZsZ1LyQ1GcBQKACE
   eylG5vK8NTo47vZTatL5UxmbmOX2HvaVQ=
                                       </xenc:CipherValue>
                                   </xenc:CipherData>
                               </pskc:EncryptedValue>
                           </pskc:Secret>
                           <pskc:Counter>
                               <pskc:PlainValue>0</pskc:PlainValue>
                           </pskc:Counter>
                       </pskc:Data>
                       <pskc:Policy>
                           <pskc:KeyUsage>OTP</pskc:KeyUsage>
                       </pskc:Policy>
                   </pskc:Key>
               </pskc:KeyPackage>
           </dskpp:KeyContainer>
       </dskpp:KeyPackage>
       <dskpp:Mac 
           MacAlgorithm=
              "urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256">
           GHZ0H6Y+KpxdlVZ7zgcJDiDdqc8Gcmlcf+HQi4EUxYU=
       </dskpp:Mac>
   </dskpp:KeyProvServerFinished>         ]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="Example Using the Key Wrap Method">
          <t>The client sends a request that specifies a shared key to protect
          the K_TOKEN, and the server responds using the Key Wrap key
          protection method. Authentication data in this example is based on
          an authentication code rather than a device certificate.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <dskpp:KeyProvClientHello 
       xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc" 
       xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp" 
       xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" 
       xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
       Version="1.0">
       <dskpp:DeviceIdentifierData>
           <dskpp:DeviceId>
               <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>
               <pskc:SerialNo>987654321</pskc:SerialNo>
               <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate>
               <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate>
           </dskpp:DeviceId>
       </dskpp:DeviceIdentifierData>
       <dskpp:SupportedKeyTypes>
           <dskpp:Algorithm>
               urn:ietf:params:xml:ns:keyprov:pskc:hotp
           </dskpp:Algorithm>
           <dskpp:Algorithm>
    http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
           </dskpp:Algorithm>
       </dskpp:SupportedKeyTypes>
       <dskpp:SupportedEncryptionAlgorithms>
           <dskpp:Algorithm>
               http://www.w3.org/2001/04/xmlenc#aes128-cbc
           </dskpp:Algorithm>
       </dskpp:SupportedEncryptionAlgorithms>
       <dskpp:SupportedMacAlgorithms>
           <dskpp:Algorithm>
               urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256
           </dskpp:Algorithm>
       </dskpp:SupportedMacAlgorithms>
       <dskpp:SupportedProtocolVariants>
           <dskpp:TwoPass>
               <dskpp:SupportedKeyProtectionMethod>
                   urn:ietf:params:xml:schema:keyprov:dskpp:wrap
               </dskpp:SupportedKeyProtectionMethod>
               <dskpp:Payload>
                   <ds:KeyInfo>
                       <ds:KeyName>Pre-shared-key-1</ds:KeyName>
                   </ds:KeyInfo>
               </dskpp:Payload>
           </dskpp:TwoPass>
       </dskpp:SupportedProtocolVariants>
       <dskpp:SupportedKeyPackages>
           <dskpp:KeyPackageFormat>
               urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container
           </dskpp:KeyPackageFormat>
       </dskpp:SupportedKeyPackages>
       <dskpp:AuthenticationData>
           <dskpp:ClientID>AC00000A</dskpp:ClientID>
           <dskpp:AuthenticationCodeMac>
               <dskpp:Nonce>
                   ESIzRFVmd4iZqrvM3e7/ESIzRFVmd4iZqrvM3e7/ESI=
               </dskpp:Nonce>
               <dskpp:IterationCount>1</dskpp:IterationCount>
               <dskpp:Mac 
                   MacAlgorithm=
                   "urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256">
                   3eRz51ILqiG+dJW2iLcjuA==
               </dskpp:Mac>
           </dskpp:AuthenticationCodeMac>
       </dskpp:AuthenticationData>
   </dskpp:KeyProvClientHello>]]></artwork>

            <postamble></postamble>
          </figure>

          <t>In this example, the server responds to the previous request by
          returning a key package in which the provisioning key was encrypted
          using the Key Wrap key protection method.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <dskpp:KeyProvServerFinished 
       xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc" 
       xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp" 
       xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" 
       xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
       xmlns:dkey="http://www.w3.org/2009/xmlsec-derivedkey#" 
       xmlns:pkcs5=
           "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"
       Version="1.0" 
       Status="Success" 
       SessionID="4114">
       <dskpp:KeyPackage>
            <dskpp:KeyContainer Version="1.0" Id="KC0001">
                <pskc:EncryptionKey>
                   <ds:KeyName>Pre-shared-key-1</ds:KeyName>
                </pskc:EncryptionKey>
                <pskc:MACMethod 
                    Algorithm=
                       "http://www.w3.org/2000/09/xmldsig#hmac-sha1">
                    <pskc:MACKey>
                        <xenc:EncryptionMethod 
                            Algorithm=
                         "http://www.w3.org/2001/04/xmlenc#aes128-cbc"/>
                        <xenc:CipherData>
                            <xenc:CipherValue>
        2GTTnLwM3I4e5IO5FkufoMUBJBuAf25hARFv0Z7MFk9Ecdb04PWY/qaeCbrgz7Es
                             </xenc:CipherValue>
                        </xenc:CipherData>
                    </pskc:MACKey>
                </pskc:MACMethod>
                <pskc:KeyPackage>
                    <pskc:DeviceInfo>
                        <pskc:Manufacturer>
                           TokenVendorAcme
                        </pskc:Manufacturer>
                        <pskc:SerialNo>
                           987654321
                        </pskc:SerialNo>
                        <pskc:StartDate>
                           2009-09-01T00:00:00Z
                        </pskc:StartDate>
                        <pskc:ExpiryDate>
                           2014-09-01T00:00:00Z
                        </pskc:ExpiryDate>
                    </pskc:DeviceInfo>
                    <pskc:CryptoModuleInfo>
                        <pskc:Id>CM_ID_001</pskc:Id>
                    </pskc:CryptoModuleInfo>
                    <pskc:Key 
                        Id="MBK000000001" 
                        Algorithm=
                           "urn:ietf:params:xml:ns:keyprov:pskc:hotp">
                        <pskc:Issuer>Example-Issuer</pskc:Issuer>
                        <pskc:AlgorithmParameters>
                          <pskc:ResponseFormat Length="6" 
                             Encoding="DECIMAL"/>
                        </pskc:AlgorithmParameters>
                        <pskc:Data>
                            <pskc:Secret>
                                <pskc:EncryptedValue>
                                  <xenc:EncryptionMethod 
                                  Algorithm=
                         "http://www.w3.org/2001/04/xmlenc#aes128-cbc"/>
                                    <xenc:CipherData>
                                        <xenc:CipherValue>
                                            oTvo+S22nsmS2Z/RtcoF8AabC6vr
                                            09sh0QIU+E224S96sZjpV+6nFYgn
                                            6525OoepbPnL/fGuuey64WCYXoqh
                                            Tg==
                                        </xenc:CipherValue>
                                    </xenc:CipherData>
                               </pskc:EncryptedValue>
                               <pskc:ValueMAC>
                                   o+e9xgMVUbYuZH9UHe0W9dIo88A=
                               </pskc:ValueMAC>
                           </pskc:Secret>
                           <pskc:Counter>
                               <pskc:PlainValue>0</pskc:PlainValue>
                           </pskc:Counter>
                       </pskc:Data>
                       <pskc:Policy>
                           <pskc:KeyUsage>OTP</pskc:KeyUsage>
                       </pskc:Policy>
                   </pskc:Key>
               </pskc:KeyPackage>
           </dskpp:KeyContainer>
       </dskpp:KeyPackage>
       <dskpp:Mac 
           MacAlgorithm=
              "urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256">
           l53BmSO6qUzoIgbQegimsKk2es+WRpEl0YFqaOp5PGE=
       </dskpp:Mac>
   </dskpp:KeyProvServerFinished>]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="Example Using the Passphrase-Based Key Wrap Method">
          <t>The client sends a request similar to that in <xref
          target="Example-TwoPass-1"></xref> with authentication data based on
          an authentication code, and the server responds using the
          Passphrase-Based Key Wrap method to encrypt the provisioning key
          (note that the encryption is derived from the password component of
          the authentication code). The authentication data is set in clear
          text when it is sent over a secure transport channel such as
          TLS.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <dskpp:KeyProvClientHello 
       xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc" 
       xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp" 
       xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" 
       xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
       Version="1.0">
       <dskpp:DeviceIdentifierData>
           <dskpp:DeviceId>
               <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>
               <pskc:SerialNo>987654321</pskc:SerialNo>
               <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate>
               <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate>
           </dskpp:DeviceId>
       </dskpp:DeviceIdentifierData>
       <dskpp:SupportedKeyTypes>
           <dskpp:Algorithm>
               urn:ietf:params:xml:ns:keyprov:pskc:hotp
           </dskpp:Algorithm>
           <dskpp:Algorithm>
    http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
           </dskpp:Algorithm>
       </dskpp:SupportedKeyTypes>
       <dskpp:SupportedEncryptionAlgorithms>
           <dskpp:Algorithm>
               http://www.w3.org/2001/04/xmlenc#rsa_1_5
           </dskpp:Algorithm>
       </dskpp:SupportedEncryptionAlgorithms>
       <dskpp:SupportedMacAlgorithms>
           <dskpp:Algorithm>
               urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256
           </dskpp:Algorithm>
       </dskpp:SupportedMacAlgorithms>
       <dskpp:SupportedProtocolVariants>
           <dskpp:TwoPass>
               <dskpp:SupportedKeyProtectionMethod>
                urn:ietf:params:xml:schema:keyprov:dskpp:passphrase-wrap
               </dskpp:SupportedKeyProtectionMethod>
               <dskpp:Payload>
                   <ds:KeyInfo>
                       <ds:KeyName>Passphrase-1</ds:KeyName>
                   </ds:KeyInfo>
               </dskpp:Payload>
           </dskpp:TwoPass>
       </dskpp:SupportedProtocolVariants>
       <dskpp:SupportedKeyPackages>
           <dskpp:KeyPackageFormat>
               urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container
           </dskpp:KeyPackageFormat>
       </dskpp:SupportedKeyPackages>
       <dskpp:AuthenticationData>
           <dskpp:ClientID>AC00000A</dskpp:ClientID>
           <dskpp:AuthenticationCodeMac>
               <dskpp:Nonce>
                   ESIzRFVmd4iZqrvM3e7/ESIzRFVmd4iZqrvM3e7/ESI=
               </dskpp:Nonce>
               <dskpp:IterationCount>1</dskpp:IterationCount>
               <dskpp:Mac 
                   MacAlgorithm=
                  "urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256">
                  K4YvLMN6Q1DZvtShoCxQag==
               </dskpp:Mac>
           </dskpp:AuthenticationCodeMac>
       </dskpp:AuthenticationData>
   </dskpp:KeyProvClientHello>         ]]></artwork>

            <postamble></postamble>
          </figure>

          <t>In this example, the server responds to the previous request by
          returning a key package in which the provisioning key was encrypted
          using the Passphrase-Based Key Wrap key protection method.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <dskpp:KeyProvServerFinished 
       xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc" 
       xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp" 
       xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" 
       xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
       xmlns:dkey="http://www.w3.org/2009/xmlsec-derivedkey#" 
       xmlns:pkcs5=
          "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"
       Version="1.0" 
       Status="Success" 
       SessionID="4114">
       <dskpp:KeyPackage>
           <dskpp:KeyContainer Version="1.0" Id="KC0002">
               <pskc:EncryptionKey>
                   <dkey:DerivedKey>
                       <dkey:KeyDerivationMethod 
                       Algorithm=
                       "http://www.rsasecurity.com/rsalabs/pkcs/schemas/
                       pkcs-5v2-0#pbkdf2">
                           <pkcs5:PBKDF2-params>
                               <Salt>
                                   <Specified>Ej7/PEpyEpw=</Specified>
                               </Salt>
                               <IterationCount>1000</IterationCount>
                               <KeyLength>16</KeyLength>
                           </pkcs5:PBKDF2-params>
                       </dkey:KeyDerivationMethod>
                       <xenc:ReferenceList>
                           <xenc:DataReference URI="#ED"/>
                       </xenc:ReferenceList>
                       <dkey:MasterKeyName>
                          Passphrase1
                       </dkey:MasterKeyName>
                   </dkey:DerivedKey>
               </pskc:EncryptionKey>
               <pskc:MACMethod 
                   Algorithm=
                      "http://www.w3.org/2000/09/xmldsig#hmac-sha1">
                   <pskc:MACKey>
                       <xenc:EncryptionMethod 
                           Algorithm=
                         "http://www.w3.org/2001/04/xmlenc#aes128-cbc"/>
                       <xenc:CipherData>
                           <xenc:CipherValue>
        2GTTnLwM3I4e5IO5FkufoOEiOhNj91fhKRQBtBJYluUDsPOLTfUvoU2dStyOwYZx
                           </xenc:CipherValue>
                       </xenc:CipherData>
                   </pskc:MACKey>
               </pskc:MACMethod>
               <pskc:KeyPackage>
                   <pskc:DeviceInfo>
                       <pskc:Manufacturer>
                          TokenVendorAcme
                       </pskc:Manufacturer>
                       <pskc:SerialNo>
                          987654321
                       </pskc:SerialNo>
                       <pskc:StartDate>
                          2009-09-01T00:00:00Z
                       </pskc:StartDate>
                       <pskc:ExpiryDate>
                          2014-09-01T00:00:00Z
                       </pskc:ExpiryDate>
                   </pskc:DeviceInfo>
                   <pskc:CryptoModuleInfo>
                       <pskc:Id>CM_ID_001</pskc:Id>
                   </pskc:CryptoModuleInfo>
                   <pskc:Key 
                       Id="MBK000000001" 
                       Algorithm=
                          "urn:ietf:params:xml:ns:keyprov:pskc:hotp">
                       <pskc:Issuer>Example-Issuer</pskc:Issuer>
                       <pskc:AlgorithmParameters>
                          <pskc:ResponseFormat Length="6" 
                             Encoding="DECIMAL"/>
                       </pskc:AlgorithmParameters>
                       <pskc:Data>
                           <pskc:Secret>
                               <pskc:EncryptedValue>
                                   <xenc:EncryptionMethod 
                                       Algorithm=
                                       "http://www.w3.org/2001/04/
                                       xmlenc#aes128-cbc"/>
                                   <xenc:CipherData>
                                       <xenc:CipherValue>
                                         oTvo+S22nsmS2Z/RtcoF8HX385uMWgJ
                                         myIFMESBmcvtHQXp/6T1TgCS9CsgKtm
                                         cOrF8VoK254tZKnrAjiD5cdw==
                                       </xenc:CipherValue>
                                   </xenc:CipherData>
                               </pskc:EncryptedValue>
                               <pskc:ValueMAC>
                                   pbgEbVYxoYs0x41wdeC7eDRbUEk=
                               </pskc:ValueMAC>
                           </pskc:Secret>
                           <pskc:Counter>
                               <pskc:PlainValue>0</pskc:PlainValue>
                           </pskc:Counter>
                       </pskc:Data>
                       <pskc:Policy>
                           <pskc:KeyUsage>OTP</pskc:KeyUsage>
                       </pskc:Policy>
                   </pskc:Key>
               </pskc:KeyPackage>
           </dskpp:KeyContainer>
       </dskpp:KeyPackage>
       <dskpp:Mac MacAlgorithm=
           "urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256">
           Jc4VsNODYXgfbDmTn9qQZgcL3cKoa//j/NRT7sTpKOM=
       </dskpp:Mac>
   </dskpp:KeyProvServerFinished>         ]]></artwork>

            <postamble></postamble>
          </figure>
        </section>
      </section>
    </section>

    <section anchor="Section-Integration" title="Integration with PKCS #11">
      <t>A DSKPP client that needs to communicate with a connected
      cryptographic module to perform a DSKPP exchange MAY use PKCS #11 <xref
      target="PKCS-11"></xref> as a programming interface as described herein.
      This appendix forms an informative part of the document.</t>

      <section title="The 4-pass Variant">
        <t>When performing 4-pass DSKPP with a cryptographic module using the
        PKCS #11 programming interface, the procedure described in <xref
        target="CT-KIP-P11"></xref>, Appendix B, is RECOMMENDED.</t>
      </section>

      <section title="The 2-pass Variant">
        <t>A suggested procedure to perform 2-pass DSKPP with a cryptographic
        module through the PKCS #11 interface using the mechanisms defined in
        <xref target="CT-KIP-P11"></xref> is as follows:</t>

        <t><list counter="2-pass" style="format %c.">
            <t>On the client side, <list counter="1st" style="format %d.">
                <t>The client selects a suitable slot and token (e.g., through
                use of the &lt;DeviceIdentifier&gt; or the
                &lt;PlatformInfo&gt; element of the DSKPP trigger
                message).</t>

                <t>A nonce R is generated, e.g. by calling C_SeedRandom and
                C_GenerateRandom.</t>

                <t>The client sends its first message to the server, including
                the nonce R.</t>
              </list></t>

            <t>On the server side, <list counter="2nd" style="format %d.">
                <t>A generic key K_PROV = K_TOKEN | K_MAC (where '|' denotes
                concatenation) is generated, e.g. by calling C_GenerateKey
                (using key type CKK_GENERIC_SECRET). The template for K_PROV
                MUST allow it to be exported (but only in wrapped form, i.e.
                CKA_SENSITIVE MUST be set to CK_TRUE and CKA_EXTRACTABLE MUST
                also be set to CK_TRUE), and also to be used for further key
                derivation. From K, a token key K_TOKEN of suitable type is
                derived by calling C_DeriveKey using the PKCS #11 mechanism
                CKM_EXTRACT_KEY_FROM_KEY and setting the CK_EXTRACT_PARAMS to
                the first bit of the generic secret key (i.e. set to 0).
                Likewise, a MAC key K_MAC is derived from K_PROV by calling
                C_DeriveKey using the CKM_EXTRACT_KEY_FROM_KEY mechanism, this
                time setting CK_EXTRACT_PARAMS to the length of K_PROV (in
                bits) divided by two.</t>

                <t>The server wraps K_PROV with either the public key of the
                DSKPP client or device, the pre-shared secret key, or the
                derived shared secret key by using C_WrapKey. If use of the
                DSKPP key wrap algorithm has been negotiated then the
                CKM_KIP_WRAP mechanism MUST be used to wrap K. When calling
                C_WrapKey, the hKey handle in the CK_KIP_PARAMS structure MUST
                be set to NULL_PTR. The pSeed parameter in the CK_KIP_PARAMS
                structure MUST point to the nonce R provided by the DSKPP
                client, and the ulSeedLen parameter MUST indicate the length
                of R. The hWrappingKey parameter in the call to C_WrapKey MUST
                be set to refer to the key wrapping key.</t>

                <t>Next, the server needs to calculate a MAC using K_MAC. If
                use of the DSKPP MAC algorithm has been negotiated, then the
                MAC is calculated by calling C_SignInit with the CKM_KIP_MAC
                mechanism followed by a call to C_Sign. In the call to
                C_SignInit, K_MAC MUST be the signature key, the hKey
                parameter in the CK_KIP_PARAMS structure MUST be set to
                NULL_PTR, the pSeed parameter of the CT_KIP_PARAMS structure
                MUST be set to NULL_PTR, and the ulSeedLen parameter MUST be
                set to zero. In the call to C_Sign, the pData parameter MUST
                be set to the concatenation of the string ServerID and the
                nonce R, and the ulDataLen parameter MUST be set to the length
                of the concatenated string. The desired length of the MAC MUST
                be specified through the pulSignatureLen parameter and MUST be
                set to the length of R.</t>

                <t>If the server also needs to authenticate its message (due
                to an existing K_TOKEN being replaced), the server MUST
                calculate a second MAC. Again, if use of the DSKPP MAC
                algorithm has been negotiated, then the MAC is calculated by
                calling C_SignInit with the CKM_KIP_MAC mechanism followed by
                a call to C_Sign. In this call to C_SignInit, the K_MAC'
                existing before this DSKPP protocol run MUST be the signature
                key (the implementation may specify K_MAC' to be the value of
                the K_TOKEN that is being replaced, or a version of K_MAC from
                the previous protocol run), the hKey parameter in the
                CK_KIP_PARAMS structure MUST be set to NULL, the pSeed
                parameter of the CT_KIP_PARAMS structure MUST be set to
                NULL_PTR, and the ulSeedLen parameter MUST be set to zero. In
                the call to C_Sign, the pData parameter MUST be set to the
                concatenation of the string ServerID and the nonce R, and the
                ulDataLen parameter MUST be set to the length of concatenated
                string. The desired length of the MAC MUST be specified
                through the pulSignatureLen parameter and MUST be set to the
                length of R.</t>

                <t>The server sends its message to the client, including the
                wrapped key K_TOKEN, the MAC and possibly also the
                authenticating MAC.</t>
              </list></t>

            <t>On the client side, <list counter="3rd" style="format %d.">
                <t>The client calls C_UnwrapKey to receive a handle to K.
                After this, the client calls C_DeriveKey twice: Once to derive
                K_TOKEN and once to derive K_MAC. The client MUST use the same
                mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same mechanism
                parameters as used by the server above. When calling
                C_UnwrapKey and C_DeriveKey, the pTemplate parameter MUST be
                used to set additional key attributes in accordance with local
                policy and as negotiated and expressed in the protocol. In
                particular, the value of the &lt;KeyID&gt; element in the
                server's response message MAY be used as CKA_ID for K_TOKEN.
                The key K_PROV MUST be destroyed after deriving K_TOKEN and
                K_MAC.</t>

                <t>The MAC is verified in a reciprocal fashion as it was
                generated by the server. If use of the CKM_KIP_MAC mechanism
                has been negotiated, then in the call to C_VerifyInit, the
                hKey parameter in the CK_KIP_PARAMS structure MUST be set to
                NULL_PTR, the pSeed parameter MUST be set to NULL_PTR, and
                ulSeedLen MUST be set to 0. The hKey parameter of C_VerifyInit
                MUST refer to K_MAC. In the call to C_Verify, pData MUST be
                set to the concatenation of the string ServerID and the nonce
                R, and the ulDataLen parameter MUST be set to the length of
                the concatenated string, pSignature to the MAC value received
                from the server, and ulSignatureLen to the length of the MAC.
                If the MAC does not verify the protocol session ends with a
                failure. The token MUST be constructed to not "commit" to the
                new K_TOKEN or the new K_MAC unless the MAC verifies.</t>

                <t>If an authenticating MAC was received (REQUIRED if the new
                K_TOKEN will replace an existing key on the token), then it is
                verified in a similar vein but using the K_MAC' associated
                with this server and existing before the protocol run (the
                implementation may specify K_MAC' to be the value of the
                K_TOKEN that is being replaced, or a version of K_MAC from the
                previous protocol run). Again, if the MAC does not verify the
                protocol session ends with a failure, and the token MUST be
                constructed no to "commit" to the new K_TOKEN or the new K_MAC
                unless the MAC verifies.</t>
              </list></t>
          </list></t>
      </section>
    </section>

    <section anchor="Section-PRFRealizations"
             title="Example of DSKPP-PRF Realizations">
      <section title="Introduction">
        <t>This example appendix defines DSKPP-PRF in terms of AES <xref
        target="FIPS197-AES"></xref> and HMAC <xref target="RFC2104"></xref>.
        This appendix forms a normative part of the document.</t>
      </section>

      <section title="DSKPP-PRF-AES">
        <section title="Identification">
          <t>For cryptographic modules supporting this realization of
          DSKPP-PRF, the following URN MUST be used to identify this algorithm
          in DSKPP:</t>

          <t>urn:ietf:params:xml:ns:keyprov:dskpp:prf-aes-128</t>

          <t>When this URN is used to identify the encryption algorithm, the
          method for encryption of R_C values described in <xref
          target="Subsection-Enc"></xref> MUST be used.</t>
        </section>

        <section anchor="AppD.2.2" title="Definition">
          <t>DSKPP-PRF-AES (k, s, dsLen)</t>

          <t>Input:</t>

          <t><list hangIndent="10" style="hanging">
              <t hangText="k">Encryption key to use</t>

              <t hangText="s">Octet string consisting of randomizing material.
              The length of the string s is sLen.</t>

              <t hangText="dsLen">Desired length of the output</t>
            </list></t>

          <t>Output:</t>

          <t><list hangIndent="10" style="hanging">
              <t hangText="DS">A pseudorandom string, dsLen-octets long</t>
            </list></t>

          <t>Steps:</t>

          <t><list hangIndent="0" style="format %d.">
              <t>Let bLen be the output block size of AES in octets:<vspace
              blankLines="1" />bLen = (AES output block length in
              octets)<vspace blankLines="0" />(normally, bLen = 16)<vspace
              blankLines="1" /></t>

              <t>If dsLen &gt; (2**32 - 1) * bLen, output "derived data too
              long" and stop<vspace blankLines="1" /></t>

              <t>Let n be the number of bLen-octet blocks in the output data,
              rounding up, and let j be the number of octets in the last
              block:<vspace blankLines="1" />n = CEILING( dsLen / bLen)<vspace
              blankLines="0" />j = dsLen - (n - 1) * bLen<vspace
              blankLines="1" /></t>

              <t>For each block of the pseudorandom string DS, apply the
              function F defined below to the key k, the string s and the
              block index to compute the block:<vspace blankLines="1" />B1 = F
              (k, s, 1) ,<vspace blankLines="0" />B2 = F (k, s, 2) ,<vspace
              blankLines="0" />...<vspace blankLines="0" />Bn = F (k, s,
              n)</t>
            </list></t>

          <t>The function F is defined in terms of the CMAC construction from
          <xref target="NIST-SP800-38B"></xref>, using AES as the block
          cipher:<vspace blankLines="1" />F (k, s, i) = CMAC-AES (k, INT (i)
          || s)<vspace blankLines="1" />where INT (i) is a four-octet encoding
          of the integer i, most significant octet first, and the output
          length of CMAC is set to bLen.<vspace blankLines="1" />Concatenate
          the blocks and extract the first dsLen octets to product the desired
          data string DS:<vspace blankLines="1" />DS = B1 || B2 || ... ||
          Bn&lt;0..j-1&gt;<vspace blankLines="1" />Output the derived data
          DS.</t>
        </section>

        <section title="Example">
          <t>If we assume that dsLen = 16, then:</t>

          <t>n = 16 / 16 = 1</t>

          <t>j = 16 - (1 - 1) * 16 = 16</t>

          <t>DS = B1 = F (k, s, 1) = CMAC-AES (k, INT (1) || s)</t>
        </section>
      </section>

      <section title="DSKPP-PRF-SHA256">
        <section title="Identification">
          <t>For cryptographic modules supporting this realization of
          DSKPP-PRF, the following URN MUST be used to identify this algorithm
          in DSKPP:</t>

          <t>urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256</t>

          <t>When this URN is used to identify the encryption algorithm to
          use, the method for encryption of R_C values described in <xref
          target="Subsection-Enc"></xref> MUST be used.</t>
        </section>

        <section anchor="AppD.3.2" title="Definition">
          <t>DSKPP-PRF-SHA256 (k, s, dsLen)</t>

          <t>Input:</t>

          <t><list hangIndent="10" style="hanging">
              <t hangText="k">Encryption key to use</t>

              <t hangText="s">Octet string consisting of randomizing material.
              The length of the string s is sLen.</t>

              <t hangText="dsLen">Desired length of the output</t>
            </list></t>

          <t>Output:</t>

          <t><list hangIndent="10" style="hanging">
              <t hangText="DS">A pseudorandom string, dsLen-octets long</t>
            </list></t>

          <t>Steps:</t>

          <t><list hangIndent="0" style="format %d.">
              <t>Let bLen be the output size of SHA-256 in octets of <xref
              target="FIPS180-SHA"></xref> (no truncation is done on the HMAC
              output):<vspace blankLines="1" />bLen = 32<vspace
              blankLines="0" />(normally, bLen = 16)<vspace
              blankLines="1" /></t>

              <t>If dsLen &gt; (2**32 - 1) * bLen, output "derived data too
              long" and stop<vspace blankLines="1" /></t>

              <t>Let n be the number of bLen-octet blocks in the output data,
              rounding up, and let j be the number of octets in the last
              block:<vspace blankLines="1" />n = CEILING( dsLen / bLen)<vspace
              blankLines="0" />j = dsLen - (n - 1) * bLen<vspace
              blankLines="1" /></t>

              <t>For each block of the pseudorandom string DS, apply the
              function F defined below to the key k, the string s and the
              block index to compute the block:<vspace blankLines="1" />B1 = F
              (k, s, 1),<vspace blankLines="0" />B2 = F (k, s, 2),<vspace
              blankLines="0" />...<vspace blankLines="0" />Bn = F (k, s,
              n)</t>
            </list></t>

          <t>The function F is defined in terms of the HMAC construction from
          <xref target="RFC2104"></xref>, using SHA-256 as the digest
          algorithm:<vspace blankLines="1" />F (k, s, i) = HMAC-SHA256 (k, INT
          (i) || s)<vspace blankLines="1" />where INT (i) is a four-octet
          encoding of the integer i, most significant octet first, and the
          output length of HMAC is set to bLen.<vspace
          blankLines="1" />Concatenate the blocks and extract the first dsLen
          octets to product the desired data string DS:<vspace
          blankLines="1" />DS = B1 || B2 || ... || Bn&lt;0..j-1&gt;<vspace
          blankLines="1" />Output the derived data DS.</t>
        </section>

        <section title="Example">
          <t>If we assume that sLen = 256 (two 128-octet long values) and
          dsLen = 16, then:</t>

          <t>n = CEILING( 16 / 32 ) = 1</t>

          <t>j = 16 - (1 - 1) * 32 = 16</t>

          <t>B1 = F (k, s, 1) = HMAC-SHA256 (k, INT (1) || s)</t>

          <t>DS = B1&lt;0 ... 15&gt;</t>

          <t>That is, the result will be the first 16 octets of the HMAC
          output.</t>
        </section>
      </section>
    </section>
  </back>
</rfc>