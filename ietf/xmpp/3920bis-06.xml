<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc compact="yes"?>
<?rfc strict="yes"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<rfc category="std" docName="draft-ietf-xmpp-3920bis-06" ipr="trust200902" obsoletes="3920">

  <front>
    <title abbrev="XMPP Core">Extensible Messaging and Presence Protocol (XMPP): Core</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization>Cisco</organization>
      <address>
        <email>psaintan@cisco.com</email>
      </address>
    </author>
    <date year="2010" month="March" day="31"/>
    <area>Applications</area>
    <keyword>Extensible Messaging and Presence Protocol</keyword>
    <keyword>XMPP</keyword>
    <keyword>Jabber</keyword>
    <keyword>Messaging</keyword>
    <keyword>Instant Messaging</keyword>
    <keyword>Presence</keyword>
    <keyword>Extensible Markup Language</keyword>
    <keyword>XML</keyword>
    <abstract>
      <t>This document defines the core features of the Extensible Messaging and Presence Protocol (XMPP), a technology for streaming Extensible Markup Language (XML) elements for the purpose of exchanging structured information in close to real time between any two or more network-aware entities.  XMPP provides a generalized, extensible framework for incrementally exchanging XML data, upon which a variety of applications can be built.  The framework includes methods for stream setup and teardown, channel encryption, authentication of a client to a server and of one server to another server, and primitives for push-style messages, publication of network availability information ("presence"), and request-response interactions.</t>
      <t>This document obsoletes RFC 3920.</t>
    </abstract>
  </front>

  <middle>

  <section title="Introduction" anchor="intro">
    <section title="Overview" anchor="intro-overview">
      <t>The Extensible Messaging and Presence Protocol (XMPP) is an application profile of the Extensible Markup Language <xref target="XML"/> for streaming XML data in close to real time between any two (or more) network-aware entities.  XMPP is typically used to exchange messages, share presence information, and engage in structured request-response interactions.  The basic syntax and semantics of XMPP were developed originally within the Jabber open-source community, mainly in 1999.  In late 2002, the XMPP Working Group was chartered with developing an adaptation of the core Jabber protocol that would be suitable as an IETF instant messaging (IM) and presence technology.  As a result of work by the XMPP WG, <xref target='RFC3920'/> and <xref target='RFC3921'/> were published in October 2004, representing the most complete definition of XMPP at that time.</t>
      <t>As a result of extensive implementation and deployment experience with XMPP since 2004, as well as more formal interoperability testing carried out under the auspices of the XMPP Standards Foundation (XSF), this document reflects consensus from the XMPP developer community regarding XMPP's core XML streaming technology.  In particular, this document incorporates the following backward-compatible changes from RFC 3920:</t>
      <t>
        <list style='symbols'>
          <t>Incorporated corrections and errata</t>
          <t>Added examples throughout</t>
          <t>Clarified and more completely specified matters that were underspecified</t>
          <t>Modified text to reflect updated technologies for which XMPP is a using protocol, e.g., Transport Layer Security (TLS) and the Simple Authentication and Security Layer (SASL)</t>
          <t>Defined several additional stream, stanza, and SASL error conditions</t>
          <t>Removed the deprecated DIGEST-MD5 SASL mechanism <xref target='DIGEST-MD5'/> as a mandatory-to-implement technology</t>
          <t>Added the TLS plus the SASL PLAIN mechanism <xref target='PLAIN'/> as a mandatory-to-implement technology</t>
          <t>Defined of optional support for multiple resources over the same connection</t>
          <t>Transferred historical documentation for the server dialback protocol from this specification to a separate specification</t>
        </list>
      </t>
      <t>Therefore, this document defines the core features of XMPP 1.0, thus obsoleting RFC 3920.</t>
      <t><list style='empty'><t>Note: <xref target="XMPP-IM"/> defines the XMPP features needed to provide the basic instant messaging and presence functionality that is described in <xref target="IMP-REQS"/>.</t></list></t>
    </section>
    <section title="Functional Summary" anchor="intro-summary">
      <t>This non-normative section provides a developer-friendly, functional summary of XMPP; refer to the sections that follow for a normative definition of XMPP.</t>
      <t>The purpose of XMPP is to enable the exchange of relatively small pieces of structured data (called "XML stanzas") over a network between any two (or more) entities.  XMPP is implemented using a client-server architecture, wherein a client needs to connect to a server in order to gain access to the network and thus be allowed to exchange XML stanzas with other entities (which can be associated with other servers).  The process whereby a client connects to a server, exchanges XML stanzas, and ends the connection is:</t>
      <t>
        <list style='numbers'>
          <t>Determine the hostname and port at which to connect</t>
          <t>Open a TCP connection</t>
          <t>Open an XML stream</t>
          <t>Complete TLS negotiation for channel encryption (recommended)</t>
          <t>Complete SASL negotiation for authentication</t>
          <t>Bind a resource to the stream</t>
          <t>Exchange an unbounded number of XML stanzas with other entities on the network</t>
          <t>Close the XML stream</t>
          <t>Close the TCP connection</t>
        </list>
      </t>
      <t>Within XMPP, one server can optionally connect to another server to enable inter-domain or inter-server communication.  For this to happen, the two servers need to negotiate a connection between themselves and then exchange XML stanzas; the process for doing so is:</t>
      <t>
        <list style='numbers'>
          <t>Determine the hostname and port at which to connect</t>
          <t>Open a TCP connection</t>
          <t>Open an XML stream</t>
          <t>Complete TLS negotiation for channel encryption (recommended)</t>
          <t>Complete SASL negotiation for authentication *</t>
          <t>Exchange an unbounded number of XML stanzas both directly for the servers and indirectly on behalf of entities associated with each server (e.g., connected clients)</t>
          <t>Close the XML stream</t>
          <t>Close the TCP connection</t>
        </list>
      </t>
      <t><list style='empty'><t>* Note: Depending on local service policies, it is possible that a deployed server will use the older server dialback protocol to provide weak identity verification in cases where SASL negotiation would not result in strong authentication (e.g., because TLS negotiation was not mandated by the peer server, or because the certificate presented by the peer server during TLS negotiation is self-signed and thus provides only weak identity); for details, see <xref target='XEP-0220'/>.</t></list></t>
      <t>In the section following discussion of XMPP architecture, this document specifies how clients connect to servers and specifies the basic semantics of XML stanzas.  However, this document does not define the "payloads" of the XML stanzas that might be exchanged once a connection is successfully established; instead, those payloads are defined by various XMPP extensions.  For example, <xref target='XMPP-IM'/> defines extensions for basic instant messaging and presence functionality.  In addition, various specifications produced in the XSF's XEP series <xref target='XEP-0001'/> define extensions for a wide range of more advanced functionality.</t>
    </section>
    <section title="Conventions" anchor="intro-conventions">
      <t>The following capitalized keywords are to be interpreted as described in <xref target="TERMS"/>: "MUST", "SHALL", "REQUIRED"; "MUST NOT", "SHALL NOT"; "SHOULD", "RECOMMENDED"; "SHOULD NOT", "NOT RECOMMENDED"; "MAY", "OPTIONAL".</t>
      <t>Certain security-related terms are to be understood in the sense defined in <xref target="SECTERMS"/>; such terms include, but are not limited to, "assurance", "attack", "authentication", "authorization", "certificate", "certification authority", "confidentiality", "credential", "downgrade", "encryption", "fingerprint", "hash value", "identity", "integrity", "signature", "security perimeter", "self-signed certificate", "sign", "spoof", "tamper", "trust", "trust anchor", "trust chain", "validate", "verify".  Other security-related terms (for example, "denial of service") are to be understood in the sense defined in the referenced specifications.</t>
      <t>The term "whitespace" is used to refer to any character that matches production [3] content of <xref target="XML"/>, i.e., any instance of SP, HT, CR, and LF.</t>
      <t>Following the "XML Notation" used in <xref target="IRI"/> to represent characters that cannot be rendered in ASCII-only documents, some examples in this document use the form "&amp;#x...." as a notational device to represent <xref target='UNICODE'/> characters (e.g., the string "&amp;#x0159;" stands for the Unicode character LATIN SMALL LETTER R WITH CARON).</t>
      <t>In examples, lines have been wrapped for improved readability, "[...]" means elision, and the following prepended strings are used (these prepended strings are not to be sent over the wire):</t>
      <t>
        <list style='symbols'>
          <t>C: = a client</t>
          <t>E: = any XMPP entity</t>
          <t>I: = an initiating entity</t>
          <t>P: = a peer server</t>
          <t>R: = a receiving entity</t>
          <t>S: = a server</t>
          <t>S1: = server1</t>
          <t>S2: = server2</t>
        </list>
      </t>
    </section>
    <section title="Acknowledgements" anchor="intro-ack">
      <t>The editor of this document finds it impossible to appropriately acknowledge the many individuals who have provided comments regarding the protocols defined herein.  However, thanks are due to those who have who have provided implementation feedback, bug reports, requests for clarification, and suggestions for improvement since the publication of the RFC this document supersedes.  The editor has endeavored to address all such feedback, but is solely responsible for any remaining errors and ambiguities.</t>
    </section>
    <section title="Discussion Venue" anchor="intro-discuss">
      <t>[[ RFC Editor: please remove this section. ]]</t>
      <t>The document editor and the broader XMPP developer community welcome discussion and comments related to the topics presented in this document.  The primary and preferred venue is the &lt;xmpp@ietf.org&gt; mailing list, for which archives and subscription information are available at <eref target='https://www.ietf.org/mailman/listinfo/xmpp'/>.  Related discussions often occur on the &lt;standards@xmpp.org&gt; mailing list, for which archives and subscription information are available at <eref target='http://mail.jabber.org/mailman/listinfo/standards'/>.</t>
    </section>
  </section>

  <section title="Architecture" anchor="arch">
    <t>XMPP provides a technology for the asynchronous, end-to-end exchange of structured data by means of direct, persistent XML streams among a distributed network of globally-addressable, presence-aware clients and servers.  Because this architectural style involves ubiquitous knowledge of network availability and a conceptually unlimited number of concurrent information transactions in the context of a given client-to-server or server-to-server session, we label it "Availability for Concurrent Transactions" (ACT) to distinguish it from the "Representational State Transfer" <xref target="REST"/> architectural style familiar from the World Wide Web.  Although the architecture of XMPP is similar in important ways to that of email (see <xref target='EMAIL-ARCH'/>), it introduces several modifications to facilitate communication in close to real time.  The salient features of this ACTive architectural style are as follows.</t>
    <section title="Global Addresses" anchor="arch-addresses">
      <t>As with email, XMPP uses globally-unique addresses (based on the Domain Name System) in order to route and deliver messages over the network.  All XMPP entities are addressable on the network, most particularly clients and servers but also various additional services that can be accessed by clients and servers.  In general, server addresses are of the form "domain.tld" (e.g., "im.example.com"), accounts hosted at a server are of the form "localpart@domain.tld" (e.g., "juliet@im.example.com"), and a particular connected device or resource that is currently authorized for interaction on behalf of an account is of the form "localpart@domain.tld/resource" (e.g., "juliet@im.example.com/balcony").  For historical reasons, XMPP addresses are often called Jabber IDs or JIDs.  Because the formal specification of the XMPP address format depends on internationalization technologies that are in flux at the time of writing, the format is defined in <xref target="XMPP-ADDR"/> instead of this document.</t>
    </section>
    <section title="Presence" anchor="arch-presence">
      <t>XMPP includes the ability for an entity to advertise its network availability or "presence" to other entities.  Such availability for communication is signalled end-to-end via dedicated communication primitives in XMPP (the &lt;presence/&gt; stanza).  Although knowledge of network availability is not strictly necessary for the exchange of XMPP messages, it facilitates real-time interaction because the originator of a message can know before initiating communication that the intended recipient is online and available.  XMPP presence is defined in <xref target="XMPP-IM"/>.</t>
    </section>
    <section title="Persistent Streams" anchor="arch-streams">
      <t>Availability for communication is also built into point-to-point connections (e.g., a discrete client-to-server or server-to-server connection) through the use of direct, persistent XML streams between the entity that initiated the connection (either a client or a server) and the entity that received the connection (a server).  Thus either party to a stream knows that it can immediately push data to the other party for immediate routing or delivery.  XML streams are defined under <xref target="streams"/>.</t>
    </section>
    <section title="Structured Data" anchor="arch-data">
      <t>The basic unit of meaning in XMPP is not an XML stream (which simply provides the transport for point-to-point communication) but an XML "stanza", which is essentially a fragment of XML that is sent over a stream.  The root element of a stanza includes routing attributes (such as "from" and "to" addresses) and the child elements of the stanza contain a payload for delivery to the intended recipient.  XML stanzas are defined under <xref target="stanzas"/>.</t>
    </section>
    <section title="Distributed Network" anchor="arch-network">
      <t>In practice, XMPP consists of a network of clients and servers that inter-communicate (however, communication between any two given deployed servers is strictly OPTIONAL).  Thus, for example, the user &lt;juliet@im.example.com&gt; associated with the server &lt;im.example.com&gt; might be able to exchange messages, presence, and other structured data with the user &lt;romeo@example.net&gt; associated with the server &lt;example.net&gt;.  This pattern is familiar from messaging protocols that make use of global addresses, such as the email network (see <xref target="SMTP"/> and <xref target="EMAIL-ARCH"/>).  As a result, end-to-end communication in XMPP is logically peer-to-peer but physically client-to-server-to-server-to-client, as illustrated in the following diagram.</t>
      <figure>
        <artwork><![CDATA[
  example.net ---------------- im.example.com
     |                                |
     |                                |
romeo@example.net           juliet@im.example.com

        ]]></artwork>
      </figure>
      <t><list style='empty'><t>Note: Architectures that employ <xref target='streams'>XML streams</xref> and <xref target="stanzas">XML stanzas</xref> but that establish peer-to-peer connections directly between clients using technologies based on <xref target='LINKLOCAL'/> have been deployed, but such architectures are not described in this specification and are best described as "XMPP-like"; for details, see <xref target='XEP-0174'/>.  In addition, XML streams can be established end-to-end over any reliable transport, including extensions to XMPP itself; however, such methods are out of scope for this specification.</t></list></t>
      <t>The following paragraphs describe the responsibilities of clients and servers on the network.</t>
      <t>A CLIENT is an entity that establishes an XML stream with a server by authenticating using the credentials of a local account and that then completes <xref target='bind'>resource binding</xref> in order to enable delivery of XML stanzas between the server and the client over the negotiated stream.  The client then uses XMPP to communicate with its server, other clients, and any other entities on the network, where the server is responsible for delivering stanzas to local entities or routing them to remote entities.  Multiple clients can connect simultaneously to a server on behalf of the same local account, where each client is differentiated by the resourcepart of an XMPP address (e.g., &lt;localpart@domain/home&gt; vs. &lt;localpart@domain/work&gt;), as defined under <xref target='XMPP-ADDR'/> and <xref target='bind'/>.</t>
      <t>A SERVER is an entity whose primary responsibilities are to:</t>
      <t>
        <list style='symbols'>
          <t>Manage <xref target="streams">XML streams</xref> with local clients and deliver <xref target="stanzas">XML stanzas</xref> to those clients over the negotiated streams; this includes responsibility for ensuring that a client needs to authenticate with the server before being granted access to the XMPP network.</t>
          <t>Subject to local service policies on server-to-server communication, manage <xref target="streams">XML streams</xref> with remote servers and route <xref target="stanzas">XML stanzas</xref> to those servers over the negotiated streams.</t>
        </list>
      </t>
      <t>Depending on the application, the secondary responsibilities of an XMPP server can include:</t>
      <t>
        <list style='symbols'>
          <t>Storing XML data that is used by clients (e.g., contact lists for users of XMPP-based instant messaging and presence applications as defined in <xref target='XMPP-IM'/>); in this case, the relevant XML stanza is handled directly by the server itself on behalf of the client and is not routed to a remote server or delivered to a local entity.</t>
          <t>Hosting local services that also use XMPP as the basis for communication but that provide additional functionality beyond that defined in this document or in <xref target='XMPP-IM'/>; examples include multi-user conferencing services as specified in <xref target='XEP-0045'/> and publish-subscribe services as specified in <xref target='XEP-0060'/>.</t>
        </list>
      </t>
    </section>
  </section>

  <section title="TCP Binding" anchor="tcp">
    <section title="Scope" anchor="tcp-scope">
      <t>As XMPP is defined in this specification, an initiating entity (client or server) MUST open a Transmission Control Protocol <xref target='TCP'/> connection at the receiving entity (server) before it negotiates XML streams with the receiving entity.  The parties then maintain that TCP connection for as long as the XML streams are in use.  The rules specified in the following sections apply to the TCP binding.</t>
    </section>
    <section title="Hostname Resolution" anchor="tcp-resolution">
      <t>Before opening the TCP connection, the initiating entity first MUST resolve the Domain Name System (DNS) hostname associated with the receiving entity and determine the appropriate TCP port for communication with the receiving entity.  The process is:</t>
      <t>
        <list style='numbers'>
          <t>Attempt to resolve the hostname using (a) a <xref target="DNS-SRV"/> Service of "xmpp-client" (for client-to-server connections) or "xmpp-server" (for server-to-server connections) and (b) a Proto of "tcp", resulting in resource records such as "_xmpp-client._tcp.example.net." or "_xmpp-server._tcp.im.example.com.".  The result of the SRV lookup will be one or more combinations of a port and hostname, which hostnames the initiating entity MUST resolve according to returned SRV record weight (if the result of the SRV lookup is a single RR with a Target of ".", i.e. the root domain, the initiating entity MUST abort SRV processing but SHOULD attempt a fallback resolution as described below).  The initiating entity uses the IP address(es) from the first successfully resolved hostname (with the corresponding port number returned by the SRV lookup) in order to connect to the receiving entity.  If the initiating entity fails to connect using one of the IP addresses, the initiating entity uses the next resolved IP address to connect.  If the initiating entity fails to connect using all resolved IP addresses, then the initiating entity repeats the process of resolution and connection for the next hostname returned by the SRV lookup.</t>
           <t>If the SRV lookup aborts or fails, the fallback SHOULD be a normal IPv4 or IPv6 address record resolution to determine the IP address, where the port used is the "xmpp-client" port of 5222 for client-to-server connections or the "xmpp-server" port 5269 for server-to-server connections.</t>
           <t>For client-to-server connections, the fallback MAY be a <xref target='DNS-TXT'/> lookup for alternative connection methods, for example as described in <xref target='XEP-0156'/>.</t>
        </list>
      </t>
      <t><list style='empty'><t>Note: If the initiating entity has been explicitly configured to associate a particular hostname (and potentially port) with the original hostname of the receiving entity (say, to "hardcode" an association between an original hostname of example.net and a configured hostname and of webcm.example.com:80), the initiating entity SHALL use the configured name instead of performing the foregoing resolution process on the original name.</t></list></t>
      <t><list style='empty'><t>Note: Many XMPP servers are implemented in such a way that they can host additional services (beyond those defined in this specification and <xref target='XMPP-IM'/>) at hostnames that are subdomains of the hostname of the main XMPP service (e.g., conference.example.net for a <xref target='XEP-0045'/> service associated with the example.net XMPP service) or subdomains of the first-level domain of the underlying host (e.g., muc.example.com for a <xref target='XEP-0045'/> service associated with the im.example.com XMPP service).  If an entity from a remote domain wishes to use such additional services, it would generate an appropriate XML stanza and the remote domain itself would attempt to resolve the service's hostname via an SRV lookup on resource records such as "_xmpp-server._tcp.conference.example.net." or "_xmpp-server._tcp.muc.example.com.".  Therefore if a service wishes to enable entities from remote domains to access these additional services, it needs to advertise the appropriate "_xmpp-server" SRV records in addition to the "_xmpp-server" record for its main XMPP service.</t></list></t>
    </section>
    <section title="Client-to-Server Communication" anchor="tcp-c2s">
      <t>A client is subordinate to a server.  As a result, a client authenticates to the server but the server does not necessarily authenticate to the client.  Therefore the server MUST allow the client to share a single, bidirectional TCP connection for XML stanzas sent from client to server and from server to client (i.e., the inital stream and response stream as specified under <xref target='streams'/>).</t>
    </section>
    <section title="Server-to-Server Communication" anchor="tcp-s2s">
      <t>Any two given servers are peers.  As a result, each peer MUST authenticate with the other.  This can be accomplished in one of two ways:</t>
      <t>
        <list style='symbols'>
          <t>Through one-way authentication on two, unidirectional TCP connections: one for XML stanzas sent from the first server to the second server and another, initiated by the second server, for XML stanzas from the second server to the first server (this is the "legacy" approach in the absence of mutual authentication).</t>
          <t>Through mutual authentication on a single, bidirectional TCP connection (this is possible using TLS and SASL with certificates, however methods for explicitly signalling the use of a single, bidirectional TCP connection are out of scope for this specification).</t>
        </list>
      </t>
      <t>This rule applies only to <xref target='stanzas'>XML stanzas</xref>.  Therefore during <xref target='tls'>STARTTLS negotiation</xref> and <xref target='sasl'>SASL negotiation</xref> the servers would use one TCP connection, but after stream setup that TCP connection would be used only for the initiating server to send XML stanzas to the receiving server.  In order for the receiving server to send XML stanzas to the initiating server, the receiving server would need to reverse the roles and negotiate an XML stream from the receiving server to the initiating server.</t>
    </section>
    <section title="Reconnection" anchor="tcp-reconnect">
      <t>It can happen that an XMPP server goes offline while servicing TCP connections from local clients and from other servers.  Because the number of such connections can be quite large, the reconnection algorithm employed by entities that seek to reconnect can have a significant impact on software and network performance.  The following guidelines are RECOMMENDED:</t>
      <t>
        <list style='symbols'>
          <t>The time to live (TTL) specified in Domain Name System records MUST be honored, even if DNS results are cached; if the TTL has not expired, an entity that seeks to reconnect MUST NOT re-resolve the server hostname before reconnecting.</t>
          <t>The time that expires before an entity first seeks to reconnect MUST be randomized (e.g., so that all clients do not attempt to reconnect exactly 30 seconds after being disconnected).</t>
          <t>If the first reconnection attempt does not succeed, an entity MUST back off increasingly on the time between subsequent reconnection attempts, e.g. in accordance with the exponential backoff principle.</t>
        </list>
      </t>
      <t><list style='empty'><t>Note: Because it is possible that a disconnected entity cannot determine the cause of disconnection (e.g., because there was no explicit stream error) or does not need a new stream for immediate communication (e.g., because the stream was idle and therefore timed out), it SHOULD NOT assume that is needs to reconnect immediately.</t></list></t>
    </section>
    <section title="Reliability" anchor="streams-reliability">
      <t>The use of long-lived TCP connections in XMPP implies that the sending of XML stanzas over XML streams can be unreliable, since the parties to a long-lived TCP connection might not discover a connectivity disruption in a timely manner.  At the XMPP application layer, long connectivity disruptions can result in undelivered stanzas.  Although the core XMPP technology defined in this specification does not contain features to overcome this lack of reliability, there exist XMPP extensions for doing so (e.g., <xref target='XEP-0198'/>).</t>
    </section>
    <section title="Other Bindings" anchor="tcp-other">
      <t>There is no necessary coupling of an XML stream to a TCP connection.  For example, two entities could connect to each other via another transport, such as <xref target="HTTP"/> as specified in <xref target="XEP-0124"/> and <xref target='XEP-0206'/>.  Although this specification neither encourages nor discourages other bindings, it defines only a binding of XMPP to TCP.</t>
    </section>
  </section>

  <section title="XML Streams" anchor="streams">

    <section title="Overview" anchor="streams-overview">
      <t>Two fundamental concepts make possible the rapid, asynchronous exchange of relatively small payloads of structured information between presence-aware entities: XML streams and XML stanzas.  These terms are defined as follows.</t>
      <t>
        <list style="hanging">
          <t hangText="Definition of XML Stream:"><iref item='XML Stream'/>An XML STREAM is a container for the exchange of XML elements between any two entities over a network.  The start of an XML stream is denoted unambiguously by an opening STREAM HEADER (i.e., an XML &lt;stream&gt; tag with appropriate attributes and namespace declarations), while the end of the XML stream is denoted unambiguously by a closing XML &lt;/stream&gt; tag.  During the life of the stream, the entity that initiated it can send an unbounded number of XML elements over the stream, either elements used to negotiate the stream (e.g., to complete <xref target='tls'>TLS negotiation</xref> or <xref target='sasl'>SASL negotiation</xref>) or XML stanzas.  <iref item='Initial Stream'/>The INITIAL STREAM is negotiated from the initiating entity (typically a client or server) to the receiving entity (typically a server), and can be seen as corresponding to the initiating entity's "connection" or "session" with the receiving entity.  <iref item='Response Stream'/>The initial stream enables unidirectional communication from the initiating entity to the receiving entity; in order to enable information exchange from the receiving entity to the initiating entity, the receiving entity MUST negotiate a stream in the opposite direction (the RESPONSE STREAM).</t>
          <t hangText="Definition of XML Stanza:"><iref item='XML Stanza'/>An XML STANZA is a discrete semantic unit of structured information that is sent from one entity to another over an XML stream, and is the basic unit of meaning in XMPP.  An XML stanza exists at the direct child level of the root &lt;stream/&gt; element; the start of any XML stanza is denoted unambiguously by the element start tag at depth=1 of the XML stream (e.g., &lt;presence&gt;), and the end of any XML stanza is denoted unambiguously by the corresponding close tag at depth=1 (e.g., &lt;/presence&gt;).  The only XML stanzas defined herein are the &lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt; elements qualified by the default namespace for the stream, as described under <xref target="stanzas"/>; for example, an XML element sent for the purpose of <xref target='tls'>TLS negotiation</xref> or <xref target='sasl'>SASL negotiation</xref> is not considered to be an XML stanza, nor is a stream error or a stream feature.  An XML stanza MAY contain child elements (with accompanying attributes, elements, and XML character data) as necessary in order to convey the desired information, which MAY be qualified by any XML namespace (see <xref target='XML-NAMES'/> as well as <xref target='stanzas-extended'/> herein).</t>
        </list>
      </t>
      <t>Consider the example of a client's connection to a server.  In order to connect to a server, a client initiates an XML stream by sending a stream header to the server, optionally preceded by a text declaration specifying the XML version and the character encoding supported (see <xref target="xml-declaration"/> and <xref target="xml-encoding"/>).  Subject to local policies and service provisioning, the server then replies with a second XML stream back to the client, again optionally preceded by a text declaration.  Once the client has completed <xref target='sasl'>SASL negotiation</xref> and <xref target='bind'>resource binding</xref>, the client can send an unbounded number of XML stanzas over the stream.  When the client desires to close the stream, it simply sends a closing &lt;/stream&gt; tag to the server  as further described under <xref target='streams-close'/>.</t>
      <t>In essence, then, an XML stream acts as an envelope for all the XML stanzas sent during a connection.  We can represent this in a simplistic fashion as follows.</t>
      <figure>
        <artwork><![CDATA[
+--------------------+
| <stream>           |
|--------------------|
| <presence>         |
|   <show/>          |
| </presence>        |
|--------------------|
| <message to='foo'> |
|   <body/>          |
| </message>         |
|--------------------|
| <iq to='bar'>      |
|   <query/>         |
| </iq>              |
|--------------------|
| <iq from='bar'>    |
|   <query/>         |
| </iq>              |
|--------------------|
| [ ... ]            |
|--------------------|
| </stream>          |
+--------------------+
        ]]></artwork>
      </figure>
      <t><list style='empty'><t>Note: Those who are accustomed to thinking of XML in a document-centric manner might view a client's connection to a server as consisting of two open-ended XML documents: one from the client to the server and one from the server to the client.  On this analogy, the two XML streams can be considered equivalent to two "documents" (matching production [1] content of <xref target='XML'/>) that are built up through the accumulation of XML stanzas, the root &lt;stream/&gt; element can be considered equivalent to the "document entity" for each "document" (as described in Section 4.8 of <xref target='XML'/>), and the XML stanzas sent over the streams can be considered equivalent to "fragments" of the "documents" as described in <xref target='XML-FRAG'/>.  However, this perspective is merely an analogy; XMPP does not deal in documents and fragments but in streams and stanzas.</t></list></t>
      <t>The remainder of this section defines the following aspects of XML streams:</t>
      <t>
        <list style='symbols'>
          <t>The stream negotation process</t>
          <t>How to close a stream</t>
          <t>The XML attributes of a stream</t>
          <t>The XML namespaces of a stream</t>
        </list>
      </t>
    </section>

    <section title="Stream Negotiation" anchor="streams-negotiation">
      <section title="Overview" anchor="streams-negotiation-overview">
        <t>Because the receiving entity for a stream acts as a gatekeeper to the domains it services, it imposes certain conditions for connecting as a client or as a peer server.  At a minimum, the initiating entity needs to authenticate with the receiving entity before it is allowed to send stanzas to the receiving entity, typically using SASL as described under <xref target='sasl'/>.  However, the receiving entity can consider conditions other than authentication to be mandatory, such as encryption using TLS as described under <xref target='tls'/>.  The receiving entity informs the initiating entity about such conditions by communicating STREAM FEATURES: the set of particular protocol interactions that are mandatory for the initiating entity to complete before the receiving entity will accept XML stanzas from the initiating entity (e.g., authentication), as well as any protocol interactions that are voluntary but that might improve the handling of an XML stream (e.g., establishment of application-layer compression).</t>
        <t>The existence of conditions for connecting implies that streams need to be negotiated.  The order of layers (TCP, then TLS, then SASL, then XMPP; see <xref target='security-layers'/>) implies that stream negotiation is a multi-stage process.  Further structure is imposed by two factors: (1) a given stream feature might be made available only to certain entities or only after certain other features have been negotiated (e.g., resource binding is made available only after SASL authentication), and (2) stream features can be either mandatory-to-negotiate or voluntary-to-negotiate.  Finally, for security reasons the parties to a stream need to discard knowledge that they gained during the negotiation process after successfully completing the protocol interactions defined for certain features (e.g., TLS in all cases and SASL in the case when a security layer might be established); this is done by flushing the old stream context and exchanging new stream headers over the existing TCP connection.</t>
      </section>
      <section title="Stream Features Format" anchor="streams-negotiation-features">
        <t>If the initiating entity includes the 'version' attribute set to a value of at least "1.0" in the initial stream header, after sending the response stream header the receiving entity MUST send a &lt;features/&gt; child element (prefixed by the streams namespace prefix) to the initiating entity in order to announce any conditions for continuation of the stream negotiation process.  Each condition takes the form of a child element of the &lt;features/&gt; element, qualified by a namespace that is different from the streams namespace and the default namespace.</t>
        <t>If a particular stream feature is or can be mandatory-to-negotiate, the definition of that feature needs to either declare that the feature is always mandatory-to-negotiate (e.g., this is true of resource binding for XMPP clients) or specify a way for the receiving entity to flag the feature as mandatory-to-negotiate for this interaction (e.g., this is done for TLS by including an empty &lt;required/&gt; element in the advertisement for that stream feature).</t>
        <t>For security reasons, certain stream features necessitate the initiating entity to send a new initial stream header upon successful negotiation of the feature (e.g., TLS in all cases and SASL in the case when a security layer might be established).  If this is true of a given stream feature, the definition of that feature needs to declare that a stream restart is expected after negotiation of the feature.</t>
        <t>A &lt;features/&gt; element that contains at least one mandatory feature indicates that the stream negotiation is not complete and that the initiating entity MUST negotiate further features.</t>
        <figure>
          <artwork><![CDATA[
R: <stream:features>
     <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'>
       <required/>
     </starttls>
   </stream:features>
          ]]></artwork>
        </figure>
        <t>A &lt;features/&gt; element MAY contain more than one mandatory feature.  This means that the initiating entity can choose among the mandatory features.  For example, perhaps a future technology will perform roughly the same function as TLS, so the receiving entity might advertise support for both TLS and the future technology.</t>
        <t>A &lt;features/&gt; element that contains only voluntary features indicates that the stream negotiation is complete and that the initiating entity is cleared to send XML stanzas, but that the initiating entity MAY negotiate further features if desired.</t>
        <figure>
          <artwork><![CDATA[
R: <stream:features>
     <session xmlns='urn:ietf:params:xml:ns:xmpp-session'/>
     <compression xmlns='http://jabber.org/features/compress'>
       <method>zlib</method>
       <method>lzw</method>
     </compression>
   </stream:features>
          ]]></artwork>
        </figure>
        <t>A &lt;features/&gt; element that contains both mandatory and voluntary features indicates that the negotiation is not complete but that the initiating entity MAY complete the voluntary feature(s) before it attempts to negotiate the mandatory feature(s).</t>
        <figure>
          <artwork><![CDATA[
R: <stream:features>
     <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>
     <compression xmlns='http://jabber.org/features/compress'>
       <method>zlib</method>
       <method>lzw</method>
     </compression>
   </stream:features>
          ]]></artwork>
        </figure>
        <t>An empty &lt;features/&gt; element indicates that the stream negotiation is complete and that the initiating entity is cleared to send XML stanzas.</t>
        <figure>
          <artwork><![CDATA[
R: <stream:features/>
          ]]></artwork>
        </figure>
        <t><list style='empty'><t>Note: The order of child elements contained in any given &lt;features/&gt; element is not significant.</t></list></t>
      </section>
      <section title="Restarts" anchor="streams-negotiation-restart">
        <t>On successful negotiation of a feature that necessitates a stream restart, both parties MUST consider the previous stream to be replaced but MUST NOT terminate the underlying TCP connection; instead, the parties MUST reuse the existing connection, which might be in a new state (e.g., encrypted as a result of TLS negotiation).  The initiating entity then MUST send a new initial stream header, which SHOULD be preceded by an XML declaration as described under <xref target='xml-declaration'/>.  When the receiving entity receives the new initial stream header, it MUST generate a new stream ID (instead of re-using the old stream ID) before sending a new response stream header (which SHOULD be preceded by an XML declaration as described under <xref target='xml-declaration'/>).</t>
        <t>For the sake of backward compatibility, the receiving entity MUST accept stream restarts at any stage in the stream negotiation process even if the receiving entity has not indicated that a stream restart is mandatory at that stage.</t>
      </section>
      <section title="Resending Features" anchor="streams-negotiation-resend">
        <t>After completing negotiation of any stream feature (even stream features that do not necessitate a stream restart), the receiving entity MUST send an updated list of stream features to the initiating entity, where the list MAY be empty if there are no further features to be advertised.</t>
        <t>At any time after stream establishment and before closing of the stream, the receiving entity MAY send additional or modified stream feature advertisements to the initiating entity (e.g., because a new feature has been enabled).</t>
      </section>
      <section title="Completion of Stream Negotiation" anchor="streams-negotiation-complete">
        <t>The receiving entity indicates completion of the stream negotiation process by sending to the initiating entity either an empty &lt;features/&gt; element or a &lt;features/&gt; element that contains only voluntary features.  After doing so, the receiving entity MUST NOT send additional stream features to the initiating entity (if the receiving entity has new features to offer, it can simply close the stream using a &lt;reset/&gt; stream error and then advertise the new features when the initiating entity reconnects, preferably closing existing streams in a staggered way so that not all of the initiating entities reconnect at once).  Once stream negotiation is complete, the initiating entity is cleared to send XML stanzas over the stream for as long as the stream is maintained by both parties.</t>
        <t>The initiating entity MUST NOT attempt to send <xref target="stanzas">XML stanzas</xref> to entities other than itself (i.e., the client's connected resource or any other authenticated resource of the client's account) or the server until stream negotiation has been completed.  However, if it does attempt to do so, the receiving entity MUST NOT accept such stanzas and MUST return a &lt;not-authorized/&gt; stream error.  This rule applies to XML stanzas only (i.e., &lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt; elements qualified by the default namespace) and not to XML elements used for stream negotiation (e.g., elements used to complete <xref target='tls'>TLS negotiation</xref> or <xref target='sasl'>SASL negotiation</xref>).</t>
      </section>
      <section title="Determination of Addresses" anchor="streams-negotiation-address">
        <t>After the parties to an XML stream have completed the appropriate aspects of stream negotiation (typically <xref target='sasl'>SASL negotiation</xref> and, if appropriate, <xref target="bind">resource binding</xref>) the receiving entity for a stream MUST determine the initiating entity's JID.</t>
        <t>For server-to-server communication, the initiating server's JID MUST be the authorization identity (as defined by <xref target="SASL"/>), either (1) as directly communicated by the initiating server during <xref target='sasl'>SASL negotiation</xref> or (2) as derived by the receiving server from the authentication identity if no authorization identity was specified during <xref target='sasl'>SASL negotiation</xref>.  In the absence of SASL negotiation (e.g., when the older server dialback protocol is used as specified in <xref target='XEP-0220'/>), the receiving server MAY consider the authentication identity to be the 'from' address on the initial stream header (preferably only the stream header sent after TLS negotiation, because otherwise the 'from' address can be spoofed).</t>
        <t>For client-to-server communication, the client's bare JID (&lt;localpart@domain&gt;) MUST be the authorization identity (as defined by <xref target="SASL"/>), either (1) as directly communicated by the client during <xref target='sasl'>SASL negotiation</xref> or (2) as derived by the server from the authentication identity if no authorization identity was specified during <xref target='sasl'>SASL negotiation</xref>.  The resourcepart of the full JID (&lt;localpart@domain/resource&gt;) MUST be the resource negotiated by the client and server during <xref target="bind">resource binding</xref>.</t>
        <t>The receiving entity MUST ensure that the resulting JID (including localpart, domainpart, resourcepart, and separator characters) conforms to the canonical format for XMPP addresses defined in <xref target='XMPP-ADDR'/>; to meet this restriction, the receiving entity MAY replace the JID sent by the initiating entity with the canonicalized JID as determined by the receiving entity.</t>
      </section>

      <section title="State Chart" anchor="streams-negotiation-statechart">
        <t>We summarize the foregoing rules in the following non-normative state chart for the stream negotiation process, presented from the perspective of the initiating entity.</t>
        <figure>
          <artwork><![CDATA[
                     +------------+
                     |  open TCP  |
                     | connection |
                     +------------+
                           |
                    +---------------+
                    | send initial  |<-------------------------+
                    | stream header |                          |
                    +---------------+                          |
                           |                                   |
                   +------------------+                        |
                   | receive response |                        |
                   | stream header    |                        |
                   +------------------+                        |
                           |                                   |
                    +----------------+                         |
                    | receive stream |                         |
+------------------>| features       |                         |
|                   +----------------+                         |
|                          |                                   |
|       +<-----------------+                                   |
|       |                                                      |
|    {empty?} ----> {all voluntary?} ----> {some mandatory?}   |
|       |      no          |          no         |             |
|       | yes              | yes                 |             |
|       |                  |                     |             |
|       |           +---------------+    +----------------+    |
|       |           | MAY negotiate |    | MUST negotiate |    |
|       |           | any or none   |    | one feature    |    |
|       |           +---------------+    +----------------+    |
|       |                  |                     |             |
|   +----------+      +-----------+              |             |
|   | process  |<-----| negotiate |              |             |
|   | complete |  no  | a feature |              |             |
|   +----------+      +-----------+              |             |
|                          |                     |             |
|                     yes  |                     |             |
|                          |                     |             |
|                          +----->----+----<-----+             |
|                                     |                        |
|                                     |                        |
+<---------------------------[restart mandatory?]------------->+
               no                                     yes

          ]]></artwork>
        </figure>
      </section>
    </section>

    <section title="Closing a Stream" anchor="streams-close">
      <t>An XML stream between two entities can be closed because a stream error has occurred or in some cases in the absence of an error.  Where feasible, it is preferable to close a stream only if a stream error has occurred.</t>
      <t>A stream is closed by sending a closing &lt;/stream&gt; tag over the TCP connection.</t>
      <figure>
        <artwork><![CDATA[
S: </stream:stream>
        ]]></artwork>
      </figure>
      <t>After an entity sends a closing stream tag, it MUST NOT send further data over that stream.</t>
      <section title="With Stream Error" anchor="streams-close-witherror">
        <t>If a stream error has occurred, the entity that detects the error MUST close the stream as described under <xref target='streams-error-rules'/>.</t>
      </section>
      <section title="Without Stream Error" anchor="streams-close-withouterror">
        <t>At any time after XML streams have been negotiated between two entities, either entity MAY close its stream to the other party in the absence of a stream error by sending a closing stream tag.</t>
        <figure>
          <artwork><![CDATA[
P: </stream:stream>
          ]]></artwork>
        </figure>
        <t>The entity that sends the closing stream tag SHOULD wait for the other party to also close its stream.</t>
        <figure>
          <artwork><![CDATA[
S: </stream:stream>
          ]]></artwork>
        </figure>
        <t>However, the entity that sends the first closing stream tag MAY consider both streams to be void if the other party does not send its closing stream tag within a reasonable amount of time (where the definition of "reasonable" is a matter of implementation or deployment).</t>
        <t>After the entity that sent the first closing stream tag receives a reciprocal closing stream tag from the other party (or if it considers the stream to be void after a reasonable amount of time), it MUST terminate the underlying TCP connection or connections.</t>
      </section>
      <section title="Handling of Idle Streams" anchor="streams-close-idle">
        <t>An XML stream can become idle, i.e., neither entity has sent XMPP traffic over the stream for some period of time.  The idle timeout period is a matter of implementation and local service policy;  however, it is RECOMMENDED to be liberal in accepting idle streams, since experience has shown that doing so improves the reliability of communications over XMPP networks.  In particular, it is typically more efficient to maintain a stream between two servers than it is to aggressively timeout such a stream, especially with regard to synchronization of presence information as described in <xref target='XMPP-IM'/>; therefore it is RECOMMENDED to maintain such a stream since experience has shown that server-to-server streams are cyclical and typically need to be re-established every 24 to 48 hours if they are timed out.</t> 
        <t>An XML stream can appear idle at the XMPP level because the underlying TCP connection has become idle (e.g., a client's network connection has been lost).  One common method for preventing a TCP connection from going idle or for detecting an idle TCP connection is to send a space character (U+0020) over the TCP connection between XML stanzas, which is allowed for XML streams as described under <xref target='xml-whitespace'/>; <iref item='Whitespace Keepalive'/>the sending of such a space character is properly called a WHITESPACE KEEPALIVE (although the term "whitespace ping" is often used, in fact it is not a ping since no "pong" is possible).  Other connection-testing methods include the application-level pings described in <xref target="XEP-0199"/> and the more comprehensive stream management protocol described in <xref target="XEP-0198"/>.  Implementers are advised to support whichever connection-testing methods they deem appropriate, but to carefully weigh the network impact of such methods against the benefits of discovering idle streams in a timely manner.  The length of time between the use of any particular connection test is a matter of implementation and local service policy; however, it is RECOMMENDED that any such test be performed not more than once every 60 seconds.</t>
        <t>To close an idle stream with a local client or remote server, a server MUST close the stream without error as explained under <xref target="streams-close-withouterror"/>.</t>
      </section>
    </section>

    <section title="Stream Attributes" anchor="streams-attr">
      <t>The attributes of the root &lt;stream/&gt; element are defined in the following sections.</t>
      <t><list style='empty'><t>Note: The attributes of the root &lt;stream/&gt; element are not prepended by a namespace prefix because, as explained in <xref target="XML-NAMES"/>, "[d]efault namespace declarations do not apply directly to attribute names; the interpretation of unprefixed attributes is determined by the element on which they appear."</t></list></t>
      <section title='from' anchor='streams-attr-from'>
        <t>The 'from' attribute communicates an XMPP identity of the entity sending the stream element.</t>
        <t><list style='empty'><t>Note: It is possible for an entity to have more than one XMPP identity (e.g., in the case of a server that provides virtual hosting).  It is also possible that an entity does not know the XMPP identity of the principal controlling the entity (e.g., because the XMPP identity is assigned at a level other than the XMPP application layer, as in the General Security Service Application Program Interface <xref target='GSS-API'/>).</t></list></t>
        <t>For initial stream headers in client-to-server communication, if the client knows the XMPP identity of the principal controlling the client (typically an account name of the form &lt;localpart@domain&gt;), then it MAY include the 'from' attribute and set its value to that identity; if not, then it MUST NOT include the 'from' attribute.  Note: Including the XMPP identity before the stream is protected via TLS can expose that identity to eavesdroppers.</t>
        <figure>
          <artwork><![CDATA[
I: <?xml version='1.0'?>
   <stream:stream
       from='juliet@im.example.com'
       to='im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <t>For initial stream headers in server-to-server communication, a server MUST include the 'from' attribute and MUST set its value to a hostname serviced by the initiating entity.</t>
        <figure>
          <artwork><![CDATA[
I: <?xml version='1.0'?>
   <stream:stream
       from='example.net'
       to='im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:server'
       xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <t>For response stream headers in both client-to-server and server-to-server communication, the receiving entity MUST include the 'from' attribute and MUST set its value to a hostname serviced by the receiving entity (which MAY be a hostname other than that specified in the 'to' attribute of the initial stream header).</t>
        <figure>
          <artwork><![CDATA[
R: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <t>Whether or not the 'from' attribute is included, each entity MUST verify the identity of the other entity before exchanging XML stanzas with it (see <xref target='security-client'/> and <xref target='security-server'/>).</t>
        <t><list style='empty'><t>Note: It is possible that implementations based on the predecessor to this specification will not include the 'from' address on stream headers; an entity SHOULD be liberal in accepting such stream headers.</t></list></t>
      </section>
      <section title='to' anchor='streams-attr-to'>
        <t>For initial stream headers in both client-to-server and server-to-server communication, the initiating entity MUST include the 'to' attribute and MUST set its value to a hostname that the initiating entity knows or expects the receiving entity to service.</t>
        <figure>
          <artwork><![CDATA[
I: <?xml version='1.0'?>
   <stream:stream
       from='juliet@im.example.com'
       to='im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <t>For response stream headers in client-to-server communication, if the client included a 'from' attribute in the initial stream header then the server MUST include a 'to' attribute in the response stream header and MUST set its value to the bare JID specified in the 'from' attribute of the initial stream header.  If the client did not include a 'from' attribute in the initial stream header then the server MUST NOT include a 'to' attribute in the response stream header.</t>
        <figure>
          <artwork><![CDATA[
R: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <t>For response stream headers in server-to-server communication, the receiving entity MUST include a 'to' attribute in the response stream header and MUST set its value to the hostname specified in the 'from' attribute of the initial stream header.</t>
        <figure>
          <artwork><![CDATA[
R: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='g4qSvGvBxJ+xeAd7QKezOQJFFlw='
       to='example.net'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:server'
       xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <t>Whether or not the 'to' attribute is included, each entity MUST verify the identity of the other entity before exchanging XML stanzas with it (see <xref target='security-client'/> and <xref target='security-server'/>).</t>
        <t><list style='empty'><t>Note: It is possible that implementations based on the predecessor to this specification will not include the 'to' address on stream headers; an entity SHOULD be liberal in accepting such stream headers.</t></list></t>
      </section>
      <section title='id' anchor='streams-attr-id'>
        <t><iref item='Stream ID'/>The 'id' attribute communicates a unique identifier for the stream.  This identifier is called a STREAM ID.  The stream ID MUST be generated by the receiving entity when it sends a response stream header, MUST BE unique within the receiving application (normally a server), and MUST be both unpredictable and nonrepeating because it can be security-critical (see <xref target="RANDOM"/> for recommendations regarding randomness for security purposes).</t>
        <t>For initial stream headers, the initiating entity MUST NOT include the 'id' attribute; however, if the 'id' attribute is included, the receiving entity MUST silently ignore it.</t>
        <t>For response stream headers, the receiving entity MUST include the 'id' attribute.</t>
        <figure>
          <artwork><![CDATA[
R: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
      </section>
      <section title='xml:lang' anchor='streams-attr-xmllang'>
        <t>The 'xml:lang' attribute communicates an entity's preferred or default language for any human-readable XML character data to be sent over the stream.  The syntax of this attribute is defined in Section 2.12 of <xref target='XML'/>; in particular, the value of the 'xml:lang' attribute MUST conform to the NMTOKEN datatype (as defined in Section 2.3 of <xref target="XML"/>) and MUST conform to the language identifier format defined in <xref target="LANGTAGS"/>.</t>
        <t>For initial stream headers, the initiating entity SHOULD include the 'xml:lang' attribute.</t>
        <figure>
          <artwork><![CDATA[
I: <?xml version='1.0'?>
   <stream:stream
       from='juliet@im.example.com'
       to='im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <t>For response stream headers, the receiving entity MUST include the 'xml:lang' attribute.  If the initiating entity included an 'xml:lang' attribute in its initial stream header and the receiving entity supports that language in the human-readable XML character data that it generates and sends to the initiating entity (e.g., in the &lt;text/&gt; element for stream and stanza errors), the value of the 'xml:lang' attribute MUST be an identifier for the initiating entity's preferred language; if the receiving entity supports a language that closely matches the initiating entity's preferred language (e.g., "de" instead of "de-CH"), then the value of the 'xml:lang' attribute SHOULD be the identifier for the matching language but MAY be the identifier for the default language of the receiving entity; if the receiving entity does not support the initiating entity's preferred language or a closely matching language (or the initiating entity did not include the 'xml:lang' attribute in its initial stream header), then the value of the 'xml:lang' attribute MUST be the identifier for the default language of the receiving entity.</t>
        <figure>
          <artwork><![CDATA[
R: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <t>If the initiating entity included the 'xml:lang' attribute in its initial stream header, the receiving entity SHOULD remember that value as the default xml:lang for all stanzas sent by the initiating entity.  As described under <xref target="stanzas-attributes-lang"/>, the initiating entity MAY include the 'xml:lang' attribute in any XML stanzas it sends over the stream.  If the initiating entity does not include the 'xml:lang' attribute in any such stanza, the receiving entity SHOULD add the 'xml:lang' attribute to the stanza, whose value MUST be the identifier for the language preferred by the initiating entity (even if the receiving entity does not support that language for human-readable XML character data it generates and sends to the initiating entity, such as in stream or stanza errors).  If the initiating entity includes the 'xml:lang' attribute in any such stanza, the receiving entity MUST NOT modify or delete it.</t>
      </section>
      <section title='version' anchor='streams-attr-version'>
        <t>The inclusion of the version attribute set to a value of at least "1.0" signals support for the stream-related protocols defined in this specification, including (<xref target='tls'>TLS negotiation</xref>, <xref target='sasl'>SASL negotiation</xref>, <xref target="streams-negotiation-features"/>, and <xref target="streams-error">stream errors</xref>.</t>
        <t>The version of XMPP specified herein is "1.0"; in particular, XMPP 1.0 encapsulates the stream-related protocols as well as the basic semantics of the three defined XML stanza types (&lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt;).</t>
        <t>The numbering scheme for XMPP versions is "&lt;major&gt;.&lt;minor&gt;".  The major and minor numbers MUST be treated as separate integers and each number MAY be incremented higher than a single digit.  Thus, "XMPP 2.4" would be a lower version than "XMPP 2.13", which in turn would be lower than "XMPP 12.3".  Leading zeros (e.g., "XMPP 6.01") MUST be ignored by recipients and MUST NOT be sent.</t>
        <t>The major version number will be incremented only if the stream and stanza formats or obligatory actions have changed so dramatically that an older version entity would not be able to interoperate with a newer version entity if it simply ignored the elements and attributes it did not understand and took the actions specified in the older specification.</t>
        <t>The minor version number will be incremented only if significant new capabilities have been added to the core protocol (e.g., a newly defined value of the 'type' attribute for message, presence, or IQ stanzas).  The minor version number MUST be ignored by an entity with a smaller minor version number, but MAY be used for informational purposes by the entity with the larger minor version number (e.g., the entity with the larger minor version number would simply note that its correspondent would not be able to understand that value of the 'type' attribute and therefore would not send it).</t>
        <t>The following rules apply to the generation and handling of the 'version' attribute within stream headers:</t>
        <t>
          <list style='numbers'>
            <t>The initiating entity MUST set the value of the 'version' attribute in the initial stream header to the highest version number it supports (e.g., if the highest version number it supports is that defined in this specification, it MUST set the value to "1.0").</t>
            <t>The receiving entity MUST set the value of the 'version' attribute in the response stream header to either the value supplied by the initiating entity or the highest version number supported by the receiving entity, whichever is lower.  The receiving entity MUST perform a numeric comparison on the major and minor version numbers, not a string match on "&lt;major&gt;.&lt;minor&gt;".</t>
            <t>If the version number included in the response stream header is at least one major version lower than the version number included in the initial stream header and newer version entities cannot interoperate with older version entities as described, the initiating entity SHOULD generate an &lt;unsupported-version/&gt; stream error.</t>
            <t>If either entity receives a stream header with no 'version' attribute, the entity MUST consider the version supported by the other entity to be "0.9" and SHOULD NOT include a 'version' attribute in the response stream header.</t>
          </list>
        </t>
      </section>
      <section title='Summary of Stream Attributes' anchor='streams-attr-summary'>
        <t>The following table summarizes the attributes of the root &lt;stream/&gt; element.</t>
        <figure>
          <artwork><![CDATA[
+----------+--------------------------+-------------------------+
|          | initiating to receiving  | receiving to initiating |
+----------+--------------------------+-------------------------+
| to       | JID of receiver          | JID of initiator        |
| from     | JID of initiator         | JID of receiver         |
| id       | silently ignored         | stream identifier       |
| xml:lang | default language         | default language        |
| version  | XMPP 1.0+ supported      | XMPP 1.0+ supported     |
+----------+--------------------------+-------------------------+
          ]]></artwork>
        </figure>
      </section>
    </section>

    <section title="Namespace Declarations" anchor="streams-ns">
      <section title="Declaration of Streams Namespace" anchor="streams-ns-stream">
        <t>A streams namespace declaration is REQUIRED in all XML stream headers and the name of the streams namespace MUST be 'http://etherx.jabber.org/streams'.  If this rule is violated, the entity that receives the offending stream header MUST return a stream error to the sending entity, which SHOULD be &lt;invalid-namespace/&gt; but MAY be &lt;bad-format/&gt;.</t>
        <t>The element names of the &lt;stream/&gt; element and its &lt;features/&gt; and &lt;error/&gt; children MUST be qualified by the streams namespace prefix in all instances.  If this rule is violated, the entity that receives the offending element MUST return a stream error to the sending entity, which SHOULD be &lt;bad-format/&gt;.</t>
        <t>For historical reasons, an implementation MAY accept only the 'stream:' prefix for these elements.  If an entity receives a stream header with a streams namespace prefix it does not accept, it MUST return a stream error to the sending entity, which SHOULD be &lt;bad-namespace-prefix/&gt; but MAY be &lt;bad-format/&gt;.</t>
      </section>
      <section title="Declaration of Default Namespace" anchor="streams-ns-default">
        <t>A default namespace declaration is REQUIRED and defines the allowable first-level children of the root stream element.  This namespace declaration MUST be the same for the initial stream and the response stream so that both streams are qualified consistently.  The default namespace declaration applies to the stream and all first-level child element sent within a stream unless explicitly qualified by the streams namespace or another namespace.</t>
        <t>A server implementation MUST support the following two default namespaces:</t>
        <t>
          <list style="symbols">
            <t>jabber:client -- this default namespace is declared when the stream is used for communication between a client and a server</t>
            <t>jabber:server -- this default namespace is declared when the stream is used for communication between two servers</t>
          </list>
        </t>
        <t>A client implementation MUST support the 'jabber:client' default namespace.</t>
        <t>If an implementation accepts a stream that is qualified by the 'jabber:client' or 'jabber:server' namespace, it MUST support the <xref target="stanzas-attributes">common attributes</xref> and <xref target="stanzas-semantics">basic semantics</xref> of all three core stanza types (message, presence, and IQ).</t>
        <t>For historical reasons, an implementation MAY refuse to support any other default namespaces.  If an entity receives a stream header with a default namespace it does not support, it MUST return an &lt;invalid-namespace/&gt; stream error.</t>
        <t>An implementation MUST NOT generate namespace prefixes for elements qualified by the default namespace if the default namespace is 'jabber:client' or 'jabber:server'.</t>
        <t><list style='empty'><t>Note: The 'jabber:client' and 'jabber:server' namespaces are nearly identical but are used in different contexts (client-to-server communication for 'jabber:client' and server-to-server communication for 'jabber:server').  The only difference between the two is that the 'to' and 'from' attributes are OPTIONAL on stanzas sent over XML streams qualified by the 'jabber:client' namespace, whereas they are REQUIRED on stanzas sent over XML streams qualified by the 'jabber:server' namespace.</t></list></t>
        <t>An implementation MAY support a default namespace other than "jabber:client" or "jabber:server".  However, because such namespaces would define applications other than XMPP, they are to be defined in separate specifications.</t>
      </section>
      <section title="Declaration of Other Namespaces" anchor="streams-ns-other">
        <t>Because an XML stanza is the primary unit of meaning in XMPP and because an XML stanza can be routed outside the context of the stream in which it originated, a stream header MUST NOT include namespace declarations for namespaces that are different from the streams namespace and the default namespace.</t>
      </section>
    </section>

    <section title="Stream Errors" anchor="streams-error">
      <t>The root stream element MAY contain an &lt;error/&gt; child element that is prefixed by the streams namespace prefix.  The error child SHALL be sent by a compliant entity if it perceives that a stream-level error has occurred.</t>
      <section title="Rules" anchor="streams-error-rules">
        <t>The following rules apply to stream-level errors.</t>
        <section title="Stream Errors Are Unrecoverable" anchor="streams-error-rules-unrecoverable">
          <t>Stream-level errors are unrecoverable.  Therefore, if an error occurs at the level of the stream, the entity that detects the error MUST send a &lt;error/&gt; element with an appropriate child element that specifies the error condition and at the same time send a closing &lt;/stream&gt; tag.</t>
          <figure>
            <artwork><![CDATA[
C: <message><body></message>

S: <stream:error>
     <xml-not-well-formed 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
          <t>The entity that generates the stream error then SHOULD immediately terminate the underlying TCP connection, although it MAY wait until after it receives a closing &lt;/stream&gt; tag from the entity to which it sent the stream error.</t>
          <figure>
            <artwork><![CDATA[
C: </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="Stream Errors Can Occur During Setup" anchor="streams-error-rules-setup">
          <t>If the error is triggered by the initial stream header, the receiving entity MUST still send the opening &lt;stream&gt; tag, include the &lt;error/&gt; element as a child of the stream element, and send the closing &lt;/stream&gt; tag (preferably all at the same time).</t>
          <figure>
            <artwork><![CDATA[
C: <?xml version='1.0'?>
   <stream:stream
       from='juliet@im.example.com'
       to='im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://wrong.namespace.example.org/'>

S: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>
   <stream:error>
     <invalid-namespace 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="Stream Errors When the Host is Unspecified or Unknown" anchor="streams-error-rules-host">
          <t>If the initiating entity provides no 'to' attribute or provides an unknown host in the 'to' attribute and the error occurs during stream setup, the receiving entity SHOULD provide an authoritative hostname in the 'from' attribute of the stream header sent before termination, but absent such an authoritative hostname MAY instead simply populate the response stream's 'from' attribute with the value of the initial stream header's 'to' attribute (where the value of the 'from' attribute MAY be empty if the initiating entity provided no 'to' attribute).</t>
          <figure>
            <artwork><![CDATA[
C: <?xml version='1.0'?>
   <stream:stream
       from='juliet@im.example.com'
       to='unknown.host.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>

S: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>
   <stream:error>
     <host-unknown
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="Where Stream Errors Are Sent" anchor="streams-error-rules-where">
          <t>When two XML streams are used between the initiating entity and the receiving entity (one in each direction) rather than using a single bidirectional stream, stanza errors triggered by stanzas sent over the outbound stream are returned on the inbound stream (since they are inbound stanzas from the perspective of the entity that sent the triggering stanza), whereas stream errors related to the outbound stream are returned on the outbound stream (since they are not inbound stanzas from the perspective of the entity that sent the triggering stanza but strictly related to the outbound stream itself); the same is true, naturally, of any stream errors that are related to the outbound stream but not triggered by an outbound stanza.</t>
        </section>
      </section>
      <section title="Syntax" anchor="streams-error-syntax">
        <t>The syntax for stream errors is as follows, where "defined-condition" is a placeholder for one of the conditions defined under <xref target='streams-error-conditions'/>.</t>
        <figure>
          <artwork><![CDATA[
<stream:error>
  <defined-condition xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
  [<text xmlns='urn:ietf:params:xml:ns:xmpp-streams'
        xml:lang='langcode'>
    [ ... descriptive text ... ]
  </text>]
  [application-specific condition element]
</stream:error>
          ]]></artwork>
        </figure>
        <t>The &lt;error/&gt; element:</t>
        <t><list style="symbols">
          <t>MUST contain a child element corresponding to one of the <xref target='streams-error-conditions'>defined stream error conditions</xref>; this element MUST be qualified by the 'urn:ietf:params:xml:ns:xmpp-streams' namespace.</t>
          <t>MAY contain a &lt;text/&gt; child element containing XML character data that describes the error in more detail; this element MUST be qualified by the 'urn:ietf:params:xml:ns:xmpp-streams' namespace and SHOULD possess an 'xml:lang' attribute specifying the natural language of the XML character data.</t>
          <t>MAY contain a child element for an application-specific error condition; this element MUST be qualified by an application-defined namespace, and its structure is defined by that namespace (see <xref target='streams-error-app'/>).</t>
        </list></t>
        <t>The &lt;text/&gt; element is OPTIONAL.  If included, it MUST be used only to provide descriptive or diagnostic information that supplements the meaning of a defined condition or application-specific condition.  It MUST NOT be interpreted programmatically by an application.  It MUST NOT be used as the error message presented to a human user, but MAY be shown in addition to the error message associated with the defined condition element (and, optionally, the application-specific condition element).</t>
      </section>
      <section title="Defined Stream Error Conditions" anchor="streams-error-conditions">
        <t>The following stream-level error conditions are defined.</t>
        <section title="bad-format" anchor="streams-error-conditions-bad-format">
          <t>The entity has sent XML that cannot be processed.</t>
          <t>(In the following example, the client sends an XMPP message that is not well-formed XML.)</t>
          <figure>
            <artwork><![CDATA[
C: <message>
     <body>No closing body tag!
   </message>

S: <stream:error>
     <bad-format 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
          <t>This error MAY be used instead of the more specific XML-related errors, such as &lt;bad-namespace-prefix/&gt;, &lt;invalid-xml/&gt;, &lt;restricted-xml/&gt;, &lt;unsupported-encoding/&gt;, and &lt;xml-not-well-formed/&gt;.  However, the more specific errors are RECOMMENDED.</t>
        </section>
        <section title="bad-namespace-prefix" anchor="streams-error-conditions-bad-namespace-prefix">
          <t>The entity has sent a namespace prefix that is unsupported, or has sent no namespace prefix on an element that needs such a prefix (see <xref target="xml-ns"/>).</t>
          <t>(In the following example, the client specifies a namespace prefix of "foobar" for the XML streams namespace.)</t>
          <figure>
            <artwork><![CDATA[
C: <?xml version='1.0'?>
   <stream:stream
       from='juliet@im.example.com'
       to='im.example.com'
       version='1.0'
       xmlns='jabber:client'
       xmlns:foobar='http://etherx.jabber.org/streams'>

S: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>
   <stream:error>
     <bad-namespace-prefix 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="conflict" anchor="streams-error-conditions-conflict">
          <t>The server is either (1) closing the existing stream for this entity because a new stream has been initiated that conflicts with the existing stream, or (2) is refusing a new stream for this entity because allowing the new stream would conflict with an existing stream (e.g., because the server allows only a certain number of connections from the same IP address).</t>
          <figure>
            <artwork><![CDATA[
C: <?xml version='1.0'?>
   <stream:stream
       from='juliet@im.example.com'
       to='im.example.com'
       version='1.0'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>

S: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>
   <stream:error>
     <conflict 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="connection-timeout" anchor="streams-error-conditions-connection-timeout">
          <t>The entity has not generated any traffic over the stream for some period of time (configurable according to a local service policy) and therefore the connection is being dropped.</t>
          <figure>
            <artwork><![CDATA[
P: <stream:error>
     <connection-timeout 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="host-gone" anchor="streams-error-conditions-host-gone">
          <t>The value of the 'to' attribute provided in the initial stream header corresponds to a hostname that is no longer serviced by the receiving entity.</t>
          <t>(In the following example, the peer specifies a 'to' address of "foo.im.example.com" when connecting to the "im.example.com" server, but the server no longer hosts a service at that address.)</t>
          <figure>
            <artwork><![CDATA[
P: <?xml version='1.0'?>
   <stream:stream
       from='example.net'
       to='foo.im.example.com'
       version='1.0'
       xmlns='jabber:server'
       xmlns:stream='http://etherx.jabber.org/streams'>

S: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='g4qSvGvBxJ+xeAd7QKezOQJFFlw='
       to='example.net'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:server'
       xmlns:stream='http://etherx.jabber.org/streams'>
   <stream:error>
     <host-gone 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="host-unknown" anchor="streams-error-conditions-host-unknown">
          <t>The value of the 'to' attribute provided in the initial stream header does not correspond to a hostname that is serviced by the receiving entity.</t>
          <t>(In the following example, the peer specifies a 'to' address of "example.org" when connecting to the "im.example.com" server, but the server knows nothing of that address.)</t>
          <figure>
            <artwork><![CDATA[
P: <?xml version='1.0'?>
   <stream:stream
       from='example.net'
       to='example.org'
       version='1.0'
       xmlns='jabber:server'
       xmlns:stream='http://etherx.jabber.org/streams'>

S: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='g4qSvGvBxJ+xeAd7QKezOQJFFlw='
       to='example.net'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:server'
       xmlns:stream='http://etherx.jabber.org/streams'>
   <stream:error>
     <host-unknown 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="improper-addressing" anchor="streams-error-conditions-improper-addressing">
          <t>A stanza sent between two servers lacks a 'to' or 'from' attribute, the 'from' or 'to' attribute has no value, or the value is not a valid XMPP address.</t>
          <t>(In the following example, the peer sends a stanza without a 'to' address.)</t>
          <figure>
            <artwork><![CDATA[
P: <message from='juliet@im.example.com'>
     <body>Wherefore art thou?</body>
   </message>

S: <stream:error>
     <improper-addressing 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="internal-server-error" anchor="streams-error-conditions-internal-server-error">
          <t>The server has experienced a misconfiguration or an otherwise-undefined internal error that prevents it from servicing the stream.</t>
          <figure>
            <artwork><![CDATA[
S: <stream:error>
     <internal-server-error 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="invalid-from" anchor="streams-error-conditions-invalid-from">
          <t>The JID or hostname provided in a 'from' address is not a valid JID or does not match an authorized JID or validated domain as negotiated between servers via SASL or server dialback, or as negotiated between a client and a server via authentication and resource binding.</t>
          <t>(In the following example, a peer that has authenticated only as "example.net" attempts to send a stanza from an address at "example.org".)</t> 
          <figure>
            <artwork><![CDATA[
P: <message from='romeo@example.org' to='juliet@im.example.com'>
     <body>Neither, fair saint, if either thee dislike.</body>
   </message>

S: <stream:error>
     <invalid-from 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="invalid-id" anchor="streams-error-conditions-invalid-id">
          <t>The stream ID or server dialback ID is invalid or does not match an ID previously provided.</t>
          <t>(In the following example, the server dialback ID is invalid; see <xref target='XEP-0220'/>.)</t>
          <figure>
            <artwork><![CDATA[
P: <db:verify
       from='example.net'
       to='im.example.com'
       id='unknown-id'
       type='invalid'/>

S: <stream:error>
     <invalid-id 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="invalid-namespace" anchor="streams-error-conditions-invalid-namespace">
          <t>The streams namespace name is something other than "http://etherx.jabber.org/streams" (see <xref target="xml-ns"/>) or the default namespace is not supported (e.g., something other than "jabber:client" or "jabber:server").</t>
          <t>(In the following example, the client specifies a namespace of 'http://wrong.namespace.example.org/' for the stream.)</t>
          <figure>
            <artwork><![CDATA[
C: <?xml version='1.0'?>
   <stream:stream
       from='juliet@im.example.com'
       to='im.example.com'
       version='1.0'
       xmlns='jabber:client'
       xmlns:stream='http://wrong.namespace.example.org/'>

S: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>
   <stream:error>
     <invalid-namespace 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="invalid-xml" anchor="streams-error-conditions-invalid-xml">
          <t>The entity has sent invalid XML over the stream to a server that performs validation (see <xref target="xml-validation"/>).</t>
          <t>(In the following example, the peer attempts to send an IQ stanza of type "subscribe" but the XML schema defines no such value for the 'type' attribute.)</t>
          <figure>
            <artwork><![CDATA[
P: <iq from='example.net' 
       id='some-id'
       to='im.example.com'
       type='subscribe'>
     <ping xmlns='urn:xmpp:ping'/>
   </iq>

S: <stream:error>
     <invalid-xml 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="not-authorized" anchor="streams-error-conditions-not-authorized">
          <t>The entity has attempted to send XML stanzas before the stream has been authenticated, or otherwise is not authorized to perform an action related to stream negotiation; the receiving entity MUST NOT process the offending stanza before sending the stream error.</t>
          <t>(In the following example, the client attempts to send XML stanzas before authenticating with the server.)</t>
          <figure>
            <artwork><![CDATA[
C: <?xml version='1.0'?>
   <stream:stream
       from='juliet@im.example.com'
       to='im.example.com'
       version='1.0'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>

S: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'

C: <message to='romeo@example.net'>
     <body>Wherefore art thou?</body>
   </message>

S: <stream:error>
     <not-authorized 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="policy-violation" anchor="streams-error-conditions-policy-violation">
          <t>The entity has violated some local service policy (e.g., the stanza exceeds a configured size limit); the server MAY choose to specify the policy in the &lt;text/&gt; element or in an application-specific condition element.</t>
          <t>(In the following example, the client sends an XMPP message that is too large according to the server's local service policy.)</t>
          <figure>
            <artwork><![CDATA[
C: <message to='juliet@im.example.com' id='foo'>
     <body>[ ... the-emacs-manual ... ]</body>
   </message>

S: <stream:error>
     <policy-violation 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>

S: </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="remote-connection-failed" anchor="streams-error-conditions-remote-connection-failed">
          <t>The server is unable to properly connect to a remote entity that is needed for authentication or authorization, such as a remote authentication database or (in server dialback) the authoritative server.</t>
          <figure>
            <artwork><![CDATA[
C: <?xml version='1.0'?>
   <stream:stream
       from='juliet@im.example.com'
       to='im.example.com'
       version='1.0'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>

S: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>
   <stream:error>
     <remote-connection-failed 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="reset" anchor="streams-error-conditions-reset">
          <t>The server is closing the stream because it has new (typically security-critical) features to offer or needs to reset the stream for some other reason (e.g., because the certificates used to establish a secure context for the stream have expired or have been revoked during the life of the stream).</t>
          <figure>
            <artwork><![CDATA[

S: <stream:error>
     <reset
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="resource-constraint" anchor="streams-error-conditions-resource-constraint">
          <t>The server lacks the system resources necessary to service the stream.</t>
          <figure>
            <artwork><![CDATA[
C: <?xml version='1.0'?>
   <stream:stream
       from='juliet@im.example.com'
       to='im.example.com'
       version='1.0'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>

S: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>
   <stream:error>
     <resource-constraint 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="restricted-xml" anchor="streams-error-conditions-restricted-xml">
          <t>The entity has attempted to send restricted XML features such as a comment, processing instruction, DTD subset, or XML entity reference (see <xref target="xml-restrictions"/>).</t>
          <t>(In the following example, the client sends an XMPP message containing an XML comment.)</t>
          <figure>
            <artwork><![CDATA[
C: <message to='juliet@im.example.com'>
     <!--<subject/>-->
     <body>This message has no subject.</body>
   </message>

S: <stream:error>
     <restricted-xml 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="see-other-host" anchor="streams-error-conditions-see-other-host">
          <t>The server will not provide service to the initiating entity but is redirecting traffic to another host; the XML character data of the &lt;see-other-host/&gt; element returned by the server SHOULD specify the alternate hostname or IP address at which to connect, which SHOULD be a valid domainpart but MAY also include a port number.  When it receives a see-other-host stream error, the initiating entity SHOULD cleanly handle the disconnection and then reconnect to the host specified in the &lt;see-other-host/&gt; element; if no port is specified, the initiating entity SHOULD perform a <xref target="DNS-SRV"/> lookup on the provided domainpart but MAY assume that it can connect to that domainpart at the standard XMPP ports (i.e., 5222 for client-to-server connections and 5269 for server-to-server connections).</t>
          <figure>
            <artwork><![CDATA[
C: <?xml version='1.0'?>
   <stream:stream
       from='juliet@im.example.com'
       to='im.example.com'
       version='1.0'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>

S: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>
   <stream:error>
     <see-other-host 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'>
       [2001:41D0:1:A49b::1]:9222
     </see-other-host>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="system-shutdown" anchor="streams-error-conditions-system-shutdown">
          <t>The server is being shut down and all active streams are being closed.</t>
          <figure>
            <artwork><![CDATA[
S: <stream:error>
     <system-shutdown 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="undefined-condition" anchor="streams-error-conditions-undefined-condition">
          <t>The error condition is not one of those defined by the other conditions in this list; this error condition SHOULD be used only in conjunction with an application-specific condition.</t>
          <figure>
            <artwork><![CDATA[
S: <stream:error>
     <undefined-condition 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
     <app-error xmlns='http://example.com/ns'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="unsupported-encoding" anchor="streams-error-conditions-unsupported-encoding">
          <t>The initiating entity has encoded the stream in an encoding that is not supported by the server (see <xref target="xml-encoding"/>) or has otherwise improperly encoded the stream (e.g., by violating the rules of the <xref target='UTF-8'/> encoding).</t>
          <t>(In the following example, the client attempts to encode data using UTF-16 instead of UTF-8.)</t>
          <figure>
            <artwork><![CDATA[
C: <?xml version='1.0' encoding='UTF-16'?>
   <stream:stream
       from='juliet@im.example.com'
       to='im.example.com'
       version='1.0'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>

S: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'
   <stream:error>
     <unsupported-encoding 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="unsupported-feature" anchor="streams-error-conditions-unsupported-feature">
          <t>The receiving entity has advertised a mandatory stream feature that the initiating entity does not support, and has offered no other mandatory feature alongside the unsupported feature.</t>
          <t>(In the following example, the receiving entity requires negotiation of an example feature but the initiating entity does not support the feature.)</t>
          <figure>
            <artwork><![CDATA[
R: <stream:features>
     <example xmlns='urn:xmpp:example'/>
   </stream:features>

I: <stream:error>
     <unsupported-feature 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="unsupported-stanza-type" anchor="streams-error-conditions-unsupported-stanza-type">
          <t>The initiating entity has sent a first-level child of the stream that is not supported by the server or consistent with the default namespace.</t>
          <t>(In the following example, the client attempts to send an XML stanza of &lt;pubsub/&gt; when the default namespace is "jabber:client".)</t>
          <figure>
            <artwork><![CDATA[
C: <pubsub>
     <publish node='princely_musings'>
       <item id='ae890ac52d0df67ed7cfdf51b644e901'>
         <entry xmlns='http://www.w3.org/2005/Atom'>
           <title>Soliloquy</title>
           <summary>
To be, or not to be: that is the question:
Whether 'tis nobler in the mind to suffer
The slings and arrows of outrageous fortune,
Or to take arms against a sea of troubles,
And by opposing end them?
           </summary>
           <link rel='alternate' type='text/html'
                 href='http://denmark.example/2003/12/13/atom03'/>
           <id>tag:denmark.example,2003:entry-32397</id>
           <published>2003-12-13T18:30:02Z</published>
           <updated>2003-12-13T18:30:02Z</updated>
         </entry>
       </item>
     </publish>
   </pubsub>

S: <stream:error>
     <unsupported-stanza-type 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="unsupported-version" anchor="streams-error-conditions-unsupported-version">
          <t>The value of the 'version' attribute provided by the initiating entity in the stream header specifies a version of XMPP that is not supported by the server; the server MAY specify the version(s) it supports in the &lt;text/&gt; element.</t>
          <t>(In the following example, the client specifies an XMPP version of "11.0" but the server supports only version "1.0" and "1.1".)</t>
          <figure>
            <artwork><![CDATA[
C: <?xml version='1.0'?>
   <stream:stream
       from='juliet@im.example.com'
       to='im.example.com'
       version='11.0'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>

S: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'
   <stream:error>
     <unsupported-version 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
     <text xmlns='urn:ietf:params:xml:ns:xmpp-streams'>
       1.0, 1.1
     </text>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
        <section title="xml-not-well-formed" anchor="streams-error-conditions-xml-not-well-formed">
          <t>The initiating entity has sent XML that violates the well-formedness rules of <xref target="XML"/> or <xref target='XML-NAMES'/>.</t>
          <t>(In the following example, the client sends an XMPP message that is not well-formed XML.)</t>
          <figure>
            <artwork><![CDATA[
C: <message>
     <body>No closing body tag!
   </message>

S: <stream:error>
     <xml-not-well-formed 
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>
            ]]></artwork>
          </figure>
        </section>
      </section>
      <section title="Application-Specific Conditions" anchor="streams-error-app">
        <t>As noted, an application MAY provide application-specific stream error information by including a properly-namespaced child in the error element.  The application-specific element SHOULD supplement or further qualify a defined element.  Thus the &lt;error/&gt; element will contain two or three child elements.</t>
        <figure>
          <artwork><![CDATA[
C: <message>
     <body>
       My keyboard layout is:

       QWERTYUIOP{}|
       ASDFGHJKL:"
       ZXCVBNM<>?
     </body>
   </message>

S: <stream:error>
     <xml-not-well-formed
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
     <text xml:lang='en' xmlns='urn:ietf:params:xml:ns:xmpp-streams'>
       Some special application diagnostic information!
     </text>
     <escape-your-data xmlns='http://example.com/ns'/>
   </stream:error>
   </stream:stream>
          ]]></artwork>
        </figure>
      </section>
    </section>

    <section title="Simplified Stream Examples" anchor="streams-example">
      <t>This section contains two simplified examples of a stream-based connection between a client and a server; these examples are included for the purpose of illustrating the concepts introduced thus far.</t>
      <figure>
        <preamble>A basic connection:</preamble>
        <artwork><![CDATA[
C: <?xml version='1.0'?>
   <stream:stream
       from='juliet@im.example.com'
       to='im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>

S: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>

[ ... channel encryption ... ]

[ ... authentication ... ]

[ ... resource binding ... ]

C:   <message from='juliet@im.example.com/balcony'
              to='romeo@example.net'
              xml:lang='en'>
       <body>Art thou not Romeo, and a Montague?</body>
     </message>

S:   <message from='romeo@example.net/orchard'
              to='juliet@im.example.com/balcony'
              xml:lang='en'>
       <body>Neither, fair saint, if either thee dislike.</body>
     </message>

C: </stream:stream>

S: </stream:stream>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>A connection gone bad:</preamble>
        <artwork><![CDATA[
C: <?xml version='1.0'?>
   <stream:stream
       from='juliet@im.example.com'
       to='im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>

S: <?xml version='1.0'?>
   <stream:stream
       from='im.example.com'
       id='++TR84Sm6A3hnt3Q065SnAbbk3Y='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>

[ ... channel encryption ... ]

[ ... authentication ... ]

[ ... resource binding ... ]


C:   <message from='juliet@im.example.com/balcony'
              to='romeo@example.net'
              xml:lang='en'>
       <body>No closing body tag!
     </message>

S: <stream:error>
    <xml-not-well-formed
        xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
   </stream:stream>

        ]]></artwork>
      </figure>
      <t>More detailed examples are provided under <xref target="examples"/>.</t>
    </section>
  </section>

  <section title="STARTTLS Negotiation" anchor="tls">
    <section title="Overview" anchor="tls-overview">
      <t>XMPP includes a method for securing the stream from tampering and eavesdropping.  This channel encryption method makes use of the Transport Layer Security <xref target="TLS"/> protocol, specifically a "STARTTLS" extension that is modelled after similar extensions for the <xref target="IMAP"/>, <xref target="POP3"/>, and <xref target="ACAP"/> protocols as described in <xref target="USINGTLS"/>.  The XML namespace name for the STARTTLS extension is 'urn:ietf:params:xml:ns:xmpp-tls'.</t>
      <t>Support for STARTTLS is REQUIRED in XMPP client and server implementations.  An administrator of a given deployment MAY necessitate the use of TLS for client-to-server communication, server-to-server communication, or both.  A deployed client SHOULD use TLS to secure its stream with a server prior to attempting the completion of <xref target='sasl'>SASL negotiation</xref>, and deployed servers SHOULD use TLS between two domains for the purpose of securing server-to-server communication.</t>
    </section>
    <section title="Stream Negotiation Rules" anchor="tls-rules">
      <section title="Mandatory-to-Negotiate" anchor="tls-rules-mtn">
        <t>If the receiving entity advertises only the STARTTLS feature or if the receiving entity includes the &lt;required/&gt; child element, the parties MUST consider TLS as mandatory-to-negotiate.  If TLS is mandatory-to-negotiate, the receiving entity SHOULD NOT advertise support for any stream feature except STARTTLS during the initial stage of the stream negotiation process, because further stream features might depend on prior negotiation of TLS given the order of layers in XMPP (e.g., the particular SASL mechanisms offered by the receiving entity will likely depend on whether TLS has been negotiated).</t>
      </section>
      <section title="Restart" anchor="tls-rules-restart">
        <t>After TLS negotiation, the parties MUST restart the stream.</t>
      </section>
      <section title="Data Formatting" anchor="tls-rules-data">
        <t>During STARTTLS negotiation, the entities MUST NOT send any whitespace as separators between XML elements (i.e., from the last character of the &lt;starttls/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-tls' namespace at depth=1 of the stream as sent by the initiating entity until the last character of the &lt;proceed/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-tls' namespace at depth=1 of the stream as sent by the receiving entity).  This prohibition helps to ensure proper security layer byte precision.  Any such whitespace shown in the STARTTLS examples provided in this document is included only for the sake of readability.</t>
      </section>
      <section title="Order of Negotiation" anchor="tls-rules-order">
        <t>If the initiating entity chooses to use TLS, STARTTLS negotiation MUST be completed before proceeding to <xref target='sasl'>SASL negotiation</xref>; this order of negotiation is necessary to help safeguard authentication information sent during SASL negotiation, as well as to make it possible to base the use of the SASL EXTERNAL mechanism on a certificate (or other credentials) provided during prior TLS negotiation.</t>
      </section>
    </section>
    <section title="Process" anchor="tls-process">
      <section title="Exchange of Stream Headers and Stream Features" anchor="tls-process-stream">
        <t>The initiating entity resolves the hostname of the receiving entity as specified under <xref target='tcp'/>, opens a TCP connection to the advertised port at the resolved IP address, and sends an initial stream header to the receiving entity; if the initiating entity is capable of STARTTLS negotiation, it MUST include the 'version' attribute set to a value of at least "1.0" in the initial stream header.</t>
        <figure>
          <artwork><![CDATA[
I: <stream:stream
     from='juliet@im.example.com'
     to='im.example.com'
     version='1.0'
     xml:lang='en'
     xmlns='jabber:client'
     xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <t>The receiving entity MUST send a response stream header to the initiating entity over the TCP connection opened by the initiating entity; if the receiving entity is capable of STARTTLS negotiation, it MUST include the 'version' attribute set to a value of at least "1.0" in the response stream header.</t>
        <figure>
          <artwork><![CDATA[
R: <stream:stream
     from='im.example.com'
     id='t7AMCin9zjMNwQKDnplntZPIDEI='
     to='juliet@im.example.com'
     version='1.0'
     xml:lang='en'
     xmlns='jabber:client'
     xmlns:stream='http://etherx.jabber.org/streams'
          ]]></artwork>
        </figure>
        <t>The receiving entity then MUST send stream features to the initiating entity.  If the receiving entity supports TLS, the stream features MUST include an advertisement for support of STARTTLS negotiation, i.e., a &lt;starttls/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-tls' namespace.</t>
        <t>If the receiving entity considers STARTTLS negotiation to be mandatory, the &lt;starttls/&gt; element SHOULD contain an empty &lt;required/&gt; child element.</t>
        <figure>
          <artwork><![CDATA[
R: <stream:features>
     <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'>
       <required/>
     </starttls>
   </stream:features>
          ]]></artwork>
        </figure>
      </section>
      <section title="Initiation of STARTTLS Negotiation" anchor="tls-process-initiate">
        <section title="STARTTLS Command" anchor="tls-process-initiate-command">
          <t>In order to begin the STARTTLS negotiation, the initiating entity issues the STARTTLS command (i.e., a &lt;starttls/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-tls' namespace) to instruct the receiving entity that it wishes to begin a STARTTLS negotiation to secure the stream.</t>
          <figure>
            <artwork><![CDATA[
I: <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>
            ]]></artwork>
          </figure>
          <t>The receiving entity MUST reply with either a &lt;proceed/&gt; element (proceed case) or a &lt;failure/&gt; element (failure case) qualified by the 'urn:ietf:params:xml:ns:xmpp-tls' namespace.</t>
        </section>
        <section title="Failure Case" anchor="tls-process-initiate-failure">
          <t>If the failure case occurs, the receiving entity MUST return a &lt;failure/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-tls' namespace, terminate the XML stream, and terminate the underlying TCP connection.</t>
          <figure>
            <artwork><![CDATA[
R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>

R: </stream:stream>
            ]]></artwork>
          </figure>
          <t>Causes for the failure case include but are not limited to:</t>
          <t>
            <list style='numbers'>
              <t>The initiating entity has sent a malformed STARTTLS command.</t>
              <t>The receiving entity does not offer STARTTLS negotiation either temporarily (e.g., at this stage in the stream negotiation process) or permanently (i.e., the feature is not supported).</t>
              <t>The receiving entity cannot complete STARTTLS negotiation because of an internal error.</t>
            </list>
          </t>
          <t><list style='empty'><t>Note: STARTTLS failure is not triggered by TLS errors such as bad certificate or unknown certificate authority; those errors are generated and handled during the TLS negotiation itself as described in <xref target='TLS'/>.</t></list></t>
          <t>If the failure case occurs, the initiating entity MAY attempt to reconnect as explained under <xref target='tcp-reconnect'/>.</t>
        </section>
        <section title="Proceed Case" anchor="tls-process-initiate-proceed">
          <t>If the proceed case occurs, the receiving entity MUST return a &lt;proceed/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-tls' namespace.</t>
          <figure>
            <artwork><![CDATA[
R: <proceed xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>
            ]]></artwork>
          </figure>
          <t>The receiving entity MUST consider the TLS negotiation to have begun immediately after sending the closing '&gt;' character of the &lt;proceed/&gt; element to the initiating entity.  The initiating entity MUST consider the TLS negotiation to have begun immediately after receiving the closing '&gt;' character of the &lt;proceed/&gt; element from the receiving entity.</t>
          <t>The entities now proceed to TLS negotiation as explained in the next section.</t>
        </section>
      </section>
      <section title="TLS Negotiation" anchor="tls-process-neg">
        <section title="Rules" anchor="tls-process-neg-rules">
          <t>In order to complete TLS negotiation over the TCP connection, the entities MUST follow the process defined in <xref target='TLS'/>.</t>
          <t>The following rules apply:</t>
          <t>
            <list style='numbers'>
              <t>The entities MUST NOT send any further XML data until the TLS negotiation has either failed or succeeded.</t>
              <t>The receiving entity MUST present a certificate.</t>
              <t>The receiving entity SHOULD send a certificate request to the initiating entity so that mutual authentication will be possible.</t>
              <t>The initiating entity MUST validate the certificate to determine if the TLS negotiation will succeed; see <xref target="security-certificates-validation"/> regarding certificate validation procedures.</t>
              <t>The receiving entity SHOULD choose which certificate to present based on the 'to' attribute of the initial stream header.</t>
            </list>
          </t>
          <t><list style='empty'><t>Note: See <xref target="security-mandatory"/> regarding ciphers that MUST be supported for TLS; naturally, other ciphers MAY be supported as well.</t></list></t>
        </section>
        <section title="TLS Failure" anchor="tls-process-neg-failure">
          <t>If the TLS negotiation results in failure, the receiving entity MUST terminate the TCP connection.</t>
          <t>The receiving entity MUST NOT send a closing &lt;/stream&gt; tag before terminating the TCP connection, since the receiving entity and initiating entity MUST consider the original stream to be replaced upon failure of the TLS negotiation.</t>
          <t>If the failure case occurs and TLS negotation was voluntary (advertised by means of the &lt;optional/&gt; child element) instead of mandatory (advertised by means of the &lt;required/&gt; child element), the initiating entity SHOULD attempt to reconnect as explained under <xref target='tcp-reconnect'/> but without attempting TLS negotiation.</t>
        </section>
        <section title="TLS Success" anchor="tls-process-neg-success">
          <t>If the TLS negotiation is successful, then the entities MUST proceed as follows.</t>
          <t>
            <list style='numbers'>
              <t>The initiating entity MUST discard any information transmitted in layers above TCP that it obtained from the receiving entity in an insecure manner before TLS took effect (e.g., the receiving entity's from address or the stream ID and stream features received from the receiving entity).</t>
              <t>The receiving entity MUST discard any information transmitted in layers above TCP that it obtained from the initiating entity in an insecure manner TLS took effect (e.g., the initiating entity's from address).</t>
              <t>The initiating entity MUST send a new initial stream header to the receiving entity over the encrypted connection.
                <figure>
                  <artwork><![CDATA[
I: <stream:stream
     from='juliet@im.example.com'
     to='im.example.com'
     version='1.0'
     xml:lang='en'
     xmlns='jabber:client'
     xmlns:stream='http://etherx.jabber.org/streams'>
                  ]]></artwork>
                  <postamble>Note: The initiating entity MUST NOT send a closing &lt;/stream&gt; tag before sending the new initial stream header, since the receiving entity and initiating entity MUST consider the original stream to be replaced upon success of the TLS negotiation.</postamble>
                </figure>
              </t>
              <t>The receiving entity MUST respond with a new response stream header over the encrypted connection.
                <figure>
                  <artwork><![CDATA[
R: <stream:stream
     from='im.example.com'
     id='vgKi/bkYME8OAj4rlXMkpucAqe4='
     to='juliet@im.example.com'
     version='1.0'
     xml:lang='en'
     xmlns='jabber:client'
     xmlns:stream='http://etherx.jabber.org/streams'
                  ]]></artwork>
                </figure>
              </t>
              <t>The receiving entity also MUST send stream features to the initiating entity, which MUST NOT include the STARTTLS feature but which SHOULD include the SASL stream feature as described under <xref target='sasl'/>.
                <figure>
                  <artwork><![CDATA[
R: <stream:features>
     <mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
       <mechanism>EXTERNAL</mechanism>
       <mechanism>PLAIN</mechanism>
     </mechanisms>
   </stream:features>
                  ]]></artwork>
                </figure>
              </t>
            </list>
          </t>
        </section>
      </section>
    </section>
  </section>

  <section title="SASL Negotiation" anchor="sasl">
    <section title="Overview" anchor="sasl-overview">
      <t>XMPP includes a method for authenticating a stream by means of an XMPP-specific profile of the Simple Authentication and Security Layer protocol (see <xref target="SASL"/>).  SASL provides a generalized method for adding authentication support to connection-based protocols, and XMPP uses an XML namespace profile of SASL that conforms to the profiling requirements of <xref target="SASL"/>.</t>
      <t>Support for SASL negotiation is REQUIRED in XMPP client and server implementations.</t>
    </section>
    <section title="Stream Negotiation Rules" anchor="sasl-rules">
      <section title="Mandatory-to-Negotiate" anchor="sasl-rules-mtn">
        <t>The parties to a stream MUST consider SASL as mandatory-to-negotiate.</t>
      </section>
      <section title="Restart" anchor="sasl-rules-restart">
        <t>After SASL negotiation, the parties MUST restart the stream.</t>
      </section>
      <section title="Mechanism Preferences" anchor="sasl-rules-preferences">
        <t>Any entity that will act as a SASL client or a SASL server MUST maintain an ordered list of its preferred SASL mechanisms according to the client or server, where the list is ordered by the perceived strength of the mechanisms.  A server MUST offer and a client MUST try SASL mechanisms in the order of their perceived strength.  For example, if the server offers the ordered list "PLAIN DIGEST-MD5 GSSAPI" or "DIGEST-MD5 GSSAPI PLAIN" but the client's ordered list is "GSSAPI DIGEST-MD5", the client MUST try GSSAPI first and then DIGEST-MD5 but MUST never try PLAIN (since PLAIN is not on its list).</t>
      </section>
      <section title="Mechanism Offers" anchor="sasl-rules-offers">
        <t>If the receiving entity considers <xref target='tls'>TLS negotiation</xref> to be mandatory before use of a particular SASL authentication mechanism will be acceptable, the receiving entity MUST NOT advertise that mechanism in its list of available SASL authentication mechanisms prior to successful TLS negotiation.</t>
        <t>If during prior TLS negotiation the initiating entity presented a certificate that is acceptable to the receiving entity for purposes of strong identity verification in accordance with local service policies, the receiving entity MUST offer the SASL EXTERNAL mechanism to the initiating entity during SASL negotiation (refer to <xref target="SASL"/>) and SHOULD prefer that mechanism to enable mutual authentication.  However, the EXTERNAL mechanism MAY be offered under other circumstances as well.</t>
        <t>See <xref target="security-mandatory"/> regarding mechanisms that MUST be supported; naturally, other SASL mechanisms MAY be supported as well.  Best practices for the use of several SASL mechanisms in the context of XMPP are described in <xref target='XEP-0175'/> and <xref target='XEP-0178'/>.</t>
      </section>
      <section title="Data Formatting" anchor="sasl-rules-data">
        <t>The following data formattting rules apply to the SASL negotiation:</t>
        <t>
          <list style='numbers'>
            <t>During SASL negotiation, the entities MUST NOT send any whitespace as separators between XML elements (i.e., from the last character of the &lt;auth/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace at depth=1 of the stream as sent by the initiating entity until the last character of the &lt;success/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace at depth=1 of the stream as sent by the receiving entity).  This prohibition helps to ensure proper security layer byte precision.  Any such whitespace shown in the SASL examples provided in this document is included only for the sake of readability.</t>
            <t>Any XML character data contained within the XML elements MUST be encoded using base64, where the encoding adheres to the definition in Section 4 of <xref target="BASE64"/> and where the padding bits are set to zero.</t>
            <t>As formally specified in the XML schema for the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace under <xref target='schemas-sasl'/>, the receiving entity MAY include one or more application-specific child elements inside the &lt;mechanisms/&gt; element to provide information that might be needed by the initiating entity in order to complete successful SASL negotiation using one or more of the offered mechanisms; however, the syntax and semantics of all such elements are out of scope for this specification.</t>
          </list>
        </t>
      </section>
      <section title="Security Layers" anchor="sasl-rules-layers">
        <t>Upon successful SASL negotiation that involves negotiation of a security layer, both the initiating entity and the receiving MUST discard any application-layer state (i.e, state from the XMPP layer, excluding state from the TLS negotiation or SASL negotiation).</t>
      </section>
      <section title="Simple Username" anchor="sasl-rules-username">
        <t>Some SASL mechanisms have the concept of a "simple username" (e.g., CRAM-MD5, DIGEST-MD5, and SCRAM).  The exact form of the simple username in any particular mechanism is a local matter, and a simple username does not necessarily map to an application identifier such as a JID or a JID component.</t>
      </section>
      <section title="Authorization Identity" anchor="sasl-rules-authzid">
        <t>An authorization identity is an optional identity specified by the initiating entity, which is typically used by an administrator to perform some management task on behalf of another user.  If the initiating entity wishes to act on behalf of another entity and the selected SASL mechanism supports transmission of an authorization identity, the initiating entity MUST provide an authorization identity during SASL negotiation.  If the initiating entity does not wish to act on behalf of another entity, it MUST NOT provide an authorization identity.  As specified in <xref target="SASL"/>, the initiating entity MUST NOT provide an authorization identity unless the authorization identity is different from the default authorization identity derived from the authentication identity.  If provided, the value of the authorization identity MUST be a bare JID of the form &lt;domain&gt; (i.e., an XMPP domainpart only) for servers and a bare JID of the form &lt;localpart@domain&gt; (i.e., localpart and domainpart) for clients.</t>
        <t><list style='empty'><t>Note: The authorization identity communicated during SASL negotiation is used to determine the canonical address for the initiating client or server according to the receiving server, as described under <xref target='streams-negotiation-address'/>.</t></list></t>
      </section>
      <section title="Realms" anchor="sasl-rules-realms">
        <t>The receiving entity MAY include a realm when negotiating certain SASL mechanisms.  If the receiving entity does not communicate a realm, the initiating entity MUST NOT assume that any realm exists.  The realm MUST be used only for the purpose of authentication; in particular, an initiating entity MUST NOT attempt to derive an XMPP hostname from the realm information provided by the receiving entity.</t>
      </section>
      <section title="Round Trips" anchor="sasl-rules-roundtrips">
        <t><xref target='SASL'/> specifies that a using protocol such as XMPP can define two methods by which the protocol can save round trips where allowed for the SASL mechanism:</t>
        <t>
          <list style='numbers'>
            <t>When the SASL client (the XMPP "initiating entity") requests an authentication exchange, it can include "initial response" data with its request if appropriate for the SASL mechanism in use.  In XMPP this is done by including the initial response as the XML character data of the &lt;auth/&gt; element.</t>
            <t>At the end of the authentication exchange, the SASL server (the XMPP "receiving entity") can include "additional data with success" if appropriate for the SASL mechanism in use.  In XMPP this is done by including the additional data as the XML character data of the &lt;success/&gt; element.</t>
          </list>
        </t>
        <t>For the sake of protocol efficiency, it is RECOMMENDED for XMPP clients and servers to use these methods, however they MUST support the less efficient modes as well.</t>
      </section>
    </section>
    <section title="Process" anchor="sasl-process">
      <t>The process for SASL negotiation is as follows.</t>
      <section title="Exchange of Stream Headers and Stream Features" anchor="sasl-process-stream">
        <t>If SASL negotiation follows successful <xref target='tls'>STARTTLS negotation</xref>, then the SASL negotiation occurs over the encrypted stream that has already been negotiated.  If not, the initiating entity resolves the hostname of the receiving entity as specified under <xref target='tcp'/>, opens a TCP connection to the advertised port at the resolved IP address, and sends an initial stream header to the receiving entity; if the initiating entity is capable of STARTTLS negotiation, it MUST include the 'version' attribute set to a value of at least "1.0" in the initial stream header.</t>
        <figure>
          <artwork><![CDATA[
I: <stream:stream
     from='juliet@im.example.com'
     to='im.example.com'
     version='1.0'
     xml:lang='en'
     xmlns='jabber:client'
     xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <t>The receiving entity MUST send a response stream header to the initiating entity; if the receiving entity is capable of SASL negotiation, it MUST include the 'version' attribute set to a value of at least "1.0" in the response stream header.</t>
        <figure>
          <artwork><![CDATA[
R: <stream:stream
     from='im.example.com'
     id='vgKi/bkYME8OAj4rlXMkpucAqe4='
     to='juliet@im.example.com'
     version='1.0'
     xml:lang='en'
     xmlns='jabber:client'
     xmlns:stream='http://etherx.jabber.org/streams'
          ]]></artwork>
        </figure>
        <t>The receiving entity also MUST send stream features to the initiating entity.  If the receiving entity supports SASL, the stream features MUST include an advertisement for support of SASL negotiation, i.e., a &lt;mechanisms/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace.</t>
        <t>The &lt;mechanisms/&gt; element MUST contain one &lt;mechanism/&gt; child element for each authentication mechanism the receiving entity offers to the initiating entity.  The order of &lt;mechanism/&gt; elements in the XML indicates the preference order of the SASL mechanisms according to the receiving entity; however the initiating entity MUST maintain its own preference order independent of the preference order of the receiving entity.</t>
        <figure>
          <artwork><![CDATA[
R: <stream:features>
     <mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
       <mechanism>EXTERNAL</mechanism>
       <mechanism>PLAIN</mechanism>
     </mechanisms>
   </stream:features>
          ]]></artwork>
        </figure>
      </section>
      <section title="Initiation" anchor="sasl-process-neg-initiate">
        <t>In order to begin the SASL negotiation, the initiating entity sends an &lt;auth/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace and includes an appropriate value for the 'mechanism' attribute.  This element MAY contain XML character data (in SASL terminology, the "initial response") if the mechanism supports or requires it; if the initiating entity needs to send a zero-length initial response, it MUST transmit the response as a single equals sign character ("="), which indicates that the response is present but contains no data.</t>
        <figure>
          <artwork><![CDATA[
I: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
         mechanism='PLAIN'>AGp1bGlldAByMG0zMG15cjBtMzA=</auth>
          ]]></artwork>
        </figure>
      </section>
      <section title="Challenge-Response Sequence" anchor="sasl-process-neg-challengeresponse">
        <t>If necessary, the receiving entity challenges the initiating entity by sending a &lt;challenge/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace; this element MAY contain XML character data (which MUST be generated in accordance with the definition of the SASL mechanism chosen by the initiating entity).</t>
        <t>The initiating entity responds to the challenge by sending a &lt;response/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace; this element MAY contain XML character data (which MUST be generated in accordance with the definition of the SASL mechanism chosen by the initiating entity).</t>
        <t>If necessary, the receiving entity sends more challenges and the initiating entity sends more responses.</t>
        <t>This series of challenge/response pairs continues until one of three things happens:</t>
        <t>
          <list style="symbols">
            <t>The initiating entity aborts the handshake.</t>
            <t>The receiving entity reports failure of the handshake.</t>
            <t>The receiving entity reports success of the handshake.</t>
          </list>
        </t>
        <t>These scenarios are described in the following sections.</t>
      </section>
      <section title="Abort" anchor="sasl-process-neg-abort">
        <t>The initiating entity aborts the handshake by sending an &lt;abort/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace.</t>
        <figure>
          <artwork><![CDATA[
I: <abort xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>
          ]]></artwork>
        </figure>
        <t>Upon receiving an &lt;abort/&gt; element, the receiving entity MUST return a &lt;failure/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace and containing an &lt;aborted/&gt; child element.</t>
        <figure>
          <artwork><![CDATA[
R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>
     <aborted/>
   </failure>
          ]]></artwork>
        </figure>
      </section>
      <section title="Failure" anchor="sasl-process-neg-failure">
        <t>The receiving entity reports failure of the handshake by sending a &lt;failure/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace (the particular cause of failure MUST be communicated in an appropriate child element of the &lt;failure/&gt; element as defined under <xref target="sasl-errors"/>).</t>
        <figure>
          <artwork><![CDATA[
R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     <not-authorized/>
   </failure>
          ]]></artwork>
        </figure>
        <t>Where appropriate for the chosen SASL mechanism, the receiving entity SHOULD allow a configurable but reasonable number of retries (at least 2 and no more than 5); this enables the initiating entity (e.g., an end-user client) to tolerate incorrectly-provided credentials (e.g., a mistyped password) without being forced to reconnect.</t>
        <t>If the initiating entity attempts a reasonable number of retries with the same SASL mechanism and all attempts fail, it MAY fall back to the next mechanism in its ordered list by sending a new &lt;auth/&gt; request to the receiving entity.  If there are no remaining mechanisms in its list, the initiating entity SHOULD instead send an &lt;abort/&gt; element to the receiving entity.</t>
        <t>If the initiating entity exceeds the number of retries, the receiving entity MUST return a stream error (which SHOULD be &lt;policy-violation/&gt; but MAY be &lt;not-authorized/&gt;).</t>
      </section>
      <section title="Success" anchor="sasl-process-neg-success">
        <t>The receiving entity reports success of the handshake by sending a &lt;success/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace; this element MAY contain XML character data (in SASL terminology, "additional data with success") if the chosen SASL mechanism supports or requires it; if the receiving entity needs to send additional data of zero length, it MUST transmit the data as a single equals sign character ("=").</t>
        <figure>
          <artwork><![CDATA[
R: <success xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>
          ]]></artwork>
        </figure>
        <t><list style='empty'><t>Note: The authorization identity communited during SASL negotiation is used to determine the canonical address for the initiating client or server according to the receiving server, as described under <xref target='streams-negotiation-address'/>.</t></list></t>
        <t>Upon receiving the &lt;success/&gt; element, the initiating entity MUST initiate a new stream over the existing TCP connection by sending a new initial stream header to the receiving entity.</t>
        <figure>
          <artwork><![CDATA[
I: <stream:stream
     from='juliet@im.example.com'
     to='im.example.com'
     version='1.0'
     xml:lang='en'
     xmlns='jabber:client'
     xmlns:stream='http://etherx.jabber.org/streams'
          ]]></artwork>
        </figure>
        <t><list style='empty'><t>Note: The initiating entity MUST NOT send a closing &lt;/stream&gt; tag before sending the new initial stream header, since the receiving entity and initiating entity MUST consider the original stream to be replaced upon sending or receiving the &lt;success/&gt; element.</t></list></t>
        <t>Upon receiving the new initial stream header from the initiating entity, the receiving entity MUST respond by sending a new response XML stream header to the initiating entity.</t>
        <figure>
          <artwork><![CDATA[
R: <stream:stream
     from='im.example.com'
     id='gPybzaOzBmaADgxKXu9UClbprp0='
     to='juliet@im.example.com'
     version='1.0'
     xml:lang='en'
     xmlns='jabber:client'
     xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <t>The receiving entity MUST also send stream features, containing any further available features or containing no features (via an empty &lt;features/&gt; element).</t>
        <figure>
          <artwork><![CDATA[
R: <stream:features>
     <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>
   </stream:features>
          ]]></artwork>
        </figure>
      </section>
    </section>
    <section title="SASL Errors" anchor="sasl-errors">
      <t>The syntax of SASL errors is as follows:</t>
      <figure>
        <artwork><![CDATA[
<failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
  <defined-condition/>
  [<text xml:lang='langcode'>
      OPTIONAL descriptive text
  </text>]
</failure>
        ]]></artwork>
      </figure>
      <t>Where "defined-condition" is one of the SASL-related error conditions defined in the following sections.</t>
      <t>Inclusion of a defined condition is REQUIRED.</t>
      <t>Inclusion of the &lt;text/&gt; element is OPTIONAL, and can be used to provide application-specific information about the error condition, which information MAY be displayed to a human but only as a supplement to the defined condition.</t>
      <section title="aborted" anchor="sasl-errors-aborted">
        <t>The receiving entity acknowledges an &lt;abort/&gt; element sent by the initiating entity; sent in reply to the &lt;abort/&gt; element.</t>
        <figure>
          <artwork><![CDATA[
I: <abort xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>

R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     <aborted/>
   </failure>
          ]]></artwork>
        </figure>
      </section>
      <section title="account-disabled" anchor="sasl-errors-account-disabled">
        <t>The account of the initiating entity has been temporarily disabled; sent in reply to an &lt;auth/&gt; element (with or without initial response data) or a &lt;response/&gt; element.</t>
        <figure>
          <artwork><![CDATA[
I: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
         mechanism='PLAIN'>AGp1bGlldAByMG0zMG15cjBtMzA=</auth>

R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     <account-disabled/>
     <text xml:lang='en'>Call 212-555-1212 for assistance.</text>
   </failure>
          ]]></artwork>
        </figure>
      </section>
      <section title="credentials-expired" anchor="sasl-errors-credentials-expired">
        <t>The authentication failed because the initiating entity provided credentials that have expired; sent in reply to a &lt;response/&gt; element or an &lt;auth/&gt; element with initial response data.</t>
        <figure>
          <artwork><![CDATA[
I: <response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     [ ... ]
   </response>

R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     <credentials-expired/>
   </failure>
          ]]></artwork>
        </figure>
      </section>
      <section title="encryption-required" anchor="sasl-errors-encryption-required">
        <t>The mechanism requested by the initiating entity cannot be used unless the underlying stream is encrypted; sent in reply to an &lt;auth/&gt; element (with or without initial response data).</t>
        <figure>
          <artwork><![CDATA[
I: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
         mechanism='PLAIN'>AGp1bGlldAByMG0zMG15cjBtMzA=</auth>

R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     <encryption-required/>
   </failure>
          ]]></artwork>
        </figure>
      </section>
      <section title="incorrect-encoding" anchor="sasl-errors-incorrect-encoding">
        <t>The data provided by the initiating entity could not be processed because the <xref target="BASE64"/> encoding is incorrect (e.g., because the encoding does not adhere to the definition in Section 4 of <xref target="BASE64"/>); sent in reply to a &lt;response/&gt; element or an &lt;auth/&gt; element with initial response data.</t>
        <figure>
          <artwork><![CDATA[
I: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
         mechanism='DIGEST-MD5'>[ ... ]</auth>

R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     <incorrect-encoding/>
   </failure>
          ]]></artwork>
        </figure>
      </section>
      <section title="invalid-authzid" anchor="sasl-errors-invalid-authzid">
        <t>The authzid provided by the initiating entity is invalid, either because it is incorrectly formatted or because the initiating entity does not have permissions to authorize that ID; sent in reply to a &lt;response/&gt; element or an &lt;auth/&gt; element with initial response data.</t>
        <figure>
          <artwork><![CDATA[
I: <response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     [ ... ]
   </response>

R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     <invalid-authzid/>
   </failure>
          ]]></artwork>
        </figure>
      </section>
      <section title="invalid-mechanism" anchor="sasl-errors-invalid-mechanism">
        <t>The initiating entity did not provide a mechanism or requested a mechanism that is not supported by the receiving entity; sent in reply to an &lt;auth/&gt; element.</t>
        <figure>
          <artwork><![CDATA[
I: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
         mechanism='CRAM-MD5'/>

R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     <invalid-mechanism/>
   </failure>
          ]]></artwork>
        </figure>
      </section>
      <section title="malformed-request" anchor="sasl-errors-malformed-request">
        <t>The request is malformed (e.g., the &lt;auth/&gt; element includes initial response data but the mechanism does not allow that, or the data sent violates the syntax for the specified SASL mechanism); sent in reply to an &lt;abort/&gt;, &lt;auth/&gt;, &lt;challenge/&gt;, or &lt;response/&gt; element.</t>
        <t>(In the following example, the XML character data of the &lt;auth/&gt; element contains more than 255 UTF-8-encoded Unicode characters and therefore violates the "token" production for the SASL ANONYMOUS mechanism as specified in <xref target='ANONYMOUS'/>.)</t>
        <figure>
          <artwork><![CDATA[
I: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
         mechanism='ANONYMOUS'>[ ... some-long-token ... ]</auth>

R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     <malformed-request/>
   </failure>
          ]]></artwork>
        </figure>
      </section>
      <section title="mechanism-too-weak" anchor="sasl-errors-mechanism-too-weak">
        <t>The mechanism requested by the initiating entity is weaker than server policy permits for that initiating entity; sent in reply to an &lt;auth/&gt; element (with or without initial response data).</t>
        <figure>
          <artwork><![CDATA[
I: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
         mechanism='PLAIN'>AGp1bGlldAByMG0zMG15cjBtMzA=</auth>

R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     <mechanism-too-weak/>
   </failure>
          ]]></artwork>
        </figure>
      </section>
      <section title="not-authorized" anchor="sasl-errors-not-authorized">
        <t>The authentication failed because the initiating entity did not provide proper credentials or the receiving entity has detected an attack but wishes to disclose as little information as possible to the attacker; sent in reply to a &lt;response/&gt; element or an &lt;auth/&gt; element with initial response data.</t>
        <figure>
          <artwork><![CDATA[
I: <response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     [ ... ]
   </response>

R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     <not-authorized/>
   </failure>
          ]]></artwork>
        </figure>
        <t><list style='empty'><t>Note: This error condition includes but is not limited to the case of incorrect credentials or an unknown username.  In order to discourage directory harvest attacks, no differentiation is made between incorrect credentials and an unknown username.</t></list></t>
      </section>
      <section title="temporary-auth-failure" anchor="sasl-errors-temporary-auth-failure">
        <t>The authentication failed because of a temporary error condition within the receiving entity, and it is advisable for the initiating entity to try again later; sent in reply to an &lt;auth/&gt; element or a &lt;response/&gt; element.</t>
        <figure>
          <artwork><![CDATA[
I: <response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     [ ... ]
   </response>

R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     <temporary-auth-failure/>
   </failure>
          ]]></artwork>
        </figure>
      </section>
      <section title="transition-needed" anchor="sasl-errors-transition-needed">
        <t>The authentication failed because the mechanism cannot be used until the initiating entity provides (for one time only) a plaintext password so that the receiving entity can build a hashed password for use in future authentication attempts; sent in reply to an &lt;auth/&gt; element with or without initial response data.</t>
        <figure>
          <artwork><![CDATA[
I: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
         mechanism='CRAM-MD5'>[ ... ]</auth>

R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     <transition-needed/>
   </failure>
          ]]></artwork>
        </figure>
        <t><list style='empty'><t>Note: An XMPP client MUST treat a &lt;transition-needed/&gt; SASL error with extreme caution, SHOULD NOT provide a plaintext password over an XML stream that is not encrypted via Transport Layer Security, and MUST warn a human user before allowing the user to provide a plaintext password over an unencrypted connection.</t></list></t>
      </section>
    </section>
    <section title="SASL Definition" anchor="sasl-def">
      <t>The profiling requirements of <xref target="SASL"/> require that the following information be supplied by the definition of a using protocol.</t>
      <t><list style="hanging">
        <t hangText="service name:">"xmpp"</t>
        <t hangText="initiation sequence:">After the initiating entity provides an opening XML stream header and the receiving entity replies in kind, the receiving entity provides a list of acceptable authentication methods.  The initiating entity chooses one method from the list and sends it to the receiving entity as the value of the 'mechanism' attribute possessed by an &lt;auth/&gt; element, optionally including an initial response to avoid a round trip.</t>
        <t hangText="exchange sequence:">Challenges and responses are carried through the exchange of &lt;challenge/&gt; elements from receiving entity to initiating entity and &lt;response/&gt; elements from initiating entity to receiving entity.  The receiving entity reports failure by sending a &lt;failure/&gt; element and success by sending a &lt;success/&gt; element; the initiating entity aborts the exchange by sending an &lt;abort/&gt; element.  Upon successful negotiation, both sides consider the original XML stream to be closed and new stream headers are sent by both entities.</t>
        <t hangText="security layer negotiation:">The security layer takes effect immediately after sending the closing '&gt;' character of the &lt;success/&gt; element for the receiving entity, and immediately after receiving the closing '&gt;' character of the &lt;success/&gt; element for the initiating entity.  The order of layers is first <xref target="TCP"/>, then <xref target="TLS"/>, then <xref target="SASL"/>, then XMPP.</t>
        <t hangText="use of the authorization identity:">The authorization identity can be used in XMPP to denote the non-default &lt;localpart@domain&gt; of a client or the sending &lt;domain&gt; of a server; an empty string is equivalent to an absent authorization identity.</t>
      </list></t>
    </section>
  </section>

  <section title="Resource Binding" anchor="bind">
    <section title="Overview" anchor="bind-overview">
      <t>After a client authenticates with a server, it MUST bind a specific resource to the stream so that the server can properly address the client.  That is, there MUST be an XMPP resource associated with the bare JID (&lt;localpart@domain&gt;) of the client, so that the address for use over that stream is a full JID of the form &lt;localpart@domain/resource&gt; (including the resourcepart).  This ensures that the server can deliver XML stanzas to and receive XML stanzas from the client in relation to entities other than the server itself, as explained under <xref target="rules"/> (the client could exchange stanzas with the server itself before binding a resource since the full JID is needed only for addressing outside the context of the stream negotiated between the client and the server, but this is not commonly done).</t>
      <t><iref item='Connected Resource'/>After a client has bound a resource to the stream, it is referred to as a CONNECTED RESOURCE.  A server SHOULD allow an entity to maintain multiple connected resources simultaneously, where each connected resource is associated with a distinct XML stream and differentiated from the other connected resources by a distinct resourcepart; however, a server MUST enable the administrator of an XMPP service to limit the number of connected resources in order to prevent certain denial of service attacks as described under <xref target='security-dos'/>.</t>
      <t>If, before completing the resource binding step, the client attempts to send an XML stanza to an entity other than the client's account or the server, the server MUST NOT process the stanza and MUST either ignore the stanza or return a &lt;not-authorized/&gt; stream error to the client.</t>
      <t>Support for resource binding is REQUIRED in XMPP client and server implementations.</t>
    </section>
    <section title="Stream Negotiation Rules" anchor="bind-rules">
      <section title="Mandatory-to-Negotiate" anchor="bind-rules-mtn">
        <t>The parties to a stream MUST consider resource binding as mandatory-to-negotiate.</t>
      </section>
      <section title="Restart" anchor="bind-rules-restart">
        <t>After resource binding, the parties MUST NOT restart the stream.</t>
      </section>
    </section>
    <section title="Advertising Support" anchor="bind-feature">
      <t>Upon sending a new response stream header to the client after successful SASL negotiation, the server MUST include a &lt;bind/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-bind' namespace in the stream features it presents to the client.</t>
      <t><list style='empty'><t>Note: Resource binding is mandatory-to-negotiate for clients.</t></list></t>
      <t><list style='empty'><t>Note: The server MUST NOT include the resource binding stream feature until after the client has authenticated, typically by means of successful SASL negotiation.</t></list></t>
      <figure>
        <artwork><![CDATA[
S: <stream:stream
       from='im.example.com'
       id='gPybzaOzBmaADgxKXu9UClbprp0='
       to='juliet@im.example.com'
       version='1.0'
       xml:lang='en'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'>

S: <stream:features>
     <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>
   </stream:features>
        ]]></artwork>
      </figure>
      <t>Upon being so informed that resource binding is mandatory, the client MUST bind a resource to the stream as described in the following sections.</t>
    </section>
    <section title="Generation of Resource Identifiers" anchor="bind-generation">
      <t>A resourcepart MUST at a minimum be unique among the connected resources for that &lt;localpart@domain&gt;.  Enforcement of this policy is the responsibility of the server.</t>
      <t>A resourcepart can be security-critical.  For example, if a malicious entity can guess a client's resourcepart then it might be able to determine if the client (and therefore the controlling principal) is online or offline, thus resulting in a presence leak as described under <xref target='security-leak'/>.  To prevent that possibility, a client can either (1) generate a random resourcepart on its own or (2) ask the server to generate a resourcepart on its behalf, which MUST be random (see <xref target="RANDOM"/>).  When generating a random resourcepart, it is RECOMMENDED that the resourcepart be a Universally Unique Identifier (UUID), for which the format specified in <xref target='UUID'/> is RECOMMENDED.</t>
    </section>
    <section title="Server-Generated Resource Identifier" anchor="bind-servergen">
      <t>A server that supports resource binding MUST be able to generate an XMPP resourcepart on behalf of a client.</t>
      <section title="Success Case" anchor="bind-servergen-success">
        <t>A client requests a server-generated resourcepart by sending an IQ stanza of type "set" (see <xref target="stanzas-semantics-iq"/>) containing an empty &lt;bind/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-bind' namespace.</t>
        <figure>
          <artwork><![CDATA[
C: <iq id='bind_1' type='set'>
    <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>
   </iq>
          ]]></artwork>
        </figure>
        <t>Once the server has generated an XMPP resourcepart for the client, it MUST return an IQ stanza of type "result" to the client, which MUST include a &lt;jid/&gt; child element that specifies the full JID for the connected resource as determined by the server.</t>
        <figure>
          <artwork><![CDATA[
S: <iq id='bind_1' type='result'>
    <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
      <jid>
        juliet@im.example.com/4db06f06-1ea4-11dc-aca3-000bcd821bfb
      </jid>
    </bind>
   </iq>
          ]]></artwork>
        </figure>
      </section>
      <section title="Error Cases" anchor="bind-servergen-error">
        <t>When a client asks the server to generate a resourcepart during resource binding, the following stanza error conditions are possible:</t>
        <t>
          <list style="symbols">
            <t>The request is malformed.</t>
            <t>The account has reached a limit on the number of simultaneous connected resources allowed.</t>
            <t>The client is otherwise not allowed to bind a resource to the stream.</t>
          </list>
        </t>
        <section title="Resource Constraint" anchor="bind-servergen-error-resourceconstraint">
          <t>If the account has reached a limit on the number of simultaneous connected resources allowed, the server MUST return a &lt;resource-constraint/&gt; stanza error.</t>
          <figure>
            <artwork><![CDATA[
S: <iq id='bind_2' type='error'>
     <error type='wait'>
       <resource-constraint 
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </iq>
            ]]></artwork>
          </figure>
        </section>
        <section title="Not Allowed" anchor="bind-servergen-error-notallowed">
          <t>If the client is otherwise not allowed to bind a resource to the stream, the server MUST return a &lt;not-allowed/&gt; stanza error.</t>
          <figure>
            <artwork><![CDATA[
S: <iq id='bind_2' type='error'>
     <error type='cancel'>
       <not-allowed 
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </iq>
            ]]></artwork>
          </figure>
        </section>
      </section>
    </section>
    <section title="Client-Submitted Resource Identifier" anchor="bind-clientsubmit">
      <t>Instead of asking the server to generate a resourcepart on its behalf, a client MAY attempt to submit a resourcepart that it has generated or that the controlling user has provided.</t>
      <section title="Success Case" anchor="bind-clientsubmit-success">
        <t>A client asks its server to accept a client-submitted resourcepart by sending an IQ stanza of type "set" containing a &lt;bind/&gt; element with a child &lt;resource/&gt; element containing non-zero-length XML character data.</t>
        <figure>
          <artwork><![CDATA[
C: <iq id='bind_2' type='set'>
     <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
       <resource>balcony</resource>
     </bind>
   </iq>
          ]]></artwork>
        </figure>
        <t>The server SHOULD accept the client-submitted resourcepart.  It does so by returning an IQ stanza of type "result" to the client, including a &lt;jid/&gt; child element that specifies the full JID for the connected resource and contains without modification the client-submitted text.</t>
        <figure>
          <artwork><![CDATA[
S: <iq id='bind_2' type='result'>
    <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
      <jid>juliet@im.example.com/balcony</jid>
    </bind>
   </iq>
          ]]></artwork>
        </figure>
      </section>
      <section title="Error Cases" anchor="bind-clientsubmit-error">
        <t>When a client attempts to submit its own XMPP resourcepart during resource binding, the following stanza error conditions are possible in addition to those described under <xref target='bind-servergen-error'/>:</t>
        <t>
          <list style="symbols">
            <t>The provided resourcepart cannot be processed by the server.</t>
            <t>The provided resourcepart is already in use.</t>
          </list>
        </t>
        <section title="Bad Request" anchor="bind-clientsubmit-error-badrequest">
          <t>If the provided resourcepart cannot be processed by the server (e.g. because it is of zero length or because it is not in accordance with the Resourceprep profile of stringprep specified in <xref target='XMPP-ADDR'/>), the server MAY return a &lt;bad-request/&gt; stanza error (but SHOULD instead apply the Resourceprep profile or otherwise process the resourcepart so that it is in conformance).</t>
          <figure>
            <artwork><![CDATA[
S: <iq id='bind_2' type='error'>
     <error type='modify'>
       <bad-request xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </iq>
            ]]></artwork>
          </figure>
        </section>
        <section title="Conflict" anchor="bind-clientsubmit-error-conflict">
          <t>If there is already a connected resource of the same name, the server MUST do one of the following:</t>
          <t>
            <list style='numbers'>
              <t>Not accept the resourcepart provided by the client but instead override it with an XMPP resourcepart that the server generates.</t>
              <t>Terminate the current resource and allow the newly-requested resource.</t>
              <t>Disallow the newly-requested resource and maintain the current resource.</t>
            </list>
          </t>
          <t>Which of these the server does is up to the implementation, although it is RECOMMENDED to implement case #1.</t>
          <figure>
            <artwork><![CDATA[
S: <iq id='bind_2' type='result'>
    <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
      <jid>
   juliet@im.example.com/balcony 4db06f06-1ea4-11dc-aca3-000bcd821bfb
      </jid>
    </bind>
   </iq>
            ]]></artwork>
          </figure>
          <t>In case #2, the server MUST send a &lt;conflict/&gt; stream error to the current resource and return an IQ stanza of type "result" (indicating success) to the newly-requested resource.</t>
          <figure>
            <artwork><![CDATA[
S: <iq id='bind_2' type='result'/>
            ]]></artwork>
          </figure>
          <t>In case #3, the server MUST send a &lt;conflict/&gt; stanza error to the newly-requested resource but maintain the XML stream for that connection so that the newly-requested resource has an opportunity to negotiate a non-conflicting resourcepart before sending another request for resource binding.</t>
          <figure>
            <artwork><![CDATA[
S: <iq id='bind_2' type='error'>
     <error type='modify'>
       <conflict xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </iq>
            ]]></artwork>
          </figure>
        </section>
      </section>
      <section title="Retries" anchor="bind-clientsubmit-retries">
        <t>If an error occurs when a client submits a resourcepart, the server SHOULD allow a configurable but reasonable number of retries (at least 2 and no more than 5); this enables the client to tolerate incorrectly-provided resourceparts (e.g., bad data formats or duplicate text strings) without being forced to reconnect.</t>
        <t>After the client has reached the retry limit, the server MUST return a &lt;policy-violation/&gt; stream error to the client.</t>
      </section>
    </section>
  </section>

  <section title="XML Stanzas" anchor="stanzas">
    <t>After a client has connected to a server or two servers have connected to each other, either party can send XML stanzas over the negotiated stream.  Three kinds of XML stanza are defined for the 'jabber:client' and 'jabber:server' namespaces: &lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt;.  In addition, there are five common attributes for these stanza types.  These common attributes, as well as the basic semantics of the three stanza types, are defined herein; more detailed information regarding the syntax of XML stanzas for instant messaging and presence applications is provided in <xref target="XMPP-IM"/>, and for other applications in the relevant XMPP extension specifications.</t>
    <t>A server MUST NOT process a partial stanza and MUST NOT attach meaning to the transmission timing of any part of a stanza (before receipt of the close tag).</t>
    <t>Support for the XML stanza syntax and semantics defined herein is REQUIRED in XMPP client and server implementations.</t>

    <section title="Common Attributes" anchor="stanzas-attributes">
      <t>The following five attributes are common to message, presence, and IQ stanzas.</t>
      <section title="to" anchor="stanzas-attributes-to">
        <t>The 'to' attribute specifies the JID of the intended recipient for the stanza.</t>
        <figure>
          <artwork><![CDATA[
<message to='romeo@example.net'>
  <body>Art thou not Romeo, and a Montague?</body>
</message>
          ]]></artwork>
        </figure>
        <t>For information about server processing of inbound and outbound XML stanzas based on the nature of the 'to' address, refer to <xref target='rules'/>.</t>
        <section title="Client-to-Server Streams" anchor="stanzas-attributes-to-c2s">
          <t>The following rules apply to inclusion of the 'to' attribute in the context of XML streams qualified by the 'jabber:client' namespace (i.e., client-to-server streams).</t>
          <t>
            <list style='numbers'>
              <t>A stanza with a specific intended recipient MUST possess a 'to' attribute whose value is an XMPP address.</t>
              <t>A stanza sent from a client to a server for direct processing by the server on behalf of the client (e.g., presence sent to the server for broadcasting to other entities) MUST NOT possess a 'to' attribute.</t>
            </list>
          </t>
        </section>
        <section title="Server-to-Server Streams" anchor="stanzas-attributes-to-s2s">
          <t>The following rules apply to inclusion of the 'to' attribute in the context of XML streams qualified by the 'jabber:server' namespace (i.e., server-to-server streams).</t>
          <t>
            <list style='numbers'>
              <t>A stanza MUST possess a 'to' attribute whose value is an XMPP address; if a server receives a stanza that does not meet this restriction, it MUST generate an &lt;improper-addressing/&gt; stream error.</t>
              <t>The domainpart of the JID in the 'to' atttribute MUST match a hostname serviced by the receiving server; if a server receives a stanza that does not meet this restriction, it MUST generate a &lt;host-unknown/&gt; or &lt;host-gone/&gt; stream error.</t>
            </list>
          </t>
        </section>
      </section>
      <section title="from" anchor="stanzas-attributes-from">
        <t>The 'from' attribute specifies the JID of the sender.</t>
        <figure>
          <artwork><![CDATA[
<message from='juliet@im.example.com/balcony'
         to='romeo@example.net'>
  <body>Art thou not Romeo, and a Montague?</body>
</message>
          ]]></artwork>
        </figure>
        <section title="Client-to-Server Streams" anchor="stanzas-attributes-from-c2s">
          <t>The following rules apply to the 'from' attribute in the context of XML streams qualified by the 'jabber:client' namespace (i.e., client-to-server streams).</t>
          <t>
            <list style='numbers'>
              <t>When the server receives an XML stanza from a client and the stanza does not include a 'from' attribute, the server MUST add a 'from' attribute to the stanza, where the value of the 'from' attribute is the full JID (&lt;localpart@domain/resource&gt;) determined by the server for the connected resource that generated the stanza (see <xref target="streams-negotiation-address"/>), or the bare JID (&lt;localpart@domain&gt;) in the case of subscription-related presence stanzas (see <xref target='XMPP-IM'/>).</t>
              <t>When the server receives an XML stanza from a client and the stanza includes a 'from' attribute, the server MUST either (a) validate that the value of the 'from' attribute provided by the client is that of a connected resource for the associated entity or (b) override the provided 'from' attribute by adding a 'from' attribute as specified under Rule #1.</t>
              <t>When the server generates a stanza from the server for delivery to the client on behalf of the account of the connected client (e.g., in the context of data storage services provided by the server on behalf of the client), the stanza MUST either (a) not include a 'from' attribute or (b) include a 'from' attribute whose value is the account's bare JID (&lt;localpart@domain&gt;).</t>
              <t>When the server generates a stanza from the server itself for delivery to the client, the stanza MUST include a 'from' attribute whose value is the bare JID (i.e., &lt;domain&gt;) of the server.</t>
              <t>A server MUST NOT send to the client a stanza without a 'from' attribute if the stanza was not generated by the server (e.g., if it was generated by another client or another server); therefore, when a client receives a stanza that does not include a 'from' attribute, it MUST assume that the stanza is from the server to which the client is connected.</t>
            </list>
          </t>
        </section>
        <section title="Server-to-Server Streams" anchor="stanzas-attributes-from-s2s">
          <t>The following rules apply to the 'from' attribute in the context of XML streams qualified by the 'jabber:server' namespace (i.e., server-to-server streams).</t>
          <t>
            <list style='numbers'>
              <t>A stanza MUST possess a 'from' attribute whose value is an XMPP address; if a server receives a stanza that does not meet this restriction, it MUST generate an &lt;improper-addressing/&gt; stream error.</t>
              <t>The domainpart of the JID contained in the 'from' attribute MUST match the hostname of the sending server (or any validated domain thereof) as communicated in the SASL negotiation (see <xref target='sasl'/>), server dialback (see <xref target='XEP-0220'/>, or similar means; if a server receives a stanza that does not meet this restriction, it MUST generate an &lt;invalid-from/&gt; stream error.</t>
            </list>
          </t>
          <t>Enforcement of these rules helps to prevent certain denial of service attacks as described under <xref target='security-dos'/>.</t>
        </section>
      </section>
      <section title="id" anchor="stanzas-attributes-id">
        <t>The 'id' attribute is used by the entity that generates a stanza ("the originating entity") to track any response or error stanza that it might receive in relation to the generated stanza from another entity (such as an intermediate server or the intended recipient).</t>
        <t>It is up to the originating entity whether the value of the 'id' attribute will be unique only within its current stream (session) or unique globally.</t>
        <t>For &lt;message/&gt; and &lt;presence/&gt; stanzas, it is RECOMMENDED for the originating entity to include an 'id' attribute; for &lt;iq/&gt; stanzas, it is REQUIRED.</t>
        <t>If the generated stanza includes an 'id' attribute then it is REQUIRED for the response or error stanza to also include an 'id' attribute, where the value of the 'id' attribute MUST match that of the generated stanza.</t>
        <t>Note: The semantics of IQ stanzas impose additional restrictions; see <xref target="stanzas-semantics-iq"/>.</t>
      </section>
      <section title="type" anchor="stanzas-attributes-type">
        <t>The 'type' attribute specifies the purpose or context of the message, presence, or IQ stanza.  The particular allowable values for the 'type' attribute vary depending on whether the stanza is a message, presence, or IQ stanza.  The defined values for message and presence stanzas are specific to instant messaging and presence applications and therefore are specified in <xref target="XMPP-IM"/>, whereas the values for IQ stanzas specify the role of an IQ stanza in a structured request-response exchange and therefore are specified under <xref target="stanzas-semantics-iq"/>.  The only 'type' value common to all three stanzas is "error"; see <xref target="stanzas-error"/>.</t>
      </section>
      <section title="xml:lang" anchor="stanzas-attributes-lang">
        <t>A stanza SHOULD possess an 'xml:lang' attribute (as defined in Section 2.12 of <xref target="XML"/>) if the stanza contains XML character data that is intended to be presented to a human user (as explained in <xref target="CHARSET"/>, "internationalization is for humans").  The value of the 'xml:lang' attribute specifies the default language of any such human-readable XML character data.</t>
        <figure>
          <artwork><![CDATA[
<presence from='romeo@example.net/orchard' xml:lang='en'>
  <show>dnd</show>
  <status>Wooing Juliet</status>
</presence>
          ]]></artwork>
        </figure>
        <t>The value of the 'xml:lang' attribute MAY be overridden by the 'xml:lang' attribute of a specific child element.</t>
        <figure>
          <artwork><![CDATA[
<presence from='romeo@example.net/orchard' xml:lang='en'>
  <show>dnd</show>
  <status>Wooing Juliet</status>
  <status xml:lang='cs'>Dvo&#x0159;&#x00ED;m se Julii</status>
</presence
          ]]></artwork>
        </figure>
        <t>If an outbound stanza generated by a client does not possess an 'xml:lang' attribute, the client's server SHOULD add an 'xml:lang' attribute whose value is that specified for the stream as defined under <xref target="streams-attr-xmllang"/>.</t>
        <figure>
          <artwork><![CDATA[
C: <presence from='romeo@example.net/orchard'>
     <show>dnd</show>
     <status>Wooing Juliet</status>
   </presence>

S: <presence from='romeo@example.net/orchard'
             to='juliet@im.example.com'
             xml:lang='en'>
     <show>dnd</show>
     <status>Wooing Juliet</status>
   </presence>
          ]]></artwork>
        </figure>
        <t>If an inbound stanza received received by a client or server does not possess an 'xml:lang' attribute, an implementation MUST assume that the default language is that specified for the stream as defined under <xref target="streams-attr-xmllang"/>.</t>
        <t>The value of the 'xml:lang' attribute MUST conform to the NMTOKEN datatype (as defined in Section 2.3 of <xref target="XML"/>) and MUST conform to the format defined in <xref target="LANGTAGS"/>.</t>
        <t>A server MUST NOT modify or delete 'xml:lang' attributes on stanzas it receives from other entities.</t>
      </section>
    </section>

    <section title="Basic Semantics" anchor="stanzas-semantics">
      <section title="Message Semantics" anchor="stanzas-semantics-message">
        <t><iref item='Message Stanza'/>The &lt;message/&gt; stanza can be seen as a "push" mechanism whereby one entity pushes information to another entity, similar to the communications that occur in a system such as email.  All message stanzas SHOULD possess a 'to' attribute that specifies the intended recipient of the message; upon receiving such a stanza, a server SHOULD route or deliver it to the intended recipient (see <xref target="rules"/> for general routing and delivery rules related to XML stanzas).</t>
      </section>
      <section title="Presence Semantics" anchor="stanzas-semantics-presence">
        <t><iref item='Presence Stanza'/>The &lt;presence/&gt; stanza can be seen as a specialized broadcast or "publish-subscribe" mechanism, whereby multiple entities receive information (in this case, network availability information) about an entity to which they have subscribed.  In general, a publishing entity (client) SHOULD send a presence stanza with no 'to' attribute, in which case the server to which the entity is connected SHOULD broadcast that stanza to all subscribed entities.  However, a publishing entity MAY also send a presence stanza with a 'to' attribute, in which case the server SHOULD route or deliver that stanza to the intended recipient.  See <xref target="rules"/> for general routing and delivery rules related to XML stanzas, and <xref target="XMPP-IM"/> for rules specific to presence applications.</t>
      </section>
      <section title="IQ Semantics" anchor="stanzas-semantics-iq">
        <t><iref item='IQ Stanza'/>Info/Query, or IQ, is a request-response mechanism, similar in some ways to the Hypertext Transfer Protocol <xref target="HTTP"/>.  The semantics of IQ enable an entity to make a request of, and receive a response from, another entity.  The data content of the request and response is defined by the schema or other structural definition associated with the XML namespace that qualifies the direct child element of the IQ element (see <xref target='stanzas-extended'/>), and the interaction is tracked by the requesting entity through use of the 'id' attribute.  Thus, IQ interactions follow a common pattern of structured data exchange such as get/result or set/result (although an error can be returned in reply to a request if appropriate):</t>
        <figure>
          <artwork><![CDATA[
Requesting                  Responding
  Entity                      Entity
----------                  ----------
    |                            |
    | <iq id='1' type='get'>     |
    |   [ ... payload ... ]      |
    | </iq>                      |
    | -------------------------> |
    |                            |
    | <iq id='1' type='result'>  |
    |   [ ... payload ... ]      |
    | </iq>                      |
    | <------------------------- |
    |                            |
    | <iq id='2' type='set'>     |
    |   [ ... payload ... ]      |
    | </iq>                      |
    | -------------------------> |
    |                            |
    | <iq id='2' type='error'>   |
    |   [ ... condition ... ]    |
    | </iq>                      |
    | <------------------------- |
    |                            |
          ]]></artwork>
        </figure>
        <t>To enforce these semantics, the following rules apply:</t>
        <t><list style='numbers'>
          <t>The 'id' attribute is REQUIRED for IQ stanzas.</t>
          <t>The 'type' attribute is REQUIRED for IQ stanzas.  The value MUST be one of the following (if the value is other than one of the following strings, the recipient or an intermediate router MUST return a stanza error of &lt;bad-request/&gt;):
            <list style="symbols">
              <t>get -- The stanza requests information, inquires about what data is needed in order to complete further operations, etc.</t>
              <t>set -- The stanza provides data that is needed for an operation to be completed, sets new values, replaces existing values, etc.</t>
              <t>result -- The stanza is a response to a successful get or set request.</t>
              <t>error -- The stanza reports an error that has occurred regarding processing or delivery of a previously-sent get or set request (see <xref target="stanzas-error"/>).</t>
            </list>
          </t>
          <t>An entity that receives an IQ request of type "get" or "set" MUST reply with an IQ response of type "result" or "error".  The response MUST preserve the 'id' attribute of the request.</t>
          <t>An entity that receives a stanza of type "result" or "error" MUST NOT respond to the stanza by sending a further IQ response of type "result" or "error"; however, the requesting entity MAY send another request (e.g., an IQ of type "set" to provide obligatory information discovered through a get/result pair).</t>
          <t>An IQ stanza of type "get" or "set" MUST contain exactly one child element, which specifies the semantics of the particular request.</t>
          <t>An IQ stanza of type "result" MUST include zero or one child elements.</t>
          <t>An IQ stanza of type "error" MAY include the child element contained in the associated "get" or "set" and MUST include an &lt;error/&gt; child; for details, see <xref target="stanzas-error"/>.</t>
        </list></t>
      </section>
    </section>

    <section title="Stanza Errors" anchor="stanzas-error">
      <t>Stanza-related errors are handled in a manner similar to <xref target="streams-error">stream errors</xref>.  Unlike stream errors, stanza errors are recoverable; therefore they do not result in termination of the XML stream and underlying TCP connection.  <iref item='Error Stanza'/>Instead, the entity that discovers the error condition returns an ERROR STANZA to the sender, i.e., a stanza of the same kind (message, presence, or IQ) whose 'type' attribute is set to a value of "error" and which contains an &lt;error/&gt; child element that specifies the error condition.  The specified error condition provides a hint regarding actions that the sender can take to remedy the error if possible.</t>
      <section title="Rules" anchor="stanzas-error-rules">
        <t>The following rules apply to stanza errors:</t>
        <t><list style="numbers">
          <t>The receiving or processing entity that detects an error condition in relation to a stanza SHOULD return an error stanza (and MUST do so for IQ stanzas).</t>
          <t>The entity that generates an error stanza MAY include the original XML sent so that the sender can inspect and, if necessary, correct the XML before attempting to resend.</t>
          <t>If the generated stanza included an 'id' attribute then it is REQUIRED for the error stanza to also include an 'id' attribute, where the value of the 'id' attribute MUST match that of the generated stanza.</t>
          <t>An error stanza MUST contain an &lt;error/&gt; child element.</t>
          <t>An &lt;error/&gt; child MUST NOT be included if the 'type' attribute has a value other than "error" (or if there is no 'type' attribute).</t>
          <t>An entity that receives an error stanza MUST NOT respond to the stanza with a further error stanza; this helps to prevent looping.</t>
        </list></t>
      </section>
      <section title="Syntax" anchor="stanzas-error-syntax">
        <t>The syntax for stanza-related errors is:</t>
        <figure>
          <artwork><![CDATA[
<stanza-kind from='intended-recipient' to='sender' type='error'>
  [OPTIONAL to include sender XML here]
  <error type='error-type'>
    <defined-condition xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
    [<text xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'
          xml:lang='langcode'>
      OPTIONAL descriptive text
    </text>]
    [OPTIONAL application-specific condition element]
  </error>
</stanza-kind>
          ]]></artwork>
        </figure>
        <t>The "stanza-kind" MUST be one of message, presence, or iq.</t>
        <t>The "error-type" MUST be one of the following:</t>
        <t>
          <list style="symbols">
            <t>auth -- retry after providing credentials</t>
            <t>cancel -- do not retry (the error cannot be remedied)</t>
            <t>continue -- proceed (the condition was only a warning)</t>
            <t>modify -- retry after changing the data sent</t>
            <t>wait -- retry after waiting (the error is temporary)</t>
          </list>
        </t>
        <t>The &lt;error/&gt; element:</t>
        <t><list style="symbols">
          <t>MUST contain a child element corresponding to one of the stanza error conditions defined under <xref target='stanzas-error-conditions'/>; this element MUST be qualified by the 'urn:ietf:params:xml:ns:xmpp-stanzas' namespace.</t>
          <t>MAY contain a &lt;text/&gt; child element containing XML character data that describes the error in more detail; this element MUST be qualified by the 'urn:ietf:params:xml:ns:xmpp-stanzas' namespace and SHOULD possess an 'xml:lang' attribute specifying the natural language of the XML character data.</t>
          <t>MAY contain a child element for an application-specific error condition; this element MUST be qualified by an application-specific namespace that defines the syntax and semantics of the element.</t>
        </list></t>
        <t>The &lt;text/&gt; element is OPTIONAL.  If included, it MUST be used only to provide descriptive or diagnostic information that supplements the meaning of a defined condition or application-specific condition.  It MUST NOT be interpreted programmatically by an application.  It MUST NOT be used as the error message presented to a human user, but MAY be shown in addition to the error message associated with the defined condition element (and, optionally, the application-specific condition element).</t>
      </section>
      <section title="Defined Conditions" anchor="stanzas-error-conditions">
        <t>The following conditions are defined for use in stanza errors.</t>
        <section title="bad-request" anchor="stanzas-error-conditions-bad-request">
          <t>The sender has sent a stanza containing XML that does not conform to the appropriate schema or that cannot be processed (e.g., an IQ stanza that includes an unrecognized value of the 'type' attribute, or an element that is qualified by a recognized namespace but that violates the defined syntax for the element); the associated error type SHOULD be "modify".</t>
          <figure>
            <artwork><![CDATA[
C: <iq from='juliet@im.example.com/balcony' 
       id='some-id'
       to='im.example.com'
       type='subscribe'>
     <ping xmlns='urn:xmpp:ping'/>
   </iq>

S: <iq from='im.example.com'
       id='some-id'
       to='juliet@im.example.com/balcony'
       type='error'>
     <error type='modify'>
       <bad-request xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </iq>
            ]]></artwork>
          </figure>
        </section>
        <section title="conflict" anchor="stanzas-error-conditions-conflict">
          <t>Access cannot be granted because an existing resource exists with the same name or address; the associated error type SHOULD be "cancel".</t>
          <figure>
            <artwork><![CDATA[
C: <iq id='bind_2' type='set'>
     <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
       <resource>balcony</resource>
     </bind>
   </iq>

S: <iq id='bind_2' type='error'>
     <error type='cancel'>
       <conflict xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </iq>
            ]]></artwork>
          </figure>
        </section>
        <section title="feature-not-implemented" anchor="stanzas-error-conditions-feature-not-implemented">
          <t>The feature represented in the XML stanza is not implemented by the intended recipient or an intermediate server and therefore the stanza cannot be processed (e.g., the entity understands the namespace but does not recognize the element name); the associated error type SHOULD be "cancel" or "modify".</t>
          <figure>
            <artwork><![CDATA[
C: <iq from='juliet@im.example.com/balcony'
       id='subscriptions1'
       to='pubsub.example.com'
       type='get'>
     <pubsub xmlns='http://jabber.org/protocol/pubsub'>
       <subscriptions/>
     </pubsub>
   </iq>

E: <iq from='pubsub.example.com
       id='subscriptions1'
       to='juliet@im.example.com/balcony'
       type='error'>
     <error type='cancel'>
       <feature-not-implemented 
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
       <unsupported 
           xmlns='http://jabber.org/protocol/pubsub#errors'
           feature='retrieve-subscriptions'/>
     </error>
   </iq>
            ]]></artwork>
          </figure>
        </section>
        <section title="forbidden" anchor="stanzas-error-conditions-forbidden">
          <t>The requesting entity does not possess the necessary permissions to perform the action; the associated error type SHOULD be "auth".</t>
          <figure>
            <artwork><![CDATA[
C: <presence
       from='juliet@im.example.com/balcony'
       to='characters@muc.example.com/JulieC'>
     <x xmlns='http://jabber.org/protocol/muc'/>
   </presence>

E: <presence
       from='characters@muc.example.com/JulieC'
       to='juliet@im.example.com/balcony'
       type='error'>
     <error type='auth'>
       <forbidden xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </presence>
            ]]></artwork>
          </figure>
        </section>
        <section title="gone" anchor="stanzas-error-conditions-gone">
          <t>The recipient or server can no longer be contacted at this address, typically on a permanent basis; the associated error type SHOULD be "cancel" or "modify" and the error stanza SHOULD include a new address as the XML character data of the &lt;gone/&gt; element (which MUST be a Uniform Resource Identifier <xref target='URI'/> or Internationalized Resource Identifier <xref target='IRI'/> at which the entity can be contacted, typically an XMPP IRI as specified in <xref target='XMPP-URI'/>).</t>
          <figure>
            <artwork><![CDATA[
C: <presence
       from='juliet@im.example.com/balcony'
       to='characters@muc.example.com/JulieC'>
     <x xmlns='http://jabber.org/protocol/muc'/>
   </presence>

E: <presence
       from='characters@muc.example.com/JulieC'
       to='juliet@im.example.com/balcony'
       type='error'>
     <error type='modify'>
       <gone xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'>
         xmpp:conference.example.com
       </gone>
     </error>
   </presence>
            ]]></artwork>
          </figure>
        </section>
        <section title="internal-server-error" anchor="stanzas-error-conditions-internal-server-error">
          <t>The server could not process the stanza because of a misconfiguration or an otherwise-undefined internal server error; the associated error type SHOULD be "wait" or "cancel".</t>
          <figure>
            <artwork><![CDATA[
C: <presence
       from='juliet@im.example.com/balcony'
       to='characters@muc.example.com/JulieC'>
     <x xmlns='http://jabber.org/protocol/muc'/>
   </presence>

E: <presence
       from='characters@muc.example.com/JulieC'
       to='juliet@im.example.com/balcony'
       type='error'>
     <error type='wait'>
       <internal-server-error 
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </presence>
            ]]></artwork>
          </figure>
        </section>
        <section title="item-not-found" anchor="stanzas-error-conditions-item-not-found">
          <t>The addressed JID or item requested cannot be found; the associated error type SHOULD be "cancel" or "modify".</t>
          <figure>
            <artwork><![CDATA[
C: <presence from='userfoo@example.com/bar'
             to='nosuchroom@conference.example.org/foo'/>

S: <presence from='nosuchroom@conference.example.org/foo' 
             to='userfoo@example.com/bar'
             type='error'>
     <error type='cancel'>
       <item-not-found xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </iq>
            ]]></artwork>
          </figure>
          <t><list style='empty'><t>Note: An application MUST NOT return this error if doing so would provide information about the intended recipient's network availability to an entity that is not authorized to know such information; instead it MUST return a &lt;service-unavailable/&gt; stanza error.</t></list></t>
        </section>
        <section title="jid-malformed" anchor="stanzas-error-conditions-jid-malformed">
          <t>The sending entity has provided or communicated an XMPP address (e.g., a value of the 'to' attribute) or aspect thereof (e.g., an XMPP resourcepart) that does not adhere to the syntax defined in <xref target="XMPP-ADDR"/>; the associated error type SHOULD be "modify".</t>
          <figure>
            <artwork><![CDATA[
C: <presence
       from='juliet@im.example.com/balcony'
       to='ch@r@cters@muc.example.com/JulieC'>
     <x xmlns='http://jabber.org/protocol/muc'/>
   </presence>

E: <presence
       from='ch@r@cters@muc.example.com/JulieC'
       to='juliet@im.example.com/balcony'
       type='error'>
     <error type='modify'>
       <jid-malformed
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </presence>
            ]]></artwork>
          </figure>
        </section>
        <section title="not-acceptable" anchor="stanzas-error-conditions-not-acceptable">
          <t>The recipient or server understands the request but is refusing to process it because it does not meet criteria defined by the recipient or server (e.g., a local policy regarding stanza size limits or acceptable words in messages); the associated error type SHOULD be "modify".</t>
          <figure>
            <artwork><![CDATA[
C: <message to='juliet@im.example.com' id='foo'>
     <body>[ ... the-emacs-manual ... ]</body>
   </message>

S: <message from='juliet@im.example.com' id='foo'>
     <error type='modify'>
       <not-acceptable
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </message>
            ]]></artwork>
          </figure>
        </section>
        <section title="not-allowed" anchor="stanzas-error-conditions-not-allowed">
          <t>The recipient or server does not allow any entity to perform the action (e.g., sending to entities at a blacklisted domain); the associated error type SHOULD be "cancel".</t>
          <figure>
            <artwork><![CDATA[
C: <presence
       from='juliet@im.example.com/balcony'
       to='characters@muc.example.com/JulieC'>
     <x xmlns='http://jabber.org/protocol/muc'/>
   </presence>

E: <presence
       from='characters@muc.example.com/JulieC'
       to='juliet@im.example.com/balcony'
       type='error'>
     <error type='cancel'>
       <not-allowed xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </presence>
            ]]></artwork>
          </figure>
        </section>
        <section title="not-authorized" anchor="stanzas-error-conditions-not-authorized">
          <t>The sender needs to provide proper credentials before being allowed to perform the action, or has provided improper credentials; the associated error type SHOULD be "auth".</t>
          <figure>
            <artwork><![CDATA[
C: <presence
       from='juliet@im.example.com/balcony'
       to='characters@muc.example.com/JulieC'>
     <x xmlns='http://jabber.org/protocol/muc'/>
   </presence>

E: <presence
       from='characters@muc.example.com/JulieC'
       to='juliet@im.example.com/balcony'>
     <error type='auth'>
       <not-authorized xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </presence>
            ]]></artwork>
          </figure>
        </section>
        <section title="not-modified" anchor="stanzas-error-conditions-not-modified">
          <t>The item requested has not changed since it was last requested; the associated error type SHOULD be "continue".</t>
          <figure>
            <artwork><![CDATA[
C: <iq from='juliet@capulet.com/balcony'
       id='roster2'
       type='get'>
    <query xmlns='jabber:iq:roster'>
       <headers xmlns='http://jabber.org/protocol/shim'>
         <header name='If-None-Match'>
           some-long-opaque-string
         </header>
       </headers>
    </query>
   </iq>

S: <iq type='error' 
       to='juliet@capulet.com/balcony'
       id='roster2'>
     <query xmlns='jabber:iq:roster'>
       <headers xmlns='http://jabber.org/protocol/shim'>
         <header name='If-None-Match'>
           some-long-opaque-string
         </header>
       </headers>
     </query>
     <error type='modify'>
       <not-modified xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </iq>
            ]]></artwork>
          </figure>
        </section>
        <section title="payment-required" anchor="stanzas-error-conditions-payment-required">
          <t>The requesting entity is not authorized to access the requested service because payment is necessary; the associated error type SHOULD be "auth".</t>
          <figure>
            <artwork><![CDATA[
C: <iq from='romeo@example.net/foo'
       id='items1'
       to='pubsub.example.com'
       type='get'>
     <pubsub xmlns='http://jabber.org/protocol/pubsub'>
       <items node='my_musings'/>
     </pubsub>
   </iq>

E: <iq from='pubsub.example.com'
       id='items1'
       to='romeo@example.net/foo'
       type='error'>
     <error type='auth'>
       <payment-required 
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </iq>
            ]]></artwork>
          </figure>
        </section>
        <section title="policy-violation" anchor="stanzas-error-conditions-policy-violation">
          <t>The entity has violated some local service policy (e.g., the stanza exceeds a configured size limit); the server MAY choose to specify the policy in the &lt;text/&gt; element or in an application-specific condition element; the associated error type SHOULD be "modify" or "wait" depending on the policy being violated.</t>
          <t>(In the following example, the client sends an XMPP message that is too large according to the server's local service policy.)</t>
          <figure>
            <artwork><![CDATA[
C: <message to='juliet@im.example.com' id='foo'>
     <body>[ ... the-emacs-manual ... ]</body>
   </message>

S: <message from='juliet@im.example.com' id='foo'>
     <error type='cancel'>
       <policy-violation 
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </message>
            ]]></artwork>
          </figure>
        </section>
        <section title="recipient-unavailable" anchor="stanzas-error-conditions-recipient-unavailable">
          <t>The intended recipient is temporarily unavailable; the associated error type SHOULD be "wait".</t>
          <figure>
            <artwork><![CDATA[
C: <presence
       from='juliet@im.example.com/balcony'
       to='characters@muc.example.com/JulieC'>
     <x xmlns='http://jabber.org/protocol/muc'/>
   </presence>

E: <presence
       from='characters@muc.example.com/JulieC'
       to='juliet@im.example.com/balcony'>
     <error type='wait'>
       <recipient-unavailable 
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </presence>
            ]]></artwork>
          </figure>
          <t><list style='empty'><t>Note: An application MUST NOT return this error if doing so would provide information about the intended recipient's network availability to an entity that is not authorized to know such information; instead it MUST return a &lt;service-unavailable/&gt; stanza error.</t></list></t>
        </section>
        <section title="redirect" anchor="stanzas-error-conditions-redirect">
          <t>The recipient or server is redirecting requests for this information to another entity, typically in a temporary fashion (the &lt;gone/&gt; condition is used for permanent addressing failures); the associated error type SHOULD be "modify" and the error stanza SHOULD contain the alternate address in the XML character data of the &lt;redirect/&gt; element (which MUST be a URI or IRI at which the entity can be contacted, typically an XMPP IRI as specified in <xref target='XMPP-URI'/>).</t>
          <figure>
            <artwork><![CDATA[
C: <presence
       from='juliet@im.example.com/balcony'
       to='characters@muc.example.com/JulieC'>
     <x xmlns='http://jabber.org/protocol/muc'/>
   </presence>

E: <presence
       from='characters@muc.example.com/JulieC'
       to='juliet@im.example.com/balcony'
       type='error'>
     <error type='modify'>
       <redirect xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'>
         xmpp:characters@conference.example.org
       </redirect>
     </error>
   </presence>
            ]]></artwork>
          </figure>
        </section>
        <section title="registration-required" anchor="stanzas-error-conditions-registration-required">
          <t>The requesting entity is not authorized to access the requested service because prior registration is necessary; the associated error type SHOULD be "auth".</t>
          <figure>
            <artwork><![CDATA[
C: <presence
       from='juliet@im.example.com/balcony'
       to='characters@muc.example.com/JulieC'>
     <x xmlns='http://jabber.org/protocol/muc'/>
   </presence>

E: <presence
       from='characters@muc.example.com/JulieC'
       to='juliet@im.example.com/balcony'>
     <error type='auth'>
       <registration-required
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </presence>
            ]]></artwork>
          </figure>
        </section>
        <section title="remote-server-not-found" anchor="stanzas-error-conditions-remote-server-not-found">
          <t>A remote server or service specified as part or all of the JID of the intended recipient does not exist; the associated error type SHOULD be "cancel".</t>
          <figure>
            <artwork><![CDATA[
C: <presence
       from='juliet@im.example.com/balcony'
       to='characters@muc.example.com/JulieC'>
     <x xmlns='http://jabber.org/protocol/muc'/>
   </presence>

E: <presence
       from='characters@muc.example.com/JulieC'
       to='juliet@im.example.com/balcony'>
     <error type='cancel'>
       <remote-server-not-found
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </presence>
            ]]></artwork>
          </figure>
        </section>
        <section title="remote-server-timeout" anchor="stanzas-error-conditions-remote-server-timeout">
          <t>A remote server or service specified as part or all of the JID of the intended recipient (or needed to fulfill a request) could not be contacted within a reasonable amount of time; the associated error type SHOULD be "wait".</t>
          <figure>
            <artwork><![CDATA[
C: <presence
       from='juliet@im.example.com/balcony'
       to='characters@muc.example.com/JulieC'>
     <x xmlns='http://jabber.org/protocol/muc'/>
   </presence>

E: <presence
       from='characters@muc.example.com/JulieC'
       to='juliet@im.example.com/balcony'>
     <error type='wait'>
       <remote-server-timeout
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </presence>
            ]]></artwork>
          </figure>
        </section>
        <section title="resource-constraint" anchor="stanzas-error-conditions-resource-constraint">
          <t>The server or recipient lacks the system resources necessary to service the request; the associated error type SHOULD be "wait" or "modify".</t>
          <figure>
            <artwork><![CDATA[
C: <iq from='romeo@example.net/foo'
       id='items1'
       to='pubsub.example.com'
       type='get'>
     <pubsub xmlns='http://jabber.org/protocol/pubsub'>
       <items node='my_musings'/>
     </pubsub>
   </iq>

E: <iq from='pubsub.example.com'
       id='items1'
       to='romeo@example.net/foo'
       type='error'>
     <error type='wait'>
       <resource-constraint
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </iq>
            ]]></artwork>
          </figure>
        </section>
        <section title="service-unavailable" anchor="stanzas-error-conditions-service-unavailable">
          <t>The server or recipient does not currently provide the requested service; the associated error type SHOULD be "cancel".</t>
          <figure>
            <artwork><![CDATA[
C: <message from='romeo@example.net/foo'
            to='juliet@im.example.com'>
     <body>Hello?</body>
   </message>

S: <message from='juliet@im.example.com/foo'
            to='romeo@example.net'>
     <error type='cancel'>
       <service-unavailable
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </message>
            ]]></artwork>
          </figure>
          <t>An application MUST return a &lt;service-unavailable/&gt; stanza error instead of &lt;item-not-found/&gt; or &lt;recipient-unavailable/&gt; if sending one of the latter errors would provide information about the intended recipient's network availability to an entity that is not authorized to know such information.</t>
        </section>
        <section title="subscription-required" anchor="stanzas-error-conditions-subscription-required">
          <t>The requesting entity is not authorized to access the requested service because a prior subscription is necessary; the associated error type SHOULD be "auth".</t>
          <figure>
            <artwork><![CDATA[
C: <message
       from='romeo@example.net/orchard'
       to='playbot@shakespeare.example.com'
     <body>help</body>
   </message>

E: <message
      from='playbot@shakespeare.example.com'
      to='romeo@example.net/orchard'
      type='error'>
     <error type='auth'>
       <subscription-required
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
     </error>
   </message>
            ]]></artwork>
          </figure>
        </section>
        <section title="undefined-condition" anchor="stanzas-error-conditions-undefined-condition">
          <t>The error condition is not one of those defined by the other conditions in this list; any error type can be associated with this condition, and it SHOULD be used only in conjunction with an application-specific condition.</t>
          <figure>
            <artwork><![CDATA[
C: <message
       from='northumberland@shakespeare.example'
       id='richard2-4.1.247'
       to='kingrichard@royalty.england.example'>
     <body>My lord, dispatch; read o'er these articles.</body>
     <amp xmlns='http://jabber.org/protocol/amp'>
       <rule action='notify' 
             condition='deliver' 
             value='stored'/>
     </amp>

S: <message from='example.org'
            id='amp1'
            to='northumberland@example.net/field'
            type='error'>
     <amp xmlns='http://jabber.org/protocol/amp'
          from='kingrichard@example.org'
          status='error'
          to='northumberland@example.net/field'>
       <rule action='error' 
             condition='deliver' 
             value='stored'/>
     </amp>
     <error type='modify'>
       <undefined-condition 
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
       <failed-rules xmlns='http://jabber.org/protocol/amp#errors'>
         <rule action='error' 
               condition='deliver' 
               value='stored'/>
       </failed-rules>
     </error>
   </message>
            ]]></artwork>
          </figure>
        </section>
        <section title="unexpected-request" anchor="stanzas-error-conditions-unexpected-request">
          <t>The recipient or server understood the request but was not expecting it at this time (e.g., the request was out of order); the associated error type SHOULD be "wait" or "modify".</t>
          <figure>
            <artwork><![CDATA[
C: <iq from='romeo@example.net/foo'
       id='unsub1'
       to='pubsub.example.com'
       type='set'>
     <pubsub xmlns='http://jabber.org/protocol/pubsub'>
        <unsubscribe
            node='my_musings'
            jid='romeo@example.net'/>
     </pubsub>
   </iq>

E: <iq from='pubsub.example.com'
       id='unsub1'
       to='romeo@example.net/foo'
       type='error'>
     <error type='cancel'>
       <unexpected-request 
           xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
       <not-subscribed 
           xmlns='http://jabber.org/protocol/pubsub#errors'/>
     </error>
   </iq>
            ]]></artwork>
          </figure>
        </section>
      </section>
      <section title="Application-Specific Conditions" anchor="stanzas-error-app">
        <t>As noted, an application MAY provide application-specific stanza error information by including a properly-namespaced child in the error element.  The application-specific element SHOULD supplement or further qualify a defined element.  Thus, the &lt;error/&gt; element will contain two or three child elements.</t>
        <figure>
          <artwork><![CDATA[
<iq id='some-id' type='error'>
  <error type='modify'>
    <bad-request xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
    <too-many-parameters xmlns='http://example.com/ns'/>
  </error>
</iq>
          ]]></artwork>
        </figure>
        <figure>
          <artwork><![CDATA[
<message type='error' id='another-id'>
  <error type='modify'>
    <undefined-condition
          xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
    <text xml:lang='en'
          xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'>
      [ ... application-specific information ... ]
    </text>
    <too-many-parameters xmlns='http://example.com/ns'/>
  </error>
</message>
          ]]></artwork>
        </figure>
        <t>An entity that receives an application-specific error condition it does not understand MUST ignore the condition.</t>
      </section>
    </section>

    <section title="Extended Content" anchor="stanzas-extended">
      <t><iref item='Extended Content'/>Although the message, presence, and IQ stanzas provide basic semantics for messaging, availability, and request-response interactions, XMPP uses XML namespaces (see <xref target='XML-NAMES'/> to extend the basic stanza syntax for the purpose of providing additional functionality.</t>
      <t>A message or presence stanza MAY contain one or more optional child elements specifying content that extends the meaning of the message (e.g., an XHTML-formatted version of the message body as described in <xref target="XEP-0071"/>), and an IQ stanza of type "get" or "set" MUST contain one such child element.  Such a child element MAY have any name and MUST possess a namespace declaration (other than "jabber:client", "jabber:server", or "http://etherx.jabber.org/streams") that defines all data contained within the child element.  Such a child element is called an "extension element".  An extension element can be included either at the direct child level of the stanza or in any mix of levels.</t>
      <t>Similarly, "extension attributes" are allowed.  That is: a stanza itself (i.e., the &lt;iq/&gt;, &lt;message/&gt;, and &lt;presence/&gt; elements qualified by the "jabber:client" or "jabber:server" namespace declared as the default namespace for the stream) and any child element of such a stanza (whether a child element qualifed by the default namespace or an extension element) MAY also include one or more attributes that are qualified by XML namespaces that are different from the default namespace or the reserved "xml" prefix (including the "empty namespace" if the attribute is not prefixed).  For the sake of backward compatibility and maximum interoperability, an entity that generates a stanza SHOULD NOT include such attributes in the stanza itself or in child elements of the stanza that are qualified by the default namespace (e.g., the message &lt;body/&gt; element).</t>
      <t>An extension element or extension attribute is said to be EXTENDED CONTENT and the namespace name for such an element or attribute is said to be an EXTENDED NAMESPACE.</t>
      <t>To illustrate these concepts, several examples follow.</t>
      <t>The following stanza contains one direct child element whose extended namespace is 'jabber:iq:roster':</t>
      <figure>
        <artwork><![CDATA[
<iq from='juliet@capulet.com/balcony'
    id='roster1'
    type='get'>
 <query xmlns='jabber:iq:roster'/>
</iq>
        ]]></artwork>
      </figure>
      <t>The following stanza contains two direct child elements with two different extended namespaces.</t>
      <figure>
        <artwork><![CDATA[
<presence from='juliet@capulet.com/balcony'>
  <c xmlns='http://jabber.org/protocol/caps' 
     node='http://exodus.jabberstudio.org/caps'
     ver='0.9'/>
  <x xmlns='vcard-temp:x:update'>
    <photo>sha1-hash-of-image</photo>
  </x>
</presence>
        ]]></artwork>
      </figure>
      <t>The following stanza contains two child elements, one of which is qualified by the default namespace and one of which is qualified by an extended namespace; the extension element in turn contains a child elememnt that is qualified by a different extended namespace.</t>
      <figure>
        <artwork><![CDATA[
<message to='juliet@capulet.com'>
  <body>Hello?</body>
  <html xmlns='http://jabber.org/protocol/xhtml-im'>
    <body xmlns='http://www.w3.org/1999/xhtml'>
      <p style='font-weight:bold'>Hello?</t>
    </body>
  </html>
</message>
        ]]></artwork>
      </figure>
      <t>It is conventional in the XMPP community for implementations to not generate namespace prefixes for elements that are qualified by extended namespaces.  However, if an implementation generates such namespace prefixes then it MUST include the namespace declaration in the stanza itself or a child element of the stanza, not in the stream header (see <xref target='streams-ns-other'/>).</t>
      <t>Routing entities (typically servers) SHOULD try to maintain prefixes when serializing XML stanzas for processing, but receiving entities MUST NOT rely on the prefix strings having any particular value.</t>
      <t>Support for any given extended namespace is OPTIONAL on the part of any implementation.  If an entity does not understand such a namespace, the entity's expected behavior depends on whether the entity is (1) the recipient or (2) an entity that is routing the stanza to the recipient.</t>
      <t><list style="hanging">
        <t hangText="Recipient:">If a recipient receives a stanza that contains an element or attribute it does not understand, it MUST silently ignore that particular XML data, i.e., it MUST NOT process it or present it to a user or associated application (if any).  In particular:
          <list style='symbols'>
            <t>If an entity receives a message or presence stanza that contains XML data qualified by a namespace it does not understand, the portion of the stanza that qualified by the unknown namespace MUST be ignored.</t>
            <t>If an entity receives a message stanza whose only child element is qualified by a namespace it does not understand, it MUST ignore the entire stanza.</t>
            <t>If an entity receives an IQ stanza of type "get" or "set" containing a child element qualified by a namespace it does not understand, the entity MUST return an IQ stanza of type "error" with an error condition of &lt;service-unavailable/&gt;.</t>
          </list>
        </t>
        <t hangText="Router:">If a routing entity (typically a server) handles a stanza that contains a child element it does not understand, it MUST ignore the associated XML data by routing or delivering it untouched to the recipient.</t>
      </list></t>
    </section>

    <section title="Stanza Size" anchor="stanza-size">
      <t>XMPP is optimized for the exchange of relatively large numbers of relatively small stanzas.  A client or server MAY enforce a maximum stanza size.  The maximum stanza size MUST NOT be smaller than 10000 bytes, from the opening "&lt;" character to the closing "&gt;" character.  If an entity receives a stanza that exceeds its maximum stanza size, it MUST return a &lt;not-acceptable/&gt; stanza error or a &lt;policy-violation/&gt; stream error.</t>
    </section>

  </section>

  <section title="Examples" anchor="examples">
    <section title="Client-to-Server" anchor="examples-c2s">
      <t>The following examples show the XMPP data flow for a client negotiating an XML stream with a server, exchanging XML stanzas, and closing the negotiated stream.  The server is "im.example.com", the server requires use of TLS, the client authenticates via the SASL PLAIN mechanism as "juliet@im.example.com", and the client binds a client-submitted resource to the stream.  It is assumed that before sending the initial stream header, the client has already resolved an SRV record of _xmpp-client._tcp.im.example.com and has opened a TCP connection to the advertised port at the resolved IP address.</t>
      <t><list style='empty'><t>Note: The alternate steps shown are provided only to illustrate the protocol for failure cases; they are not exhaustive and would not necessarily be triggered by the data sent in the examples.</t></list></t>
      <section title="TLS" anchor="examples-c2s-tls">
        <figure>
          <preamble>Step 1: Client initiates stream to server:</preamble>
          <artwork><![CDATA[
C: <stream:stream
     from='juliet@im.example.com'
     to='im.example.com'
     version='1.0'
     xml:lang='en'
     xmlns='jabber:client'
     xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 2: Server responds by sending a response stream header to client:</preamble>
          <artwork><![CDATA[
S: <stream:stream
     from='im.example.com'
     id='t7AMCin9zjMNwQKDnplntZPIDEI='
     to='juliet@im.example.com'
     version='1.0'
     xml:lang='en'
     xmlns='jabber:client'
     xmlns:stream='http://etherx.jabber.org/streams'
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 3: Server sends stream features to client (STARTTLS extension only at this point):</preamble>
          <artwork><![CDATA[
S: <stream:features>
     <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'>
       <required/>
     </starttls>
   </stream:features>
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 4: Client sends STARTTLS command to server:</preamble>
          <artwork><![CDATA[
C: <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 5: Server informs client that it is allowed to proceed:</preamble>
          <artwork><![CDATA[
S: <proceed xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 5 (alt): Server informs client that STARTTLS negotiation has failed and closes both XML stream and TCP connection:</preamble>
          <artwork><![CDATA[
S: <failure xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>

S: </stream:stream>
          ]]></artwork>
        </figure>
        <t>Step 6: Client and server attempt to complete TLS negotiation over the existing TCP connection (see <xref target='TLS'/> for details).</t>
        <figure>
          <preamble>Step 7: If TLS negotiation is successful, client initiates a new stream to server:</preamble>
          <artwork><![CDATA[
C: <stream:stream
     from='juliet@im.example.com'
     to='im.example.com'
     version='1.0'
     xml:lang='en'
     xmlns='jabber:client'
     xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <t>Step 7 (alt): If TLS negotiation is unsuccessful, server closes TCP connection.</t>
      </section>
      <section title="SASL" anchor="examples-c2s-sasl">
        <figure>
          <preamble>Step 8: Server responds by sending a stream header to client along with any available stream features:</preamble>
          <artwork><![CDATA[
S: <stream:stream
     from='im.example.com'
     id='vgKi/bkYME8OAj4rlXMkpucAqe4='
     to='juliet@im.example.com'
     version='1.0'
     xml:lang='en'
     xmlns='jabber:client'
     xmlns:stream='http://etherx.jabber.org/streams'

S: <stream:features>
     <mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
       <mechanism>DIGEST-MD5</mechanism>
       <mechanism>PLAIN</mechanism>
     </mechanisms>
   </stream:features>
            ]]></artwork>
          </figure>
        <figure>
          <preamble>Step 9: Client selects an authentication mechanism, in this case <xref target='PLAIN'/>:</preamble>
          <artwork><![CDATA[
C: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
         mechanism='PLAIN'>AGp1bGlldAByMG0zMG15cjBtMzA=</auth>
          ]]></artwork>
          <postamble>The decoded base64 data is "U+0000julietU+0000r0m30myr0m30", i.e., a username of "juliet" and a password of "r0m30myr0m30" with the actual ASCII 0 (or NUL) character as separator.</postamble>
        </figure>
        <figure>
          <preamble>Step 10: Server informs client of success:</preamble>
          <artwork><![CDATA[
S: <success xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 10 (alt): Server returns error to client:</preamble>
          <artwork><![CDATA[
S: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     <not-authorized/>
   </failure>
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 11: Client initiates a new stream to server:</preamble>
          <artwork><![CDATA[
C: <stream:stream
     from='juliet@im.example.com'
     to='im.example.com'
     version='1.0'
     xml:lang='en'
     xmlns='jabber:client'
     xmlns:stream='http://etherx.jabber.org/streams'
          ]]></artwork>
        </figure>
      </section>
      <section title="Resource Binding" anchor="examples-c2s-bind">
        <figure>
          <preamble>Step 12: Server responds by sending a stream header to client along with supported features (in this case resource binding):</preamble>
          <artwork><![CDATA[
S: <stream:stream
     from='im.example.com'
     id='gPybzaOzBmaADgxKXu9UClbprp0='
     to='juliet@im.example.com'
     version='1.0'
     xml:lang='en'
     xmlns='jabber:client'
     xmlns:stream='http://etherx.jabber.org/streams'>

S: <stream:features>
     <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>
   </stream:features>
          ]]></artwork>
        </figure>
        <t>Upon being so informed that resource binding is mandatory, the client needs to bind a resource to the stream; here we assume that the client submits a human-readable text string.</t>
        <figure>
          <preamble>Step 13: Client binds a resource:</preamble>
          <artwork><![CDATA[
C: <iq id='bind_1' type='set'>
     <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
       balcony
     </bind>
   </iq>
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 14: Server accepts submitted resourcepart and informs client of successful resource binding:</preamble>
          <artwork><![CDATA[
S: <iq id='bind_1' type='result'>
     <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
       <jid>
         juliet@im.example.com/balcony
       </jid>
     </bind>
   </iq>
          ]]></artwork>
        </figure>
      </section>
      <section title="Stanza Exchange" anchor="examples-c2s-stanzas">
        <t>Now the client is allowed to send XML stanzas over the negotiated stream.</t>
        <figure>
          <artwork><![CDATA[
C: <message from='juliet@im.example.com/balcony'
            to='romeo@example.net'
            xml:lang='en'>
     <body>Art thou not Romeo, and a Montague?</body>
   </message>
          ]]></artwork>
        </figure>
        <t>If necessary, sender's server negotiates XML streams with intended recipient's server (see <xref target='examples-s2s'/>).</t>
        <t>The intended recipient replies and the message is delivered to the client.</t>
        <figure>
          <artwork><![CDATA[
E: <message from='romeo@example.net/orchard'
            to='juliet@im.example.com/balcony'
            xml:lang='en'>
     <body>Neither, fair saint, if either thee dislike.</body>
   </message>
          ]]></artwork>
        </figure>
        <t>The client can subsequently send and receive an unbounded number of subsequent XML stanzas over the stream.</t>
      </section>
      <section title="Close" anchor="examples-c2s-close">
        <t>Desiring to send no further messages, the client closes the stream.</t>
        <figure>
          <artwork><![CDATA[
C: </stream:stream>
          ]]></artwork>
        </figure>
        <t>Consistent with the recommended stream closing handshake, the server closes the stream as well:</t>
        <figure>
          <artwork><![CDATA[
S: </stream:stream>
          ]]></artwork>
        </figure>
        <t>Client now terminates the underlying TCP connection.</t>
      </section>
    </section>
    <section title="Server-to-Server Examples" anchor="examples-s2s">
      <t>The following examples show the data flow for a server negotiating an XML stream with another server, exchanging XML stanzas, and closing the negotiated stream.  The initiating server ("Server1") is im.example.com; the receiving server ("Server2") is example.net and it requires use of TLS; im.example.com presents a certificate and authenticates via the SASL EXTERNAL mechanism.  It is assumed that before sending the initial stream header, Server1 has already resolved an SRV record of _xmpp-server._tcp.example.net and has opened a TCP connection to the advertised port at the resolved IP address.</t>
      <t><list style='empty'><t>Note: The alternate steps shown are provided only to illustrate the protocol for failure cases; they are not exhaustive and would not necessarily be triggered by the data sent in the examples.</t></list></t>
      <section title="TLS" anchor="examples-s2s-tls">
        <figure>
          <preamble>Step 1: Server1 initiates stream to Server2:</preamble>
          <artwork><![CDATA[
S1: <stream:stream
      from='im.example.com'
      to='example.net'
      version='1.0'
      xmlns='jabber:server'
      xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 2: Server2 responds by sending a response stream header to Server1:</preamble>
          <artwork><![CDATA[
S2: <stream:stream
      from='example.net'
      id='hTiXkW+ih9k2SqdGkk/AZi0OJ/Q='
      to='im.example.com'
      version='1.0'
      xmlns='jabber:server'
      xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 3: Server2 sends stream features to Server1:</preamble>
          <artwork><![CDATA[
S2: <stream:features>
      <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'>
        <required/>
      </starttls>
    </stream:features>
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 4: Server1 sends the STARTTLS command to Server2:</preamble>
          <artwork><![CDATA[
S1: <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 5: Server2 informs Server1 that it is allowed to proceed:</preamble>
          <artwork><![CDATA[
S2: <proceed xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 5 (alt): Server2 informs Server1 that STARTTLS negotiation has failed and closes stream:</preamble>
          <artwork><![CDATA[
S2: <failure xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>

S2: </stream:stream>
          ]]></artwork>
        </figure>
        <t>Step 6: Server1 and Server2 attempt to complete TLS negotiation via TCP (see <xref target='TLS'/> for details).</t>
        <figure>
          <preamble>Step 7: If TLS negotiation is successful, Server1 initiates a new stream to Server2:</preamble>
          <artwork><![CDATA[
S1: <stream:stream
      from='im.example.com'
      to='example.net'
      version='1.0'
      xmlns='jabber:server'
      xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <t>Step 7 (alt): If TLS negotiation is unsuccessful, Server2 closes TCP connection.</t>
      </section>
      <section title="SASL" anchor="examples-s2s-sasl">
        <figure>
          <preamble>Step 8: Server2 sends a response stream header to Server1 along with available stream features (including a preference for the SASL EXTERNAL mechanism):</preamble>
          <artwork><![CDATA[
S2: <stream:stream
      from='example.net'
      id='RChdjlgj/TIBcbT9Keu31zDihH4='
      to='im.example.com'
      version='1.0'
      xmlns='jabber:server'
      xmlns:stream='http://etherx.jabber.org/streams'>

S2: <stream:features>
      <mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
        <mechanism>EXTERNAL</mechanism>
      </mechanisms>
    </stream:features>
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 9: Server1 selects the EXTERNAL mechanism, in this case with an authorization identity encoded according to <xref target="BASE64"/>:</preamble>
          <artwork><![CDATA[
S1: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
          mechanism='EXTERNAL'/>aW0uZXhhbXBsZS5jb20=</auth>
          ]]></artwork>
          <postamble>The decoded authorization identity is "im.example.com".</postamble>
        </figure>
        <figure>
          <preamble>Step 10: Server2 determines that the authorization identity provided by Server1 matches the information in the presented certificate and therefore returns success:</preamble>
          <artwork><![CDATA[
S2: <success xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 10 (alt): Server2 informs Server1 of failed authentication:</preamble>
          <artwork><![CDATA[
S2: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
      <not-authorized/>
    </failure>

S2: </stream:stream>
          ]]></artwork>
         </figure>
        <figure>
          <preamble>Step 11: Server1 initiates a new stream to Server2:</preamble>
          <artwork><![CDATA[
S1: <stream:stream
      from='im.example.com'
      to='example.net'
      version='1.0'
      xmlns='jabber:server'
      xmlns:stream='http://etherx.jabber.org/streams'>
          ]]></artwork>
        </figure>
        <figure>
          <preamble>Step 12: Server2 responds by sending a stream header to Server1 along with any additional features (or, in this case, an empty features element):</preamble>
          <artwork><![CDATA[
S2: <stream:stream
      from='example.net'
      id='MbbV2FeojySpUIP6J91qaa+TWHM='
      to='im.example.com'
      version='1.0'
      xmlns='jabber:server'
      xmlns:stream='http://etherx.jabber.org/streams'>

S2: <stream:features/>
          ]]></artwork>
        </figure>
      </section>
      <section title="Stanza Exchange" anchor="examples-s2s-stanzas">
        <t>Now Server1 is allowed to send XML stanzas to Server2 over the negotiated stream; here we assume that the transferred stanzas are those shown earlier for client-to-server communication, albeit over a server-to-server stream qualified by the 'jabber:server' namespace.</t>
        <figure>
          <preamble>Server1 sends XML stanza to Server2:</preamble>
          <artwork><![CDATA[
S1: <message from='juliet@im.example.com/balcony'
             to='romeo@example.net'
             xml:lang='en'>
    <body>Art thou not Romeo, and a Montague?</body>
   </message>
          ]]></artwork>
        </figure>
        <t>The intended recipient replies and the message is delivered from Server2 to Server1.</t>
        <figure>
          <preamble>Server2 sends XML stanza to Server1:</preamble>
          <artwork><![CDATA[
S2: <message from='romeo@example.net/orchard'
             to='juliet@im.example.com/balcony'
             xml:lang='en'>
      <body>Neither, fair saint, if either thee dislike.</body>
    </message>
          ]]></artwork>
        </figure>
      </section>
      <section title="Close" anchor="examples-s2s-close">
        <t>Desiring to send no further messages, Server1 closes the stream.  (In practice, the stream would most likely remain open for some time, since Server1 and Server2 do not immediately know if the stream will be needed for further communication.)</t>
        <figure>
          <artwork><![CDATA[
S1: </stream:stream>
          ]]></artwork>
        </figure>
        <t>Consistent with the recommended stream closing handshake, Server2 closes the stream as well:</t>
        <figure>
          <artwork><![CDATA[
S2: </stream:stream>
          ]]></artwork>
        </figure>
        <t>Server1 now terminates the underlying TCP connection.</t>
      </section>
    </section>
  </section>

  <section title="Server Rules for Processing XML Stanzas" anchor="rules">
    <t>An XMPP server MUST ensure in-order processing of XML stanzas between any two entities.  This includes stanzas sent by a client to its server for direct processing by the server (e.g., in-order processing of a roster get and initial presence as described in <xref target='XMPP-IM'/>).</t>
    <t>Beyond the requirement for in-order processing, each server implementation will contain its own logic for processing stanzas it receives.  Such logic determines whether the server needs to ROUTE a given stanza to another domain, DELIVER it to a local entity (typically a connected client associated with a local account), or HANDLE it directly within the server itself.  The following rules apply.</t>
    <t><list style='empty'><t>Note: Particular XMPP applications MAY specify delivery rules that modify or supplement the following rules; for example, a set of delivery rules for instant messaging and presence applications is defined in <xref target="XMPP-IM"/>.</t></list></t>
    <section title="No 'to' Address" anchor="rules-noto">
      <section title="Overview" anchor="rules-noto-overview">
        <t>If the stanza possesses no 'to' attribute, the server MUST handle it directly on behalf of the entity that sent it, where the meaning of "handle it directly" depends on whether the stanza is message, presence, or IQ.  Because all stanzas received from other servers MUST possess a 'to' attribute, this rule applies only to stanzas received from a local entity (such as a client) that is connected to the server.</t>
      </section>
      <section title="Message" anchor="rules-noto-message">
        <t>If the server receives a message stanza with no 'to' attribute, it MUST treat the message as if the 'to' address were the bare JID &lt;localpart@domain&gt; of the sending entity.</t>
      </section>
      <section title="Presence" anchor="rules-noto-presence">
        <t>If the server receives a presence stanza with no 'to' attribute, it MUST broadcast it to the entities that are subscribed to the sending entity's presence, if applicable (<xref target="XMPP-IM"/> defines the semantics of such broadcasting for presence applications).</t>
      </section>
      <section title="IQ" anchor="rules-noto-IQ">
        <t>If the server receives an IQ stanza with no 'to' attribute, it MUST process the stanza on behalf of the account from which received the stanza, as follows:</t>
        <t>
          <list style='numbers'>
            <t>If the IQ stanza is of type "get" or "set" and the server understands the namespace that qualifies the payload, the server MUST handle the stanza on behalf of the sending entity or return an appropriate error to the sending entity.  While the meaning of "handle" is determined by the semantics of the qualifying namespace, in general the server will respond to the IQ stanza of type "get" or "set" by returning an appropriate IQ stanza of type "result" or "error", responding as if the server were the bare JID of the sending entity.  As an example, if the sending entity sends an IQ stanza of type "get" where the payload is qualified by the 'jabber:iq:roster' namespace (as described in <xref target='XMPP-IM'/>), then the server will return the roster associated with the sending entity's bare JID to the particular resource of the sending entity that requested the roster.</t>
            <t>If the IQ stanza is of type "get" or "set" and the server does not understand the namespace that qualifies the payload, the server MUST return an error to the sending entity, which MUST be &lt;service-unavailable/&gt;.</t>
            <t>If the IQ stanza is of type "error" or "result", the server MUST handle the error or result as appropriate for the request-response interaction, responding as if the server were the bare JID of the sending entity.</t>
          </list>
        </t>
      </section>
    </section>
    <section title="Local Domain" anchor="rules-local">
      <t>If the hostname of the domainpart of the JID contained in the 'to' attribute matches one of the configured hostnames of the server itself, the server MUST first determine if the hostname is serviced by the server or by a specialized local service.  If the latter, the server MUST route the stanza to that service.  If the former, the server MUST proceed as follows.</t>
      <section title="Mere Domain" anchor="rules-local-domain">
        <t>If the JID contained in the 'to' attribute is of the form &lt;domain&gt;, then the server MUST either handle the stanza as appropriate for the stanza kind or return an error stanza to the sender.</t>
      </section>
      <section title="Domain with Resource" anchor="rules-local-domainresource">
        <t>If the JID contained in the 'to' attribute is of the form &lt;domain/resource&gt;, then the server MUST either handle the stanza as appropriate for the stanza kind or return an error stanza to the sender.</t>
      </section>
      <section title="Localpart at Domain" anchor="rules-local-localpart">
        <t><list style='empty'><t>Note: For addresses of this type, more detailed rules in the context of instant messaging and presence applications are provided in <xref target='XMPP-IM'/>.</t></list></t>
        <section title="No Such User" anchor="rules-local-localpart-nosuchuser">
          <t>If there is no local account associated with the &lt;localpart@domain&gt;, how the stanza is processed depends on the stanza type.</t>
          <t>
            <list style='symbols'>
              <t>For a message stanza, the server MUST return a &lt;service-unavailable/&gt; stanza error to the sender.</t>
              <t>For a presence stanza, the server SHOULD silently discard the stanza.</t>
              <t>For an IQ stanza, the server MUST return a &lt;service-unavailable/&gt; stanza error to the sender.</t>
            </list>
          </t>
        </section>
        <section title="Bare JID" anchor="rules-local-localpart-barejid">
          <t>If the JID contained in the 'to' attribute is of the form &lt;localpart@domain&gt;, how the stanza is processed depends on the stanza type.</t>
          <t>
            <list style='symbols'>
              <t>For a message stanza, if there exists at least one connected resource for the account the server SHOULD deliver it to at least one of the connected resources.  If there exists no connected resource, the server MUST either return an error or store the message offline for delivery when the account next has a connected resource.</t>
              <t>For a presence stanza, if there exists at least one connected resource for the account the server SHOULD deliver it to at least one of the connected resources.  If there exists no connected resource, the server MUST silently discard the stanza.</t>
              <t>For an IQ stanza, the server MUST handle it directly on behalf of the intended recipient.</t>
            </list>
          </t>
        </section>
        <section title="Full JID" anchor="rules-local-localpart-fulljid">
          <t>If the JID contained in the 'to' attribute is of the form &lt;localpart@domain/resource&gt; and there is no connected resource that exactly matches the full JID, the stanza is processed as if the JID were of the form &lt;localpart@domain&gt;.</t>
          <t>If the JID contained in the 'to' attribute is of the form &lt;localpart@domain/resource&gt; and there is a connected resource that exactly matches the full JID, the server SHOULD deliver the stanza to that connected resource.</t>
        </section>
      </section>
    </section>
    <section title="Remote Domain" anchor="rules-remote">
      <t>If the hostname of the domainpart of the JID contained in the 'to' attribute does not match one of the configured hostnames of the server itself, the server SHOULD attempt to route the stanza to the remote domain (subject to local service provisioning and security policies regarding inter-domain communication, since such communication is optional for any given deployment).  There are two possible cases.</t>
      <section title="Existing Stream" anchor="rules-remote-existing">
        <t>If a server-to-server stream already exists between the two domains, the sender's server will attempt to route the stanza to the authoritative server for the remote domain over the existing stream.</t>
      </section>
      <section title="No Existing Stream" anchor="rules-remote-nostream">
        <t>If there exists no server-to-server stream between the two domains, the sender's server will proceed as follows:</t>
        <t>
          <list style='numbers'>
            <t>Resolve the hostname of the remote domain (as defined under <xref target="security-server"/>).</t>
            <t>Negotiate a server-to-server stream between the two domains (as defined under <xref target='tls'/> and <xref target='sasl'/>).</t>
            <t>Route the stanza to the authoritative server for the remote domain over the newly-established stream.</t>
          </list>
        </t>
      </section>
      <section title="Error Handling" anchor="rules-remote-error">
        <t>If routing of a stanza to the intended recipient's server is unsuccessful, the sender's server MUST return an error to the sender.  If resolution of the remote domain is unsuccessful, the stanza error MUST be &lt;remote-server-not-found/&gt;.  If resolution succeeds but streams cannot be negotiated, the stanza error MUST be &lt;remote-server-timeout/&gt;.</t>
        <t>If stream negotiation with the intended recipient's server is successful but the remote server cannot deliver the stanza to the recipient, the remote server MUST return an appropriate error to the sender by way of the sender's server.</t>
      </section>
    </section>
  </section>

  <section title="XML Usage" anchor="xml">
    <section title="Restrictions" anchor="xml-restrictions">
      <t>The Extensible Messaging and Presence Protocol (XMPP) defines a class of data objects called XML streams as well as the behavior of computer programs that process XML streams.  XMPP is an application profile or restricted form of the Extensible Markup Language <xref target='XML'/>, and a complete XML stream (including start and end stream tags) is a conforming XML document.</t>
      <t>However, XMPP does not deal with XML documents but with XML streams.  Because XMPP does not require the parsing of arbitrary and complete XML documents, there is no requirement that XMPP needs to support the full feature set of <xref target="XML"/>.  In particular, the following features of XML are prohibited in XMPP:</t>
      <t>
        <list style='symbols'>
          <t>comments (as defined in Section 2.5 of <xref target="XML"/>)</t>
          <t>processing instructions (Section 2.6 therein)</t>
          <t>internal or external DTD subsets (Section 2.8 therein)</t>
          <t>internal or external entity references (Section 4.2 therein) with the exception of the predefined entities (Section 4.6 therein)</t>
        </list>
      </t>
      <t>An XMPP implementation MUST behave as follows with regard to these features:</t>
      <t>
        <list style='numbers'>
          <t>An XMPP implementation MUST NOT inject characters matching such features into an XML stream.</t>
          <t>If an XMPP implementation receives characters matching such features over an XML stream, it MUST return a stream error, which SHOULD be &lt;restricted-xml/&gt; but MAY be &lt;bad-format/&gt;.</t>
        </list>
      </t>
    </section>

    <section title="XML Namespace Names and Prefixes" anchor="xml-ns">
      <t>XML namespaces (see <xref target="XML-NAMES"/>) are used within XMPP streams to create strict boundaries of data ownership.  The basic function of namespaces is to separate different vocabularies of XML elements that are structurally mixed together.  Ensuring that XMPP streams are namespace-aware enables any allowable XML to be structurally mixed with any data element within XMPP.  XMPP-specific rules for XML namespace names and prefixes are defined under <xref target='streams-ns'/> for XML streams and <xref target='stanzas-extended'/> for XML stanzas.</t>
    </section>

    <section title="Well-Formedness" anchor="xml-wellformed">
      <t>There are two varieties of well-formedness:</t>
      <t>
        <list style='symbols'>
          <t>"XML-well-formedness" in accordance with the definition of "well-formed" in Section 2.1 of <xref target='XML'/>.</t>
          <t>"Namespace-well-formedness" in accordance with the definition of "namespace-well-formed" in Section 7 of <xref target='XML-NAMES'/>.</t>
        </list>
      </t>
      <t>The following rules apply.</t>
      <t>An XMPP entity MUST NOT generate data that is not XML-well-formed.  An XMPP entity MUST NOT accept data that is not XML-well-formed; instead it MUST return an &lt;xml-not-well-formed/&gt; stream error and close the stream over which the data was received.</t>
      <t>An XMPP entity MUST NOT generate data that is not namespace-well-formed.  An XMPP server MUST NOT route or deliver data that is not namespace-well-formed, and MUST return a stanza error of &lt;not-acceptable/&gt; or a stream error of &lt;xml-not-well-formed/&gt; in response to the receipt of such data.</t>
      <t><list style='empty'><t>Note: Because these restrictions were underspecified in the predecessor to this specification, it is possible that implementations based on that predecessor will send data that does not comply with the restrictions.</t></list></t>
    </section>

    <section title="Validation" anchor="xml-validation">
      <t>A server is not responsible for ensuring that XML data delivered to a client or routed to another server is valid, in accordance with the definition of "valid" provided in Section 2.8 of <xref target='XML'/>.  An implementation MAY choose to accept or provide only validated data, but such behavior is OPTIONAL.  A client SHOULD NOT rely on the ability to send data that does not conform to the schemas, and SHOULD ignore any non-conformant elements or attributes on the incoming XML stream.</t>
      <t><list style='empty'><t>Note: The terms "valid" and "well-formed" are distinct in XML.</t></list></t>
    </section>

    <section title="Inclusion of XML Declaration" anchor="xml-declaration">
      <t>Before sending a stream header, an implementation SHOULD send an XML declaration (matching production [23] content of <xref target='XML'/>).  Applications MUST follow the rules provided in <xref target="XML"/> regarding the format of the XML declaration and the circumstances under which the XML declaration is included.</t>
    </section>

    <section title="Character Encoding" anchor="xml-encoding">
      <t>Implementations MUST support the UTF-8 transformation of Universal Character Set <xref target="UCS2"/> characters, as needed for conformance with <xref target="CHARSET"/> and as defined in <xref target='UTF-8'/>.  Implementations MUST NOT attempt to use any other encoding.  If one party to an XML stream detects that the other party has attempted to send XML data with an encoding other than UTF-8, it MUST return a stream error, which SHOULD be &lt;unsupported-encoding/&gt; but MAY be &lt;bad-format/&gt;.</t>
      <t>Note: Because it is mandatory for an XMPP implementation to support all and only the UTF-8 encoding and because UTF-8 always has the same byte order, an implementation MUST NOT send a byte order mark ("BOM") at the beginning of the data stream.  If an entity receives the Unicode character U+FEFF anywhere in an XML stream (including as the first character of the stream), it MUST interpret that character as a zero width no-break space, not as a byte order mark.</t>
    </section>

    <section title="Whitespace" anchor="xml-whitespace">
      <t>Except where explicitly disallowed (e.g., during <xref target='tls'>TLS negotiation</xref> and <xref target='sasl'>SASL negotiation</xref>), either entity MAY send whitespace as separators between XML stanzas or between any other first-level elements sent over the stream.  One common use for sending such whitespace is explained under <xref target='streams-close-idle'/>.</t>
    </section>

    <section title="XML Versions" anchor="xml-versions">
      <t>XMPP is an application profile of XML 1.0.  A future version of XMPP might be defined in terms of higher versions of XML, but this specification addresses XML 1.0 only.</t>
    </section>

  </section>

  <section title="Internationalization Considerations" anchor="i18n">
    <t>As specified under <xref target="xml-encoding"/>, XML streams MUST be encoded in UTF-8.</t>
    <t>As specified under <xref target="streams-attr"/>, an XML stream SHOULD include an 'xml:lang' attribute specifying the default language for any XML character data that is intended to be presented to a human user.  As specified under <xref target="stanzas-attributes-lang"/>, an XML stanza SHOULD include an 'xml:lang' attribute if the stanza contains XML character data that is intended to be presented to a human user.  A server SHOULD apply the default 'xml:lang' attribute to stanzas it routes or delivers on behalf of connected entities, and MUST NOT modify or delete 'xml:lang' attributes on stanzas it receives from other entities.</t>
    <t>Internationalization of XMPP addresses is specified in <xref target='XMPP-ADDR'/>.</t>
  </section>

  <section title="Security Considerations" anchor="security">
    <section title="High Security" anchor="security-high">
      <t>For the purposes of XMPP communication (client-to-server and server-to-server), the term "high security" refers to the use of security technologies that provide both mutual authentication and integrity checking (on the importance of high security, refer to <xref target='STRONGSEC'/>); in particular, when using certificate-based authentication to provide high security, a trust chain SHOULD be established out-of-band, although a shared certification authority signing certificates could allow a previously unknown certificate to establish trust in-band.  See <xref target="security-certificates"/> regarding certificate validation procedures.</t>
      <t>Implementations MUST support high security.  Service provisioning SHOULD use high security, subject to local security policies.</t>
      <t>The initial stream and the response stream MUST be secured separately, although security in both directions MAY be established via mechanisms that provide mutual authentication.</t>
    </section>
    <section title="Certificates" anchor="security-certificates">
      <t>Channel encryption of an XML stream using Transport Layer Security as described under <xref target='tls'/>, and in some cases also authentication as described under <xref target='sasl'/>, is commonly based on a digital certificate presented by the receiving entity (or, in the case of mutual authentication, both the receiving entity and the initiating entity).  This section describes best practices regarding the generation of digital certificates to be presented by XMPP entities and the verification of digital certificates presented by XMPP entities.</t>
      <t>Considerations specific to certificate geneneration and validation with regard to client certificates or server certificates are described in the following sections.</t> 
      <section title="Certificate Generation" anchor="security-certificates-generation">
        <section title="General Considerations" anchor="security-certificates-generation-general">
          <t>The following rules apply to public key certificates that are issued to XMPP entities:</t>
          <t>
            <list style='numbers'>
              <t>The certificate MUST conform to <xref target='X509'/>.</t>
              <t>The certificate MUST NOT contain a basicConstraints extension with the cA boolean set to TRUE.</t>
              <t>The subject field MUST NOT be null.</t>
              <t>The hash algorithm for the signature SHOULD be SHA-256 as defined by <xref target='X509-ALGO'/>.</t>
              <t>The certificate SHOULD include an Authority Information Access (AIA) extension that specifies the address of an Online Certificate Status Protocol <xref target='OCSP'/> responder.</t>
            </list>
          </t>
          <t>The following rules apply to issuers of XMPP certificates:</t>
          <t>
            <list style='numbers'>
              <t>The certificate MUST conform to <xref target='X509'/>.</t>
              <t>The certificate MUST contain a keyUsage extension with the digitalSignature bit set.</t>
              <t>The subject field MUST NOT be null.</t>
              <t>The hash algorithm for the signature SHOULD be SHA-256 as defined by <xref target='X509-ALGO'/>.</t>
              <t>For issuers of public key certificates, the issuer's certificate MUST contain a basicConstraints extension with the cA boolean set to TRUE.</t>
              <t>For issuers of access certificates, the issuer's certificate MUST NOT contain a basicConstraints extension with the cA boolean set to TRUE.</t>
            </list>
          </t>
        </section>
        <section title="Server Certificates" anchor="security-certificates-generation-server">
          <t>In a digital certificate to be presented by an XMPP server (i.e., a SERVER CERTIFICATE), it is RECOMMENDED for the certificate to include one or more JIDs (i.e., domainparts) associated with domains serviced at the server.  The representations described in the following sections are RECOMMENDED.  These representations are provided in preference order.</t>
          <section title="SRVName" anchor="security-certificates-generation-server-srvname">
            <t>A server's domainpart SHOULD be represented as an SRVName, i.e., as an otherName field of type "id-on-dnsSRV" as specified in <xref target='X509-SRV'/>.</t>
          </section>
          <section title="dNSName" anchor="security-certificates-generation-server-dnsname">
            <t>A server's domainpart SHOULD be represented as a dNSName, i.e., as a subjectAltName extension of type dNSName.</t>
            <t>The dNSName MAY contain one instance of the wildcard character '*'.  The wildcard character applies only to the left-most domain name component and matches any single component (thus a dNSName of *.example.com matches foo.example.com but not bar.foo.example.com or example.com itself).  The wildcard character is not allowed in component fragments (thus a dNSName of im*.example.net is not allowed and SHALL NOT be taken to match im1.example.net and im2.example.net).</t>
          </section>
          <section title="XmppAddr" anchor="security-certificates-generation-server-xmppaddr">
            <t>A server's domainpart MAY be represented as an XmppAddr, i.e., as a UTF8String within an otherName entity inside the subjectAltName, using the <xref target="ASN.1"/> Object Identifier "id-on-xmppAddr" specified under <xref target='security-certificates-generation-oid'/>.  In server certificates, this representation is included only for the sake of backward-compatibility.</t>
          </section>
          <section title="Common Name" anchor="security-certificates-generation-server-cn">
            <t>A server's domainpart SHOULD NOT be represented as a Common Name; instead, the Common Name field SHOULD be reserved for representation of a human-friendly name.</t>
          </section>
          <section title="Examples" anchor="security-certificates-generation-server-examples">
            <t>For our first (relatively simple) example, consider a company called "Example Products, Inc."  It hosts an XMPP service at "im.example.com" (i.e., user addresses at the service are of the form "user@im.example.com"), and SRV lookups for the xmpp-client and xmpp-server services at "im.example.com" yield one machine, called "x.example.com", as follows:</t>
            <figure>
              <artwork><![CDATA[
_xmpp-client._tcp.im.example.com. 400 IN SRV 20 0 5222 x.example.com
_xmpp-server._tcp.im.example.com. 400 IN SRV 20 0 5269 x.example.com
              ]]></artwork>
            </figure>
            <t>The certificate presented by x.example.com contains the following representations:</t>
            <t>
              <list style='symbols'>
                <t>An otherName type of SRVName (id-on-dnsSRV) containing an IA5String (ASCII) string of: "_xmpp-client.im.example.com"</t>
                <t>An otherName type of SRVName (id-on-dnsSRV) containing an IA5String (ASCII) string of: "_xmpp-server.im.example.com"</t>
                <t>A dNSName containing an ASCII string of "im.example.com"</t>
                <t>An otherName type of XmppAddr (id-on-xmppAddr) containing a UTF-8 string of: "im.example.com"</t>
                <t>A CN containing an ASCII string of "Example Products, Inc."</t>
              </list>
            </t>
            <t>For our second (more complex) example, consider an ISP called "Example Internet Services".  It hosts an XMPP service at "example.net" (i.e., user addresses at the service are of the form "user@example.net"), but SRV lookups for the xmpp-client and xmpp-server services at "example.net" yield two machines ("x1.example.net" and "x2.example.net"), as follows:</t>
            <figure>
              <artwork><![CDATA[
_xmpp-client._tcp.example.net. 68400 IN SRV 20 0 5222 x1.example.net.
_xmpp-client._tcp.example.net. 68400 IN SRV 20 0 5222 x2.example.net.
_xmpp-server._tcp.example.net. 68400 IN SRV 20 0 5269 x1.example.net.
_xmpp-server._tcp.example.net. 68400 IN SRV 20 0 5269 x2.example.net.
              ]]></artwork>
            </figure>
            <t>Example Internet Services also hosts chatrooms at chat.example.net, and provides an xmpp-server SRV record for that service as well (thus enabling entity from remote domains to access that service).  It also might provide other such services in the future, so it wishes to represent a wildcard in its certificate to handle such growth.</t>
            <t>The certificate presented by either x1.example.net or x2.example.net contains the following representations:</t>
            <t>
              <list style='symbols'>
                <t>An otherName type of SRVName (id-on-dnsSRV) containing an IA5String (ASCII) string of: "_xmpp-client.example.net"</t>
                <t>An otherName type of SRVName (id-on-dnsSRV) containing an IA5String (ASCII) string of: "_xmpp-server.example.net"</t>
                <t>An otherName type of SRVName (id-on-dnsSRV) containing an IA5String (ASCII) string of: "_xmpp-server.chat.example.net"</t>
                <t>A dNSName containing an ASCII string of "example.net"</t>
                <t>A dNSName containing an ASCII string of "*.example.net"</t>
                <t>An otherName type of XmppAddr (id-on-xmppAddr) containing a UTF-8 string of: "example.net"</t>
                <t>An otherName type of XmppAddr (id-on-xmppAddr) containing a UTF-8 string of: "chat.example.net"</t>
                <t>A CN containing an ASCII string of "Example Internet Services"</t>
              </list>
            </t>
          </section>
        </section>
        <section title="Client Certificates" anchor="security-certificates-generation-client">
          <t>In a digital certificate to be presented by an XMPP client controlled by a human user (i.e., a CLIENT CERTIFICATE), it is RECOMMENDED for the certificate to include one or more JIDs associated with an XMPP user.  If included, a JID MUST be represented as an XmppAddr, i.e., as a UTF8String within an otherName entity inside the subjectAltName, using the <xref target="ASN.1"/> Object Identifier "id-on-xmppAddr" specified under <xref target='security-certificates-generation-oid'/>.</t>
        </section>
        <section title="ASN.1 Object Identifier" anchor="security-certificates-generation-oid">
          <t>The <xref target="ASN.1"/> Object Identifier "id-on-xmppAddr" (also called an XmppAddr) is defined as follows.</t>
          <figure>
            <artwork><![CDATA[
id-pkix OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
        dod(6) internet(1) security(5) mechanisms(5) pkix(7) }

id-on  OBJECT IDENTIFIER ::= { id-pkix 8 }  -- other name forms

id-on-xmppAddr  OBJECT IDENTIFIER ::= { id-on 5 }

XmppAddr ::= UTF8String
            ]]></artwork>
          </figure>
          <t>As an alternative to the "id-on-xmppAddr" notation, this Object Identifier MAY be represented in dotted display format (i.e., "1.3.6.1.5.5.7.8.5") or in the Uniform Resource Name notation specified in <xref target='URN-OID'/> (i.e., "urn:oid:1.3.6.1.5.5.7.8.5").</t>
          <t>Thus for example the JID "juliet@im.example.com" as included in a certificate could be formatted in any of the following three ways:</t>
          <t>
            <list style='hanging'>
              <t hangText="id-on-xmppAddr:">subjectAltName=otherName:id-on-xmppAddr;UTF8:juliet@im.example.com</t>
              <t hangText="dotted display format:">subjectAltName=otherName:1.3.6.1.5.5.7.8.5;UTF8:juliet@im.example.com</t>
              <t hangText="URN notation:">subjectAltName=otherName:urn:oid:1.3.6.1.5.5.7.8.5;UTF8:juliet@im.example.com</t>
            </list>
          </t>
          <t>Use of the "id-on-xmppAddr" format is RECOMMENDED in the generation of certificates, but all three formats MUST be supported for the purpose of certificate validation.</t>
          <t>The "id-on-xmppAddr" object identifier MAY be used on conjuction with the extended key usage extension specified in Section 4.2.1.12 of <xref target='X509'/> in order to explicitly define and limit the intended use of a certificate to the XMPP network.</t>
        </section>
      </section>
      <section title="Certificate Validation" anchor="security-certificates-validation">
        <t>When an XMPP entity is presented with a server certificate or client certificate by a peer for the purpose of encryption or authentication of XML streams as described under <xref target='tls'/> and <xref target='sasl'/>, the entity MUST validate the certificate to determine if the certificate will be considered a TRUSTED CERTIFICATE, i.e., a certificate that is acceptable for encryption and/or authentication in accordance with the XMPP entity's local service policies or configured settings.</t>
        <t>For both server certificates and client certificates, the validating entity MUST verify the integrity of the certificate, MUST verify that the certificate has been properly signed by the issuing Certificate Authority, and MUST support certificate revocation messages.  An implementation MUST enable a human user to view information about the full chain of certificates.</t>
        <t>The following sections describe certificate validation rules for server-to-server and client-to-server streams.</t>
        <section title="Server Certificates" anchor="security-certificates-validation-server">
          <t>When an entity (client or server) validates a certificate presented by an XMPP server, there are three possible cases, as discussed in the following sections.</t>
          <section title="Case #1" anchor="security-certificates-validation-server-case1">
            <t>If the server certificate appears to be certified by a chain of certificates terminating in a trust anchor (as described in Section 6.1 of <xref target="X509"/>), the entity MUST check the certificate for any instances of the SRVName, dNSName, and XmppAddr (in that order of preference) as described under <xref target='security-certificates-generation-server-srvname'/>, <xref target='security-certificates-generation-server-dnsname'/>, and <xref target='security-certificates-generation-server-xmppaddr'/>.  There are three possible sub-cases:</t>
            <t>
              <list style='hanging'>
                <t hangText='Sub-Case #1:'>The server's certificate includes at least one presented identity that matches the reference identity to which the entity attempted to connect, in accordance with the matching rules specified in <xref target='TLS-CERTS'/>.  In this case, the entity MUST use the matched domainpart as the validated identity of the XMPP server.</t>
                <t hangText='Sub-Case #2:'>The server's certificate includes no presented identity that matches the reference identity to which the entity attempted to connect and a human user has not permanently accepted the certificate during a previous connection attempt.  In this case, the entity MUST NOT use the presented domainpart (if any) as the validated identity of the XMPP server.  Instead, if the connecting entity is a user-oriented client then it MUST either (1) automatically terminate the connection with a bad certificate error or (2) show the certificate (including the entire certificate chain) to the user and give the user the choice of terminating the connecting or accepting the certificate temporarily (i.e., for this connection attempt only) or permanently (i.e., for all future connection attempts) and then continuing with the connection; if a user permanently accepts a certificate in this way, the client MUST cache the certificate (or some non-forgeable representation such as a hash value) and in future connection attempts behave as in Sub-Case #3.  (It is the resposibility of the human user to verify the hash value or fingerprint of the certificate with the peer over a trusted communication layer.)  If the connecting entity is an XMPP server or an automated client, the application SHOULD terminate the connection (with a bad certificate error) and log the error to an appropriate audit log; an XMPP server or automated client MAY provide a configuration setting that disables this check, but MUST enable the check by default.</t>
                <t hangText='Sub-Case #3:'>The server's certificate includes no presented identity that matches the reference identity to which the entity attempted to connect but a human user has permanently accepted the certificate during a previous connection attempt; the entity MUST verify that the cached certificate was presented and MUST notify the user if the certificate has changed.</t>
              </list>
            </t>
          </section>
          <section title="Case #2" anchor="security-certificates-validation-server-case2">
            <t>If the server certificate is certified by a Certificate Authority not known to the entity, the entity MUST proceed as under Case #1, Sub-Case #2 or Case #1, Sub-Case #3 as appropriate.</t>
          </section>
          <section title="Case #3" anchor="security-certificates-validation-server-case3">
            <t>If the server certificate is self-signed, the entity MUST proceed as under Case #1, Sub-Case #2 or Case #1, Sub-Case #3 as appropriate.</t>
          </section>
        </section>
        <section title="Client Certificates" anchor="security-certificates-validation-client">
          <t>When an XMPP server validates a certificate presented by a client, there are three possible cases, as discussed in the following sections.</t>
          <section title="Case #1" anchor="security-certificates-validation-client-case1">
            <t>If the client certificate appears to be certified by a chain of certificates terminating in a trust anchor (as described in Section 6.1 of <xref target="X509"/>), the server MUST check the certificate for any instances of the XmppAddr as described under <xref target='security-certificates-generation-oid'/>.  There are three possible sub-cases:</t>
            <t>
              <list style='hanging'>
                <t hangText='Sub-Case #1:'>The server finds one XmppAddr for which the domainpart of the represented JID matches one of the configured hostnames of the server itself; the server SHOULD use this represented JID as the validated identity of the client.</t>
                <t hangText='Sub-Case #2:'>The server finds more than one XmppAddr for which the domainpart of the represented JID matches one of the configured hostnames of the server itself; the server SHOULD use one of these represented JIDs as the validated identity of the client, choosing among them according to local service policies or based on the 'to' address of the initial stream header.</t>
                <t hangText='Sub-Case #3:'>The server finds no XmppAddrs, or finds at least one XmppAddr but the domainpart of the represented JID does not match one of the configured hostnames of the server itself; the server MUST NOT use the represented JID (if any) as the validated identity of the client but instead MUST either validate the identity of the client using other means.</t>
              </list>
            </t>
          </section>
          <section title="Case #2" anchor="security-certificates-validation-client-case2">
            <t>If the client certificate is certified by a Certificate Authority not known to the server, the server MUST proceed as under Case #1, Sub-Case #3.</t>
          </section>
          <section title="Case #3" anchor="security-certificates-validation-client-case3">
            <t>If the client certificate is self-signed, the server MUST proceed as under Case #1, Sub-Case #3.</t>
          </section>
        </section>
        <section title="Checking of Certificates in Long-Lived Streams" anchor="security-certificates-validation-streams">
          <t>Because XMPP uses long-lived XML streams, it is possible that a certificate presented during stream negotiation might expire or be revoked while the stream is still live (this is especially relevant in the context of server-to-server streams).  Therefore, each party to a long-lived stream SHOULD:</t>
          <t>
            <list style='numbers'>
              <t>Cache the expiration date of the certificate presented by the other party and any certificates on which that certificate depends (such as a root or intermediate certificate for a certification authority), and terminate the stream when any such certificate expires.</t>
              <t>Periodically query the Online Certificate Status Protocol <xref target='OCSP'/> responder listed in the Authority Information Access (AIA) extension of the certificate presented by the other party and any certificates on which that certificate depends (such as a root or intermediate certificate for a certification authority), and terminate the stream if any such certificate has been revoked.</t>
            </list>
          </t>
          <t>If the identity presented by the initiating entity changes between the old stream and the new stream, then the receiving entity MUST perform a full re-authentication on the new stream.</t>
        </section>
        <section title="Use of Certificates in XMPP Extensions" anchor="security-certificates-validation-extensions">
          <t>Certificates MAY be used in extensions to XMPP for the purpose of application-layer encryption or authentication above the level of XML streams (e.g., for end-to-end encryption).  Such extensions will define their own certificate handling rules, which at a minimum SHOULD be consistent with the rules specified herein but MAY specify additional rules.</t>
        </section>
      </section>
    </section>
    <section title="Client-to-Server Communication" anchor="security-client">
      <t>A compliant client implementation MUST support both TLS and SASL for connections to a server.</t>
      <t>The TLS protocol for encrypting XML streams (defined under <xref target='tls'/>) provides a reliable mechanism for helping to ensure the confidentiality and integrity of data exchanged between two entities.</t>
      <t>The SASL protocol for authenticating XML streams (defined under <xref target='sasl'/>) provides a reliable mechanism for validating that a client connecting to a server is who it claims to be.</t>
      <t>Client-to-server communication MUST NOT proceed until the DNS hostname asserted by the server has been resolved as specified under <xref target='tcp'/>.  If there is a mismatch between the hostname to which a client attempted to connect (e.g., "example.net") and the hostname to which the client actually connects (e.g., "x1.example.net"), the client MUST warn a human user about the mismatch and the human user MUST approve the connection before the client proceeds; however, the client MAY also allow the user to add the presented hostname to a configured set of accepted hostnames to expedite future connections.</t>
      <t>A client's IP address and method of access MUST NOT be made public by a server, nor are any connections other than the original server connection necessary.  This helps to protect the client's server from direct attack or identification by third parties.</t>
    </section>
    <section title="Server-to-Server Communication" anchor="security-server">
      <t>A compliant server implementation MUST support both TLS and SASL for inter-domain communication.</t>
      <t>Because service provisioning is a matter of policy, it is optional for any given domain to communicate with other domains, and server-to-server communication can be disabled by the administrator of any given deployment.  If a particular domain enables inter-domain communication, it SHOULD enable high security.</t>
      <t>Administrators might want to require use of SASL for server-to-server communication to ensure both authentication and confidentiality (e.g., on an organization's private network).  Compliant implementations SHOULD support SASL for this purpose.</t>
      <t>Server-to-server communication MUST NOT proceed until the DNS hostnames asserted by both servers have been resolved as specified under <xref target='tcp'/>.</t>
    </section>
    <section title="Order of Layers" anchor="security-layers">
      <t>The order of layers in which protocols MUST be stacked is:</t>
      <t><list style="numbers">
        <t>TCP</t>
        <t>TLS</t>
        <t>SASL</t>
        <t>XMPP</t>
      </list></t>
      <t>The rationale for this order is that <xref target="TCP"/> is the base connection layer used by all of the protocols stacked on top of TCP, <xref target="TLS"/> is often provided at the operating system layer, <xref target="SASL"/> is often provided at the application layer, and XMPP is the application itself.</t>
    </section>
    <section title="Mandatory-to-Implement Technologies" anchor="security-mandatory">
      <t>At a minimum, all implementations MUST support the following mechanisms unless otherwise specified below:</t>
      <t><list style='hanging'>
        <t hangText='for authentication only:'>the SASL Salted Challenge Response mechanism <xref target='SCRAM'/> (preferred) and the SASL PLAIN mechanism <xref target='PLAIN'/> (not preferred</t>
        <t hangText='for confidentiality only:'>TLS (using the TLS_RSA_WITH_AES_128_CBC_SHA cipher)</t>
        <t hangText='for both confidentiality and authentication with passwords:'>TLS plus the SASL Salted Challenge Response mechanism (see <xref target='SCRAM'/>) and TLS plus the SASL PLAIN mechanism (see <xref target='PLAIN'/>)</t>
        <t hangText='for both confidentiality and authentication without passwords:'>TLS plus the SASL EXTERNAL mechanism (see Appendix A of <xref target='SASL'/>) using the TLS_RSA_WITH_AES_128_CBC_SHA cipher supporting peer certificates (clients SHOULD support this, and servers MUST)</t>
      </list></t>
      <t>Naturally, implementations MAY support other ciphers with TLS and MAY support other SASL mechanisms.</t>
      <t><list style='empty'><t>Note: The use of TLS plus SASL SCRAM or SASL PLAIN replaces the SASL DIGEST-MD5 mechanism as XMPP's mandatory-to-implement password-based method for authentication.  For backward-compatibility with existing deployed infrastructure, implementations are encouraged to continue supporting the SASL DIGEST-MD5 mechanism as specified in <xref target='DIGEST-MD5'/>, however there are known interoperability issues with DIGEST-MD5 that make it impractical in the long term.  The use of the SASL SCRAM mechanism is strongly preferred over the SASL PLAIN mechanism because of its superior security properties, and PLAIN is intended to be a fallback only for implementations that do not yet support SCRAM.  Refer to <xref target='SCRAM'/> and <xref target='PLAIN'/> for important security considerations related to these SASL mechanisms.</t></list></t>
    </section>
    <section title="Hash Function Agility" anchor="security-hash">
      <t>XMPP itself does not directly mandate the use of any particular hash function.  However, technologies on which XMPP depends (e.g., TLS and particular SASL mechanisms), as well as various XMPP extensions, might make use of hash functions.  Those who implement XMPP technologies or who develop XMPP extensions are advised to closely monitor the state of the art regarding attacks against cryptographic hashes in Internet protocols as they relate to XMPP.  For helpful guidance, refer to <xref target="HASHES"/>.</t>
    </section>
    <section title="SASL Downgrade Attacks" anchor="security-downgrade">
      <t>Because the initiating entity chooses an acceptable SASL mechanism from the list presented by the receiving entity, the initiating entity depends on the receiving entity's list for authentication.  This dependency introduces the possibility of a downgrade attack if an attacker can gain control of the channel and therefore present a weak list of mechanisms.  To help prevent this attack, the parties SHOULD protect the channel using TLS before attempting SASL negotiation.</t>
    </section>
    <section title="Server-to-Server Downgrade Attacks" anchor="security-dialback">
      <t>Before RFC 3920 defined TLS plus SASL EXTERNAL with certificates for encryption and authentication of server-to-server streams, the only method for weak identity verification of a peer server was server dialback as defined in <xref target='XEP-0220'/>.  Even when <xref target='DNSSEC'/> is used, dialback provides only weak identity verification and provides no confidentiality or integrity.  At the time of this writing, server dialback is still the most widely-used technique for some level of assurance over server-to-server streams.  This reality introduces the possibility of a downgrade attack from TLS + SASL EXTERNAL to dialback if an attacker can gain control of the channel and therefore convince the initiating server that the receiving server does not support TLS or does not have an appropriate certificate.  To help prevent this attack, the parties SHOULD protect the channel using TLS before proceeding, even if the presented certificates are self-signed or otherwise untrusted.</t>
    </section>
    <section title="Lack of SASL Channel Binding to TLS" anchor="security-channel">
      <t>The SASL framework itself does not provide a method for binding SASL authentication to a security layer providing confidentiality and integrity protection that was negotiated at a lower layer.  Such a binding is known as a "channel binding" (see <xref target='CHANNEL'/>).  Some SASL mechanisms provide channel bindings.  However, if a SASL mechanism does not provide a channel binding, then the mechanism cannot provide a way to verify that the source and destination end points to which the lower layer's security is bound are equivalent to the end points that SASL is authenticating; furthermore, if the end points are not identical, then the lower layer's security cannot be trusted to protect data transmitted between the SASL-authenticated entities.  In such a situation, a SASL security layer SHOULD be negotiated that effectively ignores the presence of the lower-layer security.</t>
    </section>
    <section title="Use of base64 in SASL" anchor="security-base64">
      <t>Both the client and the server MUST verify any base64 data received during <xref target='sasl'>SASL negotiation</xref>.  An implementation MUST reject (not ignore) any characters that are not explicitly allowed by the base64 alphabet; this helps to guard against creation of a covert channel that could be used to "leak" information.</t>
      <t>An implementation MUST NOT break on invalid input and MUST reject any sequence of base64 characters containing the pad ('=') character if that character is included as something other than the last character of the data (e.g., "=AAA" or "BBBB=CCC"); this helps to guard against buffer overflow attacks and other attacks on the implementation.</t>
      <t>While base 64 encoding visually hides otherwise easily recognized information (such as passwords), it does not provide any computational confidentiality.</t>
      <t>All uses of base 64 encoding MUST follow the definition in Section 4 of <xref target="BASE64"/> and padding bits MUST be set to zero.</t>
    </section>
    <section title="Firewalls" anchor="security-firewalls">
      <t>Communication using XMPP normally occurs over TCP connections on port 5222 (client-to-server) or port 5269 (server-to-server), as registered with the IANA (see <xref target="iana"/>).  Use of these well-known ports allows administrators to easily enable or disable XMPP activity through existing and commonly-deployed firewalls.</t>
    </section>
    <section title="Denial of Service" anchor="security-dos">
      <t><xref target='DOS'/> defines denial of service as follows:</t>
      <t>
        <list style='hanging'>
          <t>A Denial-of-Service (DoS) attack is an attack in which one or more machines target a victim and attempt to prevent the victim from doing useful work. The victim can be a network server, client or router, a network link or an entire network, an individual Internet user or a company doing business using the Internet, an Internet Service Provider (ISP), country, or any combination of or variant on these.</t>
        </list>
      </t>
      <t><xref target='XEP-0205'/> provides a detailed discussion of potential denial of service attacks against XMPP systems and best practices for preventing such attacks.  The recommendations include:</t>
      <t>
        <list style='numbers'>
          <t>A server implementation SHOULD enable a server administrator to limit the number of TCP connections that it will accept from a given IP address at any one time.  If an entity attempts to connect but the maximum number of TCP connections has been reached, the receiving server MUST NOT allow the new connection to proceed.</t>
          <t>A server implementation SHOULD enable a server administrator to limit the number of TCP connection attempts that it will accept from a given IP address in a given time period.  (While it is possible to limit the number of connections at the TCP layer rather than at the XMPP application layer, this is not advisable because limits at the TCP layer might result in an inability to access non-XMPP services.)  If an entity attempts to connect but the maximum number of connections has been reached, the receiving server MUST NOT allow the new connection to proceed.</t>
          <t>A server MUST NOT process XML stanzas from clients that have not yet provided appropriate authentication credentials and MUST NOT process XML stanzas from peer servers whose identity it has not either authenticated via SASL or weakly verified via server dialback (see <xref target='XEP-0220'/>).</t>
          <t>A server implementation SHOULD enable a server administrator to limit the number of connected resources it will allow an account to bind at any one time.  If a client attempts to bind a resource but it has already reached the configured number of allowable resources, the receiving server MUST return a &lt;resource-constraint/&gt; stanza error.</t>
          <t>A server implementation SHOULD enable a server administrator to limit the size of stanzas it will accept from a connected client or peer server.  If a connected resource or peer server sends a stanza that violates the upper limit, the receiving server SHOULD NOT process the stanza and instead SHOULD return a &lt;not-allowed/&gt; stanza error.  Alternatively (e.g., if the sender has sent an egregiously large stanza), the server MAY instead return a &lt;policy-violation/&gt; stream error.</t>
          <t>A server implementation SHOULD enable a server administrator to limit the number of XML stanzas that a connected client is allowed to send to distinct recipients within a given time period.  If a connected client sends too many stanzas to distinct recipients in a given time period, the receiving server SHOULD NOT process the stanza and instead SHOULD return an &lt;unexpected-request/&gt; stanza error.</t>
          <t>A server implementation SHOULD enable a server administrator to limit the amount of bandwidth it will allow a connected client or peer server to use in a given time period.</t>
          <t>A server implementation MAY enable a server administrator to limit the types of stanzas (based on the extended content "payload") that it will allow a connected resource or peer server send over an active connection.  Such limits and restrictions are a matter of deployment policy.</t>
          <t>A server implementation MAY refuse to route or deliver any stanza that it considers to be abusive, with or without returning an error to the sender.</t>
        </list>
      </t>
      <t>For more detailed recommendations regarding denial of service attacks in XMPP systems, refer to <xref target='XEP-0205'/>.</t>
    </section>
    <section title="Presence Leaks" anchor="security-leak">
      <t>One of the core aspects of XMPP is presence: information about the network availability of an XMPP entity (i.e., whether the entity is currently online or offline).  A PRESENCE LEAK occurs when an entity's network availability is inadvertently and involuntarily revealed to a second entity that is not authorized to know the first entity's network availability.</t>
      <t>Although presence is discussed more fully in <xref target='XMPP-IM'/>, it is important to note that an XMPP server MUST NOT leak presence.  In particular at the core XMPP level, real-time addressing and network availability is associated with a specific connected resource; therefore, any disclosure of a connected resource's full JID comprises a presence leak.  To help prevent such a presence leak, a server MUST NOT return different stanza errors if a potential attacker sends XML stanzas to the entity's bare JID (&lt;localpart@domain&gt;) or full JID (&lt;localpart@domain/resource&gt;).</t>
    </section>
    <section title="Directory Harvesting" anchor="security-harvesting">
      <t>When a server generates an error stanza in response to receiving a stanza for a user account that does not exist, the use of the &lt;service-unavailable/&gt; stanza error condition can help protect against dictionary attacks, since this is the same error condition that is returned if, for instance, the namespace of an IQ child element is not understood, or if offline message storage or message forwarding is not enabled for a domain.  However, subtle differences in the exact XML of error stanzas, as well as in the timing with which such errors are returned, can enable an attacker to determine the network presence of a user when more advanced blocking technologies are not used (see for instance <xref target='XEP-0016'/> and <xref target='XEP-0191'/>).</t>
    </section>
  </section>

  <section title="IANA Considerations" anchor="iana">
    <t>The following sections update the registrations provided in <xref target='RFC3920'/>.</t>
    <section title="XML Namespace Name for TLS Data" anchor="iana-ns-tls">
      <t>A URN sub-namespace for STARTTLS negotiation data in the Extensible Messaging and Presence Protocol (XMPP) is defined as follows.  (This namespace name adheres to the format defined in <xref target="XML-REG"/>.)</t>
      <t><list style='hanging'>
        <t hangText='URI:'>urn:ietf:params:xml:ns:xmpp-tls</t>
        <t hangText='Specification:'>&rfc.number;</t>
        <t hangText='Description:'>This is the XML namespace name for STARTTLS negotiation data in the Extensible Messaging and Presence Protocol (XMPP) as defined by &rfc.number;.</t>
        <t hangText='Registrant Contact:'>IETF, XMPP Working Group, &lt;xmppwg@xmpp.org&gt;</t>
      </list></t>
    </section>
    <section title="XML Namespace Name for SASL Data" anchor="iana-ns-sasl">
      <t>A URN sub-namespace for SASL negotiation data in the Extensible Messaging and Presence Protocol (XMPP) is defined as follows.  (This namespace name adheres to the format defined in <xref target="XML-REG"/>.)</t>
      <t><list style='hanging'>
        <t hangText='URI:'>urn:ietf:params:xml:ns:xmpp-sasl</t>
        <t hangText='Specification:'>&rfc.number;</t>
        <t hangText='Description:'>This is the XML namespace name for SASL negotiation data in the Extensible Messaging and Presence Protocol (XMPP) as defined by &rfc.number;.</t>
        <t hangText='Registrant Contact:'>IETF, XMPP Working Group, &lt;xmppwg@xmpp.org&gt;</t>
      </list></t>
    </section>
    <section title="XML Namespace Name for Stream Errors" anchor="iana-ns-streams">
      <t>A URN sub-namespace for stream error data in the Extensible Messaging and Presence Protocol (XMPP) is defined as follows.  (This namespace name adheres to the format defined in <xref target="XML-REG"/>.)</t>
      <t><list style='hanging'>
        <t hangText='URI:'>urn:ietf:params:xml:ns:xmpp-streams</t>
        <t hangText='Specification:'>&rfc.number;</t>
        <t hangText='Description:'>This is the XML namespace name for stream error data in the Extensible Messaging and Presence Protocol (XMPP) as defined by &rfc.number;.</t>
        <t hangText='Registrant Contact:'>IETF, XMPP Working Group, &lt;xmppwg@xmpp.org&gt;</t>
      </list></t>
    </section>
    <section title="XML Namespace Name for Resource Binding" anchor="iana-ns-bind">
      <t>A URN sub-namespace for resource binding in the Extensible Messaging and Presence Protocol (XMPP) is defined as follows.  (This namespace name adheres to the format defined in <xref target="XML-REG"/>.)</t>
      <t><list style='hanging'>
        <t hangText='URI:'>urn:ietf:params:xml:ns:xmpp-bind</t>
        <t hangText='Specification:'>&rfc.number;</t>
        <t hangText='Description:'>This is the XML namespace name for resource binding in the Extensible Messaging and Presence Protocol (XMPP) as defined by &rfc.number;.</t>
        <t hangText='Registrant Contact:'>IETF, XMPP Working Group, &lt;xmppwg@xmpp.org&gt;</t>
      </list></t>
    </section>
    <section title="XML Namespace Name for Stanza Errors" anchor="iana-ns-stanzas">
      <t>A URN sub-namespace for stanza error data in the Extensible Messaging and Presence Protocol (XMPP) is defined as follows.  (This namespace name adheres to the format defined in <xref target="XML-REG"/>.)</t>
      <t><list style='hanging'>
        <t hangText='URI:'>urn:ietf:params:xml:ns:xmpp-stanzas</t>
        <t hangText='Specification:'>&rfc.number;</t>
        <t hangText='Description:'>This is the XML namespace name for stanza error data in the Extensible Messaging and Presence Protocol (XMPP) as defined by &rfc.number;.</t>
        <t hangText='Registrant Contact:'>IETF, XMPP Working Group, &lt;xmppwg@xmpp.org&gt;</t>
      </list></t>
    </section>
    <section title="GSSAPI Service Name" anchor="iana-gssapi">
      <t>The IANA has registered "xmpp" as a <xref target="GSS-API">GSSAPI</xref> service name, as defined under <xref target="sasl-def"/>.</t>
    </section>
    <section title="Port Numbers" anchor="iana-ports">
      <t>The IANA has registered "xmpp-client" and "xmpp-server" as keywords for <xref target="TCP"/> ports 5222 and 5269 respectively.</t>
      <t>These ports SHOULD be used for client-to-server and server-to-server communications respectively, but other ports MAY be used.</t>
    </section>
  </section>

  <section title="Conformance Requirements" anchor="conformance">
    <t>This section describes a protocol feature set that summarizes the conformance requirements of this specification.  This feature set is appropriate for use in software certification, interoperability testing, and implementation reports.  For each feature, this section provides the following information:</t>
    <t>
      <list style='symbols'>
        <t>A human-readable name</t>
        <t>An informational description</t>
        <t>A reference to the particular section of this document that normatively defines the feature</t>
        <t>Whether the feature applies to the Client role, the Server role, or both (where "N/A" signifies that the feature is not applicable to the specified role)</t>
        <t>Whether the feature MUST or SHOULD be implemented, where the capitalized terms are to be understood as described in <xref target='TERMS'/></t>
      </list>
    </t>
    <t>Note: The feature set specified here attempts to adhere to the concepts and formats proposed by Larry Masinter within the IETF's NEWTRK Working Group in 2005, as captured in <xref target='INTEROP'/>.  Although this feature set is more detailed than called for by <xref target="REPORTS"/>, it provides a suitable basis for the generation of implementation reports to be submitted in support of advancing this specification from Proposed Standard to Draft Standard in accordance with <xref target="PROCESS"/>.</t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">bind-gen</t>
        <t hangText="Description:">Generate a random resource on demand.</t>
        <t hangText="Section:"><xref target='bind-servergen'/></t>
        <t hangText="Roles:">Client N/A, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">bind-mtn</t>
        <t hangText="Description:">Consider resource binding as mandatory-to-negotiate.</t>
        <t hangText="Section:"><xref target='bind-rules-mtn'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">bind-restart</t>
        <t hangText="Description:">Do not restart the stream after negotiation of resource binding.</t>
        <t hangText="Section:"><xref target='bind-rules-restart'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">bind-support</t>
        <t hangText="Description:">Support binding of client resources to an authenticated stream.</t>
        <t hangText="Section:"><xref target='bind'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">sasl-errors</t>
        <t hangText="Description:">Support SASL errors during the negotiation process.</t>
        <t hangText="Section:"><xref target='sasl-errors'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">sasl-mtn</t>
        <t hangText="Description:">Consider SASL as mandatory-to-negotiate.</t>
        <t hangText="Section:"><xref target='sasl-rules-mtn'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">sasl-restart</t>
        <t hangText="Description:">Complete a stream restart after SASL negotiation.</t>
        <t hangText="Section:"><xref target='sasl-rules-restart'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">sasl-support</t>
        <t hangText="Description:">Support the Simple Authentication and Security Layer for stream authentication.</t>
        <t hangText="Section:"><xref target='sasl'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">sasl-whitespace</t>
        <t hangText="Description:">Ensure that no whitespace is sent between XML elements during SASL negotiation.</t>
        <t hangText="Section:"><xref target='sasl-rules-data'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">security-mti-auth-plain</t>
        <t hangText="Description:">Support the SASL PLAIN mechanism for authentication only.</t>
        <t hangText="Section:"><xref target='security-mandatory'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">security-mti-auth-scram</t>
        <t hangText="Description:">Support the SASL Salted Challenge Response mechanism for authentication only.</t>
        <t hangText="Section:"><xref target='security-mandatory'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">security-mti-both-external</t>
        <t hangText="Description:">Support TLS with SASL EXTERNAL for confidentiality and authentication.</t>
        <t hangText="Section:"><xref target='security-mandatory'/></t>
        <t hangText="Roles:">Client SHOULD, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">security-mti-both-plain</t>
        <t hangText="Description:">Support TLS with SASL PLAIN for confidentiality and authentication.</t>
        <t hangText="Section:"><xref target='security-mandatory'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">security-mti-both-scram</t>
        <t hangText="Description:">Support TLS with SASL SCRAM for confidentiality and authentication.</t>
        <t hangText="Section:"><xref target='security-mandatory'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">security-mti-confidentiality</t>
        <t hangText="Description:">Support TLS using the TLS_RSA_WITH_AES_128_CBC_SHA cipher for confidentiality only.</t>
        <t hangText="Section:"><xref target='security-mandatory'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-attribute-from</t>
        <t hangText="Description:">Support the common 'from' attribute for all stanza kinds.</t>
        <t hangText="Section:"><xref target='stanzas-attributes-to'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-attribute-from-validate</t>
        <t hangText="Description:">Validate the 'from' address of all stanzas received from connected clients or peer servers.</t>
        <t hangText="Section:"><xref target='stanzas-attributes-from'/></t>
        <t hangText="Roles:">Client N/A, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-attribute-id</t>
        <t hangText="Description:">Support the common 'id' attribute for all stanza kinds.</t>
        <t hangText="Section:"><xref target='stanzas-attributes-id'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-attribute-to</t>
        <t hangText="Description:">Support the common 'to' attribute for all stanza kinds.</t>
        <t hangText="Section:"><xref target='stanzas-attributes-to'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-attribute-to-validate</t>
        <t hangText="Description:">Ensure that all stanzas received from peer servers include a 'to' address.</t>
        <t hangText="Section:"><xref target='stanzas-attributes-to'/></t>
        <t hangText="Roles:">Client N/A, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-attribute-type</t>
        <t hangText="Description:">Support the common 'type' attribute for all stanza kinds.</t>
        <t hangText="Section:"><xref target='stanzas-attributes-type'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-attribute-xmllang</t>
        <t hangText="Description:">Support the common 'xml:lang' attribute for all stanza kinds.</t>
        <t hangText="Section:"><xref target='stanzas-attributes-lang'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-error</t>
        <t hangText="Description:">Generate and handle stanzas of type "error" for all stanza kinds.</t>
        <t hangText="Section:"><xref target='stanzas-error'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-error-child</t>
        <t hangText="Description:">Ensure that stanzas of type "error" include an &lt;error/&gt; child element.</t>
        <t hangText="Section:"><xref target='stanzas-error'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-error-id</t>
        <t hangText="Description:">Ensure that stanzas of type "error" preserve the 'id' provided in the triggering stanza.</t>
        <t hangText="Section:"><xref target='stanzas-error'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-error-reply</t>
        <t hangText="Description:">Do not reply to a stanza of type "error" with another stanza of type "error".</t>
        <t hangText="Section:"><xref target='stanzas-error'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-extension</t>
        <t hangText="Description:">Correctly process XML data qualified by an unsupported XML namespace, where "correctly process" means to ignore that portion of the stanza in the case of a message or presence stanza and return an error in the case of an IQ stanza (for the intended recipient) or to routeor deliver the stanza (for a routing entity such as a server).</t>
        <t hangText="Section:"><xref target='stanzas-extended'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-iq-child</t>
        <t hangText="Description:">Include exactly one child element in an &lt;iq/&gt; stanza of type "get" or "set", zero or one child elements in an &lt;iq/&gt; stanza of type "result", and one or two child elements in an &lt;iq/&gt; stanza of type "error".</t>
        <t hangText="Section:"><xref target='stanzas-semantics-iq'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-iq-id</t>
        <t hangText="Description:">Ensure that all &lt;iq/&gt; stanzas include an 'id' attribute.</t>
        <t hangText="Section:"><xref target='stanzas-semantics-iq'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-iq-reply</t>
        <t hangText="Description:">Reply to an &lt;iq/&gt; stanzas of type "get" or "set" with an &lt;iq/&gt; stanzas of type "result" or "error".</t>
        <t hangText="Section:"><xref target='stanzas-semantics-iq'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-iq-type</t>
        <t hangText="Description:">Ensure that all &lt;iq/&gt; stanzas include an 'type' attribute whose value is "get", "set", "result", or "error".</t>
        <t hangText="Section:"><xref target='stanzas-semantics-iq'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-kind-iq</t>
        <t hangText="Description:">Support the &lt;iq/&gt; stanza.</t>
        <t hangText="Section:"><xref target='stanzas-semantics-iq'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-kind-message</t>
        <t hangText="Description:">Support the &lt;message/&gt; stanza.</t>
        <t hangText="Section:"><xref target='stanzas-semantics-message'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stanza-kind-presence</t>
        <t hangText="Description:">Support the &lt;presence/&gt; stanza.</t>
        <t hangText="Section:"><xref target='stanzas-semantics-presence'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stream-attribute-initial-from</t>
        <t hangText="Description:">Include a 'from' attribute in the initial stream header.</t>
        <t hangText="Section:"><xref target='streams-attr-from'/></t>
        <t hangText="Roles:">Both SHOULD.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stream-attribute-initial-lang</t>
        <t hangText="Description:">Include an 'xml:lang' attribute in the initial stream header.</t>
        <t hangText="Section:"><xref target='streams-attr-xmllang'/></t>
        <t hangText="Roles:">Both SHOULD.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stream-attribute-initial-to</t>
        <t hangText="Description:">Include a 'to' attribute in the initial stream header.</t>
        <t hangText="Section:"><xref target='streams-attr-to'/></t>
        <t hangText="Roles:">Both SHOULD.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stream-attribute-response-from</t>
        <t hangText="Description:">Include a 'from' attribute in the response stream header.</t>
        <t hangText="Section:"><xref target='streams-attr-from'/></t>
        <t hangText="Roles:">Client N/A, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stream-attribute-response-id</t>
        <t hangText="Description:">Include an 'id' attribute in the response stream header.</t>
        <t hangText="Section:"><xref target='streams-attr-id'/></t>
        <t hangText="Roles:">Client N/A, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stream-attribute-response-id-unique</t>
        <t hangText="Description:">Ensure that the 'id' attribute in the response stream header is unique within the context of the receiving entity.</t>
        <t hangText="Section:"><xref target='streams-attr-id'/></t>
        <t hangText="Roles:">Client N/A, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stream-attribute-response-to</t>
        <t hangText="Description:">Include a 'to' attribute in the response stream header.</t>
        <t hangText="Section:"><xref target='streams-attr-to'/></t>
        <t hangText="Roles:">Client N/A, Server SHOULD.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stream-error-generate</t>
        <t hangText="Description:">Generate a stream error (followed by a closing stream tag and termination of the TCP connection) upon detecting a stream-related error condition.</t>
        <t hangText="Section:"><xref target='streams-error'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stream-hostname-resolution</t>
        <t hangText="Description:">Resolve hostnames before opening a TCP connection.</t>
        <t hangText="Section:"><xref target='tcp-resolution'/></t>
        <t hangText="Roles:">Both MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stream-negotiation-complete</t>
        <t hangText="Description:">Do not consider the stream negotiation process to be complete until the receiving entity sends a stream features advertisement that is empty or that contains only voluntary-to-negotiate features.</t>
        <t hangText="Section:"><xref target='streams-negotiation-complete'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stream-negotiation-features</t>
        <t hangText="Description:">Send stream features after sending a response stream header.</t>
        <t hangText="Section:"><xref target='streams-negotiation-features'/></t>
        <t hangText="Roles:">Client N/A, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stream-negotiation-restart</t>
        <t hangText="Description:">Consider the previous stream to be replaced upon negotiation of a stream feature that necessitates a stream restart, and send or receive a new initial stream header after negotiation of such a stream feature.</t>
        <t hangText="Section:"><xref target='streams-negotiation-restart'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stream-reconnect</t>
        <t hangText="Description:">Reconnect with intelligently (e.g., with exponential backoff) if a TCP connection is terminated unexpectedly.</t>
        <t hangText="Section:"><xref target='tcp-reconnect'/></t>
        <t hangText="Roles:">Both MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">stream-tcp-binding</t>
        <t hangText="Description:">Bind an XML stream to a TCP connection.</t>
        <t hangText="Section:"><xref target='tcp'/></t>
        <t hangText="Roles:">Both MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">tls-certs</t>
        <t hangText="Description:">Check the identity specified in a certificate that is presented during TLS negotiation.</t>
        <t hangText="Section:"><xref target='security-certificates-validation'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">tls-mtn</t>
        <t hangText="Description:">Consider TLS as mandatory-to-negotiate if STARTTLS is the only feature advertised or ir the STARTTLS feature includes an empty &lt;required/&gt; element.</t>
        <t hangText="Section:"><xref target='tls-rules-mtn'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">tls-restart</t>
        <t hangText="Description:">Complete a stream restart after TLS negotiation.</t>
        <t hangText="Section:"><xref target='tls-rules-restart'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">tls-support</t>
        <t hangText="Description:">Support Transport Layer Security for stream encryption.</t>
        <t hangText="Section:"><xref target='tls'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">tls-whitespace</t>
        <t hangText="Description:">Ensure that no whitespace is sent between XML elements during TLS negotiation.</t>
        <t hangText="Section:"><xref target='tls-rules-data'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">xml-namespace-default</t>
        <t hangText="Description:">Ensure that there is a default namespace for the stream (other than the streams namespace).</t>
        <t hangText="Section:"><xref target='streams-ns-default'/></t>
        <t hangText="Roles:">Both MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">xml-namespace-default-client</t>
        <t hangText="Description:">Support 'jabber:client' as a default namespace.</t>
        <t hangText="Section:"><xref target='streams-ns-default'/></t>
        <t hangText="Roles:">Both MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">xml-namespace-default-server</t>
        <t hangText="Description:">Support 'jabber:server' as a default namespace.</t>
        <t hangText="Section:"><xref target='streams-ns-default'/></t>
        <t hangText="Roles:">Client N/A, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">xml-namespace-streams-declaration</t>
        <t hangText="Description:">Ensure that there is a namespace declaration for the 'http://etherx.jabber.org/streams' namespace.</t>
        <t hangText="Section:"><xref target='streams-ns-stream'/></t>
        <t hangText="Roles:">Both MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">xml-namespace-streams-prefix</t>
        <t hangText="Description:">Ensure that all elements qualified by the 'http://etherx.jabber.org/streams' namespace are prefixed by the prefix defined in the namespace declaration.</t>
        <t hangText="Section:"><xref target='streams-ns-stream'/></t>
        <t hangText="Roles:">Both MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">xml-restriction-comment</t>
        <t hangText="Description:">Do not generate or accept XML comments.</t>
        <t hangText="Section:"><xref target='xml-restrictions'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">xml-restriction-dtd</t>
        <t hangText="Description:">Do not generate or accept internal or external DTD subsets.</t>
        <t hangText="Section:"><xref target='xml-restrictions'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">xml-restriction-pi</t>
        <t hangText="Description:">Do not generate or accept XML processing instructions.</t>
        <t hangText="Section:"><xref target='xml-restrictions'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">xml-restriction-ref</t>
        <t hangText="Description:">Do not generate or accept internal or external entity references with the exception of the predefined entities.</t>
        <t hangText="Section:"><xref target='xml-restrictions'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">xml-wellformed-xml</t>
        <t hangText="Description:">Do not generate or accept data that is not XML-well-formed.</t>
        <t hangText="Section:"><xref target='xml-wellformed'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
    <t>
      <list style='hanging'>
        <t hangText="Feature:">xml-wellformed-ns</t>
        <t hangText="Description:">Do not generate or accept data that is not namespace-well-formed.</t>
        <t hangText="Section:"><xref target='xml-wellformed'/></t>
        <t hangText="Roles:">Client MUST, Server MUST.</t>
      </list>
    </t>
  </section>

  </middle>

  <back>

    <references title="Normative References">

<reference anchor="BASE64">
<front>
<title>The Base16, Base32, and Base64 Data Encodings</title>
<author initials='S.' surname='Josefsson' fullname='S. Josefsson'>
<organization /></author>
<date year='2006' month='October' />
<abstract>
<t>This document describes the commonly used base 64, base 32, and base 16 encoding schemes. It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='4648' />
<format type='TXT' octets='35491' target='ftp://ftp.isi.edu/in-notes/rfc4648.txt' />
</reference>

<reference anchor="CHARSET">
<front>
<title abbrev='Charset Policy'>IETF Policy on Character Sets and Languages</title>
<author initials='H.T.' surname='Alvestrand' fullname='Harald Tveit Alvestrand'>
<organization>UNINETT</organization>
<address>
<postal>
<street>P.O.Box 6883 Elgeseter</street>
<street>N-7002 TRONDHEIM</street>
<country>NORWAY</country></postal>
<phone>+47 73 59 70 94</phone>
<email>Harald.T.Alvestrand@uninett.no</email></address></author>
<date month='January' year='1998' />
<area>Applications</area>
<keyword>Internet Engineering Task Force</keyword>
<keyword>character encoding</keyword></front>
<seriesInfo name='BCP' value='18' />
<seriesInfo name='RFC' value='2277' />
<format type='TXT' octets='16622' target='ftp://ftp.isi.edu/in-notes/rfc2277.txt' />
<format type='HTML' octets='26556' target='http://xml.resource.org/public/rfc/html/rfc2277.html' />
<format type='XML' octets='15544' target='http://xml.resource.org/public/rfc/xml/rfc2277.xml' />
</reference>

<reference anchor='DNS-SRV'>
<front>
<title abbrev='DNS SRV RR'>A DNS RR for specifying the location of services (DNS SRV)</title>
<author initials='A.' surname='Gulbrandsen' fullname='Arnt Gulbrandsen'>
<organization>Troll Tech</organization>
<address>
<postal>
<street>Waldemar Thranes gate 98B</street>
<city>Oslo</city>
<region />
<code>N-0175</code>
<country>NO</country></postal>
<phone>+47 22 806390</phone>
<facsimile>+47 22 806380</facsimile>
<email>arnt@troll.no</email></address></author>
<author initials='P.' surname='Vixie' fullname='Paul Vixie'>
<organization>Internet Software Consortium</organization>
<address>
<postal>
<street>950 Charter Street</street>
<city>Redwood City</city>
<region>CA</region>
<code>94063</code>
<country>US</country></postal>
<phone>+1 650 779 7001</phone></address></author>
<author initials='L.' surname='Esibov' fullname='Levon Esibov'>
<organization>Microsoft Corporation</organization>
<address>
<postal>
<street>One Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code>
<country>US</country></postal>
<email>levone@microsoft.com</email></address></author>
<date month='February' year='2000' />
<abstract>
<t>This document describes a DNS RR which specifies the location of the
   server(s) for a specific protocol and domain.</t></abstract></front>
<seriesInfo name='RFC' value='2782' />
<format type='TXT' octets='24013' target='ftp://ftp.isi.edu/in-notes/rfc2782.txt' />
</reference>

<reference anchor="LANGTAGS">
<front>
<title>Tags for Identifying Languages</title>
<author initials='A.' surname='Phillips' fullname='A. Phillips'>
<organization /></author>
<author initials='M.' surname='Davis' fullname='M. Davis'>
<organization /></author>
<date year='2009' month='September' />
<abstract>
<t>This document describes the structure, content, construction, and semantics of language tags for use in cases where it is desirable to indicate the language used in an information object.  It also describes how to register values for use in language tags and the creation of user-defined extensions for private interchange.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>
<seriesInfo name='BCP' value='47' />
<seriesInfo name='RFC' value='5646' />
<format type='TXT' octets='208592' target='ftp://ftp.isi.edu/in-notes/rfc5646.txt' />
</reference>

<reference anchor='OCSP'>
<front>
<title abbrev='PKIX OCSP'>X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP</title>
<author initials='M.' surname='Myers' fullname='Michael Myers'>
<organization>VeriSign, Inc.</organization>
<address>
<postal>
<street>1350 Charleston Road</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043</code>
<country>US</country></postal>
<email>mmyers@verisign.com</email></address></author>
<author initials='R.' surname='Ankney' fullname='Rich Ankney'>
<organization>CertCo, LLC</organization>
<address>
<postal>
<street>13506 King Charles Dr.</street>
<city>Chantilly</city>
<region>VA</region>
<code>20151</code>
<country>US</country></postal>
<email>rankney@erols.com</email></address></author>
<author initials='A.' surname='Malpani' fullname='Ambarish Malpani'>
<organization>ValiCert, Inc.</organization>
<address>
<postal>
<street>1215 Terra Bella Avenue</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043</code>
<country>US</country></postal>
<phone>+1 650 567 5457</phone>
<email>ambarish@valicert.com</email></address></author>
<author initials='S.' surname='Galperin' fullname='Slava Galperin'>
<organization>My CFO, Inc.</organization>
<address>
<postal>
<street>1945 Charleston Road</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043</code>
<country>US</country></postal>
<email>galperin@mycfo.com</email></address></author>
<author initials='C.' surname='Adams' fullname='Carlisle Adams'>
<organization>Entrust Technologies</organization>
<address>
<postal>
<street>750 Heron Road</street>
<street>Suite E08</street>
<city>Ottawa</city>
<region>Ontario</region>
<code>K1V 1A7</code>
<country>CA</country></postal>
<email>cadams@entrust.com</email></address></author>
<date year='1999' month='June' />
<abstract>
<t>This document specifies a protocol useful in determining the current
   status of a digital certificate without requiring CRLs. Additional
   mechanisms addressing PKIX operational requirements are specified in
   separate documents.</t>
<t>An overview of the protocol is provided in section 2. Functional
   requirements are specified in section 4. Details of the protocol are
   in section 5. We cover security issues with the protocol in section
   6. Appendix A defines OCSP over HTTP, appendix B accumulates ASN.1
   syntactic elements and appendix C specifies the mime types for the
   messages.</t>
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document (in uppercase, as shown) are to be interpreted as described
   in.</t></abstract></front>
<seriesInfo name='RFC' value='2560' />
<format type='TXT' octets='43243' target='ftp://ftp.isi.edu/in-notes/rfc2560.txt' />
</reference>

<reference anchor='PLAIN'>
<front>
<title>The PLAIN Simple Authentication and Security Layer (SASL) Mechanism</title>
<author initials='K.' surname='Zeilenga' fullname='K. Zeilenga'>
<organization /></author>
<date year='2006' month='August' />
<abstract>
<t>This document defines a simple clear-text user/password Simple Authentication and Security Layer (SASL) mechanism called the PLAIN mechanism.  The PLAIN mechanism is intended to be used, in combination with data confidentiality services provided by a lower layer, in protocols that lack a simple password authentication command. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='4616' />
<format type='TXT' octets='20270' target='ftp://ftp.isi.edu/in-notes/rfc4616.txt' />
</reference>

<reference anchor='RANDOM'>
<front>
<title>Randomness Requirements for Security</title>
<author initials='D.' surname='Eastlake' fullname='D. Eastlake'>
<organization /></author>
<author initials='J.' surname='Schiller' fullname='J. Schiller'>
<organization /></author>
<author initials='S.' surname='Crocker' fullname='S. Crocker'>
<organization /></author>
<date year='2005' month='June' />
<abstract>
<t>Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts. However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities. The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.&lt;/t>&lt;t> Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult. This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities. It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>
<seriesInfo name='BCP' value='106' />
<seriesInfo name='RFC' value='4086' />
<format type='TXT' octets='114321' target='ftp://ftp.isi.edu/in-notes/rfc4086.txt' />
</reference>

<reference anchor="SASL">
<front>
<title>Simple Authentication and Security Layer (SASL)</title>
<author initials='A.' surname='Melnikov' fullname='A. Melnikov'>
<organization /></author>
<author initials='K.' surname='Zeilenga' fullname='K. Zeilenga'>
<organization /></author>
<date year='2006' month='June' />
<abstract>
<t>&lt;p>The Simple Authentication and Security Layer (SASL) is a framework for providing authentication and data security services in connection-oriented protocols via replaceable mechanisms. It provides a structured interface between protocols and mechanisms. The resulting framework allows new protocols to reuse existing mechanisms and allows old protocols to make use of new mechanisms. The framework also provides a protocol for securing subsequent protocol exchanges within a data security layer.&lt;/p>&lt;p> This document describes how a SASL mechanism is structured, describes how protocols include support for SASL, and defines the protocol for carrying a data security layer over a connection. In addition, this document defines one SASL mechanism, the EXTERNAL mechanism.&lt;/p>&lt;p> This document obsoletes RFC 2222. [STANDARDS TRACK]&lt;/p></t></abstract></front>
<seriesInfo name='RFC' value='4422' />
<format type='TXT' octets='73206' target='ftp://ftp.isi.edu/in-notes/rfc4422.txt' />
</reference>

<reference anchor='SCRAM'>
<front>
<title>Salted Challenge Response (SCRAM) SASL and GSS-API Mechanism</title>
<author initials='C' surname='Newman' fullname='Chris Newman'>
    <organization />
</author>
<author initials='A' surname='Menon-Sen' fullname='Abhijit Menon-Sen'>
    <organization />
</author>
<author initials='A' surname='Melnikov' fullname='Alexey Melnikov'>
    <organization />
</author>
<author initials='N' surname='Williams' fullname='Nicolas Williams'>
    <organization />
</author>
<date month='February' day='8' year='2010' />
<abstract><t>The secure authentication mechanism most widely deployed and used by Internet application protocols is the transmission of clear-text passwords over a channel protected by Transport Layer Security (TLS). There are some significant security concerns with that mechanism, which could be addressed by the use of a challenge response authentication mechanism protected by TLS.  Unfortunately, the challenge response mechanisms presently on the standards track all fail to meet requirements necessary for widespread deployment, and have had success only in limited use.  This specification describes a family of Simple Authentication and Security Layer (SASL, RFC 4422) authentication mechanisms called the Salted Challenge Response Authentication Mechanism (SCRAM), which addresses the security concerns and meets the deployability requirements.  When used in combination with TLS or an equivalent security layer, a mechanism from this family could improve the status-quo for application protocol authentication and provide a suitable choice for a mandatory-to-implement mechanism for future application protocol standards.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-sasl-scram-11' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-sasl-scram-11.txt' />
</reference>

<reference anchor="TCP">
<front>
<title abbrev='Transmission Control Protocol'>Transmission Control Protocol</title>
<author initials='J.' surname='Postel' fullname='Jon Postel'>
<organization>University of Southern California (USC)/Information Sciences Institute</organization>
<address>
<postal>
<street>4676 Admiralty Way</street>
<city>Marina del Rey</city>
<region>CA</region>
<code>90291</code>
<country>US</country></postal></address></author>
<date month='September' day='1' year='1981' /></front>
<seriesInfo name='STD' value='7' />
<seriesInfo name='RFC' value='793' />
<format type='TXT' octets='172710' target='ftp://ftp.isi.edu/in-notes/rfc793.txt' />
</reference>

<reference anchor="TERMS">
<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass.  Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date month='March' year='1997' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL
      NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,  &quot;MAY&quot;, and
      &quot;OPTIONAL&quot; in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>
<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='ftp://ftp.isi.edu/in-notes/rfc2119.txt' />
<format type='HTML' octets='14486' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5661' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>

<reference anchor='TLS'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2008' month='August' />
<abstract>
<t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5246' />
<format type='TXT' octets='222395' target='ftp://ftp.isi.edu/in-notes/rfc5246.txt' />
</reference>

<reference anchor='TLS-CERTS'>
<front>
<title>Representation and Verification of Application Server Identity in Certificates Used with Transport Layer Security (TLS)</title>
<author initials='P' surname='Saint-Andre' fullname='Peter Saint-Andre'>
    <organization />
</author>
<author initials='J' surname='Hodges' fullname='Jeff Hodges'>
    <organization />
</author>
<date month='March' day='8' year='2010' />
<abstract><t>Many application technologies enable a secure connection between two entities using certificates in the context of Transport Layer Security (TLS).  This document specifies procedures for representing and verifying the identity of application servers in such interactions.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-saintandre-tls-server-id-check-03' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-saintandre-tls-server-id-check-03.txt' />
</reference>

<reference anchor="UCS2">
  <front>
    <title>Information Technology - Universal Multiple-octet coded Character Set (UCS) - Amendment 2: UCS Transformation Format 8 (UTF-8)</title>
    <author>
      <organization>International Organization for Standardization</organization>
    </author>
    <date month="October" year="1996" />
  </front>
  <seriesInfo name="ISO" value="Standard 10646-1 Addendum 2" />
</reference>

<reference anchor="UNICODE">
  <front>
    <title>The Unicode Standard, Version 3.2.0</title>
    <author>
      <organization>The Unicode Consortium</organization>
    </author>
    <date year="2000" />
  </front>
  <annotation>
    The Unicode Standard, Version 3.2.0 is defined by The Unicode Standard, Version 3.0 (Reading, MA, Addison-Wesley, 2000. ISBN 0-201-61633-5), as amended by the Unicode Standard Annex #27: Unicode 3.1 (http://www.unicode.org/reports/tr27/) and by the Unicode Standard Annex #28: Unicode 3.2 (http://www.unicode.org/reports/tr28/).
  </annotation>
</reference>

<reference anchor='UTF-8'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'>
<organization /></author>
<date month='November' year='2003' /></front>
<seriesInfo name='STD' value='63' />
<seriesInfo name='RFC' value='3629' />
<format type='TXT' octets='33856' target='ftp://ftp.isi.edu/in-notes/rfc3629.txt' />
</reference>

<reference anchor='UUID'>
<front>
<title abbrev='UUID URN'>A Universally Unique IDentifier (UUID) URN Namespace</title>
<author initials='P.' surname='Leach' fullname='Paul J. Leach'>
<organization>Microsoft</organization>
<address>
<postal>
<street>1 Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code>
<country>US</country></postal>
<phone>+1 425-882-8080</phone>
<email>paulle@microsoft.com</email></address></author>
<author initials='M.' surname='Mealling' fullname='Michael Mealling'>
<organization>Refactored Networks, LLC</organization>
<address>
<postal>
<street>1635 Old Hwy 41</street>
<street>Suite 112, Box 138</street>
<city>Kennesaw</city>
<region>GA</region>
<code>30152</code>
<country>US</country></postal>
<phone>+1-678-581-9656</phone>
<email>michael@refactored-networks.com</email>
<uri>http://www.refactored-networks.com</uri></address></author>
<author initials='R.' surname='Salz' fullname='Rich Salz'>
<organization>DataPower Technology, Inc.</organization>
<address>
<postal>
<street>1 Alewife Center</street>
<city>Cambridge</city>
<region>MA</region>
<code>02142</code>
<country>US</country></postal>
<phone>+1 617-864-0455</phone>
<email>rsalz@datapower.com</email>
<uri>http://www.datapower.com</uri></address></author>
<date year='2005' month='July' />
<keyword>URN, UUID</keyword>
<abstract>
<t>This specification defines a Uniform Resource Name namespace for
      UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally
      Unique IDentifier). A UUID is 128 bits long, and can
      guarantee uniqueness across space and time. UUIDs were originally
      used in the Apollo Network Computing System and later in the Open
      Software Foundation's (OSF) Distributed Computing Environment (DCE),
      and then in Microsoft Windows platforms.</t>
<t>This specification is derived from the DCE specification with the
      kind permission of the OSF (now known as The Open Group).  Information from earlier versions of the DCE specification have been	
      incorporated into this document.</t></abstract></front>
<seriesInfo name='RFC' value='4122' />
<format type='TXT' octets='59319' target='ftp://ftp.isi.edu/in-notes/rfc4122.txt' />
<format type='HTML' octets='81761' target='http://xml.resource.org/public/rfc/html/rfc4122.html' />
<format type='XML' octets='62848' target='http://xml.resource.org/public/rfc/xml/rfc4122.xml' />
</reference>

<reference anchor='URI'>
<front>
<title abbrev='URI Generic Syntax'>Uniform Resource Identifier (URI): Generic Syntax</title>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization abbrev='W3C/MIT'>World Wide Web Consortium</organization>
<address>
<postal>
<street>Massachusetts Institute of Technology</street>
<street>77 Massachusetts Avenue</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>USA</country></postal>
<phone>+1-617-253-5702</phone>
<facsimile>+1-617-258-5999</facsimile>
<email>timbl@w3.org</email>
<uri>http://www.w3.org/People/Berners-Lee/</uri></address></author>
<author initials='R.' surname='Fielding' fullname='Roy T. Fielding'>
<organization abbrev='Day Software'>Day Software</organization>
<address>
<postal>
<street>5251 California Ave., Suite 110</street>
<city>Irvine</city>
<region>CA</region>
<code>92617</code>
<country>USA</country></postal>
<phone>+1-949-679-2960</phone>
<facsimile>+1-949-679-2972</facsimile>
<email>fielding@gbiv.com</email>
<uri>http://roy.gbiv.com/</uri></address></author>
<author initials='L.' surname='Masinter' fullname='Larry Masinter'>
<organization abbrev='Adobe Systems'>Adobe Systems Incorporated</organization>
<address>
<postal>
<street>345 Park Ave</street>
<city>San Jose</city>
<region>CA</region>
<code>95110</code>
<country>USA</country></postal>
<phone>+1-408-536-3024</phone>
<email>LMM@acm.org</email>
<uri>http://larry.masinter.net/</uri></address></author>
<date year='2005' month='January' />
<area>Applications</area>
<keyword>uniform resource identifier</keyword>
<keyword>URI</keyword>
<keyword>URL</keyword>
<keyword>URN</keyword>
<keyword>WWW</keyword>
<keyword>resource</keyword>
<abstract>
<t>
A Uniform Resource Identifier (URI) is a compact sequence of characters
that identifies an abstract or physical resource.  This specification
defines the generic URI syntax and a process for resolving URI references
that might be in relative form, along with guidelines and security
considerations for the use of URIs on the Internet.
The URI syntax defines a grammar that is a superset of all valid URIs,
allowing an implementation to parse the common components of a URI
reference without knowing the scheme-specific requirements of every
possible identifier.  This specification does not define a generative
grammar for URIs; that task is performed by the individual
specifications of each URI scheme.
</t></abstract></front>
<seriesInfo name='STD' value='66' />
<seriesInfo name='RFC' value='3986' />
<format type='TXT' octets='141811' target='ftp://ftp.isi.edu/in-notes/rfc3986.txt' />
<format type='HTML' octets='200858' target='http://xml.resource.org/public/rfc/html/rfc3986.html' />
<format type='XML' octets='165759' target='http://xml.resource.org/public/rfc/xml/rfc3986.xml' />
</reference>

<reference anchor='X509'>
<front>
<title>Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</title>
<author initials='D.' surname='Cooper' fullname='D. Cooper'>
<organization /></author>
<author initials='S.' surname='Santesson' fullname='S. Santesson'>
<organization /></author>
<author initials='S.' surname='Farrell' fullname='S. Farrell'>
<organization /></author>
<author initials='S.' surname='Boeyen' fullname='S. Boeyen'>
<organization /></author>
<author initials='R.' surname='Housley' fullname='R. Housley'>
<organization /></author>
<author initials='W.' surname='Polk' fullname='W. Polk'>
<organization /></author>
<date year='2008' month='May' />
<abstract>
<t>This memo profiles the X.509 v3 certificate and X.509 v2 certificate revocation list (CRL) for use in the Internet.  An overview of this approach and model is provided as an introduction.  The X.509 v3 certificate format is described in detail, with additional information regarding the format and semantics of Internet name forms.  Standard certificate extensions are described and two Internet-specific extensions are defined.  A set of required certificate extensions is specified.  The X.509 v2 CRL format is described in detail along with standard and Internet-specific extensions.  An algorithm for X.509 certification path validation is described.  An ASN.1 module and examples are provided in the appendices. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5280' />
<format type='TXT' octets='352580' target='ftp://ftp.isi.edu/in-notes/rfc5280.txt' />
</reference>

<reference anchor='X509-ALGO'>
<front>
<title>Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</title>
<author initials='J.' surname='Jonsson' fullname='J. Jonsson'>
<organization /></author>
<author initials='B.' surname='Kaliski' fullname='B. Kaliski'>
<organization /></author>
<date year='2003' month='February' />
<abstract>
<t>This memo represents a republication of PKCS #1 v2.1 from RSA Laboratories' Public-Key Cryptography Standards (PKCS) series, and change control is retained within the PKCS process.  The body of this document is taken directly from the PKCS #1 v2.1 document, with certain corrections made during the publication process.  This memo provides information for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='3447' />
<format type='TXT' octets='143173' target='ftp://ftp.isi.edu/in-notes/rfc3447.txt' />
</reference>

<reference anchor='X509-SRV'>
<front>
<title>Internet X.509 Public Key Infrastructure Subject Alternative Name for Expression of Service Name</title>
<author initials='S.' surname='Santesson' fullname='S. Santesson'>
<organization /></author>
<date year='2007' month='August' />
<abstract>
<t>This document defines a new name form for inclusion in the otherName field of an X.509 Subject Alternative Name extension that allows a certificate subject to be associated with the service name and domain name components of a DNS Service Resource Record. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='4985' />
<format type='TXT' octets='17868' target='ftp://ftp.isi.edu/in-notes/rfc4985.txt' />
</reference>

<reference anchor='XML' target='http://www.w3.org/TR/2006/REC-xml-20060816'>
<front>
<title>Extensible Markup Language (XML) 1.0 (Fourth Edition)</title>
<author initials='J.' surname='Paoli' fullname='Jean Paoli'>
    <organization />
</author>
<author initials='E.' surname='Maler' fullname='Eve Maler'>
    <organization />
</author>
<author initials='C.' surname='Sperberg-McQueen' fullname='C. M. Sperberg-McQueen'>
    <organization />
</author>
<author initials='F.' surname='Yergeau' fullname='Franois Yergeau'>
    <organization />
</author>
<author initials='T.' surname='Bray' fullname='Tim Bray'>
    <organization />
</author>
<date month='August' day='16' year='2006' />
</front>
<seriesInfo name='World Wide Web Consortium Recommendation' value='REC-xml-20060816' />
<format type='HTML' target='http://www.w3.org/TR/2006/REC-xml-20060816' />
</reference>

<reference anchor="XML-NAMES" target="http://www.w3.org/TR/REC-xml-names">
<front>
<title>Namespaces in XML 1.1 (Second Edition)</title>
<author initials='A.' surname='Layman' fullname='Andrew Layman'>
    <organization />
</author>
<author initials='D.' surname='Hollander' fullname='Dave Hollander'>
    <organization />
</author>
<author initials='R.' surname='Tobin' fullname='Richard Tobin'>
    <organization />
</author>
<author initials='T.' surname='Bray' fullname='Tim Bray'>
    <organization />
</author>
<date month='August' day='16' year='2006' />
</front>
<seriesInfo name='World Wide Web Consortium Recommendation' value='REC-xml-names11-20060816' />
<format type='HTML' target='http://www.w3.org/TR/2006/REC-xml-names11-20060816' />
</reference>

<reference anchor="XMPP-ADDR">
<front>
<title>Extensible Messaging and Presence Protocol (XMPP): Address Format</title>
<author initials='P' surname='Saint-Andre' fullname='Peter Saint-Andre'>
    <organization />
</author>
<date month='March' day='31' year='2010' />
<abstract><t>This document defines the address format for the Extensible Messaging and Presence Protocol (XMPP).</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-saintandre-xmpp-address-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-saintandre-xmpp-address-00.txt' />
</reference>

    </references>

    <references title="Informative References">

<reference anchor='ACAP'>
<front>
<title abbrev='ACAP'>ACAP -- Application Configuration Access Protocol</title>
<author initials='C.' surname='Newman' fullname='Chris Newman'>
<organization>Innosoft International, Inc.</organization>
<address>
<postal>
<street>1050 Lakes Drive</street>
<city>West Covina</city>
<region>CA</region>
<code>91790</code>
<country>US</country></postal>
<email>chris.newman@innosoft.com</email></address></author>
<author initials='J.G.' surname='Myers' fullname='John Gardiner Myers'>
<organization>Netscape Communications</organization>
<address>
<postal>
<street>501 East Middlefield Road</street>
<street>Mail Stop MV-029</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043</code>
<country>US</country></postal>
<email>jgmyers@netscape.com</email></address></author>
<date month='November' year='1997' />
<abstract>
<t>The Application Configuration Access Protocol (ACAP) is designed to support remote storage and access of program option, configuration and preference information.  The data store model is designed to allow a client relatively simple access to interesting data, to allow new information to be easily added without server re-configuration, and to promote the use of both standardized data and custom or proprietary data.  Key features include "inheritance" which can be used to manage default values for configuration settings and access control lists which allow interesting personal information to be shared and group information to be restricted.</t></abstract></front>
<seriesInfo name='RFC' value='2244' />
<format type='TXT' octets='154610' target='ftp://ftp.isi.edu/in-notes/rfc2244.txt' />
</reference>

<reference anchor='ANONYMOUS'>
<front>
<title>Anonymous Simple Authentication and Security Layer (SASL) Mechanism</title>
<author initials='K.' surname='Zeilenga' fullname='K. Zeilenga'>
<organization /></author>
<date year='2006' month='June' />
<abstract>
<t>On the Internet, it is common practice to permit anonymous access to various services. Traditionally, this has been done with a plain-text password mechanism using "anonymous" as the user name and using optional trace information, such as an email address, as the password. As plain-text login commands are not permitted in new IETF protocols, a new way to provide anonymous login is needed within the context of the Simple Authentication and Security Layer (SASL) framework. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='4505' />
<format type='TXT' octets='16599' target='ftp://ftp.isi.edu/in-notes/rfc4505.txt' />
</reference>

<reference anchor="ASN.1">
<front>
<title>Recommendation X.208: Specification of Abstract Syntax Notation One (ASN.1)
</title>
<author>
<organization>CCITT</organization>
</author>
<date year="1988" />
</front>
</reference>

<reference anchor='CHANNEL'>
<front>
<title>On the Use of Channel Bindings to Secure Channels</title>
<author initials='N.' surname='Williams' fullname='N. Williams'>
<organization /></author>
<date year='2007' month='November' />
<abstract>
<t>The concept of channel binding allows applications to establish that the two end-points of a secure channel at one network layer are the same as at a higher layer by binding authentication at the higher layer to the channel at the lower layer. This allows applications to delegate session protection to lower layers, which has various performance benefits.&lt;/t>&lt;t> This document discusses and formalizes the concept of channel binding to secure channels. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5056' />
<format type='TXT' octets='49995' target='ftp://ftp.isi.edu/in-notes/rfc5056.txt' />
</reference>

<reference anchor='DIGEST-MD5'>
<front>
<title>Using Digest Authentication as a SASL Mechanism</title>
<author initials='P.' surname='Leach' fullname='P. Leach'>
<organization /></author>
<author initials='C.' surname='Newman' fullname='C. Newman'>
<organization /></author>
<date month='May' year='2000' /></front>
<seriesInfo name='RFC' value='2831' />
<format type='TXT' octets='58124' target='ftp://ftp.isi.edu/in-notes/rfc2831.txt' />
</reference>

<reference anchor='DNSSEC'>
<front>
<title>DNS Security Introduction and Requirements</title>
<author initials='R.' surname='Arends' fullname='R. Arends'>
<organization /></author>
<author initials='R.' surname='Austein' fullname='R. Austein'>
<organization /></author>
<author initials='M.' surname='Larson' fullname='M. Larson'>
<organization /></author>
<author initials='D.' surname='Massey' fullname='D. Massey'>
<organization /></author>
<author initials='S.' surname='Rose' fullname='S. Rose'>
<organization /></author>
<date year='2005' month='March' />
<abstract>
<t>The Domain Name System Security Extensions (DNSSEC) add data origin authentication and data integrity to the Domain Name System. This document introduces these extensions and describes their capabilities and limitations. This document also discusses the services that the DNS security extensions do and do not provide. Last, this document describes the interrelationships between the documents that collectively describe DNSSEC. [STANDARDS TRACK] </t></abstract></front>
<seriesInfo name='RFC' value='4033' />
<format type='TXT' octets='52445' target='ftp://ftp.isi.edu/in-notes/rfc4033.txt' />
</reference>

<reference anchor='DNS-TXT'>
<front>
<title abbrev='Storing Arbitrary Attributes in DNS'>Using the Domain Name System To Store Arbitrary String Attributes</title>
<author initials='R.' surname='Rosenbaum' fullname='Rich Rosenbaum'>
<organization>Digital Equipment Corporation</organization>
<address>
<postal>
<street>550 King Street</street>
<street>LKG2-2/Z7</street>
<city>Littleton</city>
<region>MA</region>
<code>01460-1289</code>
<country>US</country></postal>
<phone>+1 508 486 5922</phone>
<email>rosenbaum@lkg.dec.com</email></address></author>
<date year='1993' month='May' />
<abstract>
<t>While the Domain Name System (DNS),is generally used to store predefined types of information (e.g., addresses of hosts), it is possible to use it to store information that has not been previously classified.</t>
<t>This paper describes a simple means to associate arbitrary string information (ASCII text) with attributes that have not been defined by the DNS.  It uses DNS TXT resource records to store the information.  It requires no change to current DNS implementations.</t></abstract></front>
<seriesInfo name='RFC' value='1464' />
<format type='TXT' octets='7953' target='ftp://ftp.isi.edu/in-notes/rfc1464.txt' />
</reference>

<reference anchor='DOS'>
<front>
<title>Internet Denial-of-Service Considerations</title>
<author initials='M.' surname='Handley' fullname='M. Handley'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<author>
<organization>IAB</organization></author>
<date year='2006' month='December' />
<abstract>
<t>This document provides an overview of possible avenues for denial-of-service (DoS) attack on Internet systems. The aim is to encourage protocol designers and network engineers towards designs that are more robust. We discuss partial solutions that reduce the effectiveness of attacks, and how some solutions might inadvertently open up alternative vulnerabilities. This memo provides information for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='4732' />
<format type='TXT' octets='91844' target='ftp://ftp.isi.edu/in-notes/rfc4732.txt' />
</reference>

<reference anchor='EMAIL-ARCH'>
<front>
<title>Internet Mail Architecture</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker'>
<organization /></author>
<date year='2009' month='July' />
<abstract>
<t>Over its thirty-five-year history, Internet Mail has changed significantly in scale and complexity, as it has become a global infrastructure service.  These changes have been evolutionary, rather than revolutionary, reflecting a strong desire to preserve both its installed base and its usefulness.  To collaborate productively on this large and complex system, all participants need to work from a common view of it and use a common language to describe its components and the interactions among them.  But the many differences in perspective currently make it difficult to know exactly what another participant means.  To serve as the necessary common frame of reference, this document describes the enhanced Internet Mail architecture, reflecting the current service.  This memo provides information for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='5598' />
<format type='TXT' octets='115741' target='ftp://ftp.isi.edu/in-notes/rfc5598.txt' />
</reference>

<reference anchor='GSS-API'>
<front>
<title abbrev='GSS-API'>Generic Security Service Application Program Interface Version 2, Update 1</title>
<author initials='J.' surname='Linn' fullname='John Linn'>
<organization>RSA Laboratories</organization>
<address>
<postal>
<street>20 Crosby Drive</street>
<city>Bedford</city>
<region>MA</region>
<code>01730</code>
<country>US</country></postal>
<phone>+1 781 687 7817</phone>
<email>jlinn@rsasecurity.com</email></address></author>
<date year='2000' month='January' />
<abstract>
<t>The Generic Security Service Application Program Interface (GSS-API), Version 2, as defined in, provides security services to callers in a generic fashion, supportable with a range of underlying mechanisms and technologies and hence allowing source-level portability of applications to different environments. This specification defines GSS-API services and primitives at a level independent of underlying mechanism and programming language environment, and is to be complemented by other, related specifications:</t>
<t>documents defining specific parameter bindings for particular language environments</t>
<t>documents defining token formats, protocols, and procedures to be implemented in order to realize GSS-API services atop particular security mechanisms</t>
<t>This memo obsoletesmaking specific, incremental changes in response to implementation experience and liaison requests. It is intended, therefore, that this memo or a successor version thereto will become the basis for subsequent progression of the GSS-API specification on the standards track.</t></abstract></front>
<seriesInfo name='RFC' value='2743' />
<format type='TXT' octets='229418' target='ftp://ftp.isi.edu/in-notes/rfc2743.txt' />
</reference>

<reference anchor='HASHES'>
<front>
<title>Attacks on Cryptographic Hashes in Internet Protocols</title>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'>
<organization /></author>
<author initials='B.' surname='Schneier' fullname='B. Schneier'>
<organization /></author>
<date year='2005' month='November' />
<abstract>
<t>Recent announcements of better-than-expected collision attacks in popular hash algorithms have caused some people to question whether common Internet protocols need to be changed, and if so, how.  This document summarizes the use of hashes in many protocols, discusses how the collision attacks affect and do not affect the protocols, shows how to thwart known attacks on digital certificates, and discusses future directions for protocol designers.  This memo provides information for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='4270' />
<format type='TXT' octets='26641' target='ftp://ftp.isi.edu/in-notes/rfc4270.txt' />
</reference>

<reference anchor='HTTP'>
<front>
<title abbrev='HTTP/1.1'>Hypertext Transfer Protocol -- HTTP/1.1</title>
<author initials='R.' surname='Fielding' fullname='Roy T.  Fielding'>
<organization abbrev='UC Irvine'>Department of Information and Computer Science</organization>
<address>
<postal>
<street>University of California, Irvine</street>
<city>Irvine</city>
<region>CA</region>
<code>92697-3425</code></postal>
<facsimile>+1(949)824-1715</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials='J.' surname='Gettys' fullname='James Gettys'>
<organization abbrev='Compaq/W3C'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>jg@w3.org</email></address></author>
<author initials='J.' surname='Mogul' fullname='Jeffrey C.  Mogul'>
<organization abbrev='Compaq'>Compaq Computer Corporation</organization>
<address>
<postal>
<street>Western Research Laboratory</street>
<street>250 University Avenue</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94305</code></postal>
<email>mogul@wrl.dec.com</email></address></author>
<author initials='H.' surname='Frystyk' fullname='Henrik Frystyk Nielsen'>
<organization abbrev='MIT/LCS'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>frystyk@w3.org</email></address></author>
<author initials='L.' surname='Masinter' fullname='Larry Masinter'>
<organization abbrev='Xerox'>Xerox Corporation</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94034</code></postal>
<email>masinter@parc.xerox.com</email></address></author>
<author initials='P.' surname='Leach' fullname='Paul J.  Leach'>
<organization abbrev='Microsoft'>Microsoft Corporation</organization>
<address>
<postal>
<street>1 Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code></postal>
<email>paulle@microsoft.com</email></address></author>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization abbrev='MIT/LCS'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>timbl@w3.org</email></address></author>
<date month='June' year='1999' />
<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems.  It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers .  A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.
</t>
<t>
   HTTP has been in use by the World-Wide Web global information
   initiative since 1990.  This specification defines the protocol
   referred to as "HTTP/1.1", and is an update to RFC 2068 .
</t></abstract></front>
<seriesInfo name='RFC' value='2616' />
<format type='TXT' octets='422317' target='ftp://ftp.isi.edu/in-notes/rfc2616.txt' />
<format type='PS' octets='5529857' target='ftp://ftp.isi.edu/in-notes/rfc2616.ps' />
<format type='PDF' octets='550558' target='ftp://ftp.isi.edu/in-notes/rfc2616.pdf' />
<format type='HTML' octets='498891' target='http://xml.resource.org/public/rfc/html/rfc2616.html' />
<format type='XML' octets='471630' target='http://xml.resource.org/public/rfc/xml/rfc2616.xml' />
</reference>

<reference anchor='IMAP'>
<front>
<title>INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1</title>
<author initials='M.' surname='Crispin' fullname='M. Crispin'>
<organization /></author>
<date year='2003' month='March' /></front>
<seriesInfo name='RFC' value='3501' />
<format type='TXT' octets='227640' target='ftp://ftp.isi.edu/in-notes/rfc3501.txt' />
</reference>

<reference anchor="IMP-REQS">
<front>
<title abbrev='Instant Messaging/Presence Protocol'>Instant Messaging / Presence Protocol Requirements</title>
<author initials='M.' surname='Day' fullname='Mark Day'>
<organization>SightPath, Inc.</organization>
<address>
<postal>
<street>135 Beaver Street</street>
<city>Waltham</city>
<region>MA</region>
<code>02452</code>
<country>US</country></postal>
<email>mday@alum.mit.edu</email></address></author>
<author initials='S.' surname='Aggarwal' fullname='Sonu Aggarwal'>
<organization>Microsoft Corporation</organization>
<address>
<postal>
<street>One Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code>
<country>US</country></postal>
<email>sonuag@microsoft.com</email></address></author>
<author initials='J.' surname='Vincent' fullname='Jesse Vincent'>
<organization>Into Networks, Inc.</organization>
<address>
<postal>
<street>150 Cambridgepark Drive</street>
<city>Cambridge</city>
<region>MA</region>
<code>02140</code>
<country>US</country></postal>
<email>jesse@intonet.com</email></address></author>
<date month='February' year='2000' />
<abstract>
<t>Presence and Instant Messaging have recently emerged as a new medium of communications over the Internet.  Presence is a means for finding, retrieving, and subscribing to changes in the presence information (e.g.  "online" or "offline") of other users.  Instant messaging is a means for sending small, simple messages that are delivered immediately to online users.</t>
<t>Applications of presence and instant messaging currently use independent, non-standard and non-interoperable protocols developed by various vendors.  The goal of the Instant Messaging and Presence Protocol (IMPP) Working Group is to define a standard protocol so that independently developed applications of instant messaging and/or   presence can interoperate across the Internet.  This document defines a minimal set of requirements that IMPP must meet.</t></abstract></front>
<seriesInfo name='RFC' value='2779' />
<format type='TXT' octets='47420' target='ftp://ftp.isi.edu/in-notes/rfc2779.txt' />
</reference>

<reference anchor='INTEROP'>
<front>
<title>Formalizing IETF Interoperability Reporting</title>
<author initials='L' surname='Masinter' fullname='Larry Masinter'>
    <organization />
</author>
<date month='October' day='12' year='2005' />
<abstract><t>This document suggests another way of reforming IETF standards process by formalizing the mechanism for interoperability reporting, as a way of facilitating standards development. It establishes two kinds of reports: a 'Protocol Feature Set', which lays out the set of features from IETF specifications that constitute a protocol, and a 'Protocol Implementation Report', which is submitted by an individual or group to report on implementation and interoperability testing.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-newtrk-interop-reports-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-newtrk-interop-reports-00.txt' />
</reference>

<reference anchor='IRI'>
<front>
<title>Internationalized Resource Identifiers (IRIs)</title>
<author initials='M.' surname='Duerst' fullname='M. Duerst'>
<organization /></author>
<author initials='M.' surname='Suignard' fullname='M. Suignard'>
<organization /></author>
<date year='2005' month='January' />
<abstract>
<t>&lt;p>This document defines a new protocol element, the Internationalized Resource Identifier (IRI), as a complement of the Uniform Resource Identifier (URI). An IRI is a sequence of characters from the Universal Character Set (Unicode/ISO 10646). A mapping from IRIs to URIs is defined, which means that IRIs can be used instead of URIs, where appropriate, to identify resources.&lt;/p>&lt;p> The approach of defining a new protocol element was chosen instead of extending or changing the definition of URIs. This was done in order to allow a clear distinction and to avoid incompatibilities with existing software. Guidelines are provided for the use and deployment of IRIs in various protocols, formats, and software components that currently deal with URIs.&lt;/p></t></abstract></front>
<seriesInfo name='RFC' value='3987' />
<format type='TXT' octets='111190' target='ftp://ftp.isi.edu/in-notes/rfc3987.txt' />
</reference>

<reference anchor="LINKLOCAL">
<front>
<title>Dynamic Configuration of IPv4 Link-Local Addresses</title>
<author initials='S.' surname='Cheshire' fullname='S. Cheshire'>
<organization /></author>
<author initials='B.' surname='Aboba' fullname='B. Aboba'>
<organization /></author>
<author initials='E.' surname='Guttman' fullname='E. Guttman'>
<organization /></author>
<date year='2005' day='23' month='May' /></front>
<seriesInfo name='RFC' value='3927' />
<format type='TXT' octets='83102' target='ftp://ftp.isi.edu/in-notes/rfc3927.txt' />
</reference>

<reference anchor='MAILBOXES'>
<front>
<title abbrev='Mailbox Names'>MAILBOX NAMES FOR COMMON SERVICES, ROLES AND FUNCTIONS</title>
<author initials='D.' surname='Crocker' fullname='Dave Crocker'>
<organization>Internet Mail Consortium</organization>
<address>
<postal>
<street>127 Segre Ave.</street>
<street>Santa Cruz</street>
<country>CA</country></postal>
<phone>+1 408 246 8253</phone>
<email>dcrocker@imc.org</email></address></author>
<date year='1997' month='May' />
<area>Applications</area>
<keyword>mail</keyword>
<abstract>
<t>
   This specification enumerates and describes Internet mail addresses
   (mailbox name @ host reference) to be used when contacting personnel
   at an organization.  Mailbox names are provided for both operations
   and business functions.  Additional mailbox names and aliases are not
   prohibited, but organizations which support email exchanges with the
   Internet are encouraged to support AT LEAST each mailbox name for
   which the associated function exists within the organization.
</t></abstract></front>
<seriesInfo name='RFC' value='2142' />
<format type='TXT' octets='12195' target='ftp://ftp.isi.edu/in-notes/rfc2142.txt' />
<format type='HTML' octets='29012' target='http://xml.resource.org/public/rfc/html/rfc2142.html' />
<format type='XML' octets='16576' target='http://xml.resource.org/public/rfc/xml/rfc2142.xml' />
</reference>

<reference anchor='POP3'>
<front>
<title abbrev='POP3'>Post Office Protocol - Version 3</title>
<author initials='J.G.' surname='Myers' fullname='John G.  Myers'>
<organization>Carnegie-Mellon University</organization>
<address>
<postal>
<street>5000 Forbes Ave</street>
<city>Pittsburgh</city>
<region>PA</region>
<code>15213</code>
<country>US</country></postal>
<email>jgm+@cmu.edu</email></address></author>
<author initials='M.T.' surname='Rose' fullname='Marshall T.  Rose'>
<organization>Dover Beach Consulting, Inc.</organization>
<address>
<postal>
<street>420 Whisman Court</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043-2186</code>
<country>US</country></postal>
<email>mrose@dbc.mtview.ca.us</email></address></author>
<date month='May' year='1996' /></front>
<seriesInfo name='STD' value='53' />
<seriesInfo name='RFC' value='1939' />
<format type='TXT' octets='47018' target='ftp://ftp.isi.edu/in-notes/rfc1939.txt' />
</reference>

<reference anchor='PROCESS'>
<front>
<title abbrev='Internet Standards Process'>The Internet Standards Process -- Revision 3</title>
<author initials='S.' surname='Bradner' fullname='Scott O. Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<city>Cambridge</city>
<region>MA</region>
<code>02138</code>
<country>US</country></postal>
<phone>+1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1996' month='October' />
<abstract>
<t>This memo documents the process used by the Internet community for the standardization of protocols and procedures.  It defines the stages in the standardization process, the requirements for moving a document between stages and the types of documents used during this process.  It also addresses the intellectual property rights and copyright issues associated with the standards process.</t></abstract></front>
<seriesInfo name='BCP' value='9' />
<seriesInfo name='RFC' value='2026' />
<format type='TXT' octets='86731' target='ftp://ftp.isi.edu/in-notes/rfc2026.txt' />
</reference>

<reference anchor='REPORTS'>
<front>
<title>Guidance on Interoperation and Implementation Reports for Advancement to Draft Standard</title>
<author initials='L.' surname='Dusseault' fullname='L. Dusseault'>
<organization /></author>
<author initials='R.' surname='Sparks' fullname='R. Sparks'>
<organization /></author>
<date year='2009' month='September' />
<abstract>
<t>Advancing a protocol to Draft Standard requires documentation of the interoperation and implementation of the protocol.  Historic reports have varied widely in form and level of content and there is little guidance available to new report preparers.  This document updates the existing processes and provides more detail on what is appropriate in an interoperability and implementation report.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>
<seriesInfo name='BCP' value='9' />
<seriesInfo name='RFC' value='5657' />
<format type='TXT' octets='29327' target='ftp://ftp.isi.edu/in-notes/rfc5657.txt' />
</reference>

<reference anchor="REST">
<front>
<title>Architectural Styles and the Design of Network-based Software Architectures</title>
<author initials="R." surname="Fielding" fullname="Roy Thomas Fielding">
  <organization>University of California, Irvine</organization>
</author>
</front>
<seriesInfo name="" value="2000" />
<format type="PDF" target="http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf"/>
</reference> 

<reference anchor='RFC3920'>
<front>
<title abbrev='XMPP Core'>Extensible Messaging and Presence Protocol (XMPP): Core</title>
<author initials='P.' surname='Saint-Andre' fullname='Peter Saint-Andre' role='editor'>
<organization>Jabber Software Foundation</organization>
<address>
<email>stpeter@jabber.org</email></address></author>
<date year='2004' month='October' />
<area>Applications</area>
<workgroup>XMPP Working Group</workgroup>
<keyword>RFC</keyword>
<keyword>Request for Comments</keyword>
<keyword>I-D</keyword>
<keyword>Internet-Draft</keyword>
<keyword>XMPP</keyword>
<keyword>Extensible Messaging and Presence Protocol</keyword>
<keyword>Jabber</keyword>
<keyword>IM</keyword>
<keyword>Instant Messaging</keyword>
<keyword>Presence</keyword>
<keyword>XML</keyword>
<keyword>Extensible Markup Language</keyword>
<abstract>
<t>This memo defines the core features of the Extensible Messaging and Presence Protocol (XMPP), a protocol for streaming Extensible Markup Language (XML) elements in order to exchange structured information in close to real time between any two network endpoints.  While XMPP provides a generalized, extensible framework for exchanging XML data, it is used mainly for the purpose of building instant messaging and presence applications that meet the requirements of RFC 2779.</t></abstract></front>
<seriesInfo name='RFC' value='3920' />
<format type='TXT' octets='194313' target='ftp://ftp.isi.edu/in-notes/rfc3920.txt' />
<format type='HTML' octets='279912' target='http://xml.resource.org/public/rfc/html/rfc3920.html' />
<format type='XML' octets='234610' target='http://xml.resource.org/public/rfc/xml/rfc3920.xml' />
</reference>

<reference anchor='RFC3921'>
<front>
<title abbrev='XMPP IM'>Extensible Messaging and Presence Protocol (XMPP): Instant Messaging and Presence</title>
<author initials='P.' surname='Saint-Andre' fullname='Peter Saint-Andre' role='editor'>
<organization>Jabber Software Foundation</organization>
<address>
<email>stpeter@jabber.org</email></address></author>
<date year='2004' month='October' />
<area>Applications</area>
<workgroup>XMPP Working Group</workgroup>
<keyword>RFC</keyword>
<keyword>Request for Comments</keyword>
<keyword>I-D</keyword>
<keyword>Internet-Draft</keyword>
<keyword>XMPP</keyword>
<keyword>Extensible Messaging and Presence Protocol</keyword>
<keyword>Jabber</keyword>
<keyword>IM</keyword>
<keyword>Instant Messaging</keyword>
<keyword>Presence</keyword>
<keyword>XML</keyword>
<keyword>Extensible Markup Language</keyword>
<abstract>
<t>This memo describes extensions to and applications of the core features of the Extensible Messaging and Presence Protocol (XMPP) that provide the basic instant messaging (IM) and presence functionality defined in RFC 2779.</t></abstract></front>
<seriesInfo name='RFC' value='3921' />
<format type='TXT' octets='217527' target='ftp://ftp.isi.edu/in-notes/rfc3921.txt' />
<format type='HTML' octets='274538' target='http://xml.resource.org/public/rfc/html/rfc3921.html' />
<format type='XML' octets='234468' target='http://xml.resource.org/public/rfc/xml/rfc3921.xml' />
</reference>

<reference anchor='SECTERMS'>
<front>
<title>Internet Security Glossary, Version 2</title>
<author initials='R.' surname='Shirey' fullname='R. Shirey'>
<organization /></author>
<date year='2007' month='August' />
<abstract>
<t>This Glossary provides definitions, abbreviations, and explanations of terminology for information system security.  The 334 pages of entries offer recommendations to improve the comprehensibility of written material that is generated in the Internet Standards Process (RFC 2026).  The recommendations follow the principles that such writing should (a) use the same term or definition whenever the same concept is mentioned; (b) use terms in their plainest, dictionary sense; (c) use terms that are already well-established in open publications; and (d) avoid terms that either favor a particular vendor or favor a particular technology or mechanism over other, competing techniques that already exist or could be developed.  This memo provides information for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='4949' />
<format type='TXT' octets='867626' target='ftp://ftp.isi.edu/in-notes/rfc4949.txt' />
</reference>

<reference anchor='SMTP'>
<front>
<title>Simple Mail Transfer Protocol</title>
<author initials='J.' surname='Klensin' fullname='J. Klensin'>
<organization /></author>
<date year='2008' month='October' />
<abstract>
<t>This document is a specification of the basic protocol for Internet electronic mail transport.  It consolidates, updates, and clarifies several previous documents, making all or parts of most of them obsolete.  It covers the SMTP extension mechanisms and best practices for the contemporary Internet, but does not provide details about particular extensions.  Although SMTP was designed as a mail transport and delivery protocol, this specification also contains information that is important to its use as a "mail submission" protocol for "split-UA" (User Agent) mail reading systems and mobile environments. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5321' />
<format type='TXT' octets='225929' target='ftp://ftp.isi.edu/in-notes/rfc5321.txt' />
</reference>

<reference anchor='STRONGSEC'>
<front>
<title>Strong Security Requirements for Internet Engineering Task Force Standard Protocols</title>
<author initials='J.' surname='Schiller' fullname='J. Schiller'>
<organization /></author>
<date year='2002' month='August' /></front>
<seriesInfo name='BCP' value='61' />
<seriesInfo name='RFC' value='3365' />
<format type='TXT' octets='16411' target='ftp://ftp.isi.edu/in-notes/rfc3365.txt' />
</reference>

<reference anchor='URN-OID'>
<front>
<title>A URN Namespace of Object Identifiers</title>
<author initials='M.' surname='Mealling' fullname='M. Mealling'>
<organization /></author>
<date year='2001' month='February' />
<abstract>
<t>&lt;p>This document describes a Uniform Resource Name (URN) namespace that contains Object Identifiers (OIDs). This memo provides information for the Internet community. &lt;/p></t></abstract></front>
<seriesInfo name='RFC' value='3061' />
<format type='TXT' octets='8387' target='ftp://ftp.isi.edu/in-notes/rfc3061.txt' />
</reference>

<reference anchor="USINGTLS">
<front>
<title>Using TLS with IMAP, POP3 and ACAP</title>
<author initials='C.' surname='Newman' fullname='Chris Newman'>
<organization>Innosoft International, Inc.</organization>
<address>
<postal>
<street>1050 Lakes Drive</street>
<city>West Covina</city>
<region>CA</region>
<code>91790</code>
<country>US</country></postal>
<email>chris.newman@innosoft.com</email></address></author>
<date month='June' year='1999' /></front>
<seriesInfo name='RFC' value='2595' />
<format type='TXT' octets='32440' target='ftp://ftp.isi.edu/in-notes/rfc2595.txt' />
</reference>

<reference anchor="XEP-0001">
  <front>
    <title>XMPP Extension Protocols</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="23" month="January" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0001"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0001.html"/>
</reference>

<reference anchor="XEP-0016">
  <front>
    <title>Privacy Lists</title>
    <author initials="P." surname="Millard" fullname="Peter Millard">
      <organization/>
      <address/>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="15" month="February" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0016"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0016.html"/>
</reference>

<reference anchor="XEP-0045">
  <front>
    <title>Multi-User Chat</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="17" month="July" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0045"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0045.html"/>
</reference>

<reference anchor="XEP-0060">
  <front>
    <title>Publish-Subscribe</title>
    <author initials="P." surname="Millard" fullname="Peter Millard">
      <organization/>
      <address>
        <email></email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <author initials="R." surname="Meijer" fullname="Ralph Meijer">
      <organization/>
      <address>
        <email>ralphm@ik.nu</email>
      </address>
    </author>
    <date day="3" month="September" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0060"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0060.html"/>
</reference>

<reference anchor="XEP-0071">
  <front>
    <title>XHTML-IM</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="3" month="September" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0071"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0071.html"/>
</reference>

<reference anchor="XEP-0077">
  <front>
    <title>In-Band Registration</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="24" month="January" year="2006"/>
  </front>
  <seriesInfo name="XSF XEP" value="0077"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0077.html"/>
</reference>

<reference anchor="XEP-0124">
  <front>
    <title>Bidirectional-streams Over Synchronous HTTP (BOSH)</title>
    <author initials="I." surname="Paterson" fullname="Ian Paterson">
      <organization/>
      <address>
        <email>ian.paterson@clientside.co.uk</email>
      </address>
    </author>
    <author initials="D." surname="Smith" fullname="Dave Smith">
      <organization/>
      <address>
        <email>dizzyd@jabber.org</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="30" month="April" year="2009"/>
  </front>
  <seriesInfo name="XSF XEP" value="0124"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0124.html"/>
</reference>

<reference anchor="XEP-0156">
  <front>
    <title>Discovering Alternative XMPP Connection Methods</title>
    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization/>
      <address>
        <email>jhildebrand@jabber.com</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="12" month="June" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0156"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0156.html"/>
</reference>

<reference anchor="XEP-0174">
  <front>
    <title>Link-Local Messaging</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="26" month="November" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0174"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0174.html"/>
</reference>

<reference anchor="XEP-0175">
  <front>
    <title>Best Practices for Use of SASL ANONYMOUS</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="7" month="November" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0175"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0175.html"/>
</reference>

<reference anchor="XEP-0178">
  <front>
    <title>Best Practices for Use of SASL EXTERNAL with Certificates</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <author initials="P." surname="Millard" fullname="Peter Millard">
      <organization/>
      <address>
        <email></email>
      </address>
    </author>
    <date day="15" month="February" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0178"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0178.html"/>
</reference>

<reference anchor="XEP-0191">
  <front>
    <title>Simple Communications Blocking</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="15" month="February" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0191"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0191.html"/>
</reference>

<reference anchor="XEP-0198">
  <front>
    <title>Stream Management</title>
    <author initials="J." surname="Karneges" fullname="Justin Karneges">
      <organization/>
      <address>
        <email>justin@affinix.com</email>
      </address>
    </author>
    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization/>
      <address>
        <email>jhildebr@cisco.com</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="F." surname="Forno" fullname="Fabio Forno">
      <organization/>
      <address>
        <email>fabio.forno@gmail.com</email>
      </address>
    </author>
    <date day="17" month="June" year="2009"/>
  </front>
  <seriesInfo name="XSF XEP" value="0198"/>
  <format type="HTML" target="http://xmpp.org/extensions/xep-0198.html"/>
</reference>

<reference anchor="XEP-0199">
  <front>
    <title>XMPP Ping</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="03" month="June" year="2009"/>
  </front>
  <seriesInfo name="XSF XEP" value="0199"/>
  <format type="HTML" target="http://xmpp.org/extensions/xep-0199.html"/>
</reference>

<reference anchor="XEP-0205">
  <front>
    <title>Best Practices to Discourage Denial of Service Attacks</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="7" month="January" year="2009"/>
  </front>
  <seriesInfo name="XSF XEP" value="0205"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0205.html"/>
</reference>

<reference anchor="XEP-0206">
  <front>
    <title>XMPP Over BOSH</title>
    <author initials="I." surname="Paterson" fullname="Ian Paterson">
      <organization/>
      <address>
        <email>ian.paterson@clientside.co.uk</email>
      </address>
    </author>
    <date day="29" month="October" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0206"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0206.html"/>
</reference>

<reference anchor="XEP-0220">
  <front>
    <title>Server Dialback</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <author initials="J." surname="Miller" fullname="Jeremie Miller">
      <organization/>
      <address>
        <email>jeremie@jabber.org</email>
      </address>
    </author>
    <date day="16" month="October" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0220"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0220.html"/>
</reference>

<reference anchor='XML-FRAG'
           target='http://www.w3.org/TR/2001/CR-xml-fragment-20010212'>
<front>
<title>XML Fragment Interchange</title>
<author initials='P.' surname='Grosso' fullname='Paul Grosso'>
    <organization />
</author>
<author initials='D.' surname='Veillard' fullname='Daniel Veillard'>
    <organization />
</author>
<date month='February' day='12' year='2001' />
</front>
<seriesInfo name='World Wide Web Consortium CR' value='CR-xml-fragment-20010212' />
<format type='HTML' target='http://www.w3.org/TR/2001/CR-xml-fragment-20010212' />
</reference>

<reference anchor="XML-REG">
<front>
<title>The IETF XML Registry</title>
<author initials='M.' surname='Mealling' fullname='M. Mealling'>
<organization /></author>
<date month='January' year='2004' /></front>
<seriesInfo name='BCP' value='81' />
<seriesInfo name='RFC' value='3688' />
<format type='TXT' octets='17325' target='ftp://ftp.isi.edu/in-notes/rfc3688.txt' />
</reference>

<reference anchor='XML-SCHEMA'
           target='http://www.w3.org/TR/2004/REC-xmlschema-1-20041028'>
<front>
<title>XML Schema Part 1: Structures Second Edition</title>
<author initials='H.' surname='Thompson' fullname='Henry S. Thompson'>
    <organization />
</author>
<author initials='M.' surname='Maloney' fullname='Murray Maloney'>
    <organization />
</author>
<author initials='N.' surname='Mendelsohn' fullname='Noah Mendelsohn'>
    <organization />
</author>
<author initials='D.' surname='Beech' fullname='David Beech'>
    <organization />
</author>
<date month='October' day='28' year='2004' />
</front>
<seriesInfo name='World Wide Web Consortium Recommendation' value='REC-xmlschema-1-20041028' />
<format type='HTML' target='http://www.w3.org/TR/2004/REC-xmlschema-1-20041028' />
</reference>

<reference anchor="XMPP-IM">
<front>
<title>Extensible Messaging and Presence Protocol (XMPP): Instant Messaging and Presence</title>
<author initials='P' surname='Saint-Andre' fullname='Peter Saint-Andre'>
    <organization />
</author>
<date month='March' day='31' year='2010' />
<abstract><t>This document describes extensions to the core features of the Extensible Messaging and Presence Protocol (XMPP) that provide basic instant messaging (IM) and presence functionality in conformance with RFC 2779. This document obseletes RFC 3921.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-xmpp-3921bis-06' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-xmpp-3921bis-06.txt' />
</reference>

<reference anchor='XMPP-URI'>
<front>
<title>Internationalized Resource Identifiers (IRIs) and Uniform Resource Identifiers (URIs) for the Extensible Messaging and Presence Protocol (XMPP)</title>
<author initials='P.' surname='Saint-Andre' fullname='P. Saint-Andre'>
<organization /></author>
<date year='2008' month='February' />
<abstract>
<t>This document defines the use of Internationalized Resource Identifiers (IRIs) and Uniform Resource Identifiers (URIs) in identifying or interacting with entities that can communicate via the Extensible Messaging and Presence Protocol (XMPP). [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5122' />
<format type='TXT' octets='55566' target='ftp://ftp.isi.edu/in-notes/rfc5122.txt' />
</reference>

    </references>

    <section title="XML Schemas" anchor="schema">
      <t>Because validation of XML streams and stanzas is optional, the following XML schemas are provided for descriptive purposes only.  These schemas are not normative.</t>
      <t>The following schemas formally define various XML namespaces used in the core XMPP protocols, in conformance with <xref target='XML-SCHEMA'/>.  For schemas defining the 'jabber:client' and 'jabber:server' namespaces, refer to <xref target="XMPP-IM"/>.</t>
      <section title="Streams Namespace" anchor="schemas-streams">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='http://etherx.jabber.org/streams'
    xmlns='http://etherx.jabber.org/streams'
    elementFormDefault='unqualified'>

  <xs:import namespace='jabber:client'/>
  <xs:import namespace='jabber:server'/>
  <xs:import namespace='urn:ietf:params:xml:ns:xmpp-sasl'/>
  <xs:import namespace='urn:ietf:params:xml:ns:xmpp-streams'/>
  <xs:import namespace='urn:ietf:params:xml:ns:xmpp-tls'/>

  <xs:element name='stream'>
    <xs:complexType>
      <xs:sequence xmlns:client='jabber:client'
                   xmlns:server='jabber:server'>
        <xs:element ref='features' minOccurs='0' maxOccurs='1'/>
        <xs:any namespace='urn:ietf:params:xml:ns:xmpp-tls'
                minOccurs='0'
                maxOccurs='unbounded'/>
        <xs:any namespace='urn:ietf:params:xml:ns:xmpp-sasl'
                minOccurs='0'
                maxOccurs='unbounded'/>
        <xs:choice minOccurs='0' maxOccurs='1'>
          <xs:choice minOccurs='0' maxOccurs='unbounded'>
            <xs:element ref='client:message'/>
            <xs:element ref='client:presence'/>
            <xs:element ref='client:iq'/>
          </xs:choice>
          <xs:choice minOccurs='0' maxOccurs='unbounded'>
            <xs:element ref='server:message'/>
            <xs:element ref='server:presence'/>
            <xs:element ref='server:iq'/>
            <xs:element ref='db:result'/>
            <xs:element ref='db:verify'/>
          </xs:choice>
        </xs:choice>
        <xs:element ref='error' minOccurs='0' maxOccurs='1'/>
      </xs:sequence>
      <xs:attribute name='from' type='xs:string' use='optional'/>
      <xs:attribute name='id' type='xs:string' use='optional'/>
      <xs:attribute name='to' type='xs:string' use='optional'/>
      <xs:attribute name='version' type='xs:decimal' use='optional'/>
      <xs:attribute ref='xml:lang' use='optional'/>
    </xs:complexType>
  </xs:element>

  <xs:element name='features'>
    <xs:complexType>
      <xs:any namespace='##other'/>
    </xs:complexType>
  </xs:element>

  <xs:element name='error'>
    <xs:complexType>
      <xs:sequence  xmlns:err='urn:ietf:params:xml:ns:xmpp-streams'>
        <xs:group   ref='err:streamErrorGroup'/>
        <xs:element ref='err:text'
                    minOccurs='0'
                    maxOccurs='1'/>
        <xs:any     namespace='##other'
                    minOccurs='0'
                    maxOccurs='1'/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
      <section title="Stream Error Namespace" anchor="schemas-streamerror">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-streams'
    xmlns='urn:ietf:params:xml:ns:xmpp-streams'
    elementFormDefault='qualified'>

  <xs:element name='bad-format' type='empty'/>
  <xs:element name='bad-namespace-prefix' type='empty'/>
  <xs:element name='conflict' type='empty'/>
  <xs:element name='connection-timeout' type='empty'/>
  <xs:element name='host-gone' type='empty'/>
  <xs:element name='host-unknown' type='empty'/>
  <xs:element name='improper-addressing' type='empty'/>
  <xs:element name='internal-server-error' type='empty'/>
  <xs:element name='invalid-from' type='empty'/>
  <xs:element name='invalid-id' type='empty'/>
  <xs:element name='invalid-namespace' type='empty'/>
  <xs:element name='invalid-xml' type='empty'/>
  <xs:element name='not-authorized' type='empty'/>
  <xs:element name='policy-violation' type='empty'/>
  <xs:element name='remote-connection-failed' type='empty'/>
  <xs:element name='reset' type='empty'/>
  <xs:element name='resource-constraint' type='empty'/>
  <xs:element name='restricted-xml' type='empty'/>
  <xs:element name='see-other-host' type='xs:string'/>
  <xs:element name='system-shutdown' type='empty'/>
  <xs:element name='undefined-condition' type='empty'/>
  <xs:element name='unsupported-encoding' type='empty'/>
  <xs:element name='unsupported-stanza-type' type='empty'/>
  <xs:element name='unsupported-version' type='empty'/>
  <xs:element name='xml-not-well-formed' type='empty'/>

  <xs:group name='streamErrorGroup'>
    <xs:choice>
      <xs:element ref='bad-format'/>
      <xs:element ref='bad-namespace-prefix'/>
      <xs:element ref='conflict'/>
      <xs:element ref='connection-timeout'/>
      <xs:element ref='host-gone'/>
      <xs:element ref='host-unknown'/>
      <xs:element ref='improper-addressing'/>
      <xs:element ref='internal-server-error'/>
      <xs:element ref='invalid-from'/>
      <xs:element ref='invalid-id'/>
      <xs:element ref='invalid-namespace'/>
      <xs:element ref='invalid-xml'/>
      <xs:element ref='not-authorized'/>
      <xs:element ref='policy-violation'/>
      <xs:element ref='remote-connection-failed'/>
      <xs:element ref='reset'/>
      <xs:element ref='resource-constraint'/>
      <xs:element ref='restricted-xml'/>
      <xs:element ref='see-other-host'/>
      <xs:element ref='system-shutdown'/>
      <xs:element ref='undefined-condition'/>
      <xs:element ref='unsupported-encoding'/>
      <xs:element ref='unsupported-stanza-type'/>
      <xs:element ref='unsupported-version'/>
      <xs:element ref='xml-not-well-formed'/>
    </xs:choice>
  </xs:group>

  <xs:element name='text'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='xs:string'>
          <xs:attribute ref='xml:lang' use='optional'/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name='empty'>
    <xs:restriction base='xs:string'>
      <xs:enumeration value=''/>
    </xs:restriction>
  </xs:simpleType>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
      <section title="STARTTLS Namespace" anchor="schemas-starttls">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-tls'
    xmlns='urn:ietf:params:xml:ns:xmpp-tls'
    elementFormDefault='qualified'>

  <xs:element name='starttls'>
    <xs:complexType>
      <xs:choice minOccurs='0' maxOccurs='1'>
        <xs:element name='required' type='empty'/>
      </xs:choice>
    </xs:complexType>
  </xs:element>

  <xs:element name='proceed' type='empty'/>

  <xs:element name='failure' type='empty'/>

  <xs:simpleType name='empty'>
    <xs:restriction base='xs:string'>
      <xs:enumeration value=''/>
    </xs:restriction>
  </xs:simpleType>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
      <section title="SASL Namespace" anchor="schemas-sasl">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-sasl'
    xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
    elementFormDefault='qualified'>

  <xs:element name='mechanisms'>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='mechanism'
                    minOccurs='1'
                    maxOccurs='unbounded'
                    type='xs:NMTOKEN'/>
        <xs:any namespace='##other'
                minOccurs='0'
                minOccurs='unbounded'/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name='abort' type='empty'/>

  <xs:element name='auth'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='xs:string'>
          <xs:attribute name='mechanism'
                        type='xs:NMTOKEN'
                        use='required'/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:element name='challenge' type='xs:string'/>

  <xs:element name='response' type='xs:string'/>

  <xs:element name='success' type='xs:string'/>

  <xs:element name='failure'>
    <xs:complexType>
      <xs:sequence>
        <xs:choice minOccurs='0'>
          <xs:element name='aborted' type='empty'/>
          <xs:element name='account-disabled' type='empty'/>
          <xs:element name='credentials-expired' type='empty'/>
          <xs:element name='encryption-required' type='empty'/>
          <xs:element name='incorrect-encoding' type='empty'/>
          <xs:element name='invalid-authzid' type='empty'/>
          <xs:element name='invalid-mechanism' type='empty'/>
          <xs:element name='malformed-request' type='empty'/>
          <xs:element name='mechanism-too-weak' type='empty'/>
          <xs:element name='not-authorized' type='empty'/>
          <xs:element name='temporary-auth-failure' type='empty'/>
          <xs:element name='transition-needed' type='empty'/>
        </xs:choice>
        <xs:element ref='text' minOccurs='0' maxOccurs='1'/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name='text'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='xs:string'>
          <xs:attribute ref='xml:lang' use='optional'/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name='empty'>
    <xs:restriction base='xs:string'>
      <xs:enumeration value=''/>
    </xs:restriction>
  </xs:simpleType>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
      <section title="Resource Binding Namespace" anchor="schemas-bind">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-bind'
    xmlns='urn:ietf:params:xml:ns:xmpp-bind'
    elementFormDefault='qualified'>

  <xs:element name='bind'>
    <xs:complexType>
      <xs:choice>
        <xs:choice>
          <xs:element name='resource' type='resourceType'/>
          <xs:element name='jid' type='fullJIDType'/>
        </xs:choice>
        <xs:any namespace='##other'
                minOccurs='0'
                minOccurs='unbounded'/>
      </xs:choice>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name='fullJIDType'>
    <xs:restriction base='xs:string'>
      <xs:minLength value='8'/>
      <xs:maxLength value='3071'/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name='resourceType'>
    <xs:restriction base='xs:string'>
      <xs:minLength value='1'/>
      <xs:maxLength value='1023'/>
    </xs:restriction>
  </xs:simpleType>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
      <section title="Stanza Error Namespace" anchor="schemas-stanzaerror">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-stanzas'
    xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'
    elementFormDefault='qualified'>

  <xs:element name='bad-request' type='empty'/>
  <xs:element name='conflict' type='empty'/>
  <xs:element name='feature-not-implemented' type='empty'/>
  <xs:element name='forbidden' type='empty'/>
  <xs:element name='gone' type='xs:string'/>
  <xs:element name='internal-server-error' type='empty'/>
  <xs:element name='item-not-found' type='empty'/>
  <xs:element name='jid-malformed' type='empty'/>
  <xs:element name='not-acceptable' type='empty'/>
  <xs:element name='not-allowed' type='empty'/>
  <xs:element name='not-authorized' type='empty'/>
  <xs:element name='not-modified' type='empty'/>
  <xs:element name='payment-required' type='empty'/>
  <xs:element name='policy-violation' type='empty'/>
  <xs:element name='recipient-unavailable' type='empty'/>
  <xs:element name='redirect' type='xs:string'/>
  <xs:element name='registration-required' type='empty'/>
  <xs:element name='remote-server-not-found' type='empty'/>
  <xs:element name='remote-server-timeout' type='empty'/>
  <xs:element name='resource-constraint' type='empty'/>
  <xs:element name='service-unavailable' type='empty'/>
  <xs:element name='subscription-required' type='empty'/>
  <xs:element name='undefined-condition' type='empty'/>
  <xs:element name='unexpected-request' type='empty'/>
  <xs:element name='unknown-sender' type='empty'/>

  <xs:group name='stanzaErrorGroup'>
    <xs:choice>
      <xs:element ref='bad-request'/>
      <xs:element ref='conflict'/>
      <xs:element ref='feature-not-implemented'/>
      <xs:element ref='forbidden'/>
      <xs:element ref='gone'/>
      <xs:element ref='internal-server-error'/>
      <xs:element ref='item-not-found'/>
      <xs:element ref='jid-malformed'/>
      <xs:element ref='not-acceptable'/>
      <xs:element ref='not-authorized'/>
      <xs:element ref='not-allowed'/>
      <xs:element ref='not-modified'/>
      <xs:element ref='payment-required'/>
      <xs:element ref='policy-violation'/>
      <xs:element ref='recipient-unavailable'/>
      <xs:element ref='redirect'/>
      <xs:element ref='registration-required'/>
      <xs:element ref='remote-server-not-found'/>
      <xs:element ref='remote-server-timeout'/>
      <xs:element ref='resource-constraint'/>
      <xs:element ref='service-unavailable'/>
      <xs:element ref='subscription-required'/>
      <xs:element ref='undefined-condition'/>
      <xs:element ref='unexpected-request'/>
      <xs:element ref='unknown-sender'/>
    </xs:choice>
  </xs:group>

  <xs:element name='text'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='xs:string'>
          <xs:attribute ref='xml:lang' use='optional'/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name='empty'>
    <xs:restriction base='xs:string'>
      <xs:enumeration value=''/>
    </xs:restriction>
  </xs:simpleType>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
    </section>

    <section title="Contact Addresses" anchor="contact">
      <t>Consistent with <xref target='MAILBOXES'/>, an organization that offers an XMPP service SHOULD provide an Internet mailbox of "XMPP" for inquiries related to that service, where the host portion of the resulting mailto URI MUST be the organization's domain, not the domain of the XMPP service itself (e.g., the XMPP service might be offered at im.example.com but the Internet mailbox would be &lt;xmpp@example.com&gt;).</t>
    </section>

    <section title="Account Provisioning" anchor="provisioning">
      <t>Account provisioning is out of scope for this specification.  Possible methods for account provisioning include account creation by a server administrator and in-band account registration using the 'jabber:iq:register' namespace as documented in <xref target="XEP-0077"/>.</t>
    </section>

    <section title="Differences From RFC 3920" anchor="diffs">
      <t>Based on consensus derived from implementation and deployment experience as well as formal interoperability testing, the following substantive modifications were made from RFC 3920.</t>
      <t>
        <list style='symbols'>
          <t>Moved specification of the XMPP address format to a separate document.</t>
          <t>Recommended or mandated use of the 'from' and 'to' attributes on stream headers.</t>
          <t>More fully specified stream closing handshake.</t>
          <t>Specified recommended stream reconnection algorithm.</t>
          <t>Specified return of &lt;restricted-xml/&gt; stream error in response to receipt of prohibited XML features.</t> 
          <t>Specified that the SASL SCRAM mechanism is a mandatory-to-implement technology.</t>
          <t>Specified that TLS plus the SASL PLAIN mechanism is a mandatory-to-implement technology for client-to-server connections.</t>
          <t>Specified that support for the SASL EXTERNAL mechanism is required for servers but only recommended for clients (since end-user X.509 certificates are difficult to obtain and not yet widely deployed).</t>
          <t>Removed the hard two-connection rule for server-to-server streams if mutual authentication is successful.</t>
          <t>More clearly specified the certificate profile for both public key certificates and issuer certificates.</t>
          <t>Added the &lt;reset/&gt; streams error condition to handle expired/revoked certificates or the addition of security-critical features to an existing stream.</t>
          <t>Added the &lt;account-disabled/&gt;, &lt;credentials-expired/&gt;, &lt;encryption-required/&gt;, &lt;malformed-request/&gt;, and &lt;transition-needed/&gt; SASL error conditions to handle error flows mistakenly left out of RFC 3920 or discussed in RFC 4422 but not in RFC 2222.</t>
          <t>Added the &lt;not-modified/&gt; stanza error condition to enable potential ETags usage.</t>
          <t>Removed unnecessary requirement for escaping of characters that map to certain predefined entities, which do not need to be escaped in XML.</t>
          <t>Clarified the process of DNS SRV lookups and fallbacks.</t>
          <t>Clarified the handling of SASL security layers.</t>
          <t>Clarified the handling of stream features, regularized use of the &lt;required/&gt; child element, and defined use of the &lt;optional/&gt; child element.</t>
          <t>Clarified the handling of data that violates the well-formedness definitions for XML 1.0 and XML namespaces.</t>
          <t>Specified the security considerations in more detail, especially with regard to presence leaks and denial of service attacks.</t>
          <t>Moved historical documentation of the server dialback protocol from this specification to a separate specification maintained by the XMPP Standards Foundation.</t>
        </list>
      </t>
      <t>In addition, numerous changes of an editorial nature were made in order to more fully specify and clearly explain XMPP.</t>
    </section>

    <section title="Copying Conditions" anchor="copying">
      <t>Regarding this entire document or any portion of it, the author makes no guarantees and is not responsible for any damage resulting from its use.  The author grants irrevocable permission to anyone to use, modify, and distribute it in any way that does not diminish the rights of anyone else to use, modify, and distribute it, provided that redistributed derivative works do not contain misleading author or version information.  Derivative works need not be licensed under similar terms.</t>
    </section>

  </back>

</rfc>
