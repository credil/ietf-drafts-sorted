<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2136 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2136.xml" >
<!ENTITY RFC2535 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2535.xml" >
<!ENTITY RFC2766 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2766.xml" >
<!ENTITY RFC3022 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3022.xml" >
<!ENTITY RFC3102 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3102.xml" >
<!ENTITY RFC3748 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3748.xml" >
<!-- <!ENTITY RFC4025 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4025.xml" > -->
<!ENTITY RFC4225 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4225.xml" > 
<!ENTITY RFC4306 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4306.xml" >
<!ENTITY RFC4423 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4423.xml" >
<!ENTITY RFC5201-bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-hip-rfc5201-bis.xml" >
<!ENTITY RFC5202-bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-hip-rfc5202-bis.xml" >
<!ENTITY RFC5203-bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-hip-rfc5203-bis.xml" >
<!ENTITY RFC5204-bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-hip-rfc5204-bis.xml" >
<!ENTITY RFC5205-bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-hip-rfc5205-bis.xml" >
<!ENTITY RFC5206-bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-hip-rfc5206-bis.xml" >
<!ENTITY RFC5218 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5218.xml" >
<!ENTITY RFC6253-bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-hip-rfc6253-bis.xml" >
<!ENTITY RFC5338 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5338.xml" >
<!ENTITY RFC5482 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5482.xml" >
<!ENTITY RFC5887 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5887.xml" >
<!-- <!ENTITY hip-nat SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-hip-native-nat-traversal.xml" > -->
<!ENTITY RFC6078 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6078.xml" >
<!ENTITY RFC6250 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6250.xml" >
<!ENTITY RFC6281 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6281.xml" >
<!ENTITY RFC6317 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6317.xml" >
<!ENTITY RFC6537 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6537.xml" >
<!ENTITY RFC6538 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6538.xml" >
<!ENTITY nsrg-report SYSTEM "http://medon.htt-consult.com/~rgm/hip/reference.I-D.irtf-nsrg-report.xml" >
<!ENTITY IEEE.802-15-4.2011 SYSTEM "http://medon.htt-consult.com/~rgm/hip/reference.IEEE.802-15-4.2011.xml" >
]>

<?rfc toc="yes"?>
<?rfc strict="yes"?>
<?rfc tocindent="no"?> 
<?rfc compact="yes"?> 
<?rfc subcompact="no"?> 
<?rfc symrefs="yes"?>     <!-- use anchors instead of numbers for references -->
<?rfc sortrefs="yes" ?>   <!-- alphabetize the references -->

<rfc docName="draft-ietf-hip-rfc4423-bis-06" category="info" obsoletes="4423" ipr="pre5378Trust200902">

  <front>
    <title>Host Identity Protocol Architecture</title>

    <author initials="R." surname="Moskowitz" 
      fullname="Robert Moskowitz" role="editor">
      <organization abbrev="Verizon">Verizon
      </organization>
      <address>
	<postal>
	  <street>1000 Bent Creek Blvd, Suite 200</street>
	  <city>Mechanicsburg</city>
	  <region>PA</region>
	  <country>USA</country>
	</postal>
        <email>robert.moskowitz@verizon.com</email>
      </address>
    </author>

    <author initials="M.K.T." surname="Komu" 
      fullname="Miika Komu">
      <organization abbrev="Aalto">Aalto University
      </organization>
      <address>
	<postal>
	  <street>Konemiehentie 2</street>
	  <city>Espoo</city>
	  <!--<region></region> -->
	  <country>Finland</country>
	</postal>
        <email>miika.komu@aalto.fi</email>
      </address>
    </author>

    <date month="November" year="2013" />

    <area>Internet</area>

    <keyword>Request for Comments</keyword>
    <keyword>RFC</keyword>
    <keyword>Internet Draft</keyword>
    <keyword>I-D</keyword>

    <abstract>

      <t>This memo describes a new namespace, the Host Identity namespace,
      and a new protocol layer, the Host Identity Protocol, between the
      internetworking and transport layers.  Herein are presented the
      basics of the current namespaces, their strengths and
      weaknesses, and how a new namespace will add completeness to
      them.  The roles of this new namespace in the protocols are
      defined. </t>

      <t>
        This document obsoletes RFC 4423 and addresses the concerns raised by
        the IESG, particularly that of crypto agility.  It incorporates
        lessons learned from the implementations of RFC 5201 and goes further
        to explain how HIP works as a secure signaling channel.
      </t>
    </abstract>
  </front>

  <middle>

    <section title="Introduction">

      <t>The Internet has two important global namespaces: Internet
      Protocol (IP) addresses and Domain Name Service (DNS) names.
      These two namespaces have a set of features and abstractions
      that have powered the Internet to what it is today.  They also
      have a number of weaknesses.  Basically, since they are all we
      have, we try and do too much with them.  Semantic overloading
      and functionality extensions have greatly complicated these
      namespaces.</t>

      <t>The proposed Host Identity namespace fills an important gap between
      the IP and DNS namespaces.  A Host Identity conceptually refers
      to a computing platform, and there may be multiple such Host 
      Identities per computing platform (because the platform may wish
      to present a different identity to different communicating peers).
      The Host Identity namespace consists of Host Identifiers (HI).  
      There is exactly one Host Identifier for each Host Identity.  While
      this text later talks about non-cryptographic Host Identifiers,
      the architecture focuses on the case in which Host Identifiers are
      cryptographic in nature.  Specifically, the Host Identifier is the
      public key of an asymmetric key-pair.  Each Host Identity uniquely 
      identifies a single host, i.e., no two hosts have the same Host 
      Identity.  If two or more computing platforms have the same Host
      Identifier, then they are instantiating a distributed host.  The Host 
      Identifier can either be public (e.g.  published in the DNS), or 
      unpublished.  Client systems will tend to have both public and 
      unpublished Host Identifiers.</t>

      <t>There is a subtle but important difference between Host
      Identities and Host Identifiers.  An Identity refers to the
      abstract entity that is identified.  An Identifier, on the other
      hand, refers to the concrete bit pattern that is used in the
      identification process.</t>

      <t>Although the Host Identifiers could be used in many
      authentication systems, such as <xref
      target="RFC4306">IKEv2</xref>, the presented
      architecture introduces a new protocol, called the Host Identity
      Protocol (HIP), and a cryptographic exchange, called the HIP
      base exchange; see also <xref target="esp"/>.  
      HIP provides for limited forms of
      trust between systems, enhance mobility, multi-homing and
      dynamic IP renumbering, aid in protocol translation / transition,
      and reduce certain types of denial-of-service (DoS) attacks.
      </t>

      <t>When HIP is used, the actual payload traffic between two HIP
      hosts is typically, but not necessarily, protected with ESP.
      The Host Identities are used to create the needed ESP Security
      Associations (SAs) and to authenticate the hosts.  When ESP is
      used, the actual payload IP packets do not differ in any way
      from standard ESP protected IP packets.</t>

    <t>
      Much has been learned about HIP <xref target="RFC6538" /> since <xref target="RFC4423" />
      was published. This document expands Host Identities beyond use
      to enable IP connectivity and security to general interhost secure
      signalling at any protocol layer.  The signal may establish a security
      association between the hosts, or simply pass information within
      the channel.
    </t>

    </section>

    <section title="Terminology">

<?rfc compact="no"?> 

      <section title="Terms common to other documents">

	<texttable>
	  <ttcol width="20%" align="left">Term</ttcol>
	  <ttcol align="left">Explanation</ttcol>
	  <c>Public key</c><c>The public key of an asymmetric
	    cryptographic key pair.  Used as a publicly known identifier
	    for cryptographic identity authentication. Public is a relative
	    term here, ranging from known to peers only to known to the World.</c>

	  <c>Private key</c><c>The private or secret key of an
	    asymmetric cryptographic key pair.  Assumed to be known only
	    to the party identified by the corresponding public key.
	    Used by the identified party to authenticate its identity to
	    other parties.</c>

	  <c>Public key pair</c><c>An asymmetric cryptographic key
	     pair consisting of public and private keys.  For example,
	     Rivest-Shamir-Adelman (RSA), Digital Signature Algorithm
	     (DSA) and Elliptic Curve DSA (ECDSA) key pairs are such key pairs.</c>

	  <c>End-point</c><c>A communicating entity.  For
	    historical reasons, the term 'computing platform' is used in
	    this document as a (rough) synonym for end-point.</c>
	</texttable>

      </section>

<?rfc compact="yes"?> 

<?rfc compact="no"?> 

      <section title="Terms specific to this and other HIP documents">

	<t>It should be noted that many of the terms defined herein
	are tautologous, self-referential or defined through circular
	reference to other terms.  This is due to the succinct nature
	of the definitions.  See the text elsewhere in this document
	and in RFC 5201 <xref target="I-D.ietf-hip-rfc5201-bis" /> for more elaborate
	explanations.</t>

	<texttable>
	  <ttcol width="20%" align="left">Term</ttcol>
	  <ttcol align="left">Explanation</ttcol>

	  <c>Computing platform</c><c>An entity capable of
	  communicating and computing, for example, a computer.  See
	  the definition of 'End-point', above.</c>

          <c>HIP base exchange</c><c>A cryptographic protocol;
          see also <xref target="esp" />.</c>

	  <c>HIP packet</c><c>An IP packet that carries a 'Host
	  Identity Protocol' message.</c>

	  <c>Host Identity</c><c>An abstract concept assigned to
	  a 'computing platform'.  See 'Host Identifier', below.</c>

	  <c>Host Identity namespace</c><c>A name space
	  formed by all possible Host Identifiers.</c>

	  <c>Host Identity Protocol</c><c>A protocol used to
	  carry and authenticate Host Identifiers and other
	  information. </c>

	  <c>Host Identity Hash</c><c>The cryptographic hash used
	  in creating the Host Identity Tag from the Host Identity.</c>

	  <c>Host Identity Tag</c><c>A 128-bit datum created by
	  taking a cryptographic hash over a Host Identifier plus
          bits to identify which hash used.</c>

	  <c>Host Identifier</c><c>A public key used as a name
	  for a Host Identity.</c>

	  <c>Local Scope Identifier</c><c>A 32-bit datum denoting
	  a Host Identity.</c>

	  <c>Public Host Identifier and Identity</c><c>A
	  published or publicly known Host Identifier used as a public
	  name for a Host Identity, and the corresponding
	  Identity.</c>

	  <c>Unpublished Host Identifier and Identity</c><c>A
	  Host Identifier that is not placed in any public directory,
	  and the corresponding Host Identity.  Unpublished Host
	  Identities are typically short lived in nature, being often
	  replaced and possibly used just once.</c>

	  <c>Rendezvous Mechanism</c><c>A mechanism used to
	  locate mobile hosts based on their HIT.</c>

	</texttable>
      </section>

<?rfc compact="yes"?> 

    </section>

    <section title="Background">

      <t>The Internet is built from three principal components:
      computing platforms (end-points), packet transport
      (i.e., internetworking) infrastructure, and services
      (applications).  The Internet exists to service two principal
      components: people and robotic services (silicon-based people,
      if you will).  All these components need to be named in order to
      interact in a scalable manner.  Here we concentrate on naming
      computing platforms and packet transport elements.</t>

      <t>There are two principal namespaces in use in the Internet for
      these components: IP addresses, and Domain Names.  
      Domain Names provide hierarchically assigned names for some
      computing platforms and some services.  Each hierarchy is
      delegated from the level above; there is no anonymity in Domain
      Names.  Email, HTTP, and SIP addresses all reference Domain
      Names.</t>

      <t>The IP addressing namespace has been overloaded to name both 
      interfaces (at layer-3) and endpoints (for the endpoint-specific
      part of layer-3, and for layer-4).  In their role as interface
      names, IP addresses are sometimes called "locators" and serve
      as an endpoint within a routing topology.</t>

      <t>IP addresses are numbers that name networking interfaces, and typically only
      when the interface is connected to the network.  Originally, IP
      addresses had long-term significance.  Today, the vast number of
      interfaces use ephemeral and/or non-unique IP addresses.  That is,
      every time an interface is connected to the network, it is
      assigned an IP address.</t>

      <t>In the current Internet, the transport layers are coupled to
      the IP addresses.  Neither can evolve separately from the other.
      IPng deliberations were strongly shaped by the decision that a
      corresponding TCPng would not be created.</t>

      <t>There are three critical deficiencies with the current
      namespaces.  Firstly, dynamic readdressing cannot be directly
      managed.  Secondly, confidentiality is not provided in a consistent,
      trustable manner.  Finally, authentication for systems and
      datagrams is not provided.  All of these deficiencies arise
      because computing platforms are not well named with the current
      namespaces. </t>

      <section title="A desire for a namespace for computing platforms">

        <t>An independent namespace for computing platforms could be
        used in end-to-end operations independent of the evolution of
        the internetworking layer and across the many internetworking
        layers.  This could support rapid readdressing of the
        internetworking layer because of mobility, rehoming, or
        renumbering.</t>

	<t>If the namespace for computing platforms is based on
	public-key cryptography, it can also provide authentication
        services.  If this namespace is locally created without
        requiring registration, it can provide anonymity. </t>

	<t>Such a namespace (for computing platforms) and the names in
        it should have the following characteristics:

          <list style="symbols">
        
	    <t>The namespace should be applied to the IP 'kernel' or stack.
            The IP stack is the 'component' between applications and the
            packet transport infrastructure.</t>

	    <t>The namespace should fully decouple the internetworking
	    layer from the higher layers.  The names should replace
	    all occurrences of IP addresses within applications (like
	    in the Transport Control Block, TCB). This replacement can
	    be handled transparently for legacy applications as the
	    LSIs and HITs are compatible with IPv4 and IPv6 addresses
	    <xref target="RFC5338" />. However, HIP-aware applications
	    require some modifications from the developers, who may
	    employ networking API extensions for HIP <xref
	    target="RFC6317" />.</t>

	    <t>The introduction of the namespace should not mandate
            any administrative infrastructure.  Deployment must come
            from the bottom up, in a pairwise deployment.</t>

	    <t>The names should have a fixed length representation,
            for easy inclusion in datagram headers and existing
            programming interfaces (e.g the TCB).</t>

	    <t>Using the namespace should be affordable when used in
            protocols.  This is primarily a packet size issue.  There
            is also a computational concern in affordability.</t>

      <t>Name collisions should be avoided as much as possible.  The
            mathematics of the birthday paradox can be used to estimate 
            the chance of a collision in a given population and hash space. 
            In general, for a random hash space of size n bits, we would
            expect to obtain a collision after approximately 1.2*sqrt(2**n) 
            hashes were obtained.  For 64 bits, this number is roughly 
            4 billion.  A hash size of 64 bits may be too small to avoid 
            collisions in a large population; for example, there is a 1% 
            chance of collision in a population of 640M.  For 100 bits 
            (or more), we would not expect a collision until approximately 
            2**50 (1 quadrillion) hashes were generated.</t>

	    <t>The names should have a localized abstraction so that
            it can be used in existing protocols and APIs.</t>
	    
	    <?rfc needLines="8"?>

	    <t>It must be possible to create names locally.  When such names
            are not published, this can provide anonymity at the cost of 
            making resolvability very difficult.

              <!--
              <list style="symbols">

		<t>Sometimes the names may contain a delegation
		component. This is the cost of resolvability.</t>
		
	      </list>
              -->
		
            </t>

	    <t>The namespace should provide authentication services.</t>

	    <t>The names should be long lived, but replaceable at any
            time.  This impacts access control lists; short lifetimes
            will tend to result in tedious list maintenance or require
            a namespace infrastructure for central control of access
            lists.</t>

	  </list>
        </t>

        <t>In this document, a new namespace approaching these ideas
        is called the Host Identity namespace.  Using Host Identities
        requires its own protocol layer, the Host Identity Protocol,
        between the internetworking and transport layers.  The names
        are based on public-key cryptography to supply authentication
        services.  Properly designed, it can deliver all of the above
        stated requirements.</t>

      </section>
    </section>

    <section title="Host Identity namespace">

      <t>A name in the Host Identity namespace, a Host Identifier
      (HI), represents a statistically globally unique name for naming
      any system with an IP stack.  This identity is normally
      associated with, but not limited to, an IP stack.  A system can
      have multiple identities, some 'well known', some unpublished or
      'anonymous'.  A system may self-assert its own identity, or may
      use a third-party authenticator like DNSSEC <xref
      target="RFC2535" />, PGP, or X.509 to 'notarize' the identity
      assertion to another namespace.  It is expected that the Host Identifiers will
      initially be authenticated with DNSSEC and that all
      implementations will support DNSSEC as a minimal baseline.</t>

      <t>In theory, any name that can claim to be 'statistically
      globally unique' may serve as a Host Identifier.  In the HIP
      architecture, the public key of a private-public key pair has
      been chosen as the Host Identifier because it can be self
      managed and it is computationally difficult to forge. As
      specified in the Host Identity Protocol <xref
      target="I-D.ietf-hip-rfc5201-bis" /> specification, a public-key-based HI can
      authenticate the HIP packets and protect them for
      man-in-the-middle attacks.  Since authenticated datagrams are
      mandatory to provide much of HIP's denial-of-service protection,
      the Diffie-Hellman exchange in HIP BEX has to be authenticated.
      Thus, only public-key HI and authenticated HIP messages are
      supported in practice.</t>

      <t>In this document, the non-cryptographic forms of HI and HIP
      are presented to complete the theory of HI, but they should not
      be implemented as they could produce worse denial-of-service
      attacks than the Internet has without Host Identity.  There has
      been past research in challenge puzzles to use non-cryptographic
      HI, for Radio Frequency IDentification (RFID), in an HIP
      exchange tailored to the workings of such challenges (as
      described further in <xref target="urien-rfid" /> and <xref
      target="urien-rfid-draft" />).</t>

      <section title="Host Identifiers">

	<t>Host Identity adds two main features to Internet protocols.
        The first is a decoupling of the internetworking and transport
        layers; see <xref target="sec-architecture" />.  This
        decoupling will allow for independent evolution of the two
        layers.  Additionally, it can provide end-to-end services over
        multiple internetworking realms.  The second feature is host
        authentication.  Because the Host Identifier is a public key,
        this key can be used for authentication in security protocols
        like ESP.</t>

	<t>The only completely defined structure of the Host Identity
        is that of a public/private key pair.  In this case, the Host
        Identity is referred to by its public component, the public
        key.  Thus, the name representing a Host Identity in the Host
        Identity namespace, i.e., the Host Identifier, is the public
        key.  In a way, the possession of the private key defines the
        Identity itself.  If the private key is possessed by more than
        one node, the Identity can be considered to be a distributed
        one.</t>

	<t>Architecturally, any other Internet naming convention might
	form a usable base for Host Identifiers.  However,
	non-cryptographic names should only be used in situations of
	high trust - low risk.  That is any place where host
	authentication is not needed (no risk of host spoofing) and no
	use of ESP.  However, at least for interconnected networks
	spanning several operational domains, the set of environments
	where the risk of host spoofing allowed by non-cryptographic
	Host Identifiers is acceptable is the null set.  Hence, the
	current HIP documents do not specify how to use any other
	types of Host Identifiers but public keys. For instance,
	Back-to-My-Mac <xref target="RFC6281" /> from Apple comes
	pretty close to the functionality of HIP, but unlike HIP, it
	is based on non-cryptographic identifiers.
        </t>

	<t>The actual Host Identifiers are never directly used at the
	transport or network layers.  The corresponding Host
	Identifiers (public keys) may be stored in various DNS or other
	directories as identified elsewhere in this document, and they
	are passed in the HIP base exchange.  A Host Identity Tag
	(HIT) is used in other protocols to represent the Host
	Identity.  Another representation of the Host Identities, the
	Local Scope Identifier (LSI), can also be used in protocols
	and APIs.</t>

      </section>

      <section title="Host Identity Hash (HIH)">

	<t>The Host Identity Hash is the cryptographic hash algorithm used in
        producing the HIT from the HI.  It is also the hash used
        through out the HIP protocol for consistency and simplicity.  It
        is possible to for the two hosts in the HIP exchange to use
        different hash algorithms.</t>

        <t>Multiple HIHs within HIP are needed to address the moving
        target of creation and eventual compromise of cryptographic
        hashes.  This significantly complicates HIP and offers an
        attacker an additional downgrade attack that is mitigated
        in the HIP protocol <xref target="I-D.ietf-hip-rfc5201-bis" />.</t>

      </section>

      <section title="Host Identity Tag (HIT)">

	<t>A Host Identity Tag is a 128-bit representation for a Host
        Identity.  It is created from an HIH and other information, like
        an IPv6 prefix and a hash identifier.  There are two advantages
        of using the HIT over using the Host Identifier in protocols.
        Firstly, its fixed length makes for easier protocol coding and
        also better manages the packet size cost of this technology.
        Secondly, it presents the identity in a consistent format to
        the protocol independent of the cryptographic algorithms
        used.</t>

        <t>In essence, the HIT is a hash over the public key. As such,
        two algorithms affect the generation of a HIT: the public-key
        algorithm of the HI and the used HIH. The two algorithms are
        encoded in the bit presentation of the HIT. As the two
        communicating parties may support different algorithms, <xref
        target="I-D.ietf-hip-rfc5201-bis" /> defines the minimum set for
        interoperability. For further interoperability, the responder
        may store its keys in DNS records, and thus the initiator may
        have to couple destination HITs with appropriate source HIts
        according to matching HIH.</t>

        <t>In the HIP packets, the HITs identify the sender and
        recipient of a packet.  Consequently, a HIT should be unique
        in the whole IP universe as long as it is being used.  In the
        extremely rare case of a single HIT mapping to more than one
        Host Identity, the Host Identifiers (public keys) will make
        the final difference.  If there is more than one public key
        for a given node, the HIT acts as a hint for the correct
        public key to use.</t>

      </section>

      <section title="Local Scope Identifier (LSI)" anchor="lsi">

	<t>An LSI is a 32-bit localized representation for a Host
	Identity. The purpose of an LSI is to facilitate using Host
	Identities in existing APIs for IPv4-based
	applications. Besides facilitating HIP-based connectivity for
	legacy IPv4 applications, the LSIs are beneficial in two other
	scenarios <xref target="RFC6538" />.</t>

        <t>In the first scenario, two IPv4-only applications are
        residing on two separate hosts connected by IPv6-only
        network. With HIP-based connectivity, the two applications are
        able to communicate despite of the mismatch in the protocol
        families of the applications and the underlying network. The
        reason is that the HIP layer translates the LSIs originating
        from the upper layers into routable IPv6 locators before
        delivering the packets on the wire.</t>

        <t>The second scenario is the same as the first one, but with
        the difference that one of the applications supports only
        IPv6. Now two obstacles hinder the communication between the
        application: the addressing families of the two applications
        differ, and the application residing at the IPv4-only side is
        again unable to communicate because of the mismatch between
        addressing families of the application (IPv4) and network
        (IPv6). With HIP-based connectivity for applications, this
        scenario works; the HIP layer can choose whether to translate
        the locator of an incoming packet into an LSI or HIT.</t>
 
        <t>Effectively, LSIs improve IPv6 interoperability at the
        network layer as described in the first scenario and at the
        application layer as depicted in the second example. The
        interoperability mechanism should not be used to avoid
        transition to IPv6; the authors firmly believe in IPv6
        adoption and encourage developers to port existing IPv4-only
        applications to use IPv6. However, some proprietary,
        closed-source, IPv4-only applications may never see the
        daylight of IPv6, and the LSI mechanism is suitable for
        extending the lifetime of such applications even in IPv6-only
        networks.</t>

        <t>The main disadvantage of an LSI is its local
        scope. Applications may violate layering principles and pass
        LSIs to each other in application-layer protocols. As the LSIs
        are valid only in the context of the local host, they may
        represent an entirely different host when passed to another
        host. However, it should be emphasized here that the LSI
        concept is effectively a host-based NAT and does not introduce
        any more issues than the prevalent middlebox based NATs for
        IPv4. In other words, the applications violating layering
        principles are already broken by the NAT boxes that are
        ubiquitously deployed.</t>

      </section>

      <section title="Storing Host Identifiers in directories">

	<t>The public Host Identifiers should be stored in DNS; the
        unpublished Host Identifiers should not be stored anywhere
        (besides the communicating hosts themselves).  The (public) HI
        along with the supported HIHs are stored in a new RR type.  This RR type
        is defined in <xref target="I-D.ietf-hip-rfc5205-bis">HIP DNS Extension</xref>.</t>

        <t>Alternatively, or in addition to storing Host Identifiers
        in the DNS, they may be stored in various other
        directories. For instance, Light-weight Directory Access
        Protocol (LDAP) or in a Public Key Infrastructure (PKI) <xref
        target="I-D.ietf-hip-rfc6253-bis" />. Alternatively, <xref
        target="RFC6537">Distributed Hash Tables (DHTs)</xref> have
        successfully been utilized <xref target="RFC6538" />.  Such a
        practice may allow them to be used for purposes other than
        pure host identification.</t>

        <t>Some types of application may cache and use Host
        Identifiers directly, while others may indirectly discover
        them through symbolic host name (such as FQDN) look up from a
        directory. Even though Host Identities can have a
        substantially longer lifetime associate with them than
        routable IP addresses, directories may be a better approach to
        manage the lifespan of Host Identities. For example, a LDAP or
        DHT can be used for locally published identities whereas DNS
        can be more suitable for public advertisement.</t>

      </section>
    </section>

    <section anchor="sec-architecture" title="New stack architecture">

      <t>One way to characterize Host Identity is to compare the
      proposed new architecture with the current one.  As discussed
      above, the IP addresses can be seen to be a confounding of
      routing direction vectors and interface names.  Using the
      terminology from the <xref target="nsrg-report">IRTF
      Name Space Research Group Report</xref> and, e.g., the
      unpublished Internet-Draft <xref
      target="chiappa-endpoints">Endpoints and Endpoint Names </xref>,
      the IP addresses currently embody the dual role
      of locators and end-point identifiers.  That is, each IP address
      names a topological location in the Internet, thereby acting as
      a routing direction vector, or locator.  At the same time, the IP
      address names the physical network interface currently located
      at the point-of-attachment, thereby acting as a end-point
      name.</t>

      <t>In the HIP architecture, the end-point names and locators are
      separated from each other.  IP addresses continue to act as
      locators.  The Host Identifiers take the role of end-point
      identifiers.  It is important to understand that the end-point
      names based on Host Identities are slightly different from
      interface names; a Host Identity can be simultaneously reachable
      through several interfaces.</t>

      <t>The difference between the bindings of the logical entities
      are illustrated in <xref target="figure-bindings"/>. Left side
      illustrates the current TCP/IP architecture and right side the
      HIP-based architecture.</t>

      <figure anchor="figure-bindings">
	<artwork src="draft-ietf-hip-arch-1.gif" type="gif">

Transport ---- Socket                Transport ------ Socket
association      |                   association        |
                 |                                      |
                 |                                      |
                 |                                      |
End-point        |                    End-point --- Host Identity
         \       |                                      |
           \     |                                      |
             \   |                                      |
               \ |                                      |
Location --- IP address                Location --- IP address
                 
        </artwork>
      </figure>

	<t>Architecturally, HIP provides for a different binding of
	transport-layer protocols.  That is, the transport-layer
	associations, i.e., TCP connections and UDP associations, are
	no longer bound to IP addresses but rather to Host
	Identities. In practice, the Host Identities are exposed as
	LSIs and HITs for legacy applications and the transport layer
	to facilitate backward compatibility with existing networking
	APIs and stacks.</t>

      <section title="On the multiplicity of identities">

        <t>For security reasons, it may be a bad idea to duplicate the
        same Host Identity on multiple hosts because the compromise of
        a single host taints the identities of the other hosts.
        Management of machines with identical Host Identities may also
        present other challenges and, therefore, it is advisable to
        have a unique identity for each host.</t>

        <t>Instead of duplicating identities, HIP opportunistic mode
        can be employed, where the initiator leaves out the identifier
        of the responder when initiating the key exchange and learns
        it upon the completion of the exchange. The tradeoffs are
        related to lowered security guarantees, but a benefit of the
        approach is to avoid publishing of Host Identifiers in any
        directories <xref target="komu-leap" />.  The approach could also be used
        for load balancing purposes at the HIP layer because the
        identity of the responder can be decided dynamically during
        the key exchange. Thus, the approach has
        the potential to be used as a HIP-layer "anycast", either
        directly between two hosts or indirectly through the
        rendezvous service <xref target="komu-diss" />.</t>

        <t>At the client side, a host may have multiple Host
        Identities, for instance, for privacy purposes. Another reason
        can be that the person utilizing the host employs different
        identities for different administrative domains as an extra
        security measure. If a HIP-aware middlebox, such as a
        HIP-based firewall, is on the path between the client and
        server, the user or the underlying system should carefully
        choose the correct identity to avoid the firewall to
        unnecessarily drop HIP-base connectivity <xref target="komu-diss"
        />.</t>

        <t>Similarly, a server may have multiple Host Identities. For
        instance, a single web server may serve multiple different
        administrative domains. Typically, the distinction is
        accomplished based on the DNS name, but also the Host Identity
        could be used for this purpose. However, a more compelling
        reason to employ multiple identities are HIP-aware firewalls
        that are unable see the HTTP traffic inside the encrypted
        IPsec tunnel. In such a case, each service could be configured
        with a separate identity, thus allowing the firewall to
        segregate the different services of the single web server from
        each other <xref target="lindqvist-enterprise" />.</t>

        <!--
	<t>It is possible that a single physical computer hosts
        several logical end-points.  With HIP, each of these
        end-points would have a distinct Host Identity.  Furthermore,
        since the transport associations are bound to Host Identities,
        HIP provides for process migration and clustered servers.
        That is, if a Host Identity is moved from one physical
        computer to another, it is also possible to simultaneously
        move all the transport associations without breaking them.
        Similarly, if it is possible to distribute the processing of a
        single Host Identity over several physical computers, HIP
        provides for cluster based services without any changes at the
        client end-point.</t> -->

      </section>
    </section>

    <?rfc needLines="8"?>

    <section title="Control plane">

      <t>HIP decouples control and data plane from each other. The
      control plane between two end-hosts is initialized using a key
      exchange procedure called the base exchange. The procedure can
      be assisted by new infrastructural intermediaries called
      rendezvous or relay servers. In the event of IP address changes,
      the end-hosts sustain control plane connectivity with mobility
      and multihoming extensions. Eventually, the end-hosts terminate
      the control plane and remove the associated state.</t>

    <section title="Base exchange">

      <t>The base exchange is key exchange procedure that
      authenticates the initiator and responder to each other using
      their public keys. Typically, the initiator is the client-side
      host and the responder is the server-side host. The roles are
      used by the state machine of a HIP implementation, but discarded
      upon successful completion.</t>

      <t>
      The exchange consists of four messages during which the hosts
      also create symmetric keys to protect the control plane with
      Hash-based message authentication codes (HMACs). The
      keys can be also used to protect the data plane, and IPsec ESP
      <xref target="I-D.ietf-hip-rfc5202-bis" /> is typically used as the data-plane protocol, albeit
      HIP can also accommodate others. Both the
      control and data plane are terminated using a closing procedure
      consisting of two messages.
      </t>

      <t>The base exchange also includes a computational puzzle <xref
      target="I-D.ietf-hip-rfc5201-bis" /> that the initiator must
      solve. The responder chooses the difficulty of the puzzle which
      allows the responder to delay new incoming initiators according
      to local policies, for instance, when the responder is under
      heavy load. The puzzle can offer some resiliency against DoS
      attacks because the design of the puzzle mechanism allows the
      responder to remain stateless until the very end of the base
      exchange <xref target="aura-dos" />. HIP puzzles have also been
      researched under steady-state DDoS attacks <xref
      target="beal-dos" />, multiple adversary models with varying
      puzzle difficulties <xref target="tritilanunt-dos" /> and
      ephemeral Host Identities <xref target="komu-mitigation" />.
      </t>

      <!-- XX FIXME: MORE ON HICCUPS? -->

    </section>

    <section title="End-host mobility and multi-homing">

      <t>HIP decouples the transport from the internetworking layer,
      and binds the transport associations to the Host Identities
      (through actually either the HIT or LSI). After the initial key
      exchange, the HIP layer maintains transport-layer connectivity
      and data flows using its <xref
      target="I-D.ietf-hip-rfc5206-bis">mobility</xref> and <xref
      target="I-D.ietf-hip-multihoming">multihoming</xref> extensions.
      Consequently, HIP can provide for a degree of internetworking
      mobility and multi-homing at a low infrastructure cost.  HIP
      mobility includes IP address changes (via any method) to either
      party.  Thus, a system is considered mobile if its IP address
      can change dynamically for any reason like PPP, DHCP, IPv6
      prefix reassignments, or a NAT device remapping its translation.
      Likewise, a system is considered multi-homed if it has more than
      one globally routable IP address at the same time.  HIP links IP
      addresses together, when multiple IP addresses correspond to the
      same Host Identity, and if one address becomes unusable, or a
      more preferred address becomes available, existing transport
      associations can easily be moved to another address.</t>
 
      <t>When a node moves while communication is already on-going,
      address changes are rather straightforward.  The peer of the
      mobile node can just accept a HIP or an integrity protected
      ESP packet from any address and ignore the source address.
      However, as discussed in <xref target="ssec-flooding" /> below,
      a mobile node must send a HIP UPDATE packet to inform the
      peer of the new address(es), and the peer must verify that the
      mobile node is reachable through these addresses.  This is
      especially helpful for those situations where the peer node is
      sending data periodically to the mobile node (that is
      re-starting a connection after the initial connection).</t>

    </section>

      <section title="Rendezvous mechanism">

	<t>Making a contact to a mobile node is slightly more
        involved.  In order to start the HIP exchange, the initiator
        node has to know how to reach the mobile node.  Although
        infrequently moving HIP nodes could use Dynamic DNS <xref
        target="RFC2136" /> to update their reachability information in
        the DNS, an alternative to using DNS in this fashion is to use
        a piece of new static infrastructure to facilitate rendezvous
        between HIP nodes.</t>

        <t>The mobile node keeps the rendezvous infrastructure
        continuously updated with its current IP address(es).  The
        mobile nodes must trust the rendezvous mechanism to properly
        maintain their HIT and IP address mappings.</t>

	<t>The rendezvous mechanism is also needed if both of the
	nodes happen to change their address at the same time, either
        because they are mobile and happen to move at the same time,
        because one of them is off-line for a while, or because of
        some other reason.  In such a case, the HIP UPDATE packets
        will cross each other in the network and never reach the peer
        node.</t>

	<t>The HIP rendezvous mechanism is defined in <xref
	target="I-D.ietf-hip-rfc5204-bis">HIP Rendezvous
	specifications</xref>.</t>

      </section>

      <section title="Relay mechanism">

        <t>The HIP relay mechanism <xref
        target="I-D.ietf-hip-native-nat-traversal" /> is an
        alternative to the HIP rendezvous mechanism. The HIP relay
        mechanism is more suitable for IPv4 networks with NATs because
        a HIP relay can forward all control and data plane
        communications in order to guarantee successful NAT
        traversal.</t>

      </section>

      <section title="Termination of the control plane">

        <t>The control plane between two hosts can be terminated using
        a secure two message procotol as specified in (XX FIXME). The
        related state (i.e. host associations) should be removed upon
        successful termination.</t>

      </section>

    </section>

    <section anchor="esp" title="Data plane">

      <t>The control and data plane are decoupled in the HIP
      architecture. This means that the encapsulation format for data
      plane used for carrying the application-layer traffic is
      changeable and can is dynamically negotiated during the key
      exchange. For instance, <xref target="RFC6078">HICCUPS
      extensions</xref> define a way to transport application-layer
      datagrams directly over the HIP control plane, protected by
      asymmetric key cryptography. Also, S-RTP has been considered as
      the data encapsulation protocol <xref target="hip-srtp"
      />. However, the most widely implemented method is the
      Encapsulated Security Payload (ESP) <xref
      target="I-D.ietf-hip-rfc5202-bis" /> that is protected by
      symmetric keys derived during the key exchange. ESP Security
      Associations (SAs) offer both confidentiality and integrity
      protection, of which the former can be disabled during the key
      exchange. In the future, other ways of transporting
      application-layer data may be defined.</t>

      <t>The ESP SAs are established and terminated between the
      initiator and the responder hosts. Usually, the hosts create at
      least two SAs, one in each direction (initiator-to-responder SA
      and responder-to-initiator SA).  If the IP addresses of either
      host are changed, the HIP mobility extensions can be used to
      re-negotiate the corresponding SAs.</t>

      <t>On the wire, the difference in the use of identifiers between
      the HIP control and data plane is that the HITs are included in
      all control packets, but not in the data plane when ESP is
      employed. Instead, the ESP employs SPI numbers that act as
      compressed HITs. Any HIP-aware middlebox (for instance, a
      HIP-aware firewall) interested in the ESP based data plane
      should keep track between the control and data plane identifiers
      in order to associate them with each other.</t>

      <!--

      <t>HIP base exchange uses the cryptographic Host Identifiers to
      set up a pair of ESP Security Associations (SAs) to enable ESP
      in an end-to-end manner. While it would be possible, at least in
      theory, to use some existing cryptographic protocol, such as
      IKEv2 together with Host Identifiers, to establish the needed
      SAs, HIP defines a new protocol.  There are a number of
      historical reasons for this, and there are also a few
      architectural reasons.  First, IKE (and IKEv2) were not
      originally designed with middleboxes in mind.  As adding a new
      naming layer allows one to potentially add a new forwarding
      layer (see <xref target="nat" />, below), it is very important
      that the HIP provides mechanisms for middlebox
      authentication.</t>

      <t>Second, from a conceptual point of view, the IPsec Security
      Parameter Index (SPI) in ESP provides a simple compression of
      the HITs.  This does require per-HIT-pair SAs (and SPIs), and a
      decrease of policy granularity over other Key Management
      Protocols, such as IKE and IKEv2.  In other words, from an
      architectural point of view, HIP only supports host-to-host
      (or endpoint-to-endpoint) Security Associations.</t>

      <t>Originally, as HIP is designed for host usage, not for gateways or so
      called Bump-in-the-Wire (BITW) implementations, only ESP
      transport mode is supported.  An ESP SA pair is indexed by the
      SPIs and the two HITs (both HITs since a system can have more
      than one HIT).  The SAs need not to be bound to IP addresses;
      all internal control of the SA is by the HITs.  Thus, a host can
      easily change its address using Mobile IP, DHCP, PPP, or IPv6
      readdressing and still maintain the SAs.  Since the transports
      are bound to the SA (via an LSI or a HIT), any active transport
      is also maintained.  Thus, real-world conditions like loss of a
      PPP connection and its re-establishment or a mobile handover
      will not require a HIP negotiation or disruption of transport
      services <xref target="Bel1998" />.</t>

      <t>It should be noted that there are already BITW implementations
      of HIP providing virtual private network (VPN) services.
      This is still consistent to the SA bindings above.</t>
      -->

      <t>Since HIP does not negotiate any SA lifetimes, all lifetimes
      are local policy.  The only lifetimes a HIP implementation must
      support are sequence number rollover (for replay protection),
      and SA timeout. An SA times out if no packets are received using
      that SA. Implementations may support lifetimes for the various
      ESP transforms and other data-plane protocols.</t>

    </section>

     <section anchor="nat" title="HIP and NATs">

      <!-- * UDP encap vs. HIP-aware NAT -->

      <t>Passing packets between different IP addressing realms
      requires changing IP addresses in the packet header.  This may
      occur, for example, when a packet is passed between the public
      Internet and a private address space, or between IPv4 and IPv6
      networks.  The address translation is usually implemented as
      <xref target="RFC3022">Network Address Translation (NAT)</xref>
      or <xref target="RFC2766"> NAT Protocol translation
      (NAT-PT)</xref>.</t>

      <t>In a network environment where identification is based on the
      IP addresses, identifying the communicating nodes is difficult
      when NATs are employed because the private address spaces
      introduced by NATs are overlapping. In other words, two hosts
      cannot distinguished from each other solely based on their IP
      address. With HIP, the transport-layer end-points
      (i.e. applications) are bound to unique Host Identities rather
      than overlapping private addresses. This makes it possible for
      two end-points to distinguish one other even when they are
      located in private address realms. Thus, the IP addresses used
      only for routing purposes; they may be changed freely during
      when a packet between two hosts traverses possibly multiple
      addressing realm boundaries.</t>

      <t><xref target="I-D.ietf-hip-native-nat-traversal">NAT
      traversal extensions for HIP</xref> can be used to realize the
      actual end-to-end connectivity through NAT devices. To support
      basic backward compatibility with legacy NATs, the extensions
      encapsulated both HIP control and data plane in UDP. The
      extensions define mechanisms for forwarding the two planes
      through an intermediary host called HIP relay and procedures to
      establish direct end-to-end connectivity by penetrating
      NATs. Besides this "native" NAT traversal mode for HIP, other
      NAT traversal mechanisms have been successfully utilized, such
      as Teredo <xref target="varjonen-split" />.</t>

      <t>Besides legacy NATs, a HIP-aware NAT has been designed and
      implemented <xref target="ylitalo-spinat" />. For a HIP-based flow, a HIP-aware
      NAT or NAT-PT system tracks the mapping of HITs, and the
      corresponding ESP SPIs, to an IP address.  The NAT system has to
      learn mappings both from HITs and from SPIs to IP addresses.
      Many HITs (and SPIs) can map to a single IP address on a NAT,
      simplifying connections on address poor NAT interfaces. The NAT
      can gain much of its knowledge from the HIP packets themselves;
      however, some NAT configuration may be necessary.</t>

      <!--
      <t>NAT systems cannot touch the datagrams within the ESP
      envelope, thus application-specific address translation must be
      done in the end systems. It should be noted that HIP provides
      for 'Distributed NAT', and uses the HIT or the LSI as a
      placeholder for embedded IP addresses.</t> -->

      <section title="HIP and Upper-layer checksums">

	<t>There is no way for a host to know if any of the IP
        addresses in an IP header are the addresses used to calculate
        the TCP checksum.  That is, it is not feasible to calculate
        the TCP checksum using the actual IP addresses in the pseudo
        header; the addresses received in the incoming packet are not
        necessarily the same as they were on the sending host.
        Furthermore, it is not possible to recompute the upper-layer
        checksums in the NAT/NAT-PT system, since the traffic is ESP
        protected.  Consequently, the TCP and UDP checksums are
        calculated using the HITs in the place of the IP addresses in
        the pseudo header.  Furthermore, only the IPv6 pseudo header
        format is used.  This provides for IPv4 / IPv6 protocol
        translation.</t>

      </section>
    </section>

    <section title="Multicast">

      <t>A number of studies have intestigating HIP-based multicast
      have been published (including <xref target="shields-hip" />, <xref
      target="xueyong-hip" />, <xref target="xueyong-hip" />, <xref
      target="amir-hip" />, <xref target="kovacshazi-host" /> and
      <xref target="xueyong-secure" />). Particularly, so called bloom
      filters, that allow to compressing of multiple labels into small
      datastructures, may be a promising way forward <xref
      target="sarela-bloom" />. However, the different schemes have
      not been adopted by HIP working group (nor the HIP research
      group in IRTF), so the details are not further elaborated here.</t>

    </section>

    <section title="HIP policies">

      <t>There are a number of variables that will influence the HIP
      exchanges that each host must support.  All HIP implementations
      should support at least 2 HIs, one to publish in DNS or similar
      directory service and an unpublished one for anonymous usage.
      Although unpublished HIs will be rarely used as responder HIs,
      they are likely be common for initiators.  Support for multiple
      HIs is recommended.  This provides new challenges for systems
      or users to decide which type of HI to expose when they start
      a new session.</t>

      <t>Opportunistic mode (where the initiator starts a HIP exchange
      without prior knowledge of the responder's HI) presents a
      security tradeoff. At the expense of being subject to MITM
      attacks, the opportunistic mode allows the initiator learn the
      the identity of the responder during communications rather than
      from an external directory. Opportunistic mode can be used for
      registering to HIP-based services <xref
      target="I-D.ietf-hip-rfc5203-bis" /> (i.e. utilized by HIP for
      its own internal purposes) or by the application layer <xref
      target="komu-leap" />. For security reasons, especially the
      latter requires some involvement from the user to accept the
      identity of the responder in a similar vain as SSH prompts the
      user when connecting to a server for the first time <xref
      target="pham-leap" />. In practice, this can be realized for
      with end-host based firewalls in the case of legacy applications
      <xref target="karvonen-usable" /> or with <xref
      target="RFC6317">native APIs for HIP APIs</xref> in the case of
      HIP-aware applications.</t>

      <t>Many initiators would want to use a different HI for
      different responders.  The implementations should provide for a
      policy of initiator HIT to responder HIT.  This policy should
      also include preferred transforms and local lifetimes. </t>

      <t>Responders would need a similar policy, describing the hosts
      allowed to participate in HIP exchanges, and the preferred
      transforms and local lifetimes.</t>

    </section>

    <section title="Design considerations">

    <section title="Benefits of HIP">

      <t>In the beginning, the network layer protocol (i.e., IP) had
      the following four "classic" invariants:

        <list style="numbers">

	  <t>Non-mutable: The address sent is the address
	  received.</t>

	  <t>Non-mobile: The address doesn't change during the course
          of an "association".</t>

	  <t>Reversible: A return header can always be formed by
          reversing the source and destination addresses.</t>

	  <t>Omniscient: Each host knows what address a partner host
          can use to send packets to it.</t>

	</list>
      </t>

      <t>Actually, the fourth can be inferred from 1 and 3, but it is
      worth mentioning for reasons that will be obvious soon if not
      already.</t>

      <t>In the current "post-classic" world, we are intentionally
      trying to get rid of the second invariant (both for mobility and
      for multi-homing), and we have been forced to give up the first
      and the fourth.  <xref target="RFC3102">Realm Specific IP</xref>
      is an attempt to reinstate the fourth invariant without the
      first invariant.  IPv6 is an attempt to reinstate the first
      invariant.</t>

      <t>Few client-side systems on the Internet have DNS names that are
      meaningful.  That is, if they have a Fully Qualified Domain Name
      (FQDN), that name typically belongs to a NAT device or a dial-up
      server, and does not really identify the system itself but its
      current connectivity.  FQDNs (and their extensions as email
      names) are application-layer names; more frequently naming
      services than a particular system.  This is why many systems on
      the Internet are not registered in the DNS; they do not have
      services of interest to other Internet hosts.</t>

      <t>DNS names are references to IP addresses.  This only
      demonstrates the interrelationship of the networking and
      application layers.  DNS, as the Internet's only deployed,
      distributed database is also the repository of other namespaces,
      due in part to DNSSEC and application specific key records.
      Although each namespace can be stretched (IP with v6, DNS with
      KEY records), neither can adequately provide for host
      authentication or act as a separation between internetworking
      and transport layers.</t>

      <t>The Host Identity (HI) namespace fills an important gap
      between the IP and DNS namespaces.  An interesting thing about
      the HI is that it actually allows one to give up all but the 3rd
      network-layer invariant.  That is to say, as long as the source
      and destination addresses in the network-layer protocol are
      reversible, then things work ok because HIP takes care of host
      identification, and reversibility allows one to receive a packet
      back to one's partner host.  You do not care if the
      network-layer address changes in transit (mutable) and you don't
      care what network-layer address the partner is using
      (non-omniscient).</t>

      <t>The Host Identity (HI) namespace fills an important gap
      between the IP and DNS namespaces.  An interesting thing about
      the HI is that it actually allows one to give up all but the 3rd
      network-layer invariant.  That is to say, as long as the source
      and destination addresses in the network-layer protocol are
      reversible, then things work ok because HIP takes care of host
      identification, and reversibility allows one to receive a packet
      back to one's partner host.  You do not care if the
      network-layer address changes in transit (mutable) and you don't
      care what network-layer address the partner is using
      (non-omniscient).</t>

      <t>The Sockets API is the de-facto API for utilize the TCP/IP
      stack. Application use the Sockets API either directly or
      indirectly through some libraries or frameworks. However, the
      Sockets API was based on the assumption of static IP addresses
      and DNS with its lifetime values was invented at later stages
      during the evolution of the Internet. Hence, the Sockets API
      does not deal with the lifetime of addresses <xref
      target="RFC6250" />. As majority of the end-user equipment is
      mobile today, their addresses are effectively ephemeral, but the
      Sockets API still gives a fallacious illusion of persistent IP
      addresses to the unwary developer. HIP can be used to solidify
      this illusion because HIP provides persistent surrogate
      addresses to the application layer in the form of LSIs and
      HITs.</t>

      <t>The persistent identifiers as provided by HIP are useful in
      multiple scenarios (as described in more detail in e.g. <xref
      target="ylitalo-diss" /> or <xref target="komu-diss" />):</t>

      <t>
        <list style="symbols">

          <t>When a mobile host moves physically between two different
          WLAN networks and obtains a new address, an application using
          the identifiers remains isolated of the topology changes
          while the underlying HIP layer re-establishes connectivity
          (i.e. a horizontal handoff).</t>

          <t>Similarly, the application utilizing the identifiers
          remains again unaware of the topological changes when the
          underlying host equipped with WLAN and cellular network
          interfaces switches between the two different access
          technologies (i.e. a vertical handoff).</t>

          <t>Even when hosts are located in private address realms,
          applications can uniquely distinguish different hosts from
          each other based on their identifier. In other words, it can
          be stated that HIP improves Internet transparency
          for the application layer <xref target="komu-diss" />.</t>

          <t>Site renumbering events for services can occur due to
          corporate mergers or acquisitions, or by changes in Internet
          Service Provider. They can involve changing the entire
          network prefix of an organization, which is problematic due
          to hard-coded addresses in service configuration files or
          cached IP addresses at the client side <xref target="RFC5887"
          />. Considering such human errors, a site employing
          location-independent identifiers as promoted by HIP may
          experience less problems while renumbering their network.
          </t>

          <t>More agile IPv6 interoperability as discussed in section
          <xref target="lsi" />. IPv6-based applications can
          communicate using HITs with IPv4-based applications that are
          using LSIs. Also, the underlying network type (IPv4 or IPv6)
          becomes independent of the addressing family of the
          application.</t>

          <t>HITs (or LSIs) can be used in IP-based access control
          lists as a more secure replacement for IPv6
          addresses. Besides security, HIT based access control has two
          other benefits. First, the use of HITs halves the size of
          access control lists as separate rules for IPv4 are not
          needed <xref target="komu-diss" />. Second, HIT-based configuration
          rules in HIP-aware middleboxes remain static and independent
          of topology changes, thus simplifying administrative efforts
          particularly for mobile environments. For instance, the
          benefits of HIT based access control have been harnessed in the
          case of HIP-aware firewalls, but can be utilized
          directly at the end-hosts as well <xref target="RFC6538" />.</t>

        </list>
      </t>

      <t>While some of these benefits could be and have been
      redundantly implemented by individual applications, providing
      such generic functionality at the lower layers is useful because
      it reduces software development efforts and networking software
      bugs (as the layer is tested with multiple applications). It
      also allows the developer to focus on building the application
      itself rather than delving into the intricacies of mobile
      networking, thus facilitating separation of concerns.</t>

      <t>HIP could also be realized by combining a number of different
      protocols, but the complexity of the resulting software may
      become substantially larger, and the interaction multiple
      possibly layered protocols may have adverse effects on latency
      and throughput. It is also worth noting that virtually nothing
      prevents realizing the HIP architecture, for instance, as an
      application-layer library, which has been actually implemented
      in the past <xref target="xin-hip-lib" />. However, the tradeoff
      in moving the HIP layer to the application layer is that legacy
      applications may not be supported.</t>

<!--
      <t>Since all systems can have a Host Identity, every system can
      have an entry in the DNS.  The mobility features in HIP make it
      attractive to trusted 3rd parties to offer rendezvous
      servers.</t>
-->

    </section>

    <section title="Drawbacks of HIP">

      <t>In computer science, many problems can be solved with an
      extra layer of indirection. However, the indirection always
      involves some costs as there no such thing as "free lunch". In
      the case of HIP, the main costs could be stated as follows:</t>

      <t>
        <list style="symbols">

          <t>In general, a new layer and a new namespace involves
          always some initial effort in terms implementation,
          deployment and maintenance. Some education of people may
          also be needed. However, the HIP community at the IETF have
          spent years in experimenting, exploring, testing,
          documenting and implementing HIP curb the amount of efforts
          required.
          </t>

          <t>HIP decouples identifier and locator roles of IP
          addresses. Consequently, a mapping mechanism is needed to
          associate them together. A failure to map a HIT to its
          corresponding locator may result in failed connectivity
          because a HIT is "flat" by its nature and cannot be looked
          up from the hierarchically organized DNS. HITs are flat by
          design due to a security tradeoff. The more bits are
          allocated for the hash in the HIT, the less likely there
          will be (malicious) collisions.</t>

          <t>From performance viewpoint, HIP control and data plane
          processing introduces some overhead in terms throughput and
          latency as elaborated below.</t>

        </list>
      </t>

      <t>The key exchange introduces some extra latency (two round
      trips) in connection establishment. This can further affect TCP
      traffic particularly when a TCP application triggers the key
      exchange and the triggering SYN packet is dropped instead of
      being cached. Similarly as with the key exchange, a similar
      performance penalty may incur for TCP during HIP handoff
      procedures. The penalty can be constrained with caching TCP
      packets. Also, TCP user timeout <xref target="RFC5482" /> is
      another way to optimize TCP behavior during handoffs <xref
      target="scultz-intermittent" />.</t>
      
      <t>The most CPU-intensive operations involve the use of the
      asymmetric keys and Diffie-Hellman key derivation at the control
      plane, but this occurs only during the key exchange, its
      maintenance (handoffs, refreshing of key material) and tear down
      procedures of HIP associations. The data plane is typically
      implemented with ESP has a smaller overhead due to symmetric key
      encryption. Naturally, even ESP involves some overhead in terms
      latency (processing costs) and throughput (tunneling) (see
      e.g. <xref target="ylitalo-diss" /> for a performance
      evaluation).</t>

    </section>

    <section title="Deployment and adoption considerations">

      <t>This section describes some deployment and adoption
      considerations related to HIP from a technical perspective.</t>

   <section title="Deployment analysis">

      <t>HIP has commercially been utilized at Boeing airplane factory
      for their internal purposes<xref target="paine-hip" />. It has
      been included in a security product called Tofino to support
      layer-two Virtual Private Networks <xref target="henderson-vpls"
      /> to facilitate, e.g, supervisory control and data acquisition
      (SCADA) security. However, HIP has not been a "wild success"
      <xref target="RFC5218" /> in the Internet as argued by Lev et
      al <xref target="leva-barriers" />. Here, we briefly highligt
      some of their findings based on interviews with 19 experts from
      the industry and academia.</t>

      <t>From a marketing perspective, the demand for HIP has been low
      and substitute technologies have been favored. Another
      identified reason has been that some technical misconceptions
      related to the early stages of HIP specifications still
      persist. Two identified misconceptions are that HIP does not
      support NAT traversal, and HIP must be implemented in the OS
      kernel. Both of these claims are untrue; HIP does have NAT
      traversal extensions <xref
      target="I-D.ietf-hip-native-nat-traversal" />, and kernel
      modifications can be avoided with modern operating systems by
      diverting packets for userspace processing.
      </t>

      <t>The analysis clarifies infrastructural requirements for
      HIP. In a minimal set up, a client and server machine have to
      run HIP software. However, to avoid manual configurations,
      usually DNS records for HIP are set up. For instance, the
      popular DNS server software Bind9 does not require any changes
      to accomodate DNS records for HIP because they can be supported
      in binary format in its configuration files <xref target="RFC6538" />. HIP
      rendezvous servers and firewalls are optional. No changes are
      required to network address points, NATs, edge routers or core
      networks. HIP may require holes in legacy firewalls.
      </t>

      <t>The analysis also clarifies the requirements for the host
      components that consist of three parts. First, a HIP control
      plane component is required, typically implemented as as
      userspace daemon. Second, a data plane component is needed. Most
      HIP implementations utilize the so called BEET mode of ESP that
      has been available since Linux kernel 2.6.27, but is included
      also as a userspace component in HIPL and OpenHIP
      implementations. Third, HIP systems usually provide a DNS proxy
      for the local host that translates HIP DNS records to LSIs and
      HITs, and communicates the corresponding locators to HIP
      userspace daemon. While the third component is not strictly
      speaking mandatory, it is very useful for avoiding manual
      configurations. The three components are further described in
      the <xref target="RFC6538">HIP experiment report</xref>.</t>

      <t>Based on the interviews, Lev et al suggest further
      directions to facilitate HIP deployment. Transitioning the HIP
      specifications to the standards track may help, but other
      measures could be taken. As a more radical measure, the authors
      suggest to implement HIP as a purely application-layer library
      <xref target="xin-hip-lib" /> or other kind of middleware. On
      the other hand, more conservative measures include focusing on
      private deployments controlled by a single stakeholder. As an a
      more concrete example of such a scenario, HIP could be used by a
      single service provider to provide interconnectivity between its
      servers <xref target="komu-cloud" />.
      </t>

   </section>

   <section anchor="MACsec" title="HIP in 802.15.4 networks">

      <t>The IEEE 802 standards have been defining MAC layered security.  Many
      of these standards use EAP <xref target="RFC3748"></xref> 
      as a Key Management System (KMS) transport, but some like IEEE 
      802.15.4 <xref target="IEEE.802-15-4.2011"></xref> leave the 
      KMS and its transport as "Out of Scope".</t>

      <t>HIP is well suited as a KMS in these environments:

        <list style="symbols">

	  <t>HIP is independent of IP addressing and can be directly 
	  transported over any network protocol.</t>

	  <t>Master Keys in 802 protocols are strictly pair-based with 
	  group keys transported from the group controller using pair-wise 
	  keys.</t>

	  <t>AdHoc 802 networks can be better served by a peer-to-peer 
	  KMS than the EAP client/server model.</t>

	  <t>Some devices are very memory constrained and a common KMS 
	  for both MAC and IP security represents a considerable code 
	  savings.</t>

	</list>

      </t>

    </section>

    </section>

    <section title="Answers to NSRG questions">

      <t>The IRTF Name Space Research Group has posed a number of
      evaluating questions in <xref
      target="nsrg-report">their report</xref>.  In this
      section, we provide answers to these questions.
      
          <list style="numbers">

	    <t>How would a stack name improve the overall
            functionality of the Internet?
        
              <list style="empty">
            
		<t>HIP decouples the internetworking layer from the
		transport layer, allowing each to evolve separately.
		The decoupling makes end-host mobility and
		multi-homing easier, also across IPv4 and IPv6
		networks.  HIs make network renumbering easier, and
		they also make process migration and clustered servers
		easier to implement.  Furthermore, being cryptographic
		in nature, they provide the basis for solving the
		security problems related to end-host mobility and
		multi-homing.</t>
		
	      </list>
            </t>

	    <t>What does a stack name look like?
		
              <list style="empty">
		
		<t>A HI is a cryptographic public key.  However,
                instead of using the keys directly, most protocols use
                a fixed size hash of the public key.</t>
                
	      </list>
            </t>

	    <t>What is its lifetime?
                
              <list style="empty">
                
		<t>HIP provides both stable and temporary Host
		Identifiers.  Stable HIs are typically long lived,
		with a lifetime of years or more.  The lifetime of
		temporary HIs depends on how long the upper-layer
		connections and applications need them, and can range
		from a few seconds to years.</t>

	      </list>
            </t>

	    <t>Where does it live in the stack?

              <list style="empty">
		
		<t>The HIs live between the transport and
		internetworking layers.</t>
		
	      </list>
            </t>

	    <t>How is it used on the end points?
		
              <list style="empty">

		<t>The Host Identifiers may be used directly or
		indirectly (in the form of HITs or LSIs) by
		applications when they access network services.
		Additionally, the Host Identifiers, as public keys,
		are used in the built in key agreement protocol,
		called the HIP base exchange, to authenticate the
		hosts to each other.</t>

	      </list>
            </t>

	    <t>What administrative infrastructure is needed to support
	    it?

              <list style="empty">
		
		<t>In some environments, it is possible to use HIP
		opportunistically, without any infrastructure.
		However, to gain full benefit from HIP, the HIs must
		be stored in the DNS or a PKI, and a new rendezvous
		mechanism is needed <xref target="I-D.ietf-hip-rfc5205-bis" />.</t>
		
	      </list>
            </t>

	    <t>If we add an additional layer would it make the address
            list in SCTP unnecessary?
            
              <list style="empty">
		<t>Yes</t>
	      </list>
            </t>

	    <t>What additional security benefits would a new naming
	    scheme offer?
            
              <list style="empty">
	    
		<t>HIP reduces dependency on IP addresses, making the
		so called address ownership <xref target="Nik2001" />
		problems easier to solve.  In practice, HIP provides
		security for end-host mobility and multi-homing.
		Furthermore, since HIP Host Identifiers are public
		keys, standard public key certificate infrastructures
		can be applied on the top of HIP.</t>
	      </list>
            </t>

	    <t>What would the resolution mechanisms be, or what
            characteristics of a resolution mechanisms would be
            required?

              <list style="empty">
            
		<t>For most purposes, an approach where DNS names are
		resolved simultaneously to HIs and IP addresses is
		sufficient.  However, if it becomes necessary to
		resolve HIs into IP addresses or back to DNS names, a
		flat resolution infrastructure is needed.  Such an
		infrastructure could be based on the ideas of
		Distributed Hash Tables, but would require significant
		new development and deployment.</t>
		
	      </list>
            </t>
	  </list> 
        </t>
    </section>

    </section>

    <section title="Security considerations">

      <t>This section includes discussion on some issues and solutions
      related to security in the HIP architecture.</t>

      <section title="MiTM Attacks">

      <t>HIP takes advantage of the new Host Identity paradigm to
      provide secure authentication of hosts and to provide a fast key
      exchange for ESP.  HIP also attempts to limit the exposure of
      the host to various denial-of-service (DoS) and
      man-in-the-middle (MitM) attacks.  In so doing, HIP itself is
      subject to its own DoS and MitM attacks that potentially could
      be more damaging to a host's ability to conduct business as
      usual.</t>

      <t>Resource exhausting denial-of-service attacks take advantage
      of the cost of setting up a state for a protocol on the
      responder compared to the 'cheapness' on the initiator.  HIP
      allows a responder to increase the cost of the start of state on
      the initiator and makes an effort to reduce the cost to the
      responder.  This is done by having the responder start the
      authenticated Diffie-Hellman exchange instead of the initiator,
      making the HIP base exchange 4 packets long. The first packet
      sent by the responder can be prebuilt to further mitigate the
      costs. This packet also includes a computational puzzle that can
      optionally be used to further delay the initiator, for instance,
      when the responder is overloaded. The details are explained in
      the <xref target="I-D.ietf-hip-rfc5201-bis">base exchange
      specification</xref>.</t>

      <!--
      <t>HIP optionally supports opportunistic negotiation. That is,
      if a host receives a start of transport without a HIP
      negotiation, it can attempt to force a HIP exchange before
      accepting the connection.  This has the potential for DoS
      attacks against both hosts.  If the method to force the start of
      HIP is expensive on either host, the attacker need only spoof a
      TCP SYN.  This would put both systems into the expensive
      operations.  HIP avoids this attack by having the responder send
      a simple R1 packet that it can pre-build.  Since this packet is
      fixed and easily replayed, the initiator only reacts to it if it
      has just started a connection to the responder.</t> -->

      <t>Man-in-the-middle (MitM) attacks are difficult to defend against,
      without third-party authentication.  A skillful MitM could
      easily handle all parts of the HIP base exchange, but HIP
      indirectly provides the following protection from a MitM attack.
      If the responder's HI is retrieved from a signed DNS zone or
      securely obtained by some other means, the initiator can use this to
      authenticate the signed HIP packets.  Likewise, if the
      initiator's HI is in a secure DNS zone, the responder can
      retrieve it and validate the signed HIP packets.  However, since
      an initiator may choose to use an unpublished HI, it knowingly
      risks a MitM attack.  The responder may choose not to accept a
      HIP exchange with an initiator using an unknown HI.</t>

      <t>Other types of MitM attacks against HIP can be mounted using
      ICMP messages that can be used to signal about problems. As a
      overall guideline, the ICMP messages should be considered as
      unreliable "hints" and should be acted upon only after
      timeouts. The exact attack scenarios and countermeasures are
      described in full detail the <xref target="I-D.ietf-hip-rfc5201-bis">base
      exchange specification</xref>.</t>

      <t>The need to support multiple hashes for generating the HIT 
      from the HI affords the MitM to mount a potentially powerful downgrade 
      attack due to the a-priori need of the HIT in the HIP base 
      exchange.  The base exchange has been augmented to deal with 
      such an attack by restarting on detecting the attack.  At 
      worst this  would only lead to a situation in which the 
      base exchange would never finish (or would be aborted after 
      some retries).  As a drawback, this leads to an 6-way base 
      exchange which may seem bad at first.  However, since this 
      only occurs in an attack scenario and since the attack can 
      be handled (so it is not interesting to mount anymore), we
      assume the subsequent messages do not represent a security threat. Since 
      the MitM cannot be successful with a downgrade attack, these 
      sorts of attacks will only occur as 'nuisance' attacks. So, 
      the base exchange would still be usually just four packets 
      even though implementations must be prepared to protect 
      themselves against the downgrade attack.</t>

      <t>In HIP, the Security Association for ESP is indexed by the
      SPI; the source address is always ignored, and the destination
      address may be ignored as well.  Therefore, HIP-enabled
      Encapsulated Security Payload (ESP) is IP address independent.
      This might seem to make attacking easier, but ESP with
      replay protection is already as well protected as possible, and
      the removal of the IP address as a check should not increase the
      exposure of ESP to DoS attacks.</t>

    </section>

    <section anchor="ssec-flooding" title="Protection against flooding attacks">

      <t>Although the idea of informing about address changes by
      simply sending packets with a new source address appears
      appealing, it is not secure enough.  That is, even if HIP does
      not rely on the source address for anything (once the base
      exchange has been completed), it appears to be necessary to
      check a mobile node's reachability at the new address before
      actually sending any larger amounts of traffic to the new
      address.</t>

      <t>Blindly accepting new addresses would potentially lead to
      flooding Denial-of-Service attacks against third parties <xref
      target="RFC4225" />.  In a distributed flooding attack an
      attacker opens high volume HIP connections with a large number
      of hosts (using unpublished HIs), and then claims to all of
      these hosts that it has moved to a target node's IP address.
      If the peer hosts were to simply accept the move, the result
      would be a packet flood to the target node's address.  To
      prevent this type of attack, HIP mobility extensions include a return routability
      check procedure where the reachability of a node is separately
      checked at each address before using the address for larger
      amounts of traffic.</t>
      
      <t>A credit-based authorization approach <xref target="I-D.ietf-hip-rfc5206-bis">
      Host Mobility with the Host Identity Protocol</xref>
      can be used between hosts for sending data prior to completing the address
      tests. Otherwise, if HIP is used between two hosts that fully
      trust each other, the hosts may optionally decide to skip the
      address tests. However, such performance optimization must be
      restricted to peers that are known to be trustworthy and
      capable of protecting themselves from malicious software.</t>

    </section>

    <section title="HITs used in ACLs">

	<t>At end-hosts, HITs can be used in IP-based access control
	lists at the application and network layers". At middleboxes,
	HIP-aware firewalls <xref target="lindqvist-enterprise" /> can use HITs or public
	keys to control both ingress and egress access to networks or
	individual hosts, even in the presence of mobile devices
	because the HITs and public keys are topologically
	independent. As discussed earlier in <xref target="esp"
	/>, once a HIP session has been established, the SPI value in
	an ESP packet may be used as an index, indicating the HITs.
	In practice, firewalls can inspect HIP packets to learn of the
	bindings between HITs, SPI values, and IP addresses.  They can
	even explicitly control ESP usage, dynamically opening ESP
	only for specific SPI values and IP addresses.  The signatures
	in HIP packets allow a capable firewall to ensure that the HIP
	exchange is indeed occurring between two known hosts.  This
	may increase firewall security.</t>

	<t>A potential drawback of HITs in ACLs is their 'flatness'
	means they cannot be aggregated, and this could potentially
	result in larger table searches in HIP-aware firewalls. A
	way to optimize this could be to utilize bloom filters for
	grouping of HITs <xref target="sarela-bloom" />. However, it
	should be noted that it is also easier to exclude individual,
	misbehaving hosts out when the firewall rules concern
	individual HITs rather than groups.</t>

<!--   <t>[add here wildcarding]</t> -->

	<t>There has been considerable bad experience with distributed
	ACLs that contain public key related material, for example,
	with SSH.  If the owner of a key needs to revoke it for any
	reason, the task of finding all locations where the key is
	held in an ACL may be impossible.  If the reason for the
	revocation is due to private key theft, this could be a
	serious issue.</t>

	<t>A host can keep track of all of its partners that might use
	its HIT in an ACL by logging all remote HITs.  It should only
	be necessary to log responder hosts.  With this information,
	the host can notify the various hosts about the change to the
	HIT.  There has been attempts to develop a secure method to
	issue the HIT revocation notice <xref target="zhang-revocation" />.</t>

        <t>Some of the HIP-aware middleboxes, such as firewalls <xref
        target="lindqvist-enterprise" /> or NATs <xref
        target="ylitalo-spinat" />, may observe the on-path traffic
        passively. Such middleboxes are transparent by their nature
        and may not get a notification when a host moves to a
        different network. Thus, such middleboxes should maintain soft
        state and timeout when the control and data plane between two
        HIP end-hosts has been idle too long. Correspondingly, the two
        end-hosts may send periodically keepalives, such as UPDATE
        packets or ICMP messages inside the ESP tunnel, to sustain
        state at the on-path middleboxes.</t>

        <t>Another aspect related to HIP-aware middleboxes is that the
        association between the control and data plane, in the case of
        ESP, is weak and can be exploited under certain assumptions as
        described by Heer et al<xref target="heer-end-host" />. In the
        scenario, the attacker has already gained access to the target
        network protected by a HIP-aware firewall, but wants to
        circumvent the HIP-based firewall. To achieve this, the
        attacker passively observes a base exchange between two HIP
        hosts and later replays it. This way, the attacker manages to
        penetrate the firewall and can use a fake ESP tunnel to
        transport its own data. This is possible because the firewall
        cannot distinguish when the ESP tunnel is valid. As a
        solution, HIP-aware middleboxes may participate to the control
        plane interaction by adding random nonce parameters to the
        control traffic, which the the end-hosts have to sign to
        guarantee the freshness of the control traffic <xref
        target="heer-midauth" />. As an alternative, extensions for
        transporting data plane directly over the control plane can be
        used <xref target="RFC6078" />.
        </t>

        <!--
	<t>HIP-aware NATs, however, are transparent to the HIP aware
	systems by design.  Thus, the host may find it difficult to
	notify any NAT that is using a HIT in an ACL.  Since most
	systems will know of the NATs for their network, there should
	be a process by which they can notify these NATs of the change
	of the HIT.  This is mandatory for systems that function as
	responders behind a NAT.  In a similar vein, if a host is
	notified of a change in a HIT of an initiator, it should
	notify its NAT of the change.  In this manner, NATs will be
	updated with the HIT change.</t> -->

    </section>

    <section title="Alternative HI considerations">

	<t>The definition of the Host Identifier states that the HI
	need not be a public key.  It implies that the HI could be any
	value; for example a FQDN.  This document does not describe
	how to support such a non-cryptographic HI, but examples of
	such protocol variants do exist (<xref target="urien-rfid" />,
	<xref target="urien-rfid-draft" />).  A non-cryptographic HI
	would still offer the services of the HIT or LSI for NAT
	traversal.  It would be possible to carry HITs in HIP packets
	that had neither privacy nor authentication. Such schemes may
	be employed for resource constrained devices, such as small
	sensors operating on battery power, but are not further
	analyzed here.</t>

	<t>If it is desirable to use HIP in a low security situation
	where public key computations are considered expensive, HIP
	can be used with very short Diffie-Hellman and Host Identity
	keys.  Such use makes the participating hosts vulnerable to
	MitM and connection hijacking attacks.  However, it does not
	cause flooding dangers, since the address check mechanism
	relies on the routing system and not on cryptographic
	strength.</t>

    </section>
    </section>

    <section title="IANA considerations">
    <t> This document has no actions for IANA.</t>
    </section>

    <section title="Acknowledgments">

      <t>For the people historically involved in the early stages of
      HIP, see the Acknowledgments section in the 
      Host Identity Protocol specification.</t>

      <t>During the later stages of this document, when the editing
      baton was transferred to Pekka Nikander, the comments from the
      early implementers and others, including Jari Arkko, Tom
      Henderson, Petri Jokela, Miika Komu, Mika Kousa, Andrew
      McGregor, Jan Melen, Tim Shepard, Jukka Ylitalo, Sasu Tarkoma,
      and Jorma Wall, were invaluable. Also, the comments from Lars Eggert,
      Spencer Dawkins and Dave Crocker were also useful.</t>

      <t>The authors want to express their special thanks to
      Tom Henderson, who took the burden of editing the document
      in response to IESG comments at the time when both of the
      authors were busy doing other things.  Without his perseverance
      original document might have never made it as RFC4423.</t>

      <t>This main effort to update and move HIP forward within the
      IETF process owes its impetuous to a number of HIP development
      teams. The authors are grateful for Boeing, Helsinki Institute
      for Information Technology (HIIT), NomadicLab of Ericsson, and
      the three universities: RWTH Aachen, Aalto and University of
      Helsinki, for their efforts.  Without their collective efforts
      HIP would have withered as on the IETF vine as a nice
      concept.</t>

      <t>Thanks also for Suvi Koskinen for her help with proofreading
      and with the reference jungle.</t>

    </section>

    <section title="Changes from RFC 4423">

      <t>In a nutshell, the changes from <xref target="RFC4423"> RFC
      4424</xref> are mostly editorial, including clarifications on
      topics described in a difficult way and omitting some of the
      non-architectural (implementation) details that are already
      described in other documents. A number of missing references to
      the literature were also added. New topics include the drawbacks
      of HIP, discussion on 802.15.4 and MAC security, deployment
      considerations and description of the base exchange.</t>

    </section>

  </middle>
  <back>
    <references title="Normative References">

      &RFC5201-bis;
      &RFC5202-bis;
      &RFC5203-bis;
      &RFC5204-bis;
      &RFC5205-bis;
      &RFC5206-bis;
      &RFC6253-bis;
      &RFC5482;
<!--      &hip-nat; -->
      <?rfc include="reference.I-D.ietf-hip-multihoming.xml"?>
      <?rfc include="reference.I-D.ietf-hip-native-nat-traversal.xml"?>

    </references>

    <references title="Informative references">
      &RFC2136;
      &RFC2535;
      &RFC2766;
      &RFC3022;
      &RFC3102;
      &RFC3748;
<!--      &RFC4025; -->
      &RFC4225;
      &RFC4306;
      &RFC4423;
      &RFC5218;
      &RFC5338;
      &RFC5887;
      &RFC6078;
      &RFC6250;
      &RFC6281;
      &RFC6317;
      &RFC6537;
      &RFC6538;
      &nsrg-report;
      &IEEE.802-15-4.2011;
<!-- Removed per Russ Housley IESG comment
      &I-D.ietf-hip-mm;
-->

      <reference anchor="chiappa-endpoints">
	<front>
	  <title>Endpoints and Endpoint Names: A Proposed Enhancement 
          to the Internet Architecture</title>
	  <author initials="J. N." surname="Chiappa">
	    <organization />
	  </author>
	  <date year="1999" />
	</front>
	<seriesInfo name="URL" 
	  value="http://www.chiappa.net/~jnc/tech/endpoints.txt" />
	<format type="txt" 
	  target="http://www.chiappa.net/~jnc/tech/endpoints.txt" />
      </reference>

      <reference anchor="Nik2001">
	<front>
	  <title>Denial-of-Service, Address Ownership, and Early
	  Authentication in the IPv6 World</title>
	  <author initials="P." surname="Nikander">
	    <organization />
          </author>
          <date year="2002" />
        </front>
	<seriesInfo name="in Proceesings of"
	  value="Security Protocols, 9th International Workshop" />
	<seriesInfo name=""
	  value="Cambridge, UK, April 25-27 2001" />
	<seriesInfo name="LNCS" value="2467" />
	<seriesInfo name="pp." value="12-26" />
	<seriesInfo name="" value="Springer" />
	<format type="pdf"
	  target="http://www.tml.hut.fi/~pnr/publications/cam2001.pdf"
	  />
      </reference>

      <!--
      <reference anchor="Bel1998">
	<front>
	  <title>EIDs, IPsec, and HostNAT</title>
	  <author initials="S." surname="Bellovin">
	    <organization />
	  </author>
	  <date year="1998" month="March" />
	</front>
	<seriesInfo name="in Proceedings of"
	  value="41th IETF, Los Angeles, CA" />
	<seriesInfo name="URL" 
	  value="http://www1.cs.columbia.edu/~smb/talks/hostnat.pdf" />
	<format type="pdf"
	  target="http://www1.cs.columbia.edu/~smb/talks/hostnat.pdf"
	  />
      </reference>
      -->

      <reference anchor="urien-rfid">
	<front>
	  <title>HIP-based RFID Networking Architecture</title>
	  <author initials="P." surname="Urien"></author>
	  <author initials="H." surname="Chabanne"></author>
	  <author initials="M." surname="Bouet"></author>
	  <author initials="D.O." surname="de Cunha"></author>
	  <author initials="V." surname="Guyot"></author>
	  <author initials="G." surname="Pujolle"></author>
	  <author initials="P." surname="Paradinas"></author>
	  <author initials="E." surname="Gressier"></author>
	  <author initials="J.-F." surname="Susini"></author>
	  <date year="2007" month="July" />
	</front>
	<seriesInfo name="IFIP International Conference on Wireless and Optical Communications Networks," value="DOI: 10.1109/WOCN.2007.4284140" />
      </reference>

      <reference anchor="komu-leap">
        <front>
          <title>Leap-of-Faith Security is Enough for IP Mobility</title>
          <author initials="M." surname="Komu"></author>
          <author initials="J." surname="Lindqvist"></author>
          <date year="2009" month="January" />
        </front>
        <seriesInfo name="6th Annual IEEE Consumer Communications and Networking Conference IEEE CCNC 2009, Las Vegas, Nevada," value="" />
      </reference>

      <reference anchor="komu-diss">
        <front>
          <title>A Consolidated Namespace for Network Applications, Developers, Administrators and Users</title>
          <author initials="M." surname="Komu"></author>
          <date year="2012" month="December" />
        </front>
        <seriesInfo name="Dissertation, Aalto University, Espoo, Finland" value="ISBN: 978-952-60-4904-5 (printed), ISBN: 978-952-60-4905-2 (electronic). " />
      </reference>

      <reference anchor="lindqvist-enterprise">
        <front>
          <title>Enterprise Network Packet Filtering for Mobile Cryptographic Identities</title>
          <author initials="J." surname="Lindqvist"></author>
          <author initials="E." surname="Vehmersalo"></author>
          <author initials="J." surname="Manner"></author>
          <author initials="M." surname="Komu"></author>
          <date year="2010" month="January-March" />
        </front>
        <seriesInfo name="International Journal of Handheld Computing Research, 1 (1), 79-94," value="" />
      </reference>

      <reference anchor="aura-dos">
        <front>
          <title>DOS-resistant Authentication with Client Puzzles</title>
          <author initials="T." surname="Aura"></author>
          <author initials="P." surname="Nikander"></author>
          <author initials="J." surname="Leiwo"></author>
          <date year="2001" month="April" />
        </front>
        <seriesInfo name="8th International Workshop on Security Protocols, pages 170-177. Springer," value="" />
      </reference>

      <reference anchor="beal-dos">
        <front>
          <title>Deamplification of DoS Attacks via Puzzles</title>
          <author initials="J." surname="Beal"></author>
          <author initials="T." surname="Shephard"></author>
          <date year="2004" month="October" />
        </front>
        <seriesInfo name="" value="" />
      </reference>

      <reference anchor="tritilanunt-dos">
        <front>
          <title>Examining the DoS Resistance of HIP</title>
          <author initials="S." surname="Tritilanunt"></author>
          <author initials="C." surname="Boyd"></author>
          <author initials="E." surname="Foo"></author>
          <author initials="J. M. G." surname="Nieto"></author>
          <date year="2006" month="" />
        </front>
        <seriesInfo name="OTM Workshops (1), volume 4277 of Lecture Notes
                          in Computer Science, pages 616-625,Springer" value="" />
      </reference>
      
      <reference anchor="komu-mitigation">
        <front>
          <title>Mitigation of Unsolicited Traffic Across Domains with Host Identities and Puzzles</title>
          <author initials="M." surname="Komu"></author>
          <author initials="S." surname="Tarkoma"></author>
          <author initials="A." surname="Lukyanenko"></author>
          <date year="2010" month="October" />
        </front>
        <seriesInfo name="15th Nordic Conference on Secure IT Systems (NordSec 2010), Springer Lecture Notes in Computer Science, Volume 7127, pp. 33-48,"
                    value="ISBN: 978-3-642-27936-2" />
      </reference>

      <reference anchor="varjonen-split">
        <front>
          <title>Secure and Efficient IPv4/IPv6 Handovers Using Host-Based Identifier-Location Split</title>
          <author initials="S." surname="Varjonen"></author>
          <author initials="M." surname="Komu"></author>
          <author initials="A." surname="Gurtov"></author>
          <date year="2010" month="" />
        </front>
        <seriesInfo name="Journal of Communications Software and Systems, 6(1), 2010," value="ISSN: 18456421" />
      </reference>

      <reference anchor="ylitalo-spinat">
        <front>
          <title>SPINAT: Integrating IPsec into overlay routing</title>
          <author initials="J." surname="Ylitalo"></author>
          <author initials="P." surname="Salmela"></author>
          <author initials="H." surname="Tschofenig"></author>
          <date year="2005" month="September" />
        </front>
        <seriesInfo name="Proceedings of the First International Conference on Security and Privacy for Emerging Areas in Communication Networks (SecureComm 2005). Athens, Greece. IEEE Computer Society, pages 315-326,"
                    value="ISBN: 0-7695-2369-2" />
      </reference>

      <reference anchor="shields-hip">
        <front>
          <title>The HIP protocol for hierarchical multicast routing</title>
          <author initials="C." surname="Shields"></author>
          <author initials="J. J." surname="Garcia-Luna-Aceves"></author>
          <date year="1998" month="" />
        </front>
        <seriesInfo name="Proceedings of the seventeenth annual ACM symposium on Principles of distributed computing, pages 257-266. ACM, New York, NY, USA," value="ISBN: 0-89791-977-7, DOI: 10.1145/277697.277744" />
      </reference>

      <reference anchor="xueyong-hip">
        <front>
          <title>A Multicast Routing Algorithm Applied to HIP-Multicast Model</title>
          <author initials="Z." surname="Xueyong"></author>
          <author initials="D." surname="Zhiguo"></author>
          <author initials="W." surname="Xinling"></author>
          <date year="2011" month="" />
        </front>
        <seriesInfo name="Proceedings of the 2011 International Conference on Network Computing and Information Security - Volume 01 (NCIS '11), Vol. 1. IEEE Computer Society, Washington, DC, USA, pages 169-174,"
                    value ="DOI: 10.1109/NCIS.2011.42" />
      </reference>

      <reference anchor="amir-hip">
        <front>
          <title>Security and Trust of Public Key Cryptography for HIP and HIP Multicast</title>
          <author initials="K. C." surname="Amir"></author>
          <author initials="H." surname="Forsgren"></author>
          <author initials="K." surname="Grahn"></author>
          <author initials="T." surname="Karvi"></author>
          <author initials="G." surname="Pulkkis"></author>
          <date year="2013" month="" />
        </front>
        <seriesInfo name="International Journal of Dependable and Trustworthy Information Systems (IJDTIS), 2(3), 17-35,"
                    value="DOI: 10.4018/jdtis.2011070102" />
      </reference>
      

      <reference anchor="kovacshazi-host">
        <front>
          <title>Host Identity Specific Multicast</title>
          <author initials="Z." surname="Kovacshazi"></author>
          <author initials="R." surname="Vida"></author>
          <date year="2007" month="" />
        </front>
        <seriesInfo name="International conference on Networking and Services (ICNS'06), IEEE Computer Society, Los Alamitos, CA, USA,"
                    value="http://doi.ieeecomputersociety.org/10.1109/ICNS.2007.66" />
      </reference>
      
      <reference anchor="xueyong-secure">
        <front>
          <title>A Secure Multicast Model for Peer-to-Peer and Access Networks Using the Host Identity Protocol</title>
          <author initials="Z." surname="Xueyong"></author>
          <author initials="J. W." surname="Atwood"></author>
          <date year="2007" month="January" />
        </front>
        <seriesInfo name="Consumer Communications and Networking Conference. CCNC 2007. 4th IEEE, pages 1098,1102," value="DOI: 10.1109/CCNC.2007.221" />
      </reference>
      
      <reference anchor="sarela-bloom">
        <front>
          <title>BloomCasting: Security in Bloom filter based multicast</title>
          <author initials="M." surname="Srel"></author>
          <author initials="C." surname="Esteve Rothenberg"></author>
          <author initials="A." surname="Zahemszky"></author>
          <author initials="P." surname="Nikander"></author>
          <author initials="J." surname="Ott"></author>
          <date year="2012" />
      </front>
      <seriesInfo name=""
                  value="" />
      <seriesInfo name="Lecture Notes in Computer Science"
                  value="2012" />
      <seriesInfo name="" value="" />
      <seriesInfo name="pages" value="1-16" />
      <seriesInfo name="" value="Springer Berlin Heidelberg" />
      <format type=""
              target="http://dx.doi.org/10.1007/978-3-642-27937-9_1" />
     </reference>

     <reference anchor="pham-leap">
        <front>
          <title>Security Analysis of Leap-of-Faith Protocols</title>
           <author initials="V." surname="Pham"></author>
         <author initials="T." surname="Aura"></author>
          <date year="2011" month="September" />
        </front>
        <seriesInfo name=" Seventh ICST International Conference on Security and Privacy for Communication Networks," value="" />
      </reference>

      <reference anchor="karvonen-usable">
        <front>
          <title>Usable Security Management with Host Identity Protocol</title>
          <author initials="K." surname="Karvonen"></author>
          <author initials="M." surname="Komu"></author>
          <author initials="A." surname="Gurtov"></author>
          <date year="2009" month="" />
        </front>
        <seriesInfo name="7th ACS/IEEE International Conference on Computer Systems and Applications," value="(AICCSA-2009)" />
      </reference>

      <reference anchor="ylitalo-diss">
        <front>
          <title>Secure Mobility at Multiple Granularity Levels over Heterogeneous Datacom Networks</title>
          <author initials="J." surname="Ylitalo"></author>
          <date year="2008" month="" />
        </front>
        <seriesInfo name="Dissertation, Helsinki University of Technology, Espoo, Finland" value="ISBN 978-951-22-9531-9" />
      </reference>
      
     <reference anchor="xin-hip-lib">
       <front>
         <title>Host Identity Protocol Version 2.5</title>
         <author initials="G." surname="Xin"></author>
         <date year="2012" month="June" />
       </front>
       <seriesInfo name="Master's Thesis, Aalto University, Espoo, Finland," value="" />
     </reference>

     <reference anchor="scultz-intermittent">
       <front>
         <title>Protocol enhancements for intermittently connected hosts</title>
         <author initials="S." surname="Schtz"></author>
          <author initials="L." surname="Eggert"></author>
          <author initials="S." surname="Schmid"></author>
          <author initials="M." surname="Brunner"></author>
          <date year="2005" month="July" />
       </front>
       <seriesInfo name="SIGCOMM Comput. Commun. Rev., 35(3):5-18," value="" />
     </reference>

      <reference anchor="paine-hip">
        <front>
          <title>Beyond HIP: The End to Hacking As We Know It</title>
          <author initials="R. H." surname="Paine"></author>
          <date year="2009" month="" />
        </front>
        <seriesInfo name="BookSurge Publishing," value="ISBN: 1439256047, 9781439256046" />
      </reference>

      <reference anchor="leva-barriers">
        <front>
          <title>Adoption Barriers of Network-layer Protocols: the Case of Host Identity Protocol</title>
          <author initials="A. K. T." surname="Lev"></author>
          <author initials="M." surname="Komu"></author>
          <author initials="S." surname="Luukkainen"></author>
          <date year="2013" month="March" />
        </front>
        <seriesInfo name="The International Journal of Computer and Telecommunications Networking," value="ISSN: 1389-1286" />
      </reference>

      <reference anchor="heer-end-host">
        <front>
          <title>End-host Authentication and Authorization for Middleboxes based on a Cryptographic Namespace</title>
          <author initials="T." surname="Heer"></author>
          <author initials="R." surname="Hummen"></author>
          <author initials="M." surname="Komu"></author>
          <author initials="S." surname="Gtz"></author>
          <author initials="K." surname="Wehre"></author>
          <date year="2009" month="" />
        </front>
        <seriesInfo name="ICC2009 Communication and Information Systems Security Symposium," value="" />
      </reference>
      
      <reference anchor="komu-cloud">
        <front>
          <title>Secure Networking for Virtual Machines in the Cloud</title>
          <author initials="M." surname="Komu"></author>
          <author initials="M." surname="Sethi"></author>
          <author initials="R." surname="Mallavarapu"></author>
          <author initials="H." surname="Oirola"></author>
          <author initials="R." surname="Khan"></author>
          <author initials="S." surname="Tarkoma"></author>
          <date year="2012" month="September" />
        </front>
        <seriesInfo name="International Workshop on Power and QoS Aware Computing (PQoSCom2012), IEEE," value="ISBN: 978-1-4244-8567-3" />
      </reference>

      <reference anchor="zhang-revocation">
	<front>
	  <title>Host Identifier Revocation in HIP</title>
	  <author initials="D." surname="Zhang"></author>
	  <author initials="D." surname="Kuptsov"></author>
	  <author initials="S." surname="Shen"></author>
	  <date year="2012" month="Mar" />
	</front>
	<seriesInfo name="IRTF Working draft" value="draft-irtf-hiprg-revocation-05"/>
      </reference>

      <reference anchor="urien-rfid-draft">
	<front>
	  <title>HIP support for RFIDs</title>
	  <author initials="P." surname="Urien"></author>
	  <author initials="G." surname="Lee"></author>
	  <author initials="G." surname="Pujolle"></author>
	  <date year="2013" month="April" />
	</front>
	<seriesInfo name="IRTF Working draft" value="draft-irtf-hiprg-rfid-07"/>
      </reference>

      <reference anchor="hip-srtp">
	<front>
	  <title>Using SRTP transport format with HIP</title>
	  <author initials="H." surname="Tschofenig"></author>
	  <author initials="F." surname="Muenz"></author>
	  <author initials="M." surname="Shanmugam"></author>
	  <date year="2005" month="October" />
	</front>
	<seriesInfo name="Working draft" value="draft-tschofenig-hiprg-hip-srtp-01"/>
      </reference>

      <reference anchor="henderson-vpls">
	<front>
	  <title></title>
	  <author initials="T." surname="Henderson"></author>
	  <author initials="D." surname="Mattes"></author>
	  <date year="2013" month="June" />
	</front>
	<seriesInfo name="Working draft" value="draft-henderson-hip-vpls-06"/>
      </reference>

      <reference anchor="heer-midauth">
	<front>
	  <title>End-Host Authentication for HIP Middleboxes</title>
	  <author initials="T." surname="Heer"></author>
	  <author initials="M." surname="Komu"></author>
	  <date year="2009" month="September" />
	</front>
	<seriesInfo name="Working draft" value="draft-heer-hip-middle-auth-02"/>
      </reference>

<!--

     <reference anchor="herborn-secure">
       <front>
         <title>"Secure Host Identity Delegation for Mobility," Communication Systems Software and Middleware</title>
         <author initials="S." surname="Herborn"></author>
         <author initials="A." surname="Huber"></author>
         <author initials="R." surname="Boreli"></author>
         <author initials="A." surname="Seneviratne"></author>
          <date year="2007" month="January" />
       </front>
       <seriesInfo name="Communication Systems Software and Middleware. COMSWARE 2007. pages 1, 9," value="DOI: 10.1109/COMSWA.2007.382596" />
     </reference>

     <reference anchor="nikander-hip">
       <front>
         <title> Integrating security, mobility, and multi-homing in a HIP way</title>
         <author initials="P." surname="Nikander"></author>
         <author initials="J." surname="Ylitalo"></author>
         <author initials="J." surname="Wall"></author>
          <date year="2003" month="February" />
       </front>
       <seriesInfo name="Proceedings of the 10th Annual Network and Distributed System Security Symposium (NDSS 2003). San Diego, CA, USA. Internet Society, pages 87-99,"
                   value="ISBN 1-891562-16-9" />
     </reference>
     
     <reference anchor="caesar-routing">
       <front>
         <title>Rofl: routing on flat labels</title>
         <author initials="M." surname="Caesar"></author>
          <author initials="T." surname="Condie"></author>
          <author initials="J." surname="Kannan"></author>
          <author initials="K." surname="Lakshminarayanan"></author>
          <author initials="I." surname="Stoica"></author>
          <date year="2006" month="" />
       </front>
       <seriesInfo name="Proceedings of the 2006 conference on Appli-
                         cations, technologies, architectures, and protocols for computer communi-
                         cations, SIGCOMM '06, pages 363-374, ACM, New York, NY, USA, 2006," value="" />
     </reference>

      <reference anchor="saltzer-notes">
        <front>
          <title>Naming and Binding of Objects In Operating Systems</title>
          <author initials="J." surname="Saltzer"></author>
          <date year="1978" month="" />
        </front>
        <seriesInfo name="Lecture Notes in Computer Science, Vol. 60. Springer-Verlag," value="" />
      </reference>
      
      <reference anchor="saltzer-end">
        <front>
          <title>End-to-end Arguments in System Design</title>
          <author initials="J. H." surname="Saltzer"></author>
          <author initials="D. P." surname="Reed"></author>
          <author initials="D.  D." surname="Clark"></author>
          <date year="1984" month="November" />
        </front>
        <seriesInfo name="ACM Trans. Comput. Syst., 2(4):277-288," value="" />
      </reference>
      
      <reference anchor="shoch-naming">
        <front>
          <title>Inter-Network Naming, Addressing, and Routing</title>
          <author initials="J." surname="Shoch"></author>
          <date year="1978" month="" />
        </front>
        <seriesInfo name="IEEE Proc. COMPCON, pages 72-79. IEEE," value="" />
      </reference>

-->

    </references>
  </back>
</rfc>