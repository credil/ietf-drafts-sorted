<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" ipr="trust200902" docName="draft-ietf-websec-key-pinning-06">
<front>
<title>Public Key Pinning Extension for HTTP</title>

<author initials="C." surname="Evans" fullname="Chris Evans">
<organization>Google, Inc.</organization>
<address>
<postal>
<street>1600 Amphitheatre Pkwy</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043</code>
<country>US</country>
</postal>
<email>cevans@google.com</email>
</address>
</author>

<author initials="C." surname="Palmer" fullname="Chris Palmer">
<organization>Google, Inc.</organization>
<address>
<postal>
<street>1600 Amphitheatre Pkwy</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043</code>
<country>US</country>
</postal>
<email>palmer@google.com</email>
</address>
</author>

<author initials="R." surname="Sleevi" fullname="Ryan Sleevi">
<organization>Google, Inc.</organization>
<address>
<postal>
<street>1600 Amphitheatre Pkwy</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043</code>
<country>US</country>
</postal>
<email>sleevi@google.com</email>
</address>
</author>

<date month="June" year="2013" />

<area>General</area>
<workgroup>Web Security</workgroup>

<keyword>I-D</keyword>
<keyword>Internet-Draft</keyword>
<keyword>Certificate</keyword>
<keyword>Public key</keyword>
<keyword>X.509</keyword>
<keyword>Certification authority</keyword>
<keyword>Public key pinning</keyword>
<keyword>HTTPS</keyword>
<keyword>TLS</keyword>
<keyword>SSL</keyword>

<abstract>

<t>This memo describes an extension to the HTTP protocol allowing web host
operators to instruct user agents (UAs) to remember ("pin") the hosts'
cryptographic identities for a given period of time. During that time, UAs
will require that the host present a certificate chain including at least
one Subject Public Key Info structure whose fingerprint matches one of the
pinned fingerprints for that host. By effectively reducing the number of
authorities who can authenticate the domain during the lifetime of the pin,
pinning may reduce the incidence of man-in-the-middle attacks due to
compromised Certification Authorities.</t>

</abstract>

</front>

<middle>

<section anchor="introduction" title="Introduction">

<t>We propose a new HTTP header to enable a web host to express to user
agents (UAs) which Subject Public Key Info (SPKI) structure(s) UAs SHOULD
expect to be present in the host's certificate chain in future connections
using TLS (see <xref target="RFC5246"/>). We call this "public key pinning".
At least one UA (Google Chrome) has experimented with the idea by shipping
with a user-extensible embedded set of pins. Although effective, this does
not scale. This proposal addresses the scale problem.</t>

<t>Deploying public key pinning safely will require operational and
organizational maturity due to the risk that hosts may make themselves
unavailable by pinning to a SPKI that becomes invalid. (See <xref
target="security-considerations"/>.) We believe that, with care, host
operators can greatly reduce the risk of MITM attacks and other
false-authentication problems for their users without incurring undue
risk.</t>

<t>We intend for hosts to use public key pinning together with HSTS (<xref
target="RFC6797"/>), but is possible to pin keys without requiring HSTS.</t>

<t>This draft is being discussed on the WebSec Working Group mailing
list, websec@ietf.org.</t>

<section anchor="requirements-language" title="Requirements Language">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119">RFC
2119</xref>.</t>

</section><!-- requirements-language -->

</section><!-- introduction -->

<section anchor="server-client-behavior" title="Server and Client
Behavior">

<section anchor="header-syntax" title="Response Header Field Syntax">

<t>The Public-Key-Pins HTTP response header field (PKP header field)
indicates to a UA that it SHOULD perform Pin Validation (<xref
target="validating-pinned-connections"/>) in regards to the host emitting
the response message containing this header field, and provides the
necessary information for the UA to do so.</t>

<t><xref target="header-abnf"/> describes the ABNF (Augmented Backus-Naur
Form) syntax of the header field. It is based on the Generic Grammar defined
in Section 2 of <xref target="RFC2616"/> (which includes a notion of
"implied linear whitespace", also known as "implied *LWS").</t>

<figure anchor="header-abnf" title="HPKP Header Syntax">
<artwork>
Public-Key-Pins =
    "Public-Key-Pins" ":" [ directive ] *( ";" [ directive ] )
Public-Key-Pins-Report-Only =
    "Public-Key-Pins-Report-Only" ":" [ directive ] *( ";" [ directive ] )

directive        = simple-directive
                   / pin-directive

simple-directive = directive-name [ "=" directive-value ]
directive-name   = token
directive-value  = token
                   / quoted-string

pin-directive    = "pin-" token "=" quoted-string
</artwork>
</figure>

<t>token and quoted-string are used as defined in <xref target="RFC2616"/>,
Section 2.2.</t>

<t>The directives defined in this specification are described below. The
overall requirements for directives are:</t>

<t><list style="numbers">
<t>The order of appearance of directives is not significant.</t>

<t>All simple-directives MUST appear only once in a PKP header field.
Directives are either optional or required, as stipulated in their
definitions.</t>

<t>Directive names are case-insensitive.</t>

<t>UAs MUST ignore any PKP header fields containing directives, or other
header field value data, that do not conform to the syntax defined in this
specification.</t>

<t>If a PKP header field contains any directive(s) the UA does not
recognize, the UA MUST ignore the those directives.</t>

<t>If the PKP header field otherwise satisfies the above requirements (1
through 5), the UA MUST process the directives it recognizes.</t>
</list></t>

<t>Additional directives extending the semantic functionality of the PKP
header field can be defined in other specifications, with a registry (having
an IANA policy definition of IETF Review <xref target="RFC2616"/>) defined
for them at such time. Such future directives will be ignored by UAs
implementing only this specification, as well as by generally non-conforming
UAs.</t>

<t>In the pin-directive, the token is the name of a cryptographic hash
algorithm, and MUST be either "sha1" or "sha256". The quoted-string is a
sequence of base 64 digits: the base 64-encoded SPKI Fingerprint. See <xref
target="pin-semantics"/>.</t>

<section anchor="max-age" title="The max-age Directive">

<t>The REQUIRED "max-age" directive specifies the number of seconds, after
the reception of the PKP header field, during which the UA SHOULD regard the
host (from whom the message was received) as a Known Pinned Host. The
delta-seconds production is specified in <xref target="RFC2616"/>.</t>

<t>The syntax of the max-age directive's REQUIRED value (after quoted-
string unescaping, if necessary) is defined as:</t>

<figure anchor="max-age-value-syntax" title="max-age Value Syntax">
<artwork>
max-age-value = delta-seconds
delta-seconds = 1*DIGIT
</artwork>
</figure>

<t>delta-seconds is used as defined in <xref target="RFC2616"/>, Section
3.3.2.</t>

<t>NOTE: A max-age value of zero (i.e., "max-age=0") signals the UA to cease
regarding the host as a Known Pinned Host, including the includeSubDomains
directive (if asserted for that Known Pinned Host). See <xref
target="header-field-processing"/>.</t>

</section><!-- max-age -->

<section anchor="includesubdomains" title="The includeSubDomains Directive">

<t>The OPTIONAL "includeSubDomains" directive is a valueless directive
which, if present (i.e., it is "asserted"), signals to the UA that the
Pinning Policy applies to this Pinned Host as well as any subdomains of the
host's domain name.</t>

</section><!-- includesubdomains -->

<section anchor="report-uri" title="The report-uri Directive">

<t>The OPTIONAL "report-uri" directive indicates the URI to which the UA
SHOULD report Pin Validation failures (<xref
target="validating-pinned-connections"/>). The UA POSTs the reports to the
given URI as described in <xref
target="reporting-pin-validation-failure"/>.</t>

<t>When used in the Public-Key-Pins-Report-Only header, the UA SHOULD POST
reports for Pin Validation failures to the indicated report-uri, although
the UA MUST NOT enforce Pin Validation. That is, in the event of Pin
Validation failure when the host has set the Public-Key-Pins-Report-Only
header, the UA performs Pin Validation only to check whether or not it
should POST a report, but not for causing connection failure.</t>

<t>If a Host sets both the Public-Key-Pins header and the
Public-Key-Pins-Report-Only header, the UA MUST NOT enforce Pin Validation,
and MUST note only the pins and directives given in the
Public-Key-Pins-Report-Only header.</t>

<t>When used in the Public-Key-Pins header, the presence of a report-uri
directive indicates to the UA that the UA MUST enforce Pin Validation, and
the UA SHOULD also, in the event of Pin Validation failure, POST a report to
the report-uri.</t>

<t>Note that the report-uri need not necessarily be in the same Internet
domain or web origin as the Known Pinned Host.</t>

<t>Hosts may set report-uris that use HTTP, HTTPS, or other schemes. If the
scheme in the report-uri is HTTPS, UAs MUST perform Pinning Validation when
the host in the report-uri is a Known Pinned Host; similarly, UAs MUST apply
HSTS if the host in the report-uri is a Known HSTS Host.</t>

<t>UAs SHOULD make their best effort to report Pin Validation failures to
the report-uri, but MAY fail to report in exceptional conditions. For
example, if connecting the report-uri itself incurs a Pinning Validation
failure or other certificate validation failure, the UA MUST cancel the
connection (and MAY attempt to re-send the report later). Similarly, if
Known Pinned Host A sets a report-uri referring to Known Pinned Host B, and
if B sets a report-uri referring to A, and if both hosts fail Pin
Validation, the UA SHOULD detect and break the loop by failing to send
reports to and about those hosts.</t>

<t>UAs SHOULD limit the rate at which they send reports. For example, it
is unnecessary to send the same report to the same report-uri more than
once.</t>

</section><!-- report-uri -->

<section anchor="strict" title="The strict Directive">

<t>The OPTIONAL "strict" directive is a valueless directive which, if present
(i.e., it is "asserted"), signals to the UA that it should apply to the Pinned
Host the Pinning Policy expressed in the PKP header exactly as specified,
ignoring local client policy.</t>

</section><!-- strict -->

<section anchor="grammar-examples" title="Examples">

<t><xref target="pins-examples"/> shows some example response header fields
using the pins extension (folded for clarity).</t>

<figure anchor="pins-examples" title="HPKP Header Examples">
<artwork>
Public-Key-Pins: max-age=3000;
    pin-sha1="4n972HfV354KP560yw4uqe/baXc=";
    pin-sha1="IvGeLsbqzPxdI0b0wuj2xVTdXgc="

Public-Key-Pins: max-age=2592000;
    pin-sha1="4n972HfV354KP560yw4uqe/baXc=";
    pin-sha256="LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ="

Public-Key-Pins: max-age=2592000;
    pin-sha1="4n972HfV354KP560yw4uqe/baXc=";
    pin-sha256="LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=";
    report-uri="http://example.com/pkp-report"

Public-Key-Pins-Report-Only: max-age=2592000;
    pin-sha1="4n972HfV354KP560yw4uqe/baXc=";
    pin-sha256="LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=";
    report-uri="http://example.com/pkp-report"

Public-Key-Pins: pin-sha1="4n972HfV354KP560yw4uqe/baXc=";
    pin-sha1="qvTGHdzF6KLavt4PO0gs2a6pQ00=";
    pin-sha256="LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=";
    max-age=259200

Public-Key-Pins: pin-sha1="4n972HfV354KP560yw4uqe/baXc=";
    pin-sha1="qvTGHdzF6KLavt4PO0gs2a6pQ00=";
    pin-sha256="LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=";
    max-age=10000; includeSubDomains
</artwork>
</figure>

</section><!-- grammar-examples -->

</section><!-- header-syntax -->

<section anchor="server-processing-model" title="Server Processing Model">

<t>This section describes the processing model that Pinned Hosts implement.
The model comprises two facets: the processing rules for HTTP request
messages received over a secure transport (e.g. TLS <xref
target="RFC5246"/>); and the processing rules for HTTP request messages
received over non-secure transports, such as TCP.</t>

<section anchor="https-request-type" title="HTTP-over-Secure-Transport
Request Type">

<t>When replying to an HTTP request that was conveyed over a secure
transport, a Pinned Host SHOULD include in its response exactly one PKP
header field that MUST satisfy the grammar specified above in <xref
target="header-syntax"/>. If the Pinned Host does not include the PKP header
field, and if the connection passed Pin Validation, UAs MUST treat the host
as if it had set its max-age to 0 (see <xref
target="header-field-processing"/>).</t>

<t>Establishing a given host as a Known Pinned Host, in the context of a
given UA, MAY be accomplished over the HTTP protocol, which is in turn
running over secure transport, by correctly returning (per this
specification) at least one valid PKP header field to the UA. Other
mechanisms, such as a client-side pre-loaded Known Pinned Host list MAY also
be used.</t>

</section><!-- https-request-type -->

<section anchor="http-request-type" title="HTTP Request Type">

<t>Pinned Hosts SHOULD NOT include the PKP header field in HTTP responses
conveyed over non-secure transport. UAs MUST ignore any PKP header received
in an HTTP response conveyed over non-secure transport.</t>

</section><!-- http-request-type -->

</section><!-- server-processing-model -->

<section anchor="server-ua-model" title="User Agent Processing Model">

<t>This section describes the HTTP Public Key Pinning processing model for
UAs.</t>

<t>The UA processing model relies on parsing domain names. Note that
internationalized domain names SHALL be canonicalized according to the
scheme in Section 10 of <xref target="RFC6797"/>.</t>

<section anchor="header-field-processing" title="Public-Key-Pins Response
Header Field Processing">

<t>If the UA receives, over a secure transport, an HTTP response that
includes a PKP header field conforming to the grammar specified in <xref
target="header-syntax"/>, and there are no underlying secure transport
errors or warnings (see <xref target="noting-pins"/>), the UA MUST
either:</t>

<t><list style="symbols">
<t>Note the host as a Known HSTS Host if it is not already so noted (see
<xref target="storage-model"/>),</t>
</list></t>

<t>or,</t>

<t><list style="symbols">

<t>Update the UA's cached information for the Known Pinned Host if any of of
the max-age, includeSubDomains, strict, or report-uri header field value
directives convey information different than that already maintained by the
UA.</t>

<t>The max-age value is essentially a "time to live" value relative to the
time of the most recent observation of the PKP header field.</t>

<t>If the max-age header field value token has a value of 0, the UA MUST
remove its cached Pinning Policy information (including the
includeSubDomains and strict directives, if asserted) if the Pinned Host is
Known, or, MUST NOT note this Pinned Host if it is not yet Known.</t>

<t>If a UA receives more than one PKP header field in an HTTP response
message over secure transport, then the UA MUST process only the first such
header field.</t>

</list></t>

<t>Otherwise:</t>

<t><list style="symbols">
<t>If the UA receives the HTTP response over insecure transport, or if the
PKP header is not a Valid Pinning Header (see <xref target="noting-pins"/>),
the UA MUST ignore any present PKP header field(s).</t>

<t>The UA MUST ignore any PKP header fields not conforming to the grammar
specified in <xref target="header-syntax"/>.</t>
</list></t>

</section><!-- header-field-processing -->

<section anchor="storage-model" title="Noting a Pinned Host - Storage
Model">

<t>If the substring matching the host production from the Request-URI (of
the message to which the host responded) syntactically matches the
IP-literal or IPv4address productions from Section 3.2.2 of <xref
target="RFC3986"/>, then the UA MUST NOT note this host as a Known Pinned
Host.</t>

<t>Otherwise, if the substring does not congruently match a Known Pinned
Host's domain name, per the matching procedure specified in Section 8.2 of
<xref target="RFC6797"/>, then the UA MUST note this host as a Known Pinned
Host, caching the Pinned Host's domain name and noting along with it the time
of the observation (also known as the Effective Pin Date), the value of the
max-age directive, whether or not the includeSubDomains or strict directives
are asserted, the value of the report-uri directive (if present), and any
other metadata from optional or future PKP header directives.</t>

<t>UAs MAY set an upper limit on the value of max-age, so that UAs that have
noted erroneous pins (whether by accident or due to attack) have some chance
of recovering over time. If the server sets a max-age greater than the UA's
upper limit, the UA MAY behave as if the server set the max-age to the UA's
upper limit. For example, if the UA caps max-age at 5184000 seconds (60
days), and a Pinned Host sets a max-age directive of 90 days in its Valid
Pinning Header, the UA MAY behave as if the max-age were effectively 60
days. (One way to achieve this behavior is for the UA to simply store a
value of 60 days instead of the 90 day value provided by the Pinned Host.)
For UA implementation guidance on how to select a maximum max-age, see <xref
target="maximum-max-age"/>.</t>

<t>The UA MUST NOT modify any pinning metadata of any superdomain matched
Known Pinned Host.</t>

<t>A Known Pinned Host is "expired" if the Effective Pin Date plus the max-age
refers to a date in the past. The UA MUST ignore all expired Known Pinned
Hosts from its cache if, at any time, an expired Known Pinned Host exists in
the cache.</t>

</section><!-- storage-model -->

<section anchor="http-equiv" title="HTTP-Equiv &lt;Meta&gt; Element
Attribute">

<t>UAs MUST NOT heed http-equiv="Public-Key-Pins" attribute settings on
&lt;meta&gt; elements <xref target="W3C.REC-html401-19991224"/> in
received content.</t>

</section><!-- http-equiv -->

</section><!-- ua-processing-model -->

<section anchor="pin-semantics" title="Semantics of Pins">

<t>An SPKI Fingerprint is defined as the output of a known cryptographic
hash algorithm whose input is the DER-encoded ASN.1 representation of the
SubjectPublicKeyInfo (SPKI) field of an X.509 certificate. A Pin is defined
as the combination of the known algorithm identifier and the SPKI
Fingerprint computed using that algorithm.</t>

<t>The SPKI Fingerprint is encoded in base 64 for use in an HTTP header.
(See <xref target="RFC4648"/>.)</t>

<t>In this version of the specification, the known cryptographic hash
algorithms are SHA-1, identified as "sha1", and SHA-256, identified as
"sha256". (Future versions of this specification may add new algorithms and
deprecate old ones.) UAs MUST ignore Pins for which they do not recognize
the algorithm identifier. UAs MUST continue to process the rest of a PKP
response header field and note Pins for algorithms they do recognize; UAs
MUST recognize "sha1" and "sha256".</t>

<t><xref target="spki-definition"/> reproduces the definition of
the SubjectPublicKeyInfo structure in <xref target="RFC5280"/>.</t>

<figure anchor="spki-definition" title="SPKI Definition">
<artwork>
SubjectPublicKeyInfo  ::=  SEQUENCE  {
    algorithm            AlgorithmIdentifier,
    subjectPublicKey     BIT STRING  }

AlgorithmIdentifier  ::=  SEQUENCE  {
    algorithm            OBJECT IDENTIFIER,
    parameters           ANY DEFINED BY algorithm OPTIONAL  }
</artwork>
</figure>

<t>If the SubjectPublicKeyInfo of a certificate is incomplete when taken in
isolation, such as when holding a DSA key without domain parameters, a
public key pin cannot be formed.</t>

<t>We pin public keys, rather than entire certificates, to enable operators
to generate new certificates containing old public keys (see <xref
target="why-pin-key" />).</t>

<t>See <xref target="fingerprint-generation" /> for an example non-normative
program that generates SPKI Fingerprints from SubjectPublicKeyInfo fields in
certificates.</t>

</section><!-- pin-semantics -->

<section anchor="noting-pins" title="Noting Pins">

<t>Upon receipt of the Public-Key-Pins response header field, the UA notes
the host as a Pinned Host, storing the Pins and their associated directives
in non-volatile storage (for example, along with the HSTS metadata). The
Pins and their associated directives are collectively known as Pinning
Metadata.</t>

<t>The UA MUST observe these conditions when noting a Host:</t>

<t><list style="symbols">
<t>The UA MUST note the Pins if and only if it received the Public-Key-Pins
response header field over an error-free TLS connection. If the host is a
Pinned Host, this includes the validation added in <xref
target="validating-pinned-connections" />.</t>

<t>The UA MUST note the Pins if and only if the TLS connection was
authenticated with a certificate chain containing at least one of the SPKI
structures indicated by at least one of the given SPKI Fingerprints. (See
<xref target="validating-pinned-connections"/>.)</t>

<t>The UA MUST note the Pins if and only if the given set of Pins contains
at least one Pin that does NOT refer to an SPKI in the certificate chain.
(That is, the host must set a Backup Pin; see <xref
target="backup-pins"/>.)</t>
</list></t>

<t>If the Public-Key-Pins response header field does not meet all three of
these criteria, the UA MUST NOT note the host as a Pinned Host. A
Public-Key-Pins response header field that meets all these critera is known
as a Valid Pinning Header.</t>

<t>The UA MUST ignore Public-Key-Pins response header fields received on
connections that do not meet the first criterion.</t>

<t>Whenever a UA receives a Valid Pinning Header, it MUST set its Pinning
Metadata to the exact Pins, max-age, and (if any) report-uri and strict mode
given in the most recently received Valid Pinning Header.</t>

<t>For forward compatibility, the UA MUST ignore any unrecognized
Public-Key-Pins header directives, while still processing those directives
it does recognize. <xref target="header-syntax" /> specifies the directives
max.age, pins, includeSubDomains, report-uri, and strict, but future
specifications and implementations might use additional directives.</t>

</section><!-- noting-pins -->

<section anchor="validating-pinned-connections" title="Validating Pinned
Connections">

<t>When a UA connects to a Pinned Host, if the TLS connection has errors,
the UA MUST terminate the connection without allowing the user to proceed
anyway. (This behavior is the same as that required by <xref
target="RFC6797"/>.)</t>

<t>If the connection has no errors, then the UA will determine whether to
apply a new, additional correctness check: Pin Validation. A UA SHOULD
perform Pin Validation whenever connecting to a Known Pinned Host, but MAY
allow Pin Validation to be disabled for Hosts according to local policy. For
example, a UA may disable Pin Validation for Pinned Hosts whose validated
certificate chain terminates at a user-defined trust anchor, rather than a
trust anchor built-in to the UA. However, if the Pinned Host Metadata
indicates that the Pinned Host is operating in "strict mode" (see
<xref target="strict"/>), then the UA MUST perform Pin Validation.</t>

<t>To perform Pin Validation, the UA will compute the SPKI Fingerprints for
each certificate in the Pinned Host's validated certificate chain, using each
supported hash algorithm for each certificate. (For the purposes of Pin
Validation, the UA MUST ignore certificates whose SPKI cannot be taken in
isolation, and MUST ignore superfluous certificates in the chain that do not
form part of the validating chain.) The UA will then check that the set of
these SPKI Fingerprints intersects the set of SPKI Fingerprints in that Pinned
Host's Pinning Metadata. If there is set intersection, the UA continues with
the connection as normal. Otherwise, the UA MUST treat this Pin Failure as a
non-recoverable error. Any procedure that matches the results of this Pin
Validation procedure is considered equivalent.</t>

<t>Note that, although the UA has previously received Pins at the HTTP
layer, it can and MUST perform Pin Validation at the TLS layer, before
beginning an HTTP conversation over the TLS channel. The TLS layer thus
evaluates TLS connections with pinning information the UA received
previously, regardless of mechanism: statically preloaded, via HTTP header,
or some other means (possibly in the TLS layer itself).</t>

</section><!-- validating-pinned-connections -->

<section anchor="interactions-built-in" title="Interactions With
Preloaded Pin Lists">

<t>UAs MAY choose to implement additional sources of pinning information, such
as through built-in lists of pinning information. Such UAs SHOULD allow users
to override such additional sources, including disabling them from
consideration.</t>

<t>UAs that support additional sources of pinning information MUST use the
most recently observed pinning information when performing Pin Validation for
a host. The most recently observed pinning information is determined based
upon the most recent Effective Pin Date, as described in <xref
target="storage-model"/>.</t>

<t>If the result of noting a Valid Pinning Header is to disable pinning for
the host, such as through supplying a max-age directive with a value of 0, UAs
MUST allow this new information to override any other pinning data. That is, a
host must be able to un-pin itself, even in the presence of built-in pins.</t>

<t>Example: A UA may ship with a pre-configured list of pins that are
collected from past observations of Valid Pinning Headers supplied by hosts.
In such a solution, the pre-configured list should track when the Valid
Pinning Header was last observed, in order to permit site operators to later
update the value by supplying a new Valid Pinning Header. Updates to such a
pre-configured list should not update the Effective Pin Dates for each host
unless the list vendor has actually observed a more recent header. This is to
prevent situations where updating the Effective Pin Date on a pre-configured
list of pins may effectively extend the max-age beyond the site operator's
stated policy.</t>

<t>Example: A UA may ship with a pre-configured list of pins that are
collected through out-of-band means, such as direct contact with the site
operator. In such a solution, the site operator accepts responsibility for
keeping the configured Valid Pinning Header in sync with the vendor's list,
allowing the UA vendor to have each update to the list be treated as as an
update of the Effective Pin Date.</t>

</section><!-- interactions-built-in -->

<section anchor="pinning-self-signed" title="Pinning Self-Signed End
Entities">

<t>If UAs accept hosts that authenticate themselves with self-signed end
entity certificates, they MAY also allow hosts to pin the public keys in
such certificates. The usability and security implications of this practice
are outside the scope of this specification.</t>

</section><!-- pinning-self-signed -->

</section><!-- server-client-behavior -->

<section anchor="reporting-pin-validation-failure" title="Reporting Pin
Validation Failure">

<t>When a Known Pinned Host has set the report-uri directive, the UA SHOULD
report Pin Validation failures to the indicated URI. The UA does this by
POSTing a JSON message to the URI; the JSON message takes this form:</t>

<figure anchor="json-report-format" title="JSON Report Format">
<artwork>
{
  "date-time": date-time,
  "hostname": hostname,
  "port": port,
  "certificate-chain": [
    pem1, ... pemN
  ],
  "known-pins": [
    known-pin1, ... known-pinN
  ]
}
</artwork>
</figure>

<t>Whitespace outside of quoted strings is not significant. The key/value
pairs may appear in any order, but each SHOULD appear only once.</t>

<t>The date-time indicates the time the UA observed the Pin Validation
failure. It is provided as a string formatted according to Section 5.6,
"Internet Date/Time Format", of <xref target="RFC3339"/>.</t>

<t>The hostname is the hostname to which the UA made the original request
that failed Pin Validation. It is provided as a string.</t>

<t>The port is the port to which the UA made the original request that
failed Pin Validation. It is provided either as a string or as an
integer.</t>

<t>The certificate-chain is the certificate chain, as constructed by the UA
during certificate chain verification. (This may differ from the certificate
chain as served by the Known Pinned Host, of course.) It is provided as an
array of strings; each string pem1, ... pemN is the PEM representation of each
X.509 certificate as described in <xref
target="I-D.josefsson-pkix-textual"/>.</t>

<t>The known-pins are the Pins that the UA has noted for the Known Pinned
Host. They are provided as an array of strings with the syntax:</t>

<figure anchor="known-pin-syntax" title="Known Pin Syntax">
<artwork>
known-pin = token "=" quoted-string
</artwork>
</figure>

<t>As in <xref target="pin-semantics"/>, the token refers to the algorithm
name, and the quoted-string refers to the base 64 encoding of the SPKI
Fingerprint.</t>

</section><!-- reporting-pin-validation-failure -->

<section anchor="security-considerations" title="Security Considerations">

<t>Pinning public keys helps hosts strongly assert their cryptographic
identity even in the face of issuer error, malfeasance or compromise. But
there is some risk that a host operator could lose or lose control of their
host's private key (such as by operator error or host compromise). If the
operator had pinned only the key of the host's end entity certificate, the
operator would not be able to serve their web site or application in a way
that UAs would trust for the duration of their pin's max-age. (Recall that
UAs MUST close the connection to a host upon Pin Failure.)</t>

<t>Therefore, there is a necessary trade-off between two competing goods:
pin specificity and maximal reduction of the scope of issuers on the one
hand; and flexibility and resilience of the host's cryptographic identity on
the other hand. One way to resolve this trade-off is to compromise by
pinning to the key(s) of the issuer(s) of the host's end entity
certificate(s). Often, a valid certificate chain will have at least two
certificates above the end entity certificate: the intermediate issuer, and
the trust anchor. Operators can pin any one or more of the public keys in
this chain, and indeed could pin to issuers not in the chain (as, for
example, a Backup Pin). Pinning to an intermediate issuer, or even to a
trust anchor or root, still significantly reduces the number of issuers who
can issue end entity certificates for the Known Pinned Host, while still
giving that host flexibility to change keys without a disruption of
service.</t>

<section anchor="maximum-max-age" title="Maximum max-age">

<t>As mentioned in <xref target="storage-model"/>, UAs MAY cap the max-age
value at some upper limit. There is a security trade-off in that low maximum
values provide a narrow window of protection for users who visit the Known
Pinned Host only infrequently, while high maximum values might potentially
result in a UA's inability to successfully perform Pin Validation for a
Known Pinned Host if the UA's noted pins and the Host's true pins
diverge.</t>

<t>Such divergence could occur for several reasons, including: UA error;
Host operator error; network attack; or a Known Pinned Host that
intentionally migrates all pinned keys, combined with a UA that has noted
true pins with a high max-age value and has not had a chance to observe the
new true pins for the Host. (This last example underscores the importance
for Host operators to phase in new keys gradually, and to set the max-age
value in accordance with their planned key migration schedule.)</t>

<t>There is probably no ideal upper limit to the max-age directive that
would satisfy all use cases. However, a value on the order of 60 days
(5184000 seconds) may be considered a balance between the two competing
security concerns.</t>

</section><!-- maximum-max-age -->

<section anchor="using-includeSubDomains" title="Using includeSubDomains
Safely">

<t>It may happen that Pinned Hosts whose hostnames share a parent domain use
different Valid Pinning Headers. If a Host whose hostname is a parent domain
for another Host sets the includeSubDomains directive, the two Hosts' pins may
conflict with each other. For example, consider two Known Pinned Hosts,
example.com and subdomain.example.com. Assume example.com sets a Valid Pinning
Header such as this:</t>

<figure anchor="example-com-header" title="example.com Valid Pinning
Header">
<artwork>
Public-Key-Pins: pin-sha1="ABC..."; pin-sha1="DEF..."; includeSubDomains
</artwork>
</figure>

<t>Assume subdomain.example.com sets a Valid Pinning Header such as
this:</t>

<figure anchor="subdomain-example-com-header" title="subdomain.example.com
Valid Pinning Header">
<artwork>
Public-Key-Pins: pin-sha1="GHI..."; pin-sha1="JKL..."
</artwork>
</figure>

<t>Assume a UA that has not previously noted any pins for either of these
Hosts. If the UA first contacts subdomain.example.com, it will note the pins
in the Valid Pinning Header, and perform Pin Validation as normal on
subsequent conections. If the UA then contacts example.com, again it will
note the pins and perform Pin Validation on future connections. However, if
the UA happened to first example.com before subdomain.example.com, the UA
would, due to example.com's use of the includeSubDomains directive, attempt
to perform Pin Validation for subdomain.example.com using the SPKI hashes
ABC... and DEF..., which are not valid for the certificate chains
subdomain.example.com (which uses certificates with SPKIs GHI... and
JLK...). Thus, depending on the order in which the UA observes the Valid
Pinning Headers for hosts example.com and subdomain.example.com, Pin
Validation might or might not fail for subdomain.example.com, even if the
certificate chain the UA receives for subdomain.example.com is perfectly
valid.</t>

<t>Thus, Pinned Host operators must use the includeSubDomains directive with
care. For example, they may choose to use overlapping pin sets for hosts under
a parent domain that uses includeSubDomains, or to not use the
includeSubDomains directive in their effective-second-level domains, or to
simply use the same pin set for all hosts under a given parent domain.</t>

</section><!-- using-includeSubDomains -->

<section anchor="backup-pins" title="Backup Pins">

<t>The primary way to cope with the risk of inadvertent Pin Failure is to
keep a Backup Pin. A Backup Pin is a fingerprint for the public key of a
secondary, not-yet-deployed key pair. The operator keeps the backup key pair
offline, and sets a pin for it in the Public-Key-Pins header. Then, in case
the operator loses control of their primary private key, they can deploy the
backup key pair. UAs, who have had the backup key pair pinned (when it was
set in previous Valid Pinning Headers), can connect to the host without
error.</t>

<t>Because having a backup key pair is so important to recovery, UAs MUST
require that hosts set a Backup Pin. (See <xref target="noting-pins"/>.)</t>

</section><!-- backup-pins -->

</section><!-- security-considerations -->

<section anchor="iana-considerations" title="IANA Considerations">

<t>This document has no actions for IANA.</t>

</section><!-- iana-considerations -->

<section anchor="usability" title="Usability Considerations">

<t>When pinning works to detect impostor Pinned Hosts, users will experience
denial of service. UAs MUST explain the reason why, i.e. that it was
impossible to verify the confirmed cryptographic identity of the host.</t>

<t>UAs MUST have a way for users to clear current pins for Pinned Hosts.
UAs SHOULD have a way for users to query the current state of Pinned
Hosts.</t>

</section><!-- usability -->

<section anchor="acknowledgements" title="Acknowledgements">

<t>Thanks to Tobias Gondrom, Jeff Hodges, Ivan Krstic, Adam Langley, Nicolas
Lidzborski, SM, James Manger, Eric Rescorla, Paul Hoffman, and Yoav Nir for
suggestions and edits that clarified the text. Thanks to Trevor Perrin for
suggesting a mechanism to affirmatively break pins (<xref
target="pin-break-codes"/>).</t>

</section><!-- acknowledgements -->

<section anchor="what-changed" title="What's Changed">

<t>Changed non-normative pin generation code from Go to POSIX shell script
using openssl.</t>

<t>Changed max-max-age from SHOULD to MAY, and used the example of 60 days
instead of 30.</t>

<t>Removed the section "Pin Validity Times", which was intended to be in
harmony with <xref target="I-D.perrin-tls-tack"/>. Now using max-age purely as
specified in <xref target="RFC6797"/>.</t>

<t>Added new directives: includeSubDomains, report-uri and strict.</t>

<t>Added a new variant of the PKP Header: Public-Key-Pins-Report-Only.</t>

<t>Removed the section on pin break codes and verifiers, in favor the of
most-recently-received policy (<xref target="noting-pins"/>).</t>

<t>Now using a new header field, Public-Key-Pins, separate from HSTS. This
allows hosts to use pinning separately from Strict Transport Security.</t>

<t>Explicitly requiring that UAs perform Pin Validation before the HTTP
conversation begins.</t>

<t>Backup Pins are now required.</t>

<t>Separated normative from non-normative material. Removed tangential and
out-of-scope non-normative discussion.</t>

</section><!-- what-changed -->

</middle>

<back>

<references title="Normative References">

<?rfc include="reference.RFC.6797.xml"?>
<?rfc include="reference.RFC.2119.xml"?>
<?rfc include="reference.RFC.2616.xml"?>
<?rfc include="reference.RFC.3339.xml"?>
<?rfc include="reference.RFC.3986.xml"?>
<?rfc include="reference.RFC.4648.xml"?>
<?rfc include="reference.RFC.5226.xml"?>
<?rfc include="reference.RFC.5246.xml"?>
<?rfc include="reference.RFC.5280.xml"?>
<?rfc include="reference.I-D.josefsson-pkix-textual.xml"?>
<?rfc include="reference.W3C.REC-html401-19991224.xml"?>

</references>

<references title="Informative References">

<?rfc include="reference.I-D.perrin-tls-tack.xml"?>

<reference anchor="why-pin-key"
target="http://www.imperialviolet.org/2011/05/04/pinning.html">
<front>
<title>Public Key Pinning</title>
<author initials="A." surname="Langley" fullname="Adam Langley" />
<date month="May" year="2011" />
</front>
</reference>

<reference anchor="pin-break-codes" target="http://trevp.net/SAKP/">
<front>
<title>Self-Asserted Key Pinning</title>
<author initials="T." surname="Perrin" fullname="Trevor Perrin" />
<date month="September" year="2011" />
</front>
</reference>

</references>

<section anchor="fingerprint-generation" title="Fingerprint Generation">

<t>This POSIX shell program generates SPKI Fingerprints, suitable for use in
pinning, from PEM-encoded certificates. It is non-normative.</t>

<figure anchor="fingerprint-generation-figure" title="Example SPKI
Fingerprint Generation Code">
<artwork>
openssl x509 -noout -in certificate.pem -pubkey | \
    openssl asn1parse -inform pem -out public.key
openssl dgst -sha1 -binary public.key | base64
</artwork>
</figure>

</section><!-- fingerprint-generation -->

<section anchor="deployment-guidance" title="Deployment Guidance">

<t>This section is non-normative guidance which may smooth the adoption of
public key pinning.</t>

<t><list style="symbols">

<t>Operators SHOULD get the backup public key signed by a different (root
and/or intermediary) CA than their primary certificate, and store the backup
key pair safely offline. The semantics of an SPKI Fingerprint do not require
the issuance of a certificate to construct a valid Pin. However, in many
deployment scenarios, in order to make a Backup Pin operational the server
operator will need to have a certificate to deploy TLS on the host. Failure
to obtain a certificate through prior arrangement will leave clients that
recognize the site as a Known Pinned Host unable to successfully perform Pin
Validation until such a time as the operator can obtain a new certificate
from their desired certificate issuer.</t>

<t>It is most economical to have the backup certificate signed by a
completely different signature chain than the live certificate, to maximize
recoverability in the event of either root or intermediary signer
compromise.</t>

<t>Operators SHOULD periodically exercise their Backup Pin plan â€” an
untested backup is no backup at all.</t>

<t>Operators SHOULD start small. Operators SHOULD first deploy public key
pinning by using the report-only mode together with a report-uri directive
that points to a reliable report collection endpoint. When moving out of
report-only mode, operators should start by setting a max-age of minutes or
a few hours, and gradually increase max-age as they gain confidence in their
operational capability.</t>

</list></t>

</section><!-- deployment-guidance -->

</back>
</rfc>

