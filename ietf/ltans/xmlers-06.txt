





 
 
Long-term Archive And Notary                           A. Jerman Blazic 
Services (LTANS)                                                 SETCCE 
Internet Draft                                                S. Saljic 
Intended status: Standards Track                                 SETCCE 
Expires: November 30, 2010                                   T. Gondrom 
                                                           May 30, 2010 
                                      
             Extensible Markup Language Evidence Record Syntax 
                      draft-ietf-ltans-xmlers-06.txt 


Status of this Memo 

   This Internet-Draft is submitted to IETF in full conformance with the 
   provisions of BCP 78 and BCP 79. This document may contain material 
   from IETF Documents or IETF Contributions published or made publicly 
   available before November 10, 2008. The person(s) controlling the 
   copyright in some of this material may not have granted the IETF 
   Trust the right to allow modifications of such material outside the 
   IETF Standards Process.  Without obtaining an adequate license from 
   the person(s) controlling the copyright in such materials, this 
   document may not be modified outside the IETF Standards Process, and 
   derivative works of it may not be created outside the IETF Standards 
   Process, except to format it for publication as an RFC or to 
   translate it into languages other than English. 

   Internet-Drafts are working documents of the Internet Engineering 
   Task Force (IETF), its areas, and its working groups. Note that other 
   groups may also distribute working documents as Internet-Drafts.  

   Internet-Drafts are draft documents valid for a maximum of six months 
   and may be updated, replaced, or obsoleted by other documents at any 
   time. It is inappropriate to use Internet-Drafts as reference 
   material or to cite them other than as "work in progress." 

   The list of current Internet-Drafts can be accessed at 
   http://www.ietf.org/ietf/1id-abstracts.txt. 
 
 
 
Jerman Blazic, et. al. Expires November 30, 2010                [Page 1] 
 
Internet-Draft                  XMLERS                         May 2010 
    

    

   The list of Internet-Draft Shadow Directories can be accessed at 
   http://www.ietf.org/shadow.html. 

   This Internet-Draft will expire on February 3, 2010. 

Copyright Notice 

   Copyright (c) 2010 IETF Trust and the persons identified as the 
   document authors. All rights reserved. 

    

   This document is subject to BCP 78 and the IETF Trust's Legal 
   Provisions Relating to IETF Documents 
   (http://trustee.ietf.org/license-info) in effect on the date of 
   publication of this document.  Please review these documents 
   carefully, as they describe your rights and restrictions with respect 
   to this document. Code Components extracted from this document must 
   include Simplified BSD License text as described in Section 4.e of 
   the Trust Legal Provisions and are provided without warranty as 
   described in the Simplified BSD License. 

Abstract 

   In many scenarios, users must be able to demonstrate the (time) 
   existence, integrity and validity of data including signed data for 
   long or undetermined period of time. This document specifies XML 
   syntax and processing rules for creating evidence for long-term non-
   repudiation of existence of data. ERS-XML incorporates alternative 
   syntax and processing rules to ASN.1 ERS syntax by using XML 
   language. 



 
 
Jerman Blazic, et. al. Expires November 30 2010                [Page 2] 
    
Internet-Draft                  XMLERS                         May 2010 
    

Conventions used in this document 

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this 
   document are to be interpreted as described in [RFC2119]. 































 
 
Jerman Blazic, et. al. Expires November 30 2010                [Page 3] 
    
Internet-Draft                  XMLERS                         May 2010 
    

Table of Contents 

    
   1. Introduction...................................................6 
      1.1. Motivation................................................6 
      1.2. General Overview and Requirements.........................8 
      1.3. Terminology...............................................9 
      1.4. Conventions Used in This Document........................11 
   2. Evidence Record...............................................11 
      2.1. Structure................................................12 
      2.2. Generation...............................................15 
      2.3. Verification.............................................16 
   3. Archive Time Stamp............................................17 
      3.1. Structure................................................17 
         3.1.1. Hash Tree...........................................18 
         3.1.2. Time-Stamp..........................................19 
         3.1.3. Cryptographic Information List......................20 
      3.2. Generation...............................................20 
         3.2.1. Generation of Hash-Tree.............................21 
         3.2.2. Reduction of Merkle Hash-Tree.......................25 
      3.3. Verification.............................................26 
   4. Archive Time-Stamp Sequence and Archive Time-Stamp Chain......27 
      4.1. Structure................................................28 
         4.1.1. Digest Method.......................................29 
         4.1.2. Canonicalization Method.............................29 
      4.2. Generation...............................................30 
         4.2.1. Time Stamp Renewal..................................31 
         4.2.2. Hash Tree Renewal...................................32 
      4.3. Verification.............................................34 
   5. Encryption....................................................35 
   6. XSD Schema for the Evidence Record............................36 
   7. Security Considerations.......................................42 
   8. IANA Considerations...........................................43 
   9. References....................................................43 
      9.1. Normative References.....................................43 
      9.2. Informative References...................................44 
 
 
Jerman Blazic, et. al. Expires November 30 2010                [Page 4] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   APPENDIX A: Detailed verification process of an Evidence Record..46 
   Author's Addresses...............................................48 
    

































 
 
Jerman Blazic, et. al. Expires November 30 2010                [Page 5] 
    
Internet-Draft                  XMLERS                         May 2010 
    

    

1. Introduction 

   The purpose of the document is to define XML Schema and processing 
   rules for Evidence Record Syntax in XML format. Document is related 
   to initial ASN.1 syntax for Evidence Record Syntax as defined in 
   [RFC4998]. 

1.1. Motivation 

   The evolution of electronic commerce and electronic data exchange in 
   general requires introduction of non-repudiable proof of data 
   existence as well as data integrity and authenticity. Such data and 
   non-repudiable proof of existence must endure for long periods of 
   time, even when information to prove data existence and integrity 
   weakens or ceases to exist. Mechanisms such as digital signatures 
   defined in [RFC5652] for example do not provide absolute reliability 
   on a long term basis. Algorithms and cryptographic material used to 
   create a signature can become weak in course of time and information 
   needed to validate digital signatures may became compromised or 
   simply cease to exist due to for example decomposing certificate 
   service provider. Providing a stable environment for electronic data 
   on a long term basis requires the introduction of additional means to 
   continually provide an appropriate level of trust in evidence on data 
   existence, integrity and authenticity. 

   All integrity and authenticity related techniques used today suffer 
   from the same problem of time related reliability degradation 
   including techniques for time stamping, which are generally 
   recognized as data existence and integrity proofs mechanisms. Over 
   long periods of time cryptographic algorithms used may become weak or 
   encryption keys compromised. Some of the problems might not even be 
   technically related like decomposing time stamping authority. To 
   create a stable environment where proof of existence and integrity 

 
 
Jerman Blazic, et. al. Expires November 30 2010                [Page 6] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   can endure well into the future a new technical approach must be 
   used. 

   Long term non-repudiation of data existence and demonstration of data 
   integrity techniques have been already introduced for example by long 
   term signature syntaxes like [RFC5126]. Long term signature syntaxes 
   and processing rules address mostly the long term endurance of 
   digital signatures, while evidence record syntax broadens this 
   approach for data of any type or format including digital signatures. 

   The XMLERS syntax is based on Evidence Record Syntax as defined in 
   [RFC4998] and is addressing the same problem of long term non-
   repudiable proof of data existence and demonstration of data 
   integrity on a long term basis. XMLERS does not supplement the 
   [RFC4998] specification. Following extensible markup language 
   standards and [RFC3470] guidelines it introduces the same approach 
   but in a different format and with adapted processing rules. 

   The use of eXtensible Markup Language (XML) format is already 
   recognized by a wide range of applications and services and is being 
   selected as the de-facto standard for many applications based on data 
   exchange. The introduction of evidence record syntax in XML format 
   broadens the horizon of XML use and presents a harmonized syntax with 
   a growing community of XML based standards including those related to 
   security services such as [XMLDSig] or [XAdES]. 

   Due to the differences in XML processing rules and other 
   characteristics of XML language, XMLERS does not present a direct 
   transformation of ERS in ASN.1 syntax. The XMLERS syntax is based on 
   different processing rules as defined in [RFC4998] and it does not 
   support for example import of ASN.1 values in XML tags. Creating 
   evidence records in XML syntax must follow the steps as defined in 
   this draft. XMLERS is a standalone draft and is based on [RFC4998] 
   conceptually only. 


 
 
Jerman Blazic, et. al. Expires November 30 2010                [Page 7] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   Evidence Record Syntax in XML format is based on long term archive 
   service requirements as defined in [RFC4810]. XMLERS syntax delivers 
   the same (level of) non-repudiable proof of data existence as ASN.1 
   ERS. The XML syntax supports archive data grouping (and de-grouping) 
   together with simple or complex time-stamp renewal process. Evidence 
   records can be embedded in the data itself or stored separately as a 
   standalone XML file. 

1.2. General Overview and Requirements 

   XMLERS draft specifies XML syntax and processing rules for creating 
   evidence for long-term non-repudiation of existence of data in a unit 
   called "Evidence Record". The XMLERS syntax is defined to meet the 
   requirements for data structures as set out in [RFC4810]. This 
   document also refers to ASN.1 ERS specification as defined in 
   [RFC4998]. 

   An Evidence Record may be generated and maintained for a single data 
   object or a group of data objects that form an archive object. Data 
   object (binary chunk or a file) may represent any kind of document or 
   part of it. Dependencies among data objects, their validation or any 
   other relationship than "a data object is a part of particular 
   archived object" are out of the scope of this draft. 

   Evidence Record maintains a close relationship to time stamping 
   techniques. However, time-stamps as defined in [RFC3161], can cover 
   only a single unit of data and do not provide processing rules for 
   maintaining a long term stability of time-stamps applied over a data 
   object. Evidence for an archive object is created by acquiring a 
   time-stamp from a trustworthy authority for a specific value that is 
   unambiguously related to a single or more data objects. The Evidence 
   Record syntax enables processing of several archive objects within a 
   single processing pass using a hash-treeing technique and acquiring 
   only one time-stamp to protect all archive objects. 


 
 
Jerman Blazic, et. al. Expires November 30 2010                [Page 8] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   Besides a time-stamp other artifacts are also preserved in Evidence 
   Record: data necessary to verify the relationship between a time-
   stamped value and a specific data object, packed into a structure 
   called a "hash-tree"; and long term proofs for the formal 
   verification of included time-stamp(s). 

   Due to the fact that digest algorithms or cryptographic methods used 
   may become weak or that certificates used within a time-stamp (and 
   signed data) may be revoked or expired, the collected evidence data 
   must be monitored and renewed before such events occur. This document 
   introduces XML based syntax and processing rules for the creation and 
   continuous renewal of evidence data. 

1.3. Terminology 

   Archive data object: Data unit that is archived and has to be 
   preserved for a long time by the Long-term Archive Service. 

   Archive data object group: A multitude of (archive) data objects, 
   which for some reason (logically) belong together, e.g. a group of 
   document files or a document file and a signature file could 
   represent an archive data object group. 

   Archive object: an archive data object or an archive data object 
   group. 

   Archive Time-Stamp (ATS): An Archive Time-Stamp contains a time-stamp 
   token, useful data for validation and optionally a set of ordered 
   lists of hash values (a hash tree). An Archive Time-Stamp relates to 
   a data object, if the hash value of this data object is part of the 
   first hash value list of the Archive Time-Stamp or its hash value 
   matches the time-stamped value. An Archive Time-Stamp relates to a 
   data object group, if it relates to every data object of the group 
   and no other data object. 


 
 
Jerman Blazic, et. al. Expires November 30 2010                [Page 9] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   Archive Time-Stamp Chain (ATSC): holds a sequence of Archive Time-
   Stamps generated during the preservation period. 

   Archive Time-Stamp Sequence (ATSSeq): is a sequence of Archive Time-
   Stamp Chains. 

   Canonicalization: Processing rules for transforming an XML document 
   into its canonical form. Two XML documents may have different 
   physical representations, but they may have the same canonical form. 
   For example a sort order of attributes does not change the meaning of 
   the document as defined in [XMLC14N]. 

   Cryptographic Information: Data or part of data related to the 
   validation process of signed data, e.g. digital certificates, digital 
   certificate chains, certificate revocation lists, etc. 

   Digest Method: Digest method is an identifier for a digest algorithm, 
   which is a strong one-way function, for which it is computationally 
   infeasible to find an input that corresponds to a given output or to 
   find two different input values that correspond to the same output. 
   Digest algorithm transforms input data into a short value of fixed 
   length. The output is called digest value, hash value or data 
   fingerprint. 

   Evidence: Information that may be used to resolve a dispute about 
   various aspects of authenticity, validity and existence of archived 
   data objects. 

   Evidence record: Collection of evidence compiled for one or more 
   given archived data objects over time. An evidence record includes 
   ordered collection of ATSs, which are grouped into ATSCs and ATSSeqs.  

   Long-term Archive Service (LTA): A service responsible for 
   generation, collection and maintenance (renewal) of evidence data. A 
   LTA service may also preserve data for long periods of time, e.g. 
   storage of archive data and associated evidences. 
 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 10] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   Hash Tree: Collection of significant values of protected objects 
   (input objects and generated evidence within archival period) that 
   are unambiguously related to the time-stamped value within an archive 
   time-stamp.  

   Time-Stamp (TS): A cryptographically secure confirmation generated by 
   a Time Stamping Authority (TSA) e.g. [RFC3161] which specifies a 
   structure for time-stamps and a protocol for communicating with a 
   Time-Stamp Authority. Besides this, other data structures and 
   protocols may also be appropriate, such as defined in [ISO-18014-
   1.2002], [ISO-18014-2.2002], [ISO-18014-3.2004], and [ANSI.X9-
   95.2005]. 

1.4. Conventions Used in This Document 

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this 
   document are to be interpreted as described in [RFC2119]. 

2. Evidence Record 

   An Evidence Record is a unit of data, which is to be used to prove 
   the existence of an archive object (a single archive data object or a 
   group of archive data object) at a certain time. Through the lifetime 
   of an archive object, an Evidence Record also demonstrates data 
   objects integrity and non-repudiability. It is possible to store 
   Evidence Record separately from the archive object or to integrate it 
   into the data itself. To achieve this, cryptographic means are used, 
   i.e. time-stamp tokens obtained from the Time-Stamping Authority 
   (TSA). 

   As cryptographic means are used to support evidence records, such 
   records may lose their value through time. Time-stamps obtained from 
   Time-Stamping Authorities may become invalid for a number of reasons, 
   usually due to time constrains of time-stamp validity. Before time-
   stamp tokens used become unstable, evidence record has to be renewed. 
 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 11] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   This may result in a series of time-stamp tokens, which are linked 
   between themselves according to the cryptographic methods and 
   algorithms used. 

   Evidence record can be supported with additional information, which 
   can be used to ease the processes of evidence record validation and 
   renewal. Information such as digital certificates and certificate 
   revocation lists as defined in [RFC5280] or other cryptographic 
   material can be collected, enclosed and processed together with 
   archive object data (i.e. time stamped). 

2.1. Structure 

   The Evidence Record contains one or several Archive Time-Stamps 
   (ATS). An ATS contains a time stamp token and optionally other useful 
   data for time stamp validation, e.g. certificates, CRLs or OCSP 
   responses and also specific attributes such as service policies. 
   Initially, an ATS is acquired and later, before it expires or becomes 
   invalid a new ATS is acquired, which prolongs the validity of the 
   archived object (its data objects together with all previously 
   generated archive time stamps). This process must continue during the 
   desired archiving period of archive data object. A series of 
   successive Archive Time-Stamps is collected in Archive Time-Stamp 
   Chains and a series of chains in Archive Time-Stamp Sequence. 

   In XML syntax the Evidence Record is represented by the 
   <EvidenceRecord> root element, which has the following structure 
   (where "?" denotes zero or one occurrences, "+" denotes one or more 
   occurrences and "*" denotes zero or more occurrences): 

   <EvidenceRecord Version> 
       
      <EncryptionInformation> 
         <EncryptionInformationType> 
         <EncryptionInformationValue> 
      </EncryptionInformation> ? 
 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 12] 
    
Internet-Draft                  XMLERS                         May 2010 
    

      <ArchiveTimeStampSequence> 
         <ArchiveTimeStampChain Order> 
            <DigestMethod Algorithm />  
            <CanonicalizationMethod Algorithm />  
            <ArchiveTimeStamp Order> 
               <HashTree /> ? 
               <TimeStamp Type />  
               <CryptographicInformationList> 
                     <CryptographicInformation Order Type /> + 
               </CryptographicInformationList> ? 
               <Attributes> 
                     <Attribute Order Type /> +           
               </Attributes> ? 
            </ArchiveTimeStamp> + 
         </ArchiveTimeStampChain> + 
      </ArchiveTimeStampSequence>  
   </EvidenceRecord> 

   The XML tags have the following meanings: 

     Version attribute indicates the syntax version, for compatibility 
     with future revisions of this specification and to distinguish it 
     from earlier non-conformant or proprietary versions of the XMLERS. 
     Current version of the XMLERS syntax is 05. 

     <EncryptionInformation> tag is optional and holds information on 
     cryptographic algorithms and cryptographic material used to encrypt 
     archive data (in case archive data is encrypted e.g. for privacy 
     purposes). This optional information is needed to unambiguously re-
     encrypt data objects when processing evidence records. When 
     omitted, data objects are not encrypted or non-repudiation proof is 
     not needed for the unencrypted data. Details on how to process 
     encrypted archive data and generate evidence record(s) are 
     described in Section 5. 


 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 13] 
    
Internet-Draft                  XMLERS                         May 2010 
    

     <ArchiveTimeStampSequence> is a sequence of 
     <ArchiveTimeStampChain>. 

     <ArchiveTimeStampChain> holds a sequence of Archive Time-Stamps 
     generated during the preservation period. Details on Archive Time-
     Stamp Chains and Archive Time-Stamp Sequences are described in 
     section 4. The sequences of Archive Time-Stamp Chains and Archive 
     Time-Stamps are ordered and the order must be indicated with 
     "Order" attribute of the <ArchiveTimeStampChain> and 
     <ArchiveTimeStamp> element. 

     <DigestMethod> is a required element and identifies the digest 
     algorithm used within one archive time-stamp chain to calculate 
     digest values from: archive data object(s), previous archive time-
     stamp sequence, archive time-stamps and within a time-stamp token. 

     <CanonicalizationMethod> is a required element that specifies the 
     canonicalization algorithm applied to the archive data in case of 
     XML data objects, <ArchiveTimeStampSequence> or <ArchiveTimeStamp> 
     element prior to performing digest value calculations. 

     <HashTree> tag holds a value or a structure of a reduced hash 
     tree(s) described in section 3.1.1.  

     <TimeStamp> tag holds a time-stamp token provided by the Time-
     Stamping Authority. 

     <CryptographicInformationList> tag allows the storage of data 
     needed in the process of archive time-stamp token validation in 
     case when such data is not provided by the time-stamp token itself. 
     This could include possible trust anchors, certificates, revocation 
     information or the current definition of the suitability of 
     cryptographic algorithms, past and present. Each data object is put 
     into separate child element <CryptographicInformation>, having 
     mandatory Order attribute to indicate the order within parent 
     element. These items may be added based on the policy used. This 
 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 14] 
    
Internet-Draft                  XMLERS                         May 2010 
    

     data is protected by successive time-stamps in the sequence of the 
     time-stamps. 

     <Attributes> tag contains additional information that may be 
     provided by an LTA used for the renewal process. An example of 
     additional information may be processing (renewal) policies, which 
     are relevant for data object(s) preservation and evidence 
     validation at a later stage. Each data object is put into separate 
     child element <Attribute>, having mandatory Order attribute to 
     indicate the order within parent element and optional Type 
     attribute to indicate processing directions. 

     Order attribute is mandatory in all cases when one or more XML 
     elements with the same name occur on the same level in the XMLERS 
     structure. Although most of the XML parsers will preserve order of 
     the sibling elements having the same name, within XML structure 
     there is no definition how to unambiguously define such order. 
     Preserving correct order in such cases is of significant importance 
     for digest value calculations over XML structures.  

2.2. Generation 

   The generation of an <EvidenceRecord> element can be described as 
   follows: 

   1. Select an archive object (a data object or a data object group) to 
      archive. 

   2. Create the initial <ArchiveTimeStamp>. This is the first ATS 
      within the initial <ArchiveTimeStampChain> element of the 
      <ArchiveTimeStampSequence> element. 

   3. Refresh the <ArchiveTimeStamp> when necessary by Time-Stamp 
      Renewal or Hash-Tree Renewal (see section 4.). 


 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 15] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   The time-stamping service may be, for a large number of archived 
   objects, expensive and time-demanding, so the LTA may profit from 
   acquiring one time-stamp token for many archived objects, which are 
   not otherwise related to each other. It is possible to collect many 
   archive objects, build a Merkle Hash Tree [MER1980] to generate a 
   single value to be time-stamped, and respectively reduce that Merkle 
   tree to small subsets that for each archive object provide necessary 
   binding with the time-stamped (hash) value.  

   For performance reasons or in case of local time-stamp generation, 
   hash-treeing (<HashTree> element) can be omitted. In this case ATS 
   element covers a single data object. It is also possible to convert 
   existing time-stamps into ATS for renewal. 

   In the case that only essential parts of documents or objects shall 
   be protected, the application not defined in this draft must ensure 
   that the correct extraction of binary data is made for generation of 
   evidence record. 

   Example: an application may provide also evidence such as 
   certificates, revocation lists etc., needed to verify and validate 
   signed data objects or data object group. This evidence may be added 
   to the archived object data group and will be protected within 
   initial (and successive) time-stamp(s). 

   Note that <CryptographicInformationList> element of Evidence Record 
   is not to be used to store and protect cryptographic material related 
   to signed archive data. The use of this element is limited to 
   cryptographic material related to ATS(s). 

2.3. Verification 

   The overall Verification of an Evidence Record can be described as 
   follows: 

   1. Select an archive object (a data object or a data object group) 
 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 16] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   2. Re-encrypt data object or data object group, if encryption field 
      is used (for details, see Section 5.). 

   3. Verify Archive Timestamp Sequence (details in Section 3.3. and 
      Section 4.3.). 

3. Archive Time Stamp 

   An Archive time-stamp is a timestamp with additional artifacts that 
   allow verification of the existence of several data objects at a 
   certain time.   

   The process of construction of an ATS must support evidence on a long 
   term basis and prove that the archive object existed and was 
   identical, at the time of the time-stamp, to the currently present 
   archive object (at the time of verification). To achieve this, ATS 
   must be renewed before it becomes invalid (which may happen for 
   several reasons such as invalid digital certificate or decomposing 
   TSA). 

3.1. Structure 

   An Archive Time-Stamp contains a time-stamp token, useful data for 
   its validation (cryptographic information), such as certificate chain 
   or certificate revocation list, an optional ordered set of ordered 
   lists of hash values (a hash tree) that were protected with the time-
   stamp token and optional information describing renewal steps 
   (<Attributes> element).  A hash tree may be used to store data needed 
   to bind time-stamped value with protected objects by the archive 
   time-stamp. If a hash tree is not present, ATS simply refers to a 
   single object; either input data object or a previous ATS. 

    



 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 17] 
    
Internet-Draft                  XMLERS                         May 2010 
    

3.1.1. Hash Tree 

   Hash tree structure is an optional container for significant values, 
   needed to unambiguously relate a time-stamped value to protected data 
   objects, and is represented by the <HashTree> element. The root hash 
   value that is generated from the values of the hash tree MUST be the 
   same as the time-stamped value. 

   The algorithm by which a root hash value is generated from the hash 
   tree is as follows: hashes of the first list are ordered in binary 
   ascending order, concatenated and a new hash value is generated from 
   that string (there is exception when the first list is having one 
   hash value, then this value is added to the next list). This hash 
   value is added to the next list of hashes and the previous step is 
   repeated. When there are no hash lists left, the last generated hash 
   value is the root hash value. When an archive object is composed of 
   more than one data object, the first hash list MUST contain hash 
   values of all its data objects. When a single time-stamp is obtained 
   for a group of archive objects, a Merkle Hash Tree [MER1980] may be 
   constructed to generate a single hash value to bind all archive 
   objects from that group and then a reduced hash tree may be extracted 
   from a Merkle hash tree for each archive object respectively. 

   <HashTree> 
      <Sequence Order> 
         <DigestValue></DigestValue> + 
      </Sequence> + 
   </HashTree> 
   For example: A SHA-1 digest value is a 160-bit string. The content of 
   the DigestValue element shall be the base64 encoding of this bit 
   string viewed as a 20-octet octet stream. For example, the 
   <DigestValue> element for the message digest A9993E36 4706816A 
   BA3E2571 7850C26C 9CD0D89D would be: 

   <DigestValue>qZk+NkcGgWq6PiVxeFDCbJzQ2J0=</DigestValue> 

 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 18] 
    
Internet-Draft                  XMLERS                         May 2010 
    

3.1.2. Time-Stamp 

   Time-Stamp Token is an attestation generated by a TSA that a data 
   item existed at a certain time. The time-stamp Token is a signed data 
   object that contains the hash value, the identity of the TSA, and the 
   exact time (obtained from trusted time source) of time-stamping. This 
   proves that the given data existed before the time of time-stamping. 
   For example, [RFC3161] specifies a structure for signed time-stamp 
   tokens in ASN.1 format. Since at the time being there is no standard 
   for an XML time-stamp, the following structure example is provided 
   (referring to the Entrust XML Schema for time-stamp 
   http://www.entrust.com/schemas/timestamp19protocol-20020207), which 
   is a digital signature compliant to [XMLDSig] specification 
   containing time-stamp specific data, such as time-stamped value and 
   time within <Object> element of a signature. 

   <element name="TimeStampInfo"> 
      <complexType> 
         <sequence> 
            <element ref="ts:Policy" />  
            <element ref="ts:Digest" />  
            <element ref="ts:SerialNumber" minOccurs="0" />  
            <element ref="ts:CreationTime" />  
            <element ref="ts:Accuracy" minOccurs="0" />  
            <element ref="ts:Ordering" minOccurs="0" />  
            <element ref="ts:Nonce" minOccurs="0" />  
            <element ref="ts:Extensions" minOccurs="0" />  
         </sequence> 
      </complexType> 
   </element> 

   A <TimeStamp> element of ATS holds a complete structure of time-stamp 
   token as provided by a TSA. Time-stamp token may come in XML or ASN.1 
   format. Attribute Type must be used to indicate format for processing 
   purposes, with values XMLEnTrust and RFC3161 respectively For RFC3161 

 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 19] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   type of a time-stamp token, <TimeStamp> element must contain base64 
   encoding of a DER-encoded ASN1 data. For example: 

   <TimeStamp Type="RFC3161"> MIAGCSqGSIb3DQEH...</TimeStamp> 

   or 

   <TimeStamp Type="XMLEnTrust"><dsig:Signature>...</dsig:Signature> 
   </TimeStamp>. 

3.1.3. Cryptographic Information List 

   Digital certificates, CRLs or OCSP-Responses needed to verify the 
   time-stamp token should be stored in the time-stamp token itself. 
   When this is not possible, such data may be stored in 
   <CryptographicInformationList> element, each data object into a 
   separate <CryptographicInformation> element, using a mandatory Order 
   attribute. 

   The attribute Type is mandatory and is used to store processing 
   information about type of stored cryptographic information. Following 
   values MUST be used as identifiers for the Type attribute: CRL, OCSP 
   or CERT, and for each type the content must be encoded respectively: 

   o  for type CRL, a base64 encoding of a DER-encoded X.509 CRL; 

   o  for type OCSP, a base64 encoding of a DER-encoded OCSPResponse;  

   o  for type CERT, a base64 encoding of a DER-encoded X.509 
      certificate. 

3.2. Generation 

   Initial ATS relates to a data object or a data object group that 
   represents an archive object. The generation of the initial ATS 

 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 20] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   element can be done in a single process pass for one or for many 
   archived objects, described as follows: 

   1. Collect one or more archive objects to be time-stamped and 
      optionally include their references in the <Reference> element. 

   2. Select canonicalization method C to be used for obtaining binary 
      representation of archive data and for Archive Time-Stamp at a 
      later stage in renewing process (see section 4). Note that 
      canonicalization method is to be used for archive data only when 
      data is represented in XML format. 

   3. Select a valid digest algorithm H. Selected secure hash algorithm 
      MUST be the same as hash algorithm used in the time-stamp token 
      and for the hash tree computations. 

   4. Generate a hash tree for selected archive object (see 3.2.1).  

      Hash tree may be omitted in the initial ATS, when an archive 
      object has a single data object; then the time-stamped value must 
      match the digest value of that single data object. 

   5. Acquire time-stamp from TSA for root hash value of a hash tree 
      (see 3.1.1). If the time-stamp is valid, the initial archive time-
      stamp may be generated. 

3.2.1. Generation of Hash-Tree 

   The <DigestValue> elements within the <Sequence> element MUST be 
   ordered in binary ascending order to ensure correct calculation of 
   digest values at time of renewal and later for verification purposes.  

   Hash tree MUST be generated when the time-stamped value is not equal 
   to the hash value of the input data object. This is the case: 


 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 21] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   1. When an archive object is having more than one data object, its 
     digest value is the digest value of binary ascending ordered and 
     concatenated digest values of all its containing data objects. 
     Note that in this case the first list of the hash tree MUST 
     contain hash values of all data objects and only those values.  

   2. When for more than one archive object a single time-stamp token is 
     generated and a Merkle Hash-Tree is used. Then the hash-tree is a 
     reduced hash tree (see 3.2.2) for that archive object (extracted 
     from Merkle Hash-Tree). 

   The Merkle Hash-Tree for a group of archive objects is built from 
   bottom to the root. First are collected the leaves of the tree. The 
   leaves represent digest values of archive objects: 

   1. Collect archive objects and for each archive object its 
      corresponding data objects. 

   2. Chose a secure hash algorithm H and calculate digest values for 
      the data objects and put them into the input list for the Merkle 
      Hash-Tree as follows: a digest value of an archive object is the 
      digest value of its data object, if there is only one data object; 
      for more than one data object a digest value is the digest value 
      of binary sorted, concatenated digest values of all its containing 
      data objects.  

      Note that for some hash values on that input list (archive objects 
      having more than one data object), also lists of their sub-digest 
      values are stored. 

   3. Group together items in the input list by N (e.g. to make binary 
      tree group in pairs) and for each group: binary ascending sort, 
      concatenate and calculate hash values. The result is a new input 
      list. 


 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 22] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   4. Repeat step 3, until only one digest value is left; this is the 
      root value of the Merkle Hash-Tree, which is time-stamped. 

   Note that selected secure hash algorithm MUST be the same as the one 
   defined in the <DigestMethod> element of the ATS. 

   Example: An input list with 18 hash values, where the h'1 is 
   generated for a group of data objects (d4, d5, d6 and d7) and has 
   been grouped by 3. The group could be of any size (2, 3...). It is 
   also possible to extend the tree with "dummy" values; to make every 
   node have the same number of children. 

























 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 23] 
    
Internet-Draft                  XMLERS                         May 2010 
    

                    ---------- 
                    d1  -> h1 \ 
                               \ 
       G1           d2  -> h2  |-> h''1 
   +--------+                  /       \ 
   |d4 -> h4|\      d3  -> h3 /         \ 
   |d5 -> h5| \     ----------          | 
   |        | |  -> h'1       \         | 
   |d6 -> h6| /                \        | 
   |d7 -> h7|/      d8  -> h8  |-> h''2 |->  h'''1 
   +--------+                  /        |         \ 
                    d9  -> h9 /         |          \ 
                    ----------          |          | 
                    d10 -> h10\         /          | 
                               \       /           | 
                    d11 -> h11 |-> h''3            | 
                               /                   | 
                    d12 -> h12/                    |-> root hash value 
                    ----------                     | 
                    d13 -> h13\                    | 
                               \                   | 
                    d14 -> h14 |-> h''4            | 
                               /       \           / 
                    d15 -> h15/         \         / 
                    ----------          |->  h'''2 
                    d16 -> h16\         / 
                               \       / 
                    d17 -> h17 |-> h''5 
                               / 
                    d18 -> h18/ 
                    ---------- 
    
               Figure 1 Generation of the Merkle Hash-Tree. 



 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 24] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   Note that there are no restrictions on the quantity of hash value 
   lists and of their length. Also note that it is profitable but not 
   required to build Merkle Hash-tree and reduce hash-trees. An Archive 
   Time-Stamp may consist only of one list of hash values and a time-
   stamp or in the extreme case, only a time-stamp with no hash value 
   lists. 

3.2.2. Reduction of Merkle Hash-Tree 

   The generated Merkle Hash-Tree can be reduced to lists of hash 
   values, necessary as a proof of existence for a single archive object 
   as follows: 

   1. For a selected archive object (AO) select its hash value h within 
      the leaves of the Merkle Hash-Tree. 

   2. Select all hash values, which have the same father node as hash 
      value h. Place these hash values as a list of hashes within 
      separate <Sequence> element with Order attribute 1. Generate the 
      first list of hash values by arranging these hashes in binary 
      ascending order. 

      Note: if that archive object is having more than one data object, 
      this will be the second list in the hash-tree with Order attribute 
      2. The first list is containing the hash values of AO's data 
      objects. 

   3. Repeat step 2 for the parent node of all hashes until the root 
      hash value is reached. Place lists of hashes that belong to the 
      same node within separate <Sequence> element with Order attribute 
      increased by one. Note that node values and hash value h are not 
      saved in the list as they are computable and that the order of 
      hash values within sequences MUST be binary ascending. 

   Reduced Hash tree for data object d4 (from the previous example, 
   presented in Figure 1): 
 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 25] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   <HashTree> 
   <Sequence Order=1> 
      <DigestValue>h4</DigestValue> 
      <DigestValue>h5</DigestValue> 
      <DigestValue>h6</DigestValue> 
      <DigestValue>h7</DigestValue> 
   </Sequence> 
   <Sequence Order=2> 
      <DigestValue>h8</DigestValue> 
      <DigestValue>h9</DigestValue> 
   </Sequence> 
   <Sequence Order=3> 
      <DigestValue>h''1</DigestValue> 
      <DigestValue>h''3</DigestValue> 
   </Sequence> 
   <Sequence Order=4> 
      <DigestValue>h'''2</DigestValue> 
   </Sequence></HashTree> 

    

3.3. Verification 

   An Archive Timestamp shall prove that an archive object existed at a 
   certain time, indicated by its time-stamp. Verification procedure is 
   as follows: 

   1. Identify hash algorithm H (from <DigestMethod> element) and 
     calculate hash value for each data object of the archive object. 

   2. If the hash-tree is present, search for hash values in the first 
     <Sequence> element. If not present, terminate verification process 
     with negative result. If an additional proof is necessary that the 
     Archive Time-Stamp relates to a data object group (e.g. a document 
     and all its digital signatures), it can also be verified that only 

 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 26] 
    
Internet-Draft                  XMLERS                         May 2010 
    

     the hash values of the given data objects are in the first hash-
     value list. 

   3. If the hash-tree is present, calculate its root hash value. 
     Compare the root hash value with the time-stamped value. If not 
     equal, terminate verification process with negative result. 

   4. If the hash-tree is omitted, compare the hash value of the single 
     data object with the time-stamped value. If not equal, terminate 
     verification process with negative result. If an archive object is 
     having more data objects and the hash tree is omitted, also exit 
     with result. 

   5. Check the validity of the time stamp. If the needed information to 
     verify formal validity of the time stamp is not found within the 
     timestamp element or within its <CryptographicInformationList> 
     element, exit with a negative result. 

4. Archive Time-Stamp Sequence and Archive Time-Stamp Chain 

   An Archive Time-Stamp proves the existence of single data objects or 
   data object group at a certain time. However, the initial evidence 
   record created can become invalid due to decomposing validity of 
   time-stamp token for a number of reasons: hash algorithms or public 
   key algorithms used in its hash tree or the time-stamp may become 
   weak or the validity period of the timestamp authority certificate 
   expires or is revoked. 

   To preserve the validity of evidence record before such events occur, 
   evidence record has to be renewed. This can be done by creating a new 
   ATS. Depending on the reason for renewing evidence record (the time-
   stamp becomes invalid or the hash algorithm of the hash tree becomes 
   weak) two types of renewal processes are possible: 



 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 27] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   o  Time-stamp renewal: For this process a new Archive Time-Stamp is 
      generated, which is applied over last time-stamp created. The 
      process results in a series of Archive Time-Stamps which are 
      contained within a single Archive Time-Stamp Chain (ATSC). 

   o  Hash-tree renewal: For this process a new Archive Time-Stamp is 
      generated, which is applied over all existing time-stamps and data 
      objects. Newly generated Archive Time-Stamp is placed in a new 
      Archive Time-Stamp Chain. The process results in a series of 
      Archive Time-Stamps Chains which are contained within a single 
      Archive Time-Stamp Sequence (ATSS). 

   After renewal process, only the most recent (i.e. the last generated) 
   Archive Time-Stamp has to be monitored for expiration or decomposing 
   validity. 

4.1. Structure 

   Archive Time-Stamp Chain and Archive Time-Stamp Sequence are 
   containers for sequences of archive time-stamp(s) which are generated 
   through renewal processes. Renewal process results in a series of 
   evidence record elements: <ArchiveTimeStampSequence> element contains 
   an ordered sequence of <ArchiveTimeStampChain> elements and 
   <ArchiveTimeStampChain> element contains an ordered sequence of 
   <ArchiveTimeStamp> elements. Both elements MUST be sorted by time of 
   the time-stamp in ascending order. Order is indicated by the Order 
   attribute. 

   When Archive Time-Stamp must be renewed, a new <ArchiveTimeStamp> 
   element is generated and depending on the generation process, it is 
   either placed: 

   o  as the last <ArchiveTimeStamp> child element in a sequence of the 
      last <ArchiveTimeStampChain> element in case of time-stamp renewal 
      or 

 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 28] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   o  as the first <ArchiveTimeStamp> child element in a sequence of the 
      newly created <ArchiveTimeStampChain> element in case of hash-tree 
      renewal. 

   The ATS with the largest Order attribute value within the ATSC with 
   the largest Order attribute value is the latest ATS and must be valid 
   at the present time. 

4.1.1. Digest Method 

   Digest method is a required element that identifies the digest 
   algorithm used to calculate hash values of archive data (and node 
   values of hash tree). Digest method is specified in the 
   <ArchiveTimeStampChain> element by required <DigestMethod> element 
   and indicates the digest algorithm that MUST be used for all hash 
   value calculations related to the archive time-stamps within archive 
   time-stamp chain. 

   The Algorithm attribute contains URIs for identifiers and those must 
   be used as defined in [RFC3275] and [RFC4051]. For example when SHA-1 
   algorithm is used, algorithm identifier is: 

   <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/> 

   Digest algorithms used for evidence record must be equal to the 
   algorithms used for time stamp token(s) within a single ATSC. When 
   algorithms used by TSA are changed (e.g. upgraded) a new ATSC must be 
   started using equal or stronger digest algorithm. 

4.1.2. Canonicalization Method 

   Prior to hash value calculations of an XML element, a proper binary 
   representation must be extracted from its (abstract) XML data 
   presentation. The binary representation is determined by UTF-8 
   encoding and canonicalization of the XML element. The XML element 
   includes the entire text of the start and end tags as well as all 
 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 29] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   descendant markup and character data (i.e., the text and sub-
   elements) between those tags. 

   <CanonicalizationMethod> is a required element that identifies the 
   canonicalization algorithm used to obtain binary representation of an 
   XML element(s). Algorithm identifiers (URIs) must be used as defined 
   in [RFC3275] and [RFC4051]. For example when Canonical XML 1.0 (omits 
   comments) is used, algorithm identifier is 

   <CanonicalizationMethod Algorithm=" http://www.w3.org/TR/2001/REC-
   xml-c14n-20010315"/>. 

   Canonicalization MUST be applied over XML structured archive data and 
   MUST be applied over elements of evidence record (namely ATS and ATSC 
   in the renewing process).  

   Canonicalization method is specified in the <Algorithm> attribute of 
   the <CanonicalizationMethod> element within <ArchiveTimeStampChain> 
   element and indicates the canonicalization method that MUST be used 
   for all binary representations of the archive time-stamps within that 
   archive time-stamp chain. In case of succeeding ATSC the 
   canonicalization method indicated within the ATSC must also be used 
   for calculation of digest value of preceding ATSC. Note that 
   canonicalization method is unlikely to change over time as it does 
   not impose the same constrains as digest method. In theory, the same 
   canonicalization method can be used for a single Archive Time-Stamp 
   Sequence. 

4.2. Generation 

   Before the cryptographic algorithms used within the most recent 
   Archive Time-Stamp become weak or the time-stamp certificates are 
   invalidated, Archive Time-Stamps have to be renewed by generating a 
   new Archive Time-Stamp. 


 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 30] 
    
Internet-Draft                  XMLERS                         May 2010 
    

4.2.1. Time Stamp Renewal 

   In case of time-stamp renewal, i.e. if the digest algorithm (H) to be 
   used in the renewal process is the same as digest algorithm (H') used 
   in the last Archive Time-Stamp, the complete content of the last ATS 
   MUST be time-stamped and new <ArchiveTimeStamp> element created as 
   follows: 

   1. If the current <ArchiveTimeStamp> element does not contain needed 
      proof for long-term formal validation of its time-stamp token 
      within the time-stamp token, collect needed data such as root 
      certificates, certificate revocation lists, etc., and include them 
      in <CryptographicInformationList> element of the last Archive 
      Time-Stamp (each data object into a separate 
      <CryptographicInformation> element). 

   2. Select canonicalization method from <CanonicalizationMethod> 
      element and select digest algorithm from <DigestMethod> element. 
      Calculate hash value from binary representation of the last 
      <ArchiveTimeStamp> element including added cryptographic 
      information. Acquire the time-stamp for the calculated hash value. 
      If the time-stamp is valid, the new Archive Time-Stamp may be 
      generated. 

   3. Increase the value order of the new ATS by one and place the new 
      ATS into the last <ArchiveTimeStampChain> element. 

   The new ATS and its hash tree MUST use the same digest algorithm as 
   the preceding one, which is specified in the <DigestMethod> element 
   within <ArchiveTimeStampChain> element. Note that Time Stamp Renewal 
   process may be optimized to acquire one time-stamp for many archive 
   time-stamps using the Merkle Hash Tree. In such case a hash tree MUST 
   be generated, having the previous ATS's hash value as the first hash 
   list, which is also the input hash value for the Merkle hash-tree. 
   See 3.2.1. 

 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 31] 
    
Internet-Draft                  XMLERS                         May 2010 
    

4.2.2. Hash Tree Renewal 

   The process of hash tree renewal occurs when the new digest algorithm 
   is different to the one used in the last Archive Time-Stamp (H <> 
   H'). In this case the complete Archive Time-Stamp Sequence and the 
   archive data objects covered by existing Archive Time-stamp must be 
   time-stamped as follows: 

   1. Select one or more archive objects to be renewed and theirs 
      current <ArchiveTimeStamp> elements. 

   2. For each archive object check the current <ArchiveTimeStamp> 
      element. If it does not contain needed proof for long-term formal 
      validation of its time-stamp token within the time-stamp token, 
      collect needed data such as root certificates, certificate 
      revocation lists, etc., and include them in 
      <CryptographicInformationList> element of the last Archive Time-
      Stamp (each data object into a separate <CryptographicInformation> 
      element). 

   3. Select canonicalization method C and select a new secure hash 
      algorithm H. 

   4. For each archive object select its data objects d(i). Generate 
      hash values h(i) = H(d(i)), for example: h(1), h(2).., h(n). 

   5. For each archive object calculate a hash hseq=H(ATSSeq) from 
      binary representation of the <ArchiveTimeStampSequence> element, 
      corresponding to that archive object. Note that Archive Time-Stamp 
      Chains and Archive Time-Stamps MUST be chronologically ordered, 
      each respectively to its Order attribute, and that the 
      canonicalization method C MUST be applied. 

   6. For each archive object sort in binary ascending order and 
      concatenate all h(i) and the hseq. Generate a new digest value 
      h(j)=H(h(1)..h(n),hseq). 
 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 32] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   7. Build a new Archive Time-Stamp for each h(j) (hash tree generation 
      and reduction is defined in sections 3.2.1. and 3.2.2.). Note that 
      each h(j) is treated as the document hash in section 3.2.2. The 
      first hash value list in the reduced hash tree should only contain 
      h(i) and hseq.  

   8. Create new <ArchiveTimeStampChain> containing the new 
      <ArchiveTimeStamp> element (with order number 1), and place it 
      into the existing <ArchiveTimeStampSequence> as a last child with 
      the order number increased by one. 

    

   Example for an archive object with 3 data objects: Select a new hash 
   algorithm and canonicalization method. Collect all 3 data objects and 
   currently generated archive time-stamp sequence. 

               AO     

            /  |   \ 

         d1    d2    d3  

   ATSSeq 

         ATSChain1: ATS0, ATS1 

         ATSChain2: ATS0, ATS1, ATS2 

    

   The hash values MUST be calculated with the new hash algorithm H for 
   all data objects and for the whole ATSSeq. Note, that ATSSeq MUST be 
   chronologically ordered and canonicalized before retrieving its 
   binary representation.  

 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 33] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   When generating the hash tree for the new ATS, the first sequence 
   become values: H(d1), H(d2),..., H(dn), H(ATSSeq). Note: hash values 
   MUST be sorted in binary ascending order.  

   <HashTree> 
      <Sequence Order=1> 
            <DigestValue>H(d1)</DigestValue> 
            <DigestValue>H(d2)</DigestValue> 
            <DigestValue>H(d3)</DigestValue> 
            <DigestValue>H(ATSSeq)</DigestValue> 
      </Sequence> 
   </HashTree> 

   Note that if the group processing is being performed, the hash value 
   of the concatenation of the first sequence is an input hash value 
   into the Merkle Hash Tree. 

4.3. Verification 

   An Evidence Record shall prove that an archive object existed and has 
   not been changed from the time of the initial time-stamp token within 
   the first ATS. In order to complete the non-repudiation proof for an 
   archive object, the last ATS has to be valid and ATSCs and their 
   relations to each other have to be proved: 

   1. Select archive object and re-encrypt its data object or data 
      object group, if <EncryptionInformation> field is used. Select the 
      initial digest algorithm specified within the first Archive Time-
      Stamp Chain and calculate hash value of the archive object. Verify 
      that the initial Archive Time-Stamp contains (identical) hash 
      value of the AO's data object (or hash values of AO's data object 
      group). Note that when Hash-tree is omitted, calculated AO's value 
      MUST match the time-stamped value. 



 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 34] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   2. Verify each Archive Time-Stamp Chain and each Archive Time-Stamp 
      within. The first hash value list of the second and the next 
      Archive Time-Stamp in the Archive Time-Stamp chain MUST contain 
      the hash value of the Archive Time-Stamp before. Each Archive 
      Time-Stamp must be valid relative to the time of the succeeding 
      Archive Time-Stamp. All Archive Time-Stamps with the Archive Time-
      Stamp Chain MUST use the same algorithm, which was secure at the 
      time of the first Archive Time-Stamp of the succeeding Archive 
      Time-Stamp Chain. 

   3. Verify that the first hash value list of the first Archive Time-
      Stamp of all succeeding Archive Time-Stamp Chains contains hash 
      values of data object and the hash value of Archive Time-Stamp 
      Sequence of the preceding Archive Time-Stamp Chains. Verify that 
      Archive Time-Stamp was created when the last Archive Time-Stamp of 
      the preceding Archive Time-Stamp Chain was valid. 

   4. To prove the Archive Time-Stamp Sequence relates to a data object 
      group, verify that the first Archive Time-Stamp of the first 
      Archive Time-Stamp Chain does not contain other hash values in its 
      first hash value list (than the hash values of those data 
      objects). 

   For non-repudiation proof for the data object, the last Archive Time-
   Stamp MUST be valid at the time of verification process. 

5. Encryption 

   In some archive services scenarios it may be required that clients 
   send encrypted data only, preventing information disclosure to third 
   parties, such as archive service providers. In such scenarios it must 
   be clear that evidence records generated refer to encrypted data 
   objects. Evidence records in general protect the bit-stream (or 
   binary representation of XML data) which freezes the bit structure at 
   the time of archiving. Encryption schemes in such scenarios cannot be 
   changed afterwards without losing the integrity proof. Therefore, an 
 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 35] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   ERS record must hold and preserve encryption information in a 
   consistent manner. 

   Encryption is a two way process, whose result depends on the 
   cryptographic material used, e.g. encryption keys and encryption 
   algorithms. Encryption and decryption keys as well as algorithms must 
   match in order to reconstruct the original message or data that was 
   encrypted. When different cryptographic material is used, the results 
   may not be the same, i.e. decrypted data does not match the original 
   (unencrypted) data. In cases when evidence was generated to prove the 
   existence of encrypted data the corresponding algorithm and 
   decryption keys used for encryption must become a part of the 
   evidence record and is used to unambiguously represent original 
   (unencrypted) data that was encrypted. 

   Cryptographic material may also be used in scenarios when a local 
   copy of encrypted data submitted to the archive service provider for 
   preservation is kept in an unencrypted form by a client. In such 
   scenarios cryptographic material is used to re-encrypt unencrypted 
   data kept by a client for the purpose of performing validation of 
   evidence record, which is related to the encrypted form of client's 
   data. 

   The attribute Type within <EncrytionInformation> element is optional 
   and is used to store processing information about type of stored 
   encryption information, e.g. encryption algorithm or encryption key. 
   The use of encryption elements heavily depends on the cryptographic 
   mechanism and has to be defined by other specification. 

6. XSD Schema for the Evidence Record 

   <?xml version="1.0" encoding="UTF-8"?> 
   <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" 
   xmlns="http://www.setcce.org/schemas/ers" 

 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 36] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   targetNamespace="http://www.setcce.org/schemas/ers" 
   elementFormDefault="qualified" attributeFormDefault="unqualified"> 
    
   <xs:element name="EvidenceRecord" type="EvidenceRecordType"/> 
   <xs:complexType name="EvidenceRecordType"> 
   <xs:sequence> 
       <xs:element name="EncryptionInformation"  
         type="EncryptionInfo" minOccurs="0"/> 
    <xs:element name="ArchiveTimeStampSequence" 
    type="ArchiveTimeStampSequenceType"/> 
   </xs:sequence> 
   <xs:attribute name="Version" type="xs:string" use="required" 
   fixed="5.0"/> 
   </xs:complexType> 
    
   <!-- TYPE DEFINITIONS--> 
   <xs:complexType name="ArchiveTimeStampSequenceType"> 
   <xs:sequence> 
    <xs:element name="ArchiveTimeStampChain" 
    maxOccurs="unbounded"><xs:complexType><xs:sequence> 
            <xs:element name="DigestMethod" type="DigestMethodType"/> 
            <xs:element name="CanonicalizationMethod" 
            type="CanonicalizationMethodType"/> 
            <xs:element name="ArchiveTimeStamp" maxOccurs="unbounded"> 
            <xs:complexType> 
         <xs:sequence> 
                 <xs:element name="HashTree" type="HashTreeType" 
                 minOccurs="0"/> 
                 <xs:element name="TimeStamp"> 
                 <xs:complexType mixed="true"> 
                 <xs:complexContent mixed="true"> 

 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 37] 
    
Internet-Draft                  XMLERS                         May 2010 
    

                 <xs:restriction base="xs:anyType"> 
                 <xs:sequence> 
                 <xs:any processContents="skip" minOccurs="0" 
                 maxOccurs="unbounded"/> 
                 </xs:sequence> 
                 <xs:attribute name="Type" type="TimeStampType" 
                 use="required"/> 
                 </xs:restriction> 
                 </xs:complexContent> 
                 </xs:complexType> 
                 </xs:element> 
                 <xs:element name="CryptographicInformationList" 
                 type="CryptographicInformationType" minOccurs="0"/> 
                 <xs:element name="Attributes" type="Attributes" 
                 minOccurs="0"/> 
                 </xs:sequence> 
         <xs:attribute name="Order" type="OrderType" use="required"/> 
         </xs:complexType> 
         </xs:element> 
         </xs:sequence> 
    <xs:attribute name="Order" type="OrderType" use="required"/> 
   </xs:complexType> 
   </xs:element> 
   </xs:sequence> 
   </xs:complexType> 
    
   <xs:complexType name="EncryptionInfo"> 
       <xs:sequence> 
       <xs:element name="EncryptionInfoType" type="ObjectIdentifier"/> 
       <xs:element name="EncryptionInfoValue"> 
       <xs:complexType mixed="true"> 

 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 38] 
    
Internet-Draft                  XMLERS                         May 2010 
    

       <xs:sequence> 
       <xs:any minOccurs="0"/> 
       </xs:sequence> 
       </xs:complexType> 
       </xs:element> 
       </xs:sequence> 
   </xs:complexType> 
    
   <xs:complexType name="DigestMethodType" mixed="true"> 
       <xs:sequence> 
       <xs:any namespace="##other" minOccurs="0"/> 
       </xs:sequence> 
       <xs:attribute name="Algorithm" type="xs:anyURI" use="required"/> 
   </xs:complexType> 
    
   <xs:complexType name="CanonicalizationMethodType" mixed="true"> 
       <xs:sequence minOccurs="0"> 
       <xs:any namespace="##any" minOccurs="0"/> 
       </xs:sequence> 
       <xs:attribute name="Algorithm" type="xs:anyURI" use="required"/> 
   </xs:complexType> 
    
   <xs:complexType name="HashTreeType"> 
    <xs:sequence> 
         <xs:element name="Sequence" maxOccurs="unbounded"> 
         <xs:complexType> 
         <xs:sequence> 
              <xs:element name="DigestValue" type="xs:base64Binary" 
              maxOccurs="unbounded"/> 
    </xs:sequence> 
    <xs:attribute name="Order" type="OrderType" use="required"/> 

 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 39] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   </xs:complexType> 
   </xs:element> 
   </xs:sequence> 
   </xs:complexType> 
    
   <xs:complexType name="Attributes"> 
   <xs:sequence> 
       <xs:element name="Attribute" maxOccurs="unbounded"> 
       <xs:complexType mixed="true"> 
       <xs:complexContent mixed="true"> 
       <xs:restriction base="xs:anyType"> 
       <xs:sequence> 
       <xs:any processContents="skip" minOccurs="0" 
       maxOccurs="unbounded"/> 
       </xs:sequence> 
       <xs:attribute name="Order" type="OrderType" use="required"/> 
       <xs:attribute name="Type" type="xs:string" use="optional"/> 
       </xs:restriction> 
       </xs:complexContent> 
       </xs:complexType> 
       </xs:element> 
   </xs:sequence> 
   </xs:complexType> 
    
   <xs:complexType name="CryptographicInformationType"> 
   <xs:sequence> 
       <xs:element name="CryptographicInformation" 
       maxOccurs="unbounded"> 
       <xs:complexType mixed="true"> 
       <xs:complexContent mixed="true"> 
       <xs:restriction base="xs:anyType"> 

 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 40] 
    
Internet-Draft                  XMLERS                         May 2010 
    

       <xs:sequence> 
       <xs:any processContents="skip" minOccurs="0" 
       maxOccurs="unbounded"/> 
       </xs:sequence> 
       <xs:attribute name="Order" type="OrderType" use="required"/> 
       <xs:attribute name="Type" type="CryptoInfoType" use="required"/> 
       </xs:restriction> 
       </xs:complexContent> 
       </xs:complexType> 
       </xs:element> 
   </xs:sequence> 
   </xs:complexType> 
    
   <xs:simpleType name="ObjectIdentifier"> 
       <xs:restriction base="xs:token"> 
         <xs:pattern value="[0-2](\.[1-3]?[0-9]?(\.\d+)*)?"/> 
       </xs:restriction> 
   </xs:simpleType> 
    
   <xs:simpleType name="OrderType"> 
       <xs:restriction base="xs:int"> 
         <xs:minInclusive value="1"/> 
       </xs:restriction> 
   </xs:simpleType> 
    
   <xs:simpleType name="TimeStampType"> 
       <xs:restriction base="xs:token"> 
            <xs:enumeration value="XMLEnTrust"/> 
            <xs:enumeration value="RFC3161"/> 
       </xs:restriction> 
   </xs:simpleType> 

 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 41] 
    
Internet-Draft                  XMLERS                         May 2010 
    

    
   <xs:simpleType name="CryptoInfoType"> 
       <xs:restriction base="xs:token"> 
            <xs:enumeration value="CERT"/> 
            <xs:enumeration value="CRL"/> 
            <xs:enumeration value="OCSP"/> 
       </xs:restriction> 
   </xs:simpleType> 
    
   </xs:schema> 
    

7. Security Considerations 

   Secure Algorithms 

   Cryptographic algorithms and parameters that are used within Archive 
   Time-Stamps must always be secure at the time of generation. This 
   concerns the hash algorithm used in the hash lists of Archive 
   Timestamp as well as hash algorithms and public key algorithms of the 
   timestamps. Publications regarding security suitability of 
   cryptographic algorithms ([NIST.800-57-Part1.2006] and [ETSI TS 102 
   176-1 V2.0.0]) have to be considered by verifying components. A 
   generic solution for automatic interpretation of security suitability 
   policies in electronic form is not the subject of this specification. 

   Redundancy 

   Evidence records may become affected by weakening cryptographic 
   algorithms even before this is publicly known. Retrospectively this 
   has an impact on Archive Time-Stamps generated and renewed during 
   the archival period. In this case the validity of evidence records 
   created may end without any options for retroactive action. 

 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 42] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   Many TSAs are using the same cryptographic algorithms. While 
   compromise of a private key of a TSA may compromise the security of 
   only one TSA (and only on Archive Time-Stamp for example), weakening 
   cryptographic algorithms used to generate time-stamp tokens would 
   affect many TSAs at the same time. 

   To manage such risks and to avoid the loss of evidence record 
   validity due to weakening cryptographic algorithms used, it is 
   recommended to generate and manage at least two redundant Evidence 
   Records for a single data object. In such scenarios Redundant 
   Evidence Records must use different hash algorithms within Archive 
   Time Stamp Sequences and different TSAs using different 
   cryptographic algorithms for time-stamp tokens. 

   Secure Time-Stamps 

   Archive Time-Stamps depend upon the security of normal time stamping 
   provided by TSA and stated in security policies. Renewed Archive 
   Time-Stamps should have the same or higher quality as the initial 
   Archive Time-Stamp of archive data. Archive Time-Stamps used for 
   signed archive data should have the same or higher quality than the 
   maximum quality of the signatures. 

8. IANA Considerations 

   This document has no actions for IANA. 

9. References 

9.1. Normative References 

   [MER1980] Merkle, R., "Protocols for Public Key Cryptosystems, 
             Proceedings of the 1980 IEEE Symposium on Security and 
             Privacy (Oakland, CA, USA)", pages 122-134, April 1980. 


 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 43] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   [RFC2119] Bradner, S., "Key words for use in RFCs to Indicate 
             Requirement Levels", BPC 14, RFC 2119, March 1997. 

   [RFC3161] Adams, C., Cain, P., Pinkas, D., and R. Zuccherato, 
             "Internet X.509 Public Key Infrastructure Time-Stamp 
             Protocol (TSP)", RFC 3161, August 2001. 

   [RFC3275] Eastlake, D., Reagle, J., Solo, D., "XML-Signature Syntax 
             and Processing", RFC 3275, March 2002. 

   [RFC4051] Eastlake, D., "Additional XML Security Uniform Resource 
             Identifiers", RFC 4051, April 2005. 

   [RFC4998] Gondrom, T., Brandner, R., Pordesch, U., "Evidence Record 
             Syntax (ERS)", RFC 4998, August 2007. 

   [RFC5280] Cooper, D., Santesson, S., Farell, S., Boyen, S., Housley, 
             R.,Polk, W., "Internet X.509 Public Key Infrastructure 
             Certificate and Certificate Revocation List (CRL) Profile", 
             RFC 5280, May 2008. 

   [XMLC14N] Boyer, J., "Canonical XML", W3C Recommendation, March 2001. 

   [XMLDSig] Eastlake, D., Reagle, J., Solo, D., Hirsch, F., Roessler, 
             T., "XML-Signature Syntax and Processing", XMLDSig, W3C 
             Recommendation, July 2006. 

9.2. Informative References 

   [ETSI TS 102 176-1 V2.0.0] ETSI, "Electronic Signatures and 
             Infrastructures (ESI); Algorithms and Parameters for Secure 
             Electronic Signatures; Part 1: Hash functions and 
             asymmetric algorithms", ETSI TS 102 176-1 V2.0.0 (2007-11), 
             November 2007. 


 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 44] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   [RFC3470] Hollenbeck, S., Rose, M., Masinter, L., "Guidelines for the 
             Use of Extensible Markup Language (XML) within IETF 
             Protocols", RFC 3470, January 2003. 

   [RFC4810] Wallace, C., Pordesch, U., Brandner, R., "Long-Term Archive 
             Service Requirements", RFC 4810, March 2007. 

   [RFC5126] Pinkas, D., Popoe, N., Ross, J., "CMS Advanced Electronic 
             Signatures (CAdES)", RFC 5126, February 2008. 

   [XAdES]   Cruellas, J. C., Karlinger, G., Pinkas, D., Ross, J., "XML 
             Advanced Electronic Signatures", XAdES, W3C Note, February 
             2003. 

   [RFC5652] Housley, R., "Cryptographic Message Syntax (CMS)", RFC 
             5652, September 2009. 

    


















 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 45] 
    
Internet-Draft                  XMLERS                         May 2010 
    

APPENDIX A: Detailed verification process of an Evidence Record 

   To verify the validity of an Evidence Record start with the first ATS 
   till the last ATS (ordered by attribute Order) and perform 
   verification for each ATS, as follows: 

   1. Select corresponding archive object and its data object or a group 
      of data objects. 

   2. Re-encrypt data object or data object group, if 
      <EncryptionInformation> field is used (see section 5.  for more 
      details) 

   3. Get a canonicalization method C and a digest method H from the 
      <DigestMethod> element of the current chain. 

   4. Make a new list L of digest values of (binary representation of) 
      objects (data, ATS or sequence) that MUST be protected with this 
      ATS as follows: 

       a. If this ATS is the first in the Archive Time-Stamp Chain: 

           i. If this is the first ATS of the first ATSC (the initial 
               ATS) in the ATSSeq, calculate digest values of data 
               objects with H and add each digest value to the list L. 

          ii. If this ATS is not the initial ATS, calculate a digest 
               value with H of ordered ATSSeq without this and 
               successive chains. Add value H and digest values of data 
               objects to the list L. 

       b. If this ATS is not the first in the ATSC: 

           i. Calculate the digest value with H of the previous ATS 
               element and add this digest value to the list L. 

 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 46] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   5. Verify the ATS's time-stamped value as follows. Get the first 
      sequence of the hash tree for this ATS.  

       a. If this ATS has no hash tree elements then: 

          ii. If this ATS is not the first in the ATSSeq  (the initial 
               ATS), then the time-stamped value must be equal to digest 
               value of previous ATS. If not, exit with a negative 
               result. 

         iii. If this ATS is the initial ATS in ATSC, there must be 
               only one data object of the archive object. The digest 
               value of that data object must be the same as its time-
               stamped value. If not, exit with a negative result. 

       b. If this ATS has a hash-tree then: If there is a digest value 
          in the list L of digest values of protected objects, which 
          cannot be found in the first sequence of the hash tree or if 
          there is a hash value in the first sequence of the hash tree 
          which is not in the list L of digest values of protected 
          objects, exit with a negative result.  

           i. Get the hash tree from the current ATS and use H to 
               calculate the root hash value (see sections 3.2.1. and 
               3.2.2.) 

          ii. Get time stamped value from the time stamp token. If 
               calculated root hash value from the hash tree does not 
               match the time stamped value, exit with a negative 
               result. 

   6. Verify time-stamp cryptographically and formally (validate the 
      used certificate and its chain which may be available within the 
      time stamp token itself or <CryptographicInformation> tag). 


 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 47] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   7. If this ATS is the last ATS, check formal validity for the current 
      time (now), or get "valid from" time of the next ATS and verify 
      formal validity at that specific time. 

   8. If the needed information to verify formal validity is not found 
      within the time-stamp or within its Cryptographic Information 
      section of ATS, exit with a negative result. 

    

Author's Addresses 

   Aleksej Jerman Blazic 
   SETCCE 
   Tehnoloski park 21 
   1000 Ljubljana 
   Slovenia 
    
   Phone: +386 (0) 1 620 4500 
   Fax:   +386 (0) 1 620 4509 
   Email: aljosa@setcce.si 
    

   Svetlana Saljic  
   SETCCE 
   Tehnoloski park 21 
   1000 Ljubljana 
   Slovenia 
    
   Phone: +386 (0) 1 620 4506 
   Fax:   +386 (0) 1 620 4509 
   Email: svetlana.saljic@setcce.si 
    



 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 48] 
    
Internet-Draft                  XMLERS                         May 2010 
    

   Tobias Gondrom 
   Waisenhausstr. 67C 
   80637 Munich 
   Germany 
    
   Phone: +49 (0) 89 3205 330 
   Fax:   / 
   Email: tobias.gondrom@gondrom.org 
 



























 
 
Jerman Blazic, et. al. Expires November 30 2010               [Page 49] 
    
