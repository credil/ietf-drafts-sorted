<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY Kwds        PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
<!ENTITY ABNF        PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml'>
<!ENTITY Sieve       PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5228.xml'>
<!ENTITY ManageSieve PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5804.xml'>
<!ENTITY URI         PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml'>
<!ENTITY URN-REG     PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3553.xml'>
<!ENTITY TAG-URI     PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4151.xml'>
<!ENTITY ACAP        PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2244.xml'>
<!ENTITY LDAP        PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4510.xml'>
<!ENTITY Variables   PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5229.xml'>
<!ENTITY Subaddress  PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5233.xml'>
<!ENTITY Relational  PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5231.xml'>
<!ENTITY Spamtest    PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5235.xml'>
<!ENTITY Date        PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5260.xml'>
<!ENTITY Notify      PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5435.xml'>
<!ENTITY NotifyXMPP  PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5437.xml'>
<!ENTITY Ihave       PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5463.xml'>
<!ENTITY MIMEparts   PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5703.xml'>
<!ENTITY carddav     PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-vcarddav-carddav-10.xml'>
]>
<!-- ?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ? -->
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc tocompact="no" ?>
<?rfc tocindent="no" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="std"
     ipr="trust200902"
     docName="draft-ietf-sieve-external-lists-08">
    <front>
        <title>Sieve Extension: Externally Stored Lists</title>
        <author initials='A.' surname="Melnikov" fullname="Alexey Melnikov">
            <organization>Isode Limited</organization>
            <address>
              <postal>
                <street>5 Castle Business Village</street>
                <street>36 Station Road</street>
                <city>Hampton</city>
                <region>Middlesex</region>
                <code>TW12 2BX</code>
                <country>UK</country>
              </postal>
              <email>Alexey.Melnikov@isode.com</email>
            </address>
        </author>
        <author initials='B.' surname="Leiba" fullname="Barry Leiba">
            <organization>Huawei Technologies</organization>
            <address>
              <phone>+1 646 827 0648</phone>
              <email>barryleiba@computer.org</email>
              <uri>http://internetmessagingtechnology.org/</uri>
            </address>
        </author>
        <date year="2011"/>
        <area>Applications</area>
        <workgroup>Sieve Working Group</workgroup>
        <keyword>Sieve</keyword>
        <keyword>external list</keyword>
        
        <abstract>
          <t>
            The Sieve scripting language can be used to implement whitelisting,
            blacklisting, personal distribution lists, and other sorts of list matching.
            Currently, this requires
            that all members of such lists be hardcoded in the script itself.
            Whenever a member of a list is added or deleted, the script needs
            to be updated and possibly uploaded to a mail server.
          </t>
            
          <t>
            This document defines a Sieve extension for accessing externally stored
            lists -- lists whose members are stored externally to the script, such as
            using LDAP (RFC 4510), ACAP (RFC 2244), CardDAV (work in progress),
            or relational databases.
          </t>
        </abstract>
    </front>

    <middle>
        <section anchor="intro" title="Introduction">
          <t>
            This document specifies an extension to the Sieve language <xref target="RFC5228"/>
            for checking membership in an external list 
            or for redirecting messages to an external list of recipients.
            An "external list" is a list whose members are stored externally to the Sieve script,
            such as using
            LDAP <xref target="RFC4510"/>,
            ACAP <xref target="RFC2244"/>,
            CardDAV <xref target="I-D.ietf-vcarddav-carddav"/>,
            or relational databases.
          </t>
          <t>
            This extension adds a new match type to apply to supported tests,
            and a new tagged argument to the "redirect" action.
          </t>
          
          <section title="Conventions Used In This Document">
            <t>
              Conventions for notations are as in <xref target="RFC5228"/> section 1.1, including
              the use of <xref target="RFC5234"/>.
            </t>
            <t>
              The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
              "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
              document are to be interpreted as described in <xref target="RFC2119"/>.
            </t>
          </section>
        </section>
        
        <section title="Extlists Extension">
            
          <section anchor="capability" title="Capability Identifier">
            <t>
              The capability string associated with the extension defined in this
              document is "extlists".
            </t>
          </section>

          <section title=':list Match Type for Supported Tests'>
            <t>ABNF:
              <list style="hanging" hangIndent="8">
                <t hangText="   MATCH-TYPE">=/ ":list"
                  <vspace />; only valid for supported tests
                </t>
              </list>
            </t>
            <t>
              The new ":list" match type changes the interpretation
              of the "key-list" parameter (the second parameter) in
              supported tests.
              When the match type is ":list", the key-list becomes a list of names of externally
              stored lists. The external lists are queried, perhaps through a list-specific
              mechanism, and the test evaluates to "true" if any of the specified values
              matches any member of one or more of the lists.
            </t>
            <t>
              Comparators are not allowed together with the ":list" match type,
              so if both are specified in a test, that MUST result in an error.
              Queries done through list-specific mechanisms might have the effect of built-in
              comparators; for example, queries to certain lists might be case-sensitive,
              while queries to other lists might be done without regard to case.
            </t>
            <t>
              Implementations MUST support the use of ":list" in
              "address", "envelope" and "header" tests.
              Implementations that include the Variables extension <xref target="RFC5229" />
              MUST also support its use in "string" tests.
            </t>
            <t>
              Implementations MAY support other tests but MUST raise an error
              (which SHOULD be a compile-time error, but MAY be a runtime error)
              when a script uses ":list" with a test for which it is not supported.
              To maintain interoperability, other tests that can be used with ":list"
              SHOULD be documented in a
              specification that defines a capability string that can be tested (in a
              "require" statement, or using ihave <xref target="RFC5463" />).
            </t>
            <t>
              For example, testing 'header ["to", "cc"]' against a list would cause each
              "to" and "cc" value, ignoring leading and trailing whitespace, to be queried.
              If any value is found to belong to the list, the test returns "true".
              If no value belongs to the list, the test returns "false".
              Once a value is found in the list, there is no need for the query
              mechanism to look further.
            </t>              
            <t>
              For some lists, the Sieve engine might directly retrieve the list and make its
              own comparison.  Other lists might not work that way -- they might provide a way
              to ask if a value is in the list, but not permit retrieval of the list itself.
              It is up to the Sieve implementation to understand how to interact with any
              supported list.  If the Sieve engine is permanently unable to query the list
              (perhaps because the list doesn't support the required operation), the test
              MUST result in a runtime error in the Sieve script.
            </t>
            <t>
              See <xref target="list-name-syntax"/> for the detailed description
              of syntax used for naming externally stored lists.
            </t>

            <t>
              The ":list" match type uses the concept of "match variables"
              as defined in Section 3.2 of the Variables extension <xref target="RFC5229" />.
              Implementations that also support that extension MUST set the
              ${0} match variable to the value in the list that matched the query.
              Other numbered match variables (${1}, ${2}, and so on)
              MAY be set with list-specific information that might be of use to the script.
            </t>
          </section>

          <section title=':list Tagged Argument to the "redirect" Action'>
            <t>
              <list style="hanging" hangIndent="8">
                <t hangText="Usage:">
                  redirect :list &lt;ext-list-name: string&gt;
                </t>
              </list>
            </t>
            <t>
              The "redirect" action with the ":list" argument is used to send
              the message to the set of email addresses in the externally stored
              list named by the ext-list-name string.
              This variant of the redirect command can be used
              to implement a personal distribution list.
            </t>
            <t>
              For this feature to work, one of the following conditions has to be true:
              <list style="numbers">
                <t>
                  The list resolves to a list of email addresses, and the Sieve
                  engine is able to enumerate those addresses.
                </t>
                <t>
                  The list handler is able to take care of the redirection on
                  behalf of the Sieve engine.
                </t>
              </list>
            </t>

            <t>
              In cases where, for example, a list contains hashed email address values or
              an email address pattern ("sz*@example.com", "*+ietf@example.net"),
              the Sieve engine will not be able to redirect to that list, and responsibility
              must pass to the list handler.
            </t>
            <t>
              If neither the Sieve engine nor the list handler
              can enumerate (or iterate) the list, or the list
              does not resolve to email addresses, the situation
              MUST result in a runtime error in the Sieve script.
            </t>
            <t>
              See <xref target="list-name-syntax"/> for the detailed description
              of syntax used for naming externally stored lists.
            </t>
          </section>

          <section anchor="other-uses" title='Other Uses for External Lists'>
            <t>
              The uses for external lists specified here represent the useful
              cases and situations at the time of this writing.
              Other uses for external lists, using other Sieve features,
              might be devised in the future, and such uses can be
              described in extensions to this document.
            </t>
          </section>

          <section anchor="list-name-syntax" title='Syntax of an Externally Stored List Name'>
            <t>
              A name of an externally stored list is always an absolute URI <xref target="RFC3986"/>.
              Implementations might find URIs such as LDAP <xref target="RFC4510"/>,
              CardDAV <xref target="I-D.ietf-vcarddav-carddav"/>,
              or Tag <xref target="RFC4151"/> to be useful for naming external lists.
            </t>

            <t>
              The "tag" URI scheme <xref target="RFC4151"/> can be used to represent opaque,
              but user friendlier identifiers. Resolution of such identifiers is going
              to be implementation specific and it can help in hiding the complexity of
              an implementation from end users. For example, an implementation can
              provide a web interface for managing lists of users stored in LDAP.
              Requiring users to know generic LDAP URI syntax might not be very
              practical, due to its complexity. An implementation can instead use
              a fixed tag URI prefix such as "tag:example.com,&lt;date&gt;:" (where &lt;date&gt;
              can be, for example, a date generated once on installation of the web interface and
              left untouched upon upgrades)
              and the prefix doesn't even need to be shown to end users.
            </t>

            <t>
              The "addrbook" URNs defined in <xref target="abDef" />
              (in particular, the reserved URI "urn:ietf:params:sieve:addrbook:default")
              MUST be supported.
              To make it easier to use registered Sieve URN parameters, we define a
              shorthand way to specify them in a Sieve script: a list name that begins
              with ":" is taken as referencing a Sieve URN parameter, with the initial
              ":" expanding to "urn:ietf:params:sieve:".
              So we have the following equivalences:
              <list>
                <t>:addrbook:default == urn:ietf:params:sieve:addrbook:default</t>
                <t>:addrbook:personal == urn:ietf:params:sieve:addrbook:personal</t>
              </list>
              ...and so on.
            </t>

            <t>              
              The mandatory-to-implement URI
              <list>
                <t>urn:ietf:params:sieve:addrbook:default</t>
              </list>
              gives access to the user's
              default address book (usually the user's personal address book).
              Note that these are URIs, subject to normal URI encoding rules, including
              percent-encoding.  The reserved name "default" MUST be considered case-insensitive
              after decoding.  That means that the following URIs are all equivalent:
              <list>
                <t>:addrbook:default</t>
                <t>:ADDRBOOK:DEFAULT</t>
                <t>:aDdRbOOk:DeFauLt</t>
                <t>:AddrBook:%44%65%66ault</t>
              </list>
              Address book names other than "default" MAY be case-sensitive, depending upon
              the implementation, so their case (after URI decoding) MUST be maintained.
            </t>
            <t>
              It's possible that a server will have no access to anything resembling an
              address book (perhaps in an implementation where address books are only
              client-side things), but the server can still provide access to other sorts
              of lists -- consider the list of dates in Example 2 (<xref target="example2"/>),
              or lists of important keywords and the like.
              It might sometimes make sense to map ":addrbook:default" into some available list,
              but that might not always be reasonable.
              If there really is no concept of an address book in a particular server
              implementation, the server MAY support ":addrbook:default" by having all matches
              to it fail.  Such an implementation SHOULD NOT be done except as a last resort.
            </t>
            <t>
              Queries against address books SHOULD be done without regard to case.
            </t>
          </section>

          <section anchor="abDef" title='Definition of "addrbook" URN Parameter'>
            <t>
              This section gives the details of the "addrbook" Sieve URN parameter
              that's registered in <xref target="abReg"/>.
              URIs that use this parameter begin with "urn:ietf:params:sieve:addrbook:".
            </t>
            <t>
              <list style="hanging" hangIndent="4">
                <t hangText="URN parameter name:">addrbook
                <vspace/></t>
                <t hangText="URN parameter syntax:"> 
                  The "addrbook" parameter is defined by the &lt;addrbook-urn&gt; rule,
                  defined using ABNF <xref target="RFC5234"/>:
                  <vspace blankLines="1"/>
                  addrbook-urn = "addrbook:" addrbook [ "?" extensions ]<vspace/>
                  <vspace/>
                  addrbook = segment<vspace/>
                  &nbsp;&nbsp;&nbsp;&nbsp; ; &lt;segment&gt; defined in [RFC3986]<vspace/>
                  <vspace/>
                  extensions = query<vspace/>
                  &nbsp;&nbsp;&nbsp;&nbsp; ; &lt;query&gt; defined in [RFC3986]<vspace/>
                <vspace/></t>
                <t hangText="Intended usage:">
                  "addrbook" URNs are used for designating references to address books.
                  An address book is a concept used by different applications
                  (such as Sieve interpreters) for describing a list of named entries,
                  and may be translated into other types of address books, such as
                  LDAP Groups.  Address books may be private or shared; they may
                  be personal, organizational, or perhaps even "crowdsourced".
                  <vspace blankLines="1"/>
                  The address book name (the "addrbook" element in the ABNF above)
                  refers to a specifically named address book, as defined by the
                  implementation.  A user might, for example, have access to a number
                  of different address books, such as a personal one, a family one, 
                  a company one, and one for the town where the user lives.
                  <vspace blankLines="1"/>
                  The extension information (the "extensions" element in the ABNF above)
                  is available for use in future extensions.  It might allow for things
                  such as dynamic subsets of an address book -- for example, something
                  such as this might be defined in the future:
                  <list>
                    <t>
                      urn:ietf:params:sieve:addrbook:personal?name.contains=fred
                    </t>
                  </list>
                  There are no extensions defined at this time.
                  <vspace blankLines="1"/>
                  An "addrbook" URN is designed to be used by applications
                  for referencing address books.  Each URN is intended to represent a
                  grouping of addresses that can be logically thought of as one "book".
                  Any given address can belong to more than one book -- that is, can
                  be referred to by more than one URN.
                  <vspace blankLines="1"/>
                  The URI "urn:ietf:params:sieve:addrbook" has no meaning in itself.
                  It MUST be used with sub-parameters representing the address book name
                  and extension information, as shown in the ABNF above.
                  <vspace blankLines="1"/>
                  The sub-parameter "default"
                  (creating the URN "urn:ietf:params:sieve:addrbook:default")
                  is a reserved (case-insensitive) name that MUST be implemented,
                  representing a default grouping (book) of addresses.  Other names,
                  representing the same or other groupings MAY be implemented.
                  For example, an implementation might use the following sub-parameters:
                  <list style="symbols">
                  <t>personal -- a book representing the user's personal address book.</t>
                  <t>friends -- a subset of urn:ietf:params:sieve:addrbook:personal,
                     defined by the user.</t>
                  <t>family -- a subset of urn:ietf:params:sieve:addrbook:personal,
                     defined by the user.</t>
                  <t>company -- a book representing user's company's address book.</t>
                  <t>department -- a subset of urn:ietf:params:sieve:addrbook:company,
                     defined by the company.</t>
                  <t>co-workers -- a subset of urn:ietf:params:sieve:addrbook:company,
                     defined by the user.</t>
                  <t>default -- the default address book, a reference to
                     urn:ietf:params:sieve:addrbook:personal.</t>
                  </list>
                <vspace/></t>
                <t hangText="Interoperability considerations:">
                  Applications are only REQUIRED to support "addrbook:default",
                  where all cases and encodings of "default" are considered equivalent.
                  Address book names other than "default" MAY be case-sensitive, depending upon
                  the implementation, so their case (after URI decoding) MUST be maintained.
                <vspace/></t>
                <t hangText="Security considerations:">
                  Applications SHOULD ensure appropriate
                  restrictions are in place to protect sensitive information that
                  might be revealed by "addrbook" URNs from access or modification by
                  untrusted sources.
                <vspace/></t>
                <t hangText="Contact:">Sieve mailing list &lt;sieve@ietf.org&gt;
                <vspace/></t>
              </list>
            </t>
          </section>

          <section title='Test valid_ext_list'>
              
            <t>Usage:  valid_ext_list &lt;ext-list-names: string-list&gt;</t>
              
            <t>
              The "valid_ext_list" test is true if all of the external list names
              in the ext-list-names argument are supported, and they are
              valid both syntactically (including URI parameters) and semantically
              (including implementation-specific semantic restrictions). Otherwise
              the test returns false.
            </t>
              
            <t>
              This test MUST perform exactly the same validation of an external
              list name as would be performed by the "header :list" test.            
            </t>

          </section>

          <section anchor="manage-sieve" title='Interaction with ManageSieve'>
            <t>
              This extension defines the following new capability for ManageSieve
              (see <xref target="RFC5804"/> section 1.7):
            </t>
            <t>
              EXTLISTS - A space-separated list of URI schema parts <xref target="RFC3986"/>
              for supported externally stored list types.  This capability MUST be returned
              if the corresponding Sieve implementation supports the "extlists" extension
              defined in this document.
            </t>
            <t>
              This also extends the ManageSieve ABNF as follows:
              <list style="hanging" hangIndent="8">
                <t hangText="single-capability">=/ DQUOTE "EXTLISTS" DQUOTE SP ext-list-types CRLF
                  <vspace />; single-capability is defined in <xref target="RFC5804"/>
                </t>
                <t hangText="ext-list-types">= string
                  <vspace />; space separated list of URI schema parts
                  <vspace />; for supported externally stored list types.
                  <vspace />; MUST NOT be empty.
                </t>
              </list>
            </t>

          </section>

          <section anchor="examples" title='Examples'>

            <section anchor="example1" title='Example 1'>
            <t>
              This example uses a personal address book, along with
              the Spamtest <xref target="RFC5235"/>
              and Relational <xref target="RFC5231"/> extensions
              to give a different level of spam tolerance to known senders.
              <figure>
               <artwork><![CDATA[
    require ["envelope", "extlists", "fileinto", "spamtest",
             "relational", "comparator-i;ascii-numeric"];
    if envelope :list "from" ":addrbook:default"
      { /* Known: allow high spam score */
        if spamtest :value "ge" :comparator "i;ascii-numeric" "8"
          {
            fileinto "spam";
          }
      }
    elsif spamtest :value "ge" :comparator "i;ascii-numeric" "3"
      { /* Unknown: less tolerance in spam score */
        fileinto "spam";
      }
]]></artwork>
              </figure>
            </t>
            <t>
              The same example can also be written another way, if
              the Variables extension <xref target="RFC5229"/> is also supported:
              <figure>
               <artwork><![CDATA[
    require ["envelope", "extlists", "fileinto", "spamtest",
        "variables", "relational", "comparator-i;ascii-numeric"];
    if envelope :list "from" ":addrbook:default" {
      set "lim" "8";  /* Known: allow high spam score */
    } else {
      set "lim" "3";  /* Unknown: less tolerance in spam score */
    }
    if spamtest :value "ge" :comparator "i;ascii-numeric" "${lim}" {
      fileinto "spam";
    }
]]></artwork>
              </figure>
            </t>            
            </section>

            <section anchor="example2" title='Example 2'>
            <t>
              This example uses the "currentdate" test <xref target="RFC5260"/>
              and a list containing the dates of local holidays.  If today is
              a holiday, the script will notify <xref target="RFC5435"/>
              the user via XMPP <xref target="RFC5437"/>
              about the message.
              <figure>
               <artwork><![CDATA[
    require ["extlists", "date", "enotify"];
    if currentdate :list "date"
       "tag:example.com,2011-01-01:localHolidays" {
       notify "xmpp:romeo@im.example.com";
    }
]]></artwork>
              </figure>
            </t>
            </section>

            <section anchor="example3" title='Example 3'>
            <t>
              This example also uses the "envelope" option <xref target="RFC5228"/>
              and the Subaddress extension  <xref target="RFC5233"/>.
              If mail is sent with the list name as a subaddress of the recipient
              (to, say, "alexey+mylist"), and the message comes from a member of the
              list, it will be redirected to all members of the list.
              Variants of this technique might be useful for creating private
              mailing lists.
              <figure>
               <artwork><![CDATA[
    require ["extlists", "envelope", "subaddress"];

    # Submission from list members is sent to all members
    if allof (envelope :detail "to" "mylist",
              header :list "from"
                     "tag:example.com,2010-05-28:mylist") {
        redirect :list "tag:example.com,2010-05-28:mylist";
    }
]]></artwork>
              </figure>
            </t>
            </section>

            <section anchor="example4" title='Example 4'>
            <t>
              This example uses variable matching <xref target="RFC5229"/>
              to extract the IP address from the last "Received" header field.
              It then checks that against a "block list" of undesirable
              IP addresses, and rejects the message if there's a match.
              <figure>
               <artwork><![CDATA[
    require ["variables", "extlists", "index", "reject"];
    if header :index 1 :matches "received" "*(* [*.*.*.*])*" {
      set "ip" "${3}.${4}.${5}.${6}";
      if string :list "${ip}"
          "tag:example.com,2011-04-10:DisallowedIPs" {
        reject "Message not allowed from this IP address";
      }
    }
]]></artwork>
              </figure>
            </t>
            </section>

            <section anchor="example5" title='Example 5'>
            <t>
              This example uses several features of the MIME parts extension
              <xref target="RFC5703"/>
              to scan for unsafe attachment types.
              To make it easily extensible, the unsafe types are kept in an
              external list, which would be shared among all users and all scripts,
              avoiding the need to change scripts when the list changes.
            </t>
            <t>
              [Note that this is an illustrative example, and more rigorous
              malware filtering is advisable.  It is insufficient to base
              email security on checks of filenames alone.]
              <figure>
               <artwork><![CDATA[
    require [ "extlists", "foreverypart", "mime", "enclose" ];

    foreverypart
    {
      if header :mime :param "filename"
         :list ["Content-Type", "Content-Disposition"]
           "tag:example.com,2011-04-10:BadFileNameExts"
      {
        # these attachment types are executable
        enclose :subject "Warning" :text
 WARNING! The enclosed message attachments that might be unsafe.
 These attachment types may contain a computer virus program
 that can infect your computer and potentially damage your data.

 Before clicking on these message attachments, you should verify
 with the sender that this message was sent intentionally, and
 that the attachments are safe to open.
 .
 ;
        break;
      }
    }
]]></artwork>
              </figure>
            </t>
            </section>

          </section>
        </section>


        <section anchor="security" title="Security Considerations">
          <t>
            Security considerations related to the "address"/"envelope"/"header" tests and
            "redirect" action discussed in Sieve <xref target="RFC5228"/> also apply
            to this document.
          </t>

          <t>
            External list memberships ought to be treated as if they are
            an integral part of the script,
            so a temporary failure to access an external list
            SHOULD be handled in the same way as a temporary failure to retrieve
            the Sieve script itself.
          </t>

          <t>
            For example, if the Sieve script is stored in the 
            Lightweight Directory Access Protocol <xref target="RFC4510"/> and the script
            can't be retrieved when a message is processed (perhaps the LDAP server is
            unavailable), then the Sieve engine
            might delay message delivery until the script can be retrieved successfully.
            Similarly, if an external list is stored in LDAP and that LDAP server is
            unavailable, the Sieve engine would take the same action -- delay message delivery
            and try again later.
          </t>

          <t>
            Protocols/APIs used to retrieve/verify external list membership MUST provide
            an appropriate level of confidentiality and authentication.
            Usually, that will be at least the same level of confidentiality as
            protocols/APIs used to retrieve Sieve scripts, but only the implementation
            (or deployment) will know what is appropriate.
            There's a difference, for example, between making an LDAP
            request on a closed LAN that's only used for trusted servers
            (it may be that neither encryption nor authentication is needed),
            on a firewalled LAN internal to a company
            (it might be OK to skip encryption, depending upon policy),
            and on the open Internet
            (encryption and authentication are probably both required).
            It also matters whether the list being accessed is private or public
            (no encryption or authentication may be needed for public data, even on the
            Internet).
          </t>

          <t>
            Having the processing and outcome of a Sieve script depend on the contents
            of external data can allow someone with control of the external data to have
            unusual, and perhaps unauthorized, control of the script -- and, consequently,
            of the disposition of the user's email.  A user using such a list for spam control,
            for example, might find important mail being discarded because of tampering
            with the list.  Someone using redirect to an external list could have her email
            redirected to the wrong eyes because of such tampering.  Security and integrity
            protection of external lists is as important as protection of the Sieve script
            itself.
          </t>

          <t>
            Implementations of this extension should keep in mind that
            matching values against an externally stored list can be IO
            and/or CPU intensive. This can be used to deny service to the mailserver
            and/or to servers providing access to externally stored mailing lists.
            A na&iuml;ve implementation, such as the one that tries to retrieve content
            of the whole list to perform matching can make this worse.
          </t>
            
          <t>
            But note that many protocols that can be used for accessing externally
            stored lists support flexible searching features that can be used
            to minimize network traffic and load on the directory service.
            For example, LDAP allows for search filters.
            Implementations SHOULD use such features whenever they can.
          </t>

          <t>
            Many organizations support external lists with thousands of recipients.
            In order to avoid mailbombs when redirecting a message to
            an externally stored list, implementations SHOULD enforce
            limits on the number of recipients and/or on domains to which such
            recipients belong.
          </t>

          <t>
            Note in particular that it can be too easy for a script to use
            <vspace/>
            &nbsp;&nbsp;&nbsp;&nbsp; redirect :list ":addrbook:default";
            <vspace/>
            to send messages to "everyone in your address book", and one can easily
            imagine both intentional and accidental abuse.
            The situation can be even worse for, say, ":addrbook:corporate".
            Warnings, as well as enforced limits, are appropriate here.
          </t>

          <t>
            Applications SHOULD ensure appropriate restrictions are in place
            to protect sensitive information that might be revealed by "addrbook"
            URIs from access or modification by untrusted sources.
          </t>
          
        </section>

        <section anchor="iana" title="IANA Considerations">
          <section title="Registration of Sieve Extension">
            <t>
              The following template specifies the IANA registration of the
              Sieve extension specified in this document.
              This information should be added to the list of sieve extensions
              given on http://www.iana.org/assignments/sieve-extensions.
            </t>
            <t>
              <list style="hanging" hangIndent="4">
                <t hangText="To:">iana@iana.org
                <vspace/></t>
                <t hangText="Subject:">Registration of new Sieve extension
                <vspace/></t>
                <t hangText="Capability name:">extlists
                <vspace/></t>
                <t hangText="Description:">
                  Adds the ":list" match type to certain Sieve tests,
                  and the ":list" argument to the "redirect" action.
                  The ":list" match type changes tests to match
                  values against values stored in one or more externally stored
                  lists. The ":list" argument to the redirect action changes
                  the redirect action to forward the message to email addresses
                  stored in the externally stored list.
                <vspace/></t>
                <t hangText="RFC number:">this RFC
                <vspace/></t>
                <t hangText="Contact address:">Sieve mailing list &lt;sieve@ietf.org&gt;
                <vspace/></t>
              </list>
            </t>
          </section>

          <section title="Registration of ManageSieve Capability">
            <t>
              The following requests IANA to register a new ManageSieve Capability according
              to the IANA registration template specified in <xref target="RFC5804"/>:
            </t>
            <t>
              <list style="hanging" hangIndent="4">
                <t hangText="To:">iana@iana.org
                <vspace/></t>
                <t hangText="Subject:">ManageSieve Capability Registration
                <vspace/></t>
                <t hangText="Capability name:">extlists
                <vspace/></t>
                <t hangText="Description:">
                  This capability is returned if the server supports the
                  "extlists" [RFCXXXX] Sieve extension.
                <vspace/></t>
                <t hangText="Relevant publications:">
                  this RFC, <xref target="manage-sieve"/>
                <vspace/></t>
                <t hangText="Person & email address to contact for further information:">
                  Sieve mailing list &lt;sieve@ietf.org&gt;
                <vspace/></t>
                <t hangText="Author/Change controller:">IESG
                <vspace/></t>
              </list>
            </t>
          </section>

          <section anchor="paramReg" title='Creation of Sieve URN Parameters registry'>
            <t>
              The following requests IANA to create a new registry under "Sieve Extensions"
              for Sieve URN Parameters.
            </t>
            <t>
              <list style="hanging" hangIndent="4">
                <t hangText="URN parameter name:">The name of the URN parameter.
                If the name is "paramname", 
                the resulting top-level URN will be "urn:ietf:params:sieve:paramname".
                <vspace/></t>
                <t hangText="Reference:">The document and section where the definition of
                the parameter can be found.  The documentation MUST include the following
                information (see <xref target="abDef"/> for an example):
                  <list style="hanging" hangIndent="4">
                    <t hangText="URN parameter name:">The name of the URN parameter.
                    <vspace/></t>
                    <t hangText="URN parameter syntax:">The syntax of the parameter and any
                    sub-parameters, which SHOULD be specified using ABNF <xref target="RFC5234"/>.
                    <vspace/></t>
                    <t hangText="Intended usage:">A detailed description of how the
                    parameter and any sub-parameters are expected to be used.
                    This is the place to define static sub-parameters, registries for
                    sub-parameters, options, registries for options, and so on.
                    <vspace/></t>
                    <t hangText="Interoperability considerations:">Any notes specific to
                    interoperability issues.  This is where to put mandatory-to-implement
                    sub-parameters and the like.
                    <vspace/></t>
                    <t hangText="Security considerations:">Any notes specific to security
                    and privacy issues.
                    <vspace/></t>
                    <t hangText="Contact:">Contact information, in case there are questions.
                    <vspace/></t>
                  </list>
                <vspace/></t>
              </list>
            </t>
          </section>

          <section anchor="abReg" title='Registration of the "addrbook" URN parameter'>
            <t>
              The following requests IANA to register a new Sieve URN parameter in the
              registry defined in <xref target="paramReg"/>.
            </t>
            <t>
              <list style="hanging" hangIndent="4">
                <t hangText="URN parameter name:">addrbook
                <vspace/></t>
                <t hangText="Reference:">[This RFC], <xref target="abDef"/>
                <vspace/></t>
              </list>
            </t>
          </section>

          <section anchor="abURN" title='Registration of "sieve" URN sub-namespace'>
            <t>
              The following requests IANA to register a new URN sub-namespace within the
              IETF URN Sub-namespace for Registered Protocol Parameter Identifiers
              defined in <xref target="RFC3553"/>.
            </t>
            <t>
              <list style="hanging" hangIndent="4">
                <t hangText="Registry name:">sieve
                <vspace/></t>
                <t hangText="Specification:">[this RFC]
                <vspace/></t>
                <t hangText="Repository:">[the registry created in <xref target="paramReg"/>]
                <vspace/></t>
                <t hangText="Index value:">Sub-parameters MUST be specified in UTF-8,
                using standard URI encoding where necessary.
                <vspace/></t>
              </list>
            </t>
          </section>
        </section>

        <section anchor="acknowledgements" title="Acknowledgements">
          <t>
            Thanks to Alexandros Vellis, Nigel Swinson, Ned Freed,
            Kjetil Torgrim Homme, Dave Cridland, Cyrus Daboo, Pete Resnick,
            and Robert Burrell Donkin
            for ideas, comments and suggestions.
            Kristin Hubner also helped greatly with the examples.
          </t>
        </section>
    </middle>

    <back>
      <references title="Normative References">
        &Kwds;
        &ABNF;
        &Sieve;
        &ManageSieve;
        &URI;
        &TAG-URI;
      </references>
        
      <references title="Informative References">
        &ACAP;
        &LDAP;
        &URN-REG;
        &Variables;
        &Subaddress;
        &Relational;
        &Spamtest;
        &Date;
        &Notify;
        &NotifyXMPP;
        &Ihave;
        &MIMEparts;
        &carddav;
      </references>
    </back>
</rfc>
