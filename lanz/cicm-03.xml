<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!-- General -->
<?rfc strict="yes" ?>   <!-- Enforce Internet-Drafts nits & DTD validity? -->
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<!-- References -->
<?rfc symrefs="yes"?>   <!-- Show symbolic links (yes) or numbers (no). -->
<?rfc sortrefs="yes" ?> <!-- Sort references? -->
<!-- Comments -->
<?rfc comments="yes" ?> <!-- Display <cref> elements? -->
<?rfc inline="yes" ?>   <!-- Place comments inline (yes) or in comments section (no). -->
<?rfc editing="no" ?>   <!-- Insert editing marks? -->
<!-- Table of Contents -->
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc tocompact="yes"?>
<!-- End of directives; start of RFC. -->
<rfc category="info" ipr="trust200902" docName="draft-lanz-cicm-03">
  <front>
    <title abbrev="CICM">
      Common Interface to Cryptographic Modules (CICM)
    </title>
    <author fullname="Daniel J. Lanz" initials="D." surname="Lanz">
      <organization abbrev="MITRE">The MITRE Corporation</organization>
      <address>
        <email>dlanz@mitre.org</email>
      </address>
    </author>
    <author fullname="Lev Novikov" initials="L." surname="Novikov">
      <organization abbrev="MITRE">The MITRE Corporation</organization>
      <address>
        <email>lnovikov@mitre.org</email>
      </address>
    </author>
    <date year="2011" month="July" />
    <area>Security</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <abstract>
      <t>This memo presents a programming interface to standardize
      the way software programs manage cryptographic modules and
      use cryptographic services offered by modules. Although a
      number of interfaces for commercial environments have been
      standardized and are in use, this is the first generic
      cryptographic interface to be developed that supports
      cryptographic modules separating two security domains and is
      thus ideal for the high assurance environment. The interface
      has been designed to also allow less demanding environments
      to take advantage of its features.</t>
    </abstract>
  </front>
  <middle><!-- Content. -->
	<section title="Introduction">
    <t>This document defines the high-level entities of a programming
    interface for high assurance cryptographic modules called
    Common Interface to Cryptographic Modules (CICM) based on the
    logical model outlined in <xref target="CICM-LM" />.</t>
    <section title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
      "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
      and "OPTIONAL" in this document are to be interpreted as
      described in <xref target="RFC2119" />.</t>
    </section>
    <section title="Definition Language">
      <t>CICM is defined using Interface Definition Language (IDL)
      <xref target="IDL" />, a specification language that describes
      a software interface in a language-neutral way.
      IDL compilers can generate a functionally equivalent CICM
      interface binding for common programming languages. The use of IDL
      in CICM is not intended to either prescribe or preclude a particular
      communications protocol such as General Inter-ORB Protocol (GIOP) <xref target="CORBA" />
      between programs in different address	spaces or on different devices.</t>
      <t>Additionally, CICM does not use the IDL exception mechanism to report errors.
      See <xref target="extend" format="title" /> for more information.</t>
    </section>
    <section title="IDL Language Mapping Conventions">
      <t>Memory responsibilities and calling conventions MUST follow
      the appropriate IDL language mapping conventions.</t>
      <!-- @todo(lnovikov@mitre.org) We need to provide a reference to "appropriate IDL language mapping conventions". -->
    </section>
  <section title="Endianness">
    <t>Endianness is the byte ordering used to
    represent data stored in a computer or transmitted between
    computers. A big-endian ordering of bytes is REQUIRED by CICM.</t>
  </section>
  <section title="Blocking and Non-blocking Calls">
    <t>All CICM methods block
    (wait for the operation defined by the method) to complete before
    returning, unless they are explicitly defined as non-blocking. For
    example, the CICM::Encrypt::Stream::encrypt method (defined in
    <xref target="CICM-CM" />) blocks when sending data on a stream
    to be encrypted, while its sibling
    CICM::Encrypt::Stream::encrypt_non_blocking is identified not only
    in its name as non-blocking, but also clearly within the
    documentation for the method.</t>
  </section>
		<section title="Assumptions">
			<t>The following assumptions were made in the
			development of CICM:
			<list style="symbols">
			  <t>Library implementers may implement part of the specification
			  (refer to the sections on <xref target="conform" format="title" /> and
        <xref target="extend" format="title" />, for the normative rules).</t>
			  <t>A client program initiates cryptographic transformations
			  with a cryptographic module via the CICM API. Multiple client
			  programs may concurrently access a single module from a single
			  security domain, but CICM provides no support for controlling
			  access to a module by two or more client programs.</t>
			  <t>A module may be implemented as hardware, firmware, or
			  software component, or any combination thereof.</t>
			  <t>Although CICM is intended for use in high assurance
			  environments, its use is not precluded in less demanding
			  environments.</t>
			  <t>One or more entities between the API library and the module
			  translates CICM commands or interfaces to module-specific
			  commands or interfaces.</t>
			  <t>CICM makes no provision in the design of the API to guarantee
			  the confidentiality, integrity, or authenticity of commands and
			  data between a client program calling the API and a module.
			  However, such protections can be applied in the library or
			  runtime system software.</t>
			  <t>Specialized hardware (e.g., hardware access tokens, key fill
			  devices, trusted displays) independent of a module may require
			  host (and thus API) interaction or may require no host
			  interaction.</t>
			</list></t>
		</section>
		<section title="Specification Organization">
			<t>The CICM specification is composed of five documents.
      <list style="symbols">
        <t><xref target="CICM-LM" /> provides an informative (non-normative) underlying
        logical model and terminology,</t>
        <t>this document defines the basic types and rules for conformance (<xref target="conform" />)
        and extension (<xref target="extend" />),</t>
        <t><xref target="CICM-MM" /> defines module management capabilities,</t>
        <t><xref target="CICM-KM" /> defines key management capabilities, and</t>
        <t><xref target="CICM-CM" /> defines channel management capabilities.</t>
      </list>
      </t>
      <t>The informative material is for informational purposes; it assists the reader in the
			understanding and use of the specification but does not contain
			provisions required for conformance.</t>
      <t>The namespaces, interfaces, datatypes,
      methods, and attributes that comprise the specification are
      presented in a prescriptive manner.
      For each category, each namespace is described followed by the
      interfaces contained within it. The datatype, method, and attribute
      definitions then follow each interface definition.</t>
		</section>
	</section>
  <section title="Fundamental Definitions">
    <section title="Namespace CICM">
      <figure>
        <preamble>Namespace CICM</preamble>
        <artwork><![CDATA[module CICM]]></artwork>
        <postamble>CICM is the top-level namespace for all CICM interfaces and
        sub-namespaces.</postamble>
      </figure>
    </section>
    <section title="Fundamental Types">
      <section title="General Types">
        <figure>
          <preamble>Type CICM::UInt32</preamble>
          <artwork><![CDATA[typedef unsigned long UInt32;]]></artwork>
          <postamble>Unsigned 32-bit integer.</postamble>
        </figure>
        <figure>
          <preamble>Type CICM::Bool</preamble>
          <artwork><![CDATA[typedef boolean Bool;]]></artwork>
          <postamble>Boolean value.</postamble>
        </figure>
        <figure>
          <preamble>Type CICM::CharString</preamble>
          <artwork><![CDATA[typedef string CharString;]]></artwork>
          <postamble>Sequence of characters.</postamble>
        </figure>
        <figure>
          <preamble>Type CICM::Buffer</preamble>
          <artwork><![CDATA[typedef sequence<octet> Buffer;]]></artwork>
          <postamble>Byte sequence, encapsulating the sequence of bytes, the
          length of the sequence, and the amount of allocated space.</postamble>
        </figure>
      </section>
      <section title="Identifiers">
        <figure>
          <preamble>Type CICM::ModuleId</preamble>
          <artwork><![CDATA[typedef CICM::CharString ModuleId;]]></artwork>
          <postamble>Unique cryptographic module identifier.</postamble>
        </figure>
        <figure>
          <preamble>Type CICM::TransId</preamble>
          <artwork><![CDATA[typedef CICM::UInt32 TransId;]]></artwork>
          <postamble>Unique transaction identifier for read/write operations.</postamble>
        </figure>
      </section>
      <section title="Status Codes">
        <figure>
          <preamble>Type CICM::Status</preamble>
          <artwork><![CDATA[typedef CICM::UInt32 Status;]]></artwork>
          <postamble>Status of an executed method.</postamble>
        </figure>
        <t>See also:
          <list>
            <t><xref target="status-codes" /> for a full list of status codes.</t>
          </list>
        </t>
      </section>
      <section title="Classifications">
        <figure>
          <preamble>Type CICM::Classification</preamble>
          <artwork><![CDATA[typedef CICM::UInt32 Classification;]]></artwork>
          <postamble>Classification levels.</postamble>
        </figure>
        <figure>
          <preamble>Constant CICM::C_LEVEL_UNCLASSIFIED</preamble>
<artwork><![CDATA[const CICM::Classification
C_LEVEL_UNCLASSIFIED = 0x0000602F;]]></artwork>
          <postamble>Value indicating unclassified classification level.</postamble>
        </figure>
        <figure>
          <preamble>Constant CICM::C_LEVEL_CONFIDENTIAL</preamble>
<artwork><![CDATA[const CICM::Classification
C_LEVEL_CONFIDENTIAL = 0x00006029;]]></artwork>
          <postamble>Value indicating confidential classification level.</postamble>
        </figure>
        <figure>
          <preamble>Constant CICM::C_LEVEL_SECRET</preamble>
<artwork><![CDATA[const CICM::Classification
C_LEVEL_SECRET = 0x0000602A;]]></artwork>
          <postamble>Value indicating secret classification level.</postamble>
        </figure>
        <figure>
          <preamble>Constant CICM::C_LEVEL_TOP_SECRET</preamble>
<artwork><![CDATA[const CICM::Classification
C_LEVEL_TOP_SECRET = 0x0000602C;]]></artwork>
          <postamble>Value indicating top secret classification level.</postamble>
        </figure>
      </section>
      <section title="Ports">
        <figure>
          <preamble>Type CICM::RemotePort</preamble>
          <artwork><![CDATA[typedef CICM::UInt32 RemotePort;]]></artwork>
          <postamble>Remote module port.</postamble>
        </figure>
        <figure>
          <preamble>Constant CICM::IMPLICIT_REMOTE_PORT</preamble>
<artwork><![CDATA[const CICM::RemotePort
IMPLICIT_REMOTE_PORT = 0xFFFFFF99;]]></artwork>
          <postamble>Value that indicates that the remote port value is
          implicit.</postamble>
        </figure>
        <figure>
          <preamble>Type CICM::LocalPort</preamble>
          <artwork><![CDATA[typedef CICM::UInt32 LocalPort;]]></artwork>
          <postamble>Local module port.</postamble>
        </figure>
        <figure>
          <preamble>Constant CICM::IMPLICIT_LOCAL_PORT</preamble>
<artwork><![CDATA[const CICM::LocalPort
IMPLICIT_LOCAL_PORT = 0xFFFFFFBB;]]></artwork>
          <postamble>Value that indicates that the local port value is
          implicit.</postamble>
        </figure>
        <figure>
          <preamble>Constant CICM::FILL_INTERFACE_PORT</preamble>
<artwork><![CDATA[const CICM::LocalPort
FILL_INTERFACE_PORT = 0xFFFFFFEE;]]></artwork>
          <postamble>Value that represents the port on which keys are filled or
          exported.</postamble>
        </figure>
      </section>
    </section>
    <section title="Fundamental Interfaces">
      <section title="Interface CICM::CICMRoot">
        <figure>
          <preamble>Interface CICM::CICMRoot</preamble>
          <artwork><![CDATA[interface CICMRoot]]></artwork>
          <postamble>CICMRoot serves as the entry point to the CICM API and
          enables a specific cryptographic module of potentially many modules
          available to a host to be selected.</postamble>
        </figure>
        <section title="CICM::CICMRoot Methods">
          <figure>
            <preamble>Method CICM::CICMRoot::get_module_by_id()</preamble>
<artwork><![CDATA[CICM::Status get_module_by_id(
in  CICM::ModuleId id,
out CICM::CryptoModule crypto_module_ref
);]]></artwork>
            <postamble>Returns a reference to the module with the given module
            unique identifier.</postamble>
          </figure>
          <t>Parameters:
            <list>
              <t>[in] id Unique identifier for the module.</t>
              <t>[out] crypto_module_ref Module associated with the given identifier.</t>
            </list>
          </t>
          <t>Returns:
            <list>
              <t>S_OK, S_GENERAL_ERROR,
                S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_HOST_RESOURCES,
                S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE,
                S_TIMEOUT, S_MODULE_DOES_NOT_EXIST</t></list>
          </t>
          <figure>
            <preamble>Example (C++):</preamble>
<artwork><![CDATA[CICM::Status sCode;
CICM::CryptoModule device;

// Instantiate the root object.
CICM::CICMRoot cicm = new CICM::CICMRoot();

// Retrieve a reference to the module
// corresponding to the specified module identifier.
const string MODULE_ID = "CM10293495867";

// If found, [device] refers to the specified
crypto module. sCode = cicm.get_module_by_id(MODULE_ID, &device);]]></artwork>
          </figure>
        </section>
      </section>
      <section title="Interface CICM::CryptoModule">
        <figure>
          <preamble>Interface CICM::CryptoModule</preamble>
          <artwork><![CDATA[interface CryptoModule]]></artwork>
          <postamble>CICM::CryptoModule contains attributes that provide access to
          module-specific information and attributes that enable access to
          module managers, through which nearly all interface functionality
          is accessed.</postamble>
        </figure>
        <t>
          <figure>
<artwork><![CDATA[            CryptoModule
                 |
                 |-> SymKeyManager
                 |-> AsymKeyManager
                 |-> KeyDatabase
ChannelManager <-|
                 |-> EventManager
  LoginManager <-|
   UserManager <-|
  TokenManager <-|
                 |-> PackageManager
                 |-> TestManager
                 |-> LogManager
]]></artwork>
            <postamble>Figure 1. Interface Relationship Diagram for CryptoModule</postamble>
          </figure>
        </t>
        <section title="CICM::CryptoModule Attributes">
          <figure>
            <preamble>Attribute CICM::CryptoModule::module_id</preamble>
            <artwork><![CDATA[readonly attribute CICM::ModuleId module_id;]]></artwork>
            <postamble>Unique identifier for this module.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::manufacturer</preamble>
            <artwork><![CDATA[readonly attribute CICM::CharString manufacturer;]]></artwork>
            <postamble>Name of cryptographic module manufacturer.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::model</preamble>
            <artwork><![CDATA[readonly attribute CICM::CharString model;]]></artwork>
          <postamble>Model of cryptographic module.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::serial_number</preamble>
            <artwork><![CDATA[readonly attribute CICM::CharString serial_number;]]></artwork>
            <postamble>Serial number of cryptographic module.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::module_version</preamble>
            <artwork><![CDATA[readonly attribute CICM::CharString module_version;]]></artwork>
            <postamble>Hardware version of cryptographic module.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::software_version</preamble>
            <artwork><![CDATA[readonly attribute CICM::CharString software_version;]]></artwork>
            <postamble>Currently executing software/firmware version number.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::driver_version</preamble>
            <artwork><![CDATA[readonly attribute CICM::CharString driver_version;]]></artwork>
            <postamble>CICM module-specific abstraction layer version number.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::library_version</preamble>
            <artwork><![CDATA[readonly attribute CICM::CharString library_version;]]></artwork>
            <postamble>CICM library version number.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::role</preamble>
            <artwork><![CDATA[readonly attribute CICM::RoleId role;]]></artwork>
            <postamble>Current security role in which module is operating.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::date_time</preamble>
            <artwork><![CDATA[attribute CICM::CharString date_time;]]></artwork>
            <postamble>Current date/time. Intended for use only with module services
            that require coarse-grained time (e.g., timestamp on a log), not
            for time-of-day encryption.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::sym_key_manager</preamble>
            <artwork><![CDATA[readonly attribute CICM::SymKeyManager sym_key_manager;]]></artwork>
            <postamble>Reference to CICM::SymKeyManager.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::asym_key_manager</preamble>
            <artwork><![CDATA[readonly attribute CICM::AsymKeyManager asym_key_manager;]]></artwork>
            <postamble>Reference to CICM::AsymKeyManager.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::key_database</preamble>
            <artwork><![CDATA[readonly attribute CICM::KeyDatabase key_database;]]></artwork>
            <postamble>Reference to CICM::KeyDatabase.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::channel_manager</preamble>
            <artwork><![CDATA[readonly attribute CICM::ChannelManager channel_manager;]]></artwork>
            <postamble>Reference to CICM::ChannelManager.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::event_manager</preamble>
            <artwork><![CDATA[readonly attribute CICM::ModuleEventManager event_manager;]]></artwork>
            <postamble>Reference to CICM::ModuleEventManager.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::package_manager</preamble>
            <artwork><![CDATA[readonly attribute CICM::PackageManager package_manager;]]></artwork>
            <postamble>Reference to CICM::PackageManager.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::token_manager</preamble>
            <artwork><![CDATA[readonly attribute CICM::TokenManager token_manager;]]></artwork>
            <postamble>Reference to CICM::TokenManager.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::user_manager</preamble>
            <artwork><![CDATA[readonly attribute CICM::UserManager user_manager;]]></artwork>
            <postamble>Reference to CICM::UserManager.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::login_manager</preamble>
            <artwork><![CDATA[readonly attribute CICM::LoginManager login_manager;]]></artwork>
            <postamble>Reference to CICM::LoginManager.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::test_manager</preamble>
            <artwork><![CDATA[readonly attribute CICM::TestManager test_manager;]]></artwork>
            <postamble>Reference to CICM::TestManager.</postamble>
          </figure>
          <figure>
            <preamble>Attribute CICM::CryptoModule::log_manager</preamble>
            <artwork><![CDATA[readonly attribute CICM::LogManager log_manager;]]></artwork>
            <postamble>Reference to CICM::LogManager.</postamble>
          </figure>
        </section>
        <section title="CICM::CryptoModule Methods">
          <figure>
            <preamble>Method CICM::CryptoModule::configure_fill_interface()</preamble>
<artwork><![CDATA[CICM::Status configure_fill_interface(
in  CICM::Buffer interface_parameters,
in  CICM::LocalPort fill_port
);]]></artwork>
            <postamble>Configure a module key fill interface.</postamble>
          </figure>
          <t>Remarks:
            <list>
              <t>This method accepts an opaque buffer containing a
              module-specific data structure specifying fill port
              configuration parameters.</t>
              <t>The format of the interface parameters value is not defined
              by CICM. The Implementation Conformance Statement
              (see <xref target="conform" />) MUST reference a standard format
              or define a module developer-specific format implemented by the module for this datatype.</t>
            </list>
          </t><t>Parameters:
            <list>
              <t>[in] interface_parameters Opaque buffer containing
              the fill interface configuration parameters.</t>
              <t>[in] fill_port Fill port to configure.</t>
            </list>
          </t><t>Returns:
            <list>
              <t>S_OK, S_GENERAL_ERROR,
            S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
            S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
            S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
            S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_DATA_BUFFER,
            S_KEY_FILL_DEVICE_NOT_CONNECTED, S_LOCAL_PORT_INVALID,
            S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
            S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
            </list>
          </t>

          <figure>
            <preamble>Method CICM::CryptoModule::reset()</preamble>
            <artwork><![CDATA[CICM::Status reset();]]></artwork>
            <postamble>Perform a software-initiated reset on the module.</postamble>
          </figure>
          <t>Remarks:
            <list>
              <t>This method attempts to restart a module in the event of a
              module failure or in the event a module has entered an alarm
              state. A CICM::S_OK status denotes that the command was
              accepted by the module or runtime system, not that any specific
              action has been initiated as a result of the reset
              request.</t>
            </list>
          </t><t>Returns:
            <list>
              <t>S_OK, S_GENERAL_ERROR,
                S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
                S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
                S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
                S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
                S_TOKEN_ADMIN_NOT_PRESENT</t>
            </list>
          </t>
        </section>
      </section>
      <section title="Interface CICM::Iterator">
        <figure>
          <preamble>Interface CICM::Iterator</preamble>
          <artwork><![CDATA[interface Iterator]]></artwork>
          <postamble>Interface from which other iterators are inherited.</postamble>
        </figure>
        <t>Remarks:
          <list>
            <t>The specification does not define any specific order in which
            iterated elements are returned.</t>
          </list>
        </t>

        <section title="CICM::Iterator Types and Constants">
          <figure>
            <preamble>Type CICM::Iterator::Status</preamble>
            <artwork><![CDATA[typedef CICM::UInt32 Status;]]></artwork>
            <postamble>Indicates whether or not there are more items over which to
            iterate.</postamble>
          </figure>
          <figure>
            <preamble>Constant CICM::Iterator::C_ITERATOR_HAS_NEXT</preamble>
<artwork><![CDATA[const CICM::Iterator::Status
  C_ITERATOR_HAS_NEXT = 0x00006031;]]></artwork>
            <postamble>There are more items in the list.</postamble>
          </figure>
          <figure>
            <preamble>Constant CICM::Iterator::C_ITERATOR_NO_MORE</preamble>
<artwork><![CDATA[const CICM::Iterator::Status
  C_ITERATOR_NO_MORE = 0x00006032;]]></artwork>
            <postamble>There are no more items in the list.</postamble>
          </figure>
        </section>
        <section title="CICM::Iterator Methods">
          <figure>
            <preamble>Method CICM::Iterator::has_next()</preamble>
<artwork><![CDATA[CICM::Status has_next(
out CICM::Iterator::Status has_next
);]]></artwork>
            <postamble>Used with get_next() to determine if one or more additional
            elements are available to be retrieved.</postamble>
          </figure>
          <t>Remarks:
            <list>
              <t>For elements that have not already been processed, changes
              in the state of the list/database over which the iterator is
              being run during the lifetime of the iterator will be reflected
              in the results from calls to retrieve iterator elements.</t>
            </list>
          </t><t>Parameters:
            <list>
              <t>[out] has_next Indicates whether more elements are available to be retrieved.</t>
            </list>
          </t><t>Returns:
            <list>
              <t>S_OK, S_GENERAL_ERROR,
              S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
              S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
              S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
              S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
              S_TOKEN_ADMIN_NOT_PRESENT</t>
            </list>
          </t>
        </section>
      </section>
    </section>
  </section>
  <section title="Module Management">
    <t>Module management capabilities are defined in <xref target="CICM-MM" />.</t>
  </section>
  <section title="Key Management">
    <t>Key management capabilities are defined in <xref target="CICM-KM" />.</t>
  </section>
  <section title="Channel Management">
    <t>Channel management capabilities are defined in <xref target="CICM-CM" />.</t>
  </section>
  <section anchor="conform" title="Conformance">
			<t>Many modules will not require the
			implementation of the full specification to support a module's
			capabilities. Thus, the CICM conformance model was developed to be
			flexible. This model does not normatively prescribe the
			implementation of specific functional subsets of the specification.
			Instead, CICM outlines a normative Implementation Conformance
			Statement (ICS) and associated documentation that MUST be supplied
			with any conformant implementation.</t>
			<t>The ICS guides the developer of a library for a specific module
			to record the implementation state and presence of extensions for
			each section of the specification. The gradations of the
			implementation state are relatively coarse: "implemented,"
			"partially implemented," or "not implemented." Extensions are
			identified as interface extensions or status code extensions, and
			are recorded as "existing" or "not-existing." An analysis of the
			resulting matrix enables a software developer using the API or an
			architect designing a system integrating with a specific
			cryptographic module to quickly determine if a developer's library
			will meet user requirements. Those specification sections marked
			"partially implemented" or for which extensions are indicated may
			require additional analysis to determine what elements have been
			extended or are not implemented, and the resulting repercussions on
			the system utilizing the library.</t>
			<t>CICM interfaces are organized into three major sections: module
			management, channel management, and key management. Each section is
			partitioned differently into logical subsections in the ICS. The
			module management section is partitioned into subsections by
			individual module managers. The channel management section is
			partitioned into subsections by channel type. The key
			management section is partitioned into subsections by the type of
			key and class of operation performed on the key.</t>
			<t>An Implementation Data Specification (IDS) based on the ICS also
			is required. For each implemented interface containing an
			opaque data parameter (module-specific or
			infrastructure-specific parameter not described in detail in the
			specification), the IDS requires a detailed specification of the
			data structure for each parameter.</t>
			<t>An implementation conforms to the specification if it meets the
			following conditions:
			<list style="symbols">
			  <t>A CICM library implementation MUST include only the subset
			  of interfaces corresponding to the functionality supported by the
			  module for which it was designed. The implementation MUST
			  implement the full subset of interfaces implemented by the
			  module. A library MUST implement a non-zero set of interfaces
			  corresponding to functionality implemented by the module that
			  reasonably maps back to the CICM interface and is appropriate for
			  the system in use.</t>
			  <t>A CICM library MUST minimally implement the CICMRoot and
			  CryptoModule interfaces, both fundamental parts of the
			  specification without which no other interfaces can be
			  implemented. The CryptoModule interfaces MUST implement
			  minimally one manager, which must be at least "partially"
			  implemented (e.g., simply implementing non-functional inherited
			  or dependent interfaces is non-conformant).</t>
			  <t>A CICM library MUST be made available with a corresponding ICS.</t>
			  <t>A CICM library MUST be made available with an IDS
			  corresponding to its ICS. The format of any module-specific data
			  structures defined as opaque data elements in the specification
			  with which a client program using CICM must have knowledge MUST
			  be documented by the module developer and MUST be made available
			  as the IDS. If the implementation implements no interfaces with
			  opaque data parameters and includes no extensions, the IDS MUST
			  state that the implementation requires no IDS entries.</t>
			  <t>A CICM interface is only conformant if it also implements any
			  inherited and all dependent interfaces (e.g., the interface
			  Encrypt::WithSignConduit defined in <xref target="CICM-CM" />
        requires that symmetric keys and asymmetric keysets defined in
        <xref target="CICM-KM" /> also be implemented). The exception is the
			  CICM::ChannelManager interface, which only requires the implementation of
			  one or more of its inherited interfaces.</t>
			  <t>Any interfaces that are not implemented precisely as
			  specified in the normative portion of the specification MUST be
			  identified as extensions to the specification.</t>
			  <t>Extensions to the CICM specification MUST NOT contradict nor
			  cause the non-conformance of functionality defined in the
			  normative specification, MUST follow the requirements and
			  guidelines of the normative specification, and MUST be clearly
			  described in supporting documentation.</t>
			  <t>Memory responsibilities and calling conventions MUST follow
			  the appropriate IDL language mapping conventions.</t>
        <!-- @todo(lnovikov@mitre.org) We need to provide a reference to "appropriate IDL language mapping conventions". -->
			</list></t>
			<section title="Implementation Conformance Statement Contents">
				<t>A library implementation conforming to the CICM specification MUST be
				accompanied by an ICS. The ICS is generated by the module developer
				or implementer of a CICM-conformant library for a specific
				cryptographic module configuration (including any associated
				hardware/firmware/software) and MUST contain the following
				information:
				<list style="symbols">
				  <t>Details regarding the product and version of the
				  specification to which it conforms, including:
				  <list style="symbols">
					<t>CICM version number</t>
					<t>Product manufacturer/name, version number (hardware,
					firmware, and software)</t>
					<t>Configuration details, including patch state</t>
					<t>Date of claim</t>
				  </list></t>

				  <t>Capability Support Matrix, listing the major sections of the
				  specification and their implementation state ("I"=implemented,
				  "P"=partially implemented, and "N"=not implemented), and the
				  presence of any extensions</t>
				  <t>List of developer-defined extensions to specification.
				  Extensions MUST be divided into four classes: Interface extensions,
				  status code extensions, event listener extensions,
				  and constant extensions. Extensions MUST be documented as
				  specified in the IDS.</t>
				  <t>List of unique identifiers for all supported cryptographic
				  algorithms, organized by class of algorithm, and all supported
				  key agreement protocols; each algorithm/protocol unique
				  identifier MUST be in CICM-specified format (refer to the
				  section <xref target="gen-uniq-id" format="title"/>).</t>
				</list></t>
				<t>The following represents a sample CICM ICS.</t>
        <figure><artwork><![CDATA[
Date of claim: January 1, 2011                              ExampleCorp


              CICMv1 Implementation Conformance Statement


1.  Product Claiming Conformance

   ExampleCorp ABC-XYZ, Version 1.2.3

2.  Capability Support Matrix

2.1  Module Management

   Columns
   1: Implementation State
   2: Interface Extensions                  | Impl   | Iface  | Codes
   3: Status Code Extensions                | State  | Exts   | Exts
   -----------------------------------------|--------|--------|--------
   EventManager                             |   I    |   N    |   N
   -----------------------------------------|--------|--------|--------
   TokenManager                             |   P    |   N    |   N
   -----------------------------------------|--------|--------|--------
   LoginManager                             |   I    |   N    |   N
   -----------------------------------------|--------|--------|--------
   UserManager                              |   P    |   I    |   I
   -----------------------------------------|--------|--------|--------
   TestManager                              |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   LogManager                               |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   PackageManager                           |   P    |   N    |   N

2.2  Key Management

   Columns
   1: Implementation State
   2: Interface Extensions                  | Impl   | Iface  | Codes
   3: Status Code Extensions                | State  | Exts   | Exts
   -----------------------------------------|--------|--------|--------
   AsymKeyManager                           |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   SymKeyManager                            |   P    |   N    |   N
   -----------------------------------------|--------|--------|--------
   KeyDatabase                              |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   KeyProtocol                              |   N    |   N    |   N

2.3  Channel Management

   Columns
   1: Implementation State
   2: Interface Extensions                  | Impl   | Iface  | Codes
   3: Status Code Extensions                | State  | Exts   | Exts
   -----------------------------------------|--------|--------|--------
   EventManager                             |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Groups                                   |   N    |   N    |   N

2.3.1  Encrypt

   Columns
   1: Implementation State
   2: Interface Extensions                  | Impl   | Iface  | Codes
   3: Status Code Extensions                | State  | Exts   | Exts
   -----------------------------------------|--------|--------|--------
   Encrypt::Stream                          |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Encrypt::Controller                      |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Encrypt::NegotiatedController            |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Encrypt::Conduit                         |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Encrypt::NegotiatedConduit               |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Encrypt::WithMACConduit                  |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Encrypt::WithMACNegotiatedConduit        |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Encrypt::WithSignConduit                 |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Encrypt::WithSignNegotiatedConduit       |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Encrypt::KeyWrapConduit                  |   N    |   N    |   N

2.3.2  Encrypt with Selective Bypass

   Columns
   1: Implementation State
   2: Interface Extensions                  | Impl   | Iface  | Codes
   3: Status Code Extensions                | State  | Exts   | Exts
   -----------------------------------------|--------|--------|--------
   EncryptBypass::Stream                    |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   EncryptBypass::Controller                |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   EncryptBypass::NegotiatedController      |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   EncryptBypass::Conduit                   |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   EncryptBypass::NegotiatedConduit         |   N    |   N    |   N

2.3.3  Decrypt

   Columns
   1: Implementation State
   2: Interface Extensions                  | Impl   | Iface  | Codes
   3: Status Code Extensions                | State  | Exts   | Exts
   -----------------------------------------|--------|--------|--------
   Decrypt::Stream                          |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Decrypt::Controller                      |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Decrypt::NegotiatedController            |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Decrypt::Conduit                         |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Decrypt::NegotiatedConduit               |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Decrypt::WithMACConduit                  |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Decrypt::WithMACNegotiatedConduit        |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Decrypt::WithVerifyConduit               |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Decrypt::WithVerifyNegotiatedConduit     |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Decrypt::KeyUnwrapConduit                |   N    |   N    |   N

2.3.4  Decrypt with Selective Bypass

   Columns
   1: Implementation State
   2: Interface Extensions                  | Impl   | Iface  | Codes
   3: Status Code Extensions                | State  | Exts   | Exts
   -----------------------------------------|--------|--------|--------
   DecryptBypass::Stream                    |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   DecryptBypass::Controller                |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   DecryptBypass::NegotiatedController      |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   DecryptBypass::Conduit                   |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   DecryptBypass::NegotiatedConduit         |   N    |   N    |   N

2.3.5  Duplex

   Columns
   1: Implementation State
   2: Interface Extensions                  | Impl   | Iface  | Codes
   3: Status Code Extensions                | State  | Exts   | Exts
   -----------------------------------------|--------|--------|--------
   Duplex::Stream                           |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Duplex::Controller                       |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Duplex::NegotiatedController             |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Duplex::Conduit                          |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Duplex::NegotiatedConduit                |   N    |   N    |   N

2.3.6  Full Bypass (Write)

   Columns
   1: Implementation State
   2: Interface Extensions                  | Impl   | Iface  | Codes
   3: Status Code Extensions                | State  | Exts   | Exts
   -----------------------------------------|--------|--------|--------
   BypassWrite::Stream                      |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   BypassWrite::Controller                  |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   BypassWrite::Conduit                     |   N    |   N    |   N

2.3.7  Full Bypass (Read)

   Columns
   1: Implementation State
   2: Interface Extensions                  | Impl   | Iface  | Codes
   3: Status Code Extensions                | State  | Exts   | Exts
   -----------------------------------------|--------|--------|--------
   BypassRead::Stream                       |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   BypassRead::Controller                   |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   BypassRead::Conduit                      |   N    |   N    |   N

2.3.8  Emit

   Columns
   1: Implementation State
   2: Interface Extensions                  | Impl   | Iface  | Codes
   3: Status Code Extensions                | State  | Exts   | Exts
   -----------------------------------------|--------|--------|--------
   Emit::RandomController                   |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Emit::RandomConduit                      |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Emit::PseudorandomController             |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Emit::PseudorandomConduit                |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Emit::KeyStreamGenController             |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Emit::KeyStreamGenConduit                |   N    |   N    |   N

2.3.9  Integrity

   Columns
   1: Implementation State
   2: Interface Extensions                  | Impl   | Iface  | Codes
   3: Status Code Extensions                | State  | Exts   | Exts
   -----------------------------------------|--------|--------|--------
   Answer::HashConduit                      |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Answer::MACConduit                       |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Answer::MACVerifyConduit                 |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Answer::SignConduit                      |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Answer::VerifyHashConduit                |   N    |   N    |   N

2.3.10  Single-Domain

   Columns
   1: Implementation State
   2: Interface Extensions                  | Impl   | Iface  | Codes
   3: Status Code Extensions                | State  | Exts   | Exts
   -----------------------------------------|--------|--------|--------
   Coprocessor::EncryptConduit              |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Coprocessor::EncryptWithMACConduit       |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Coprocessor::EncryptWithSignConduit      |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Coprocessor::DecryptConduit              |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Coprocessor::DecryptWithMACConduit       |   N    |   N    |   N
   -----------------------------------------|--------|--------|--------
   Coprocessor::DecryptWithVerifyConduit    |   N    |   N    |   N

3.  Extensions

3.1.  Interface Extensions

   CICM::UserManager::enable()

   CICM::UserManager::disable()

3.2  Status Code Extensions

   CICM::S_USER_ALREADY_ENABLED

   CICM::S_USER_ALREADY_DISABLED

3.3  Module / Channel Event Listener Extensions

   None

3.4  Constant Extensions

   None

4.  Supported Algorithms

   AES128-CBC

   3DES-OFB
]]></artwork></figure>
			</section>
			<section title="Implementation Data Specification Contents">
				<t>The IDS serves
				as the detailed supporting documentation for the ICS. Conformance
				with the CICM specification requires that:
				<list style="symbols">
				  <t>Each implemented interface that accepts an opaque data object
				  MUST reference an existing standard or document the data
				  structure associated with that object in sufficient detail to
				  allow an implementer to create new objects and manipulate
				  existing objects. The exception to this requirement is those
				  cases where a client program will NOT be allowed to manipulate
				  the opaque data object (e.g.,
				  CICM::KeyProtocolReceiver::get_from_module defined in <xref target="CICM-KM" /> or
				  CICM::PackageImporter::import_segment defined in <xref target="CICM-MM" />).</t>
				  <t>Each interface extension listed in the ICS MUST be clearly
				  described in the IDS and MUST be documented in a manner similar
				  to the normative CICM documentation.</t>
				  <t>Each status code extension listed in the ICS MUST be
				  referenced in the IDS with a corresponding description, numeric
				  code, and a list of CICM interfaces to which the extension
				  applies.</t>
				  <t>Each module or channel event listener extension listed in the
				  ICS MUST be referenced in the IDS with corresponding
				  description, numeric code, and data structure definition
				  associated with the event_data parameter, if applicable.</t>
				  <t>Each extended constant value listed in the ICS MUST be
				  referenced in the IDS with corresponding description and numeric
				  code.</t>
				</list></t>
				<t>Examples of interfaces requiring an IDS entry to be conformant
				include:
				<list style="symbols">
				  <t>CICM::SymKeyManager::get_key_by_id defined in <xref target="CICM-KM" />,
          where the key identifier is specific to the key management system in use.</t>
				  <t>CICM::LogManager::retrieve defined in <xref target="CICM-MM" />,
          where the log returned from the method call will vary from module-to-module.</t>
				  <t>CICM::ModuleEventListener::event_occurred defined in <xref target="CICM-MM" />,
          where the event_data parameter passed to a client program as part of an
				  event notification is system specific.</t>
				</list></t>
				<t>Note that the event listener callbacks
				(CICM::ModuleEventListener::event_occurred and
				CICM::ChannelEventListener::event_occurred) require that the
				event_data parameter be described for each event type implemented.</t>
			</section>
			<section anchor="gen-uniq-id" title="Generating Unique Identifiers">
				<t>CICM does not provide a list
				of algorithms with their corresponding normative unique
				identifiers. Instead, normative guidance is provided for generating
				the identifiers for the different classes of algorithms defined in
				the specification and for key agreement protocols. These
				identifiers are used by software developers when specifying
				algorithms or protocols as parameters to CICM methods. This
				identifier generation guidance is intended to promote
				interoperability, and encourage the use of the same identifier for
				algorithms among vendors.</t>
				<!-- @todo(lnovikov@mitre.org) We need to use ABNF notation. -->
				<t>Three major components may be combined to form a unique
				algorithm identifier: an algorithm (ALGO), that may be precisely
				specified as an encryption algorithm (ENCRALGO), signature
				algorithm (SIGALGO), MAC algorithm (MACALGO), or hash algorithm
				(HASHALGO); a mode (MODE); and an encoding scheme (SCHEME), that
				may be precisely specified as an encryption scheme (ENCRSCHEME) or
				a signature scheme (SIGSCHEME). Note that some components above may
				not apply to certain algorithms. In addition, applicable modes and
				components need not always be specified. For encryption and
				signature algorithms, if a length is required, the length SHALL be
				appended to the algorithm without a dash ("-") delimiter.
				Otherwise, components are concatenated with a dash ("-").</t>
				<t>Alternatively, an identifier can consist of a simple personality
				designation (PERSONALITY). The personality consists of a
				combination of parameters that comprise a logically complete
				crypto, and specifies a specific equipment type or configuration
				for which algorithm, mode, and any other parameters are implicit.
				The designation may contain dashes.</t>
				<t>Certain algorithms may be appropriate for and thus listed under
				more than one algorithm class. Below are the classes of algorithms
				and format of the identifiers for each class:</t>
				<t>Asymmetric encryption algorithm identifiers (AsymEncrAlgorithmId)
					<list>
						<t>Format: ENCRALGO [ "-" ENCRSCHEME ] | PERSONALITY</t>
						<t>Examples: "RSA1024-OAEP"</t>
					</list>
				</t><t>Asymmetric signature algorithm identifiers (AsymSigAlgorithmId)
					<list>
						<t>Format: SIGALGO [ "-" HASHALGO [ "-" SIGSCHEME ]] | PERSONALITY</t>
						<t>Examples: "DSA-SHA1" or "RSA1024-SHA256-PKCS1V1_5"</t>
					</list>
				</t><t>Symmetric encryption algorithm identifiers (SymEncrAlgorithmId)
					<list>
						<t>Format: ENCRALGO | PERSONALITY</t>
						<t>Examples: "AES128" or "3DES"</t>
					</list>
				</t><t>Symmetric MAC algorithm identifiers (SymMacAlgorithmId)
					<list>
						<t>Format: MACALGO [ - HASHALGO ] | PERSONALITY</t>
						<t>Examples: "HMAC-SHA1" or "UMAC"</t>
					</list>
				</t><t>Hash algorithm identifiers (HashAlgorithmId)
					<list>
						<t>Format: HASHALGO | PERSONALITY</t>
						<t>Examples: "MD5" or "SHA1"</t>
					</list>
				</t><t>Key wrap algorithm identifiers (KeyWrapAlgorithmId)
					<list>
						<t>Format: ENCRALGO | PERSONALITY</t>
						<t>Examples: AESKW</t>
					</list>
				</t>
				<t>Two major components may be combined to form a key agreement
				protocol identifier: the key agreement protocol including its
				version number (KEYAGREEPROTO) and the protocol's associated
				algorithm suite including its version number (ALGOSUITE). The
				following is the format for key agreement protocol identifiers.</t>
				<t>Key agreement protocol identifier (ProtocolId)
					<list>
						<t>Format: KEYAGREEPROTO "-" ALGOSUITE</t>
						<t>Examples: "IKE2.0-FIREFLY"</t>
					</list>
				</t>
				<t>Note that the resulting identifiers may not be compatible with
				those identifiers defined for other module developers'
				implementations. A client program utilizing an identifier
				corresponding to one algorithm for a specific module may be
				required to modify the identifier for the same algorithm for a
				different type of module. Discrepancies may be discovered through a
				brief review of the ICS "Supported Algorithms" section.</t>
			</section>
			<section title="Conformance Verification">
				<t>In the future, test assertions may
				be made available to allow results from different organizations to
				be compared, and to provide proof of conformance to the
				specification.</t>
			</section>
  </section>
  <section anchor="extend" title="Extensions">
			<t>An extension is a mechanism to define
			functionality beyond what is defined in the official specification.
			In the interest of promoting interoperability, extensions to the
			specification are discouraged except where necessary. Extensions to
			the specification enable module developers to add functionality
			unanticipated by the specification developers and to support
			proprietary features.</t>

			<section title="Extending an Interface">
				<t>Developers may augment CICM
				interfaces by extending CICM IDL by adding new methods/attributes
				to existing interfaces or by deriving off existing CICM interfaces.
				Extensions SHALL be documented in the ICS.</t>
			</section>
			<section title="Extending Codes">
				<t>CICM codes are constants that share a
				single 32-bit space. A number of datatypes for different purposes
				correspond to ranges in this space. The "CICM" codes are
				normatively defined in the specification; the "extended" codes are
				module developer-defined extensions. The codes, with their
				corresponding ranges and uses, are as follows:</t>
				<t>CICM status codes
					<list><t>0x00000000 - 0x00001000</t></list>
				</t><t>Extended status codes
					<list><t>0x00001001 - 0x00002000</t></list>
				</t><t>CICM module event codes
					<list><t>0x00002001 - 0x00003000</t></list>
				</t><t>Extended module event codes
					<list><t>0x00003001 - 0x00004000</t></list>
				</t><t>CICM channel event codes
					<list><t>0x00004001 - 0x00005000</t></list>
				</t><t>Extended channel event codes
					<list><t>0x00005001 - 0x00006000</t></list>
				</t><t>CICM generic constants
					<list><t>0x00006001 - 0x00007000</t></list>
				</t><t>Extended generic constants
					<list><t>0x00007001 - 0x00008000</t></list>
				</t><t>RESERVED
					<list><t>0x00008001 - 0x7FFFFFFF</t></list>
				</t>
				<t>Normatively-defined CICM codes SHOULD be used whenever possible.
				If any of the extended codes above are defined, they MUST be
				documented as specified below.</t>

				<section title="Extending Status Codes">
					<t>The return value from CICM methods
					informs the caller of the status of the call. CICM does not use
					the IDL exception mechanism to report errors.</t>
					<t>The specification normatively defines a set of error codes in
					the range of 0x00000000 - 0x00001000, which may not be modified or extended. A
					block of codes in the range of 0x00001001 - 0x00002000 are reserved for
          module developer-defined status codes.
          Any codes defined in this range MUST be documented
					in the ICS.</t>
				</section>
				<section title="Extending Module/Channel Event Codes">
					<t>The specification
					supports registering and unregistering user-defined channel event
					listeners for specific module and channel events. Module events in
					the range of 0x00003001 - 0x00004000 and channel events in the range of
					0x00004001 - 0x00005000 are normatively defined and may not be
					modified or extended. A block of module events in the range
					0x00003001 - 0x00004000 and channel events in the range of
					0x00005001 - 0x00006000 are reserved for module developer-defined
					events. Any codes defined in this range MUST be documented in the
					ICS.</t>
				</section>
				<section title="Extending Constants">
					<t>A number of constants are normatively
					defined for specification use in the range of
					0x00006001 - 0x00007000. Module developer-defined constants may be
					specified in the range of 0x00007001 - 0x00008000.
					Any constants defined in this range MUST be documented in the ICS.</t>
				</section>
			</section>
  </section>
    <section title="IANA Considerations">
      <t>[RFC Editor: Please remove this section prior to publication.]</t>
      <t>This document has no IANA actions.</t>
    </section>
    <section title="Security Considerations">
      <t>This document defines basic aspects of the CICM specification and the normative rules
      for conformance and extensions. Other aspects of CICM contain important security considerations.</t>

      <section title="Unauthorized Usage">
        <t>CICM provides several interfaces related to mitigating unauthorized usage
        in <xref target="CICM-MM" />. Furthermore, <xref target="CICM-KM" /> discusses
        aspects of how authorization can be indirectly controlled via key white lists and black lists.</t>
      </section>
      <section title="Inappropriate Usage">
        <t>CICM defines several status codes related to inappropriate usage. For example, attempting to use
        an invalid key (S_KEY_INVALID) or specifying an inappropriate algorithm (S_ALGO_INVALID).
        The wide range of status codes relate to the anticipated mechanisms in which using the interface
        may fail. Additionally, module developers can extend the set of status codes to accommodate their
        own needs and prevent inappropriate usage.</t>
      </section>
    </section>
    <section title="Acknowledgments">
			<t>Many individuals participated in the development and review of
			the CICM specification. The CICM development team consists of
			Ronald Albuquerque, Samuel Cardman, Greg Carrier, James Cottrell,
			Shirley Kawamoto, Daniel Lanz, Brent Midwood, Lev Novikov, Brian
			O'Hanlon, Rick Page, Adam Pennington, and Nguyen Thai. The document
			production team consists of Mark Dwyer, Amanda Lind, and Brian
			Parrish.</t>
			<t>The CICM team wishes to thank the following individuals for
			participating in a review of the specification:</t>
			<t><list>
				<t>Bill Beckwith, Objective Interface Systems</t>
				<t>Dennis Bourget, Viasat</t>
				<t>Thom Brooke, Linquest Corporation</t>
				<t>Randy Culver, RT Logic</t>
				<t>John Davis, ITT Corporation</t>
				<t>Eric Dube, The MITRE Corporation</t>
				<t>Jan Duffy, Rockwell Collins</t>
				<t>H.J. Eckles, General Dynamics</t>
				<t>Mark Flinchbaugh, Harris Corporation</t>
				<t>Carolyn Francisco, The MITRE Corporation</t>
				<t>James Howard, L-3 Communications</t>
				<t>Kent Kofstad, The MITRE Corporation</t>
				<t>Hema Krishnamurthy, ITT Corporation</t>
				<t>Prithvi Kumar, The MITRE Corporation</t>
				<t>Chip McGrogan, L-3 Communications</t>
				<t>Hank Morris, Concurrent Technologies Corporation</t>
				<t>Jeff Picciotto, The MITRE Corporation</t>
				<t>Tom Plachecki, General Dynamics</t>
				<t>Ray Purvis, The MITRE Corporation</t>
				<t>Mike Ridge, The MITRE Corporation</t>
				<t>Harry Shaffer, The MITRE Corporation</t>
				<t>Patrick Smith, Linquest Corporation</t>
				<t>Wayne Staats, Rockwell Collins</t>
				<t>James Steinwachs, Harris Corporation</t>
				<t>Porter Taylor, The MITRE Corporation</t>
				<t>Otaway Thomas, Arkham Technology</t>
				<t>Bob Walcott, The MITRE Corporation</t>
				<t>Blane Yamamoto, SafeNet Mykotronx</t>
			</list></t>
		</section>
  </middle>
  <back><!-- Back material. -->
    <references title="Normative References">
      <?rfc include="reference.RFC.2119" ?>

      <reference anchor="CICM">
        <front>
          <title>Common Interface to Cryptographic Modules (CICM)
          [RFC Editor: Please update the RFC reference and date prior to publication.]</title>
          <author fullname="Daniel J. Lanz" initials="D." surname="Lanz" />
          <author fullname="Lev Novikov" initials="L." surname="Novikov" />
          <date year="2011" month="January" />
        </front>
        <format type="TXT" target="http://tools.ietf.org/id/draft-lanz-cicm-02.txt" />
      </reference>

      <reference anchor="CICM-MM">
        <front>
          <title>Common Interface to Cryptographic Modules (CICM) Module Management
          [RFC Editor: Please update the RFC reference and date prior to publication.]</title>
          <author fullname="Daniel J. Lanz" initials="D." surname="Lanz" />
          <author fullname="Lev Novikov" initials="L." surname="Novikov" />
          <date year="2011" month="January" />
        </front>
        <format type="TXT" target="http://tools.ietf.org/id/draft-lanz-cicm-mm-00.txt" />
      </reference>

      <reference anchor="CICM-KM">
        <front>
          <title>Common Interface to Cryptographic Modules (CICM) Key Management
          [RFC Editor: Please update the RFC reference and date prior to publication.]</title>
          <author fullname="Daniel J. Lanz" initials="D." surname="Lanz" />
          <author fullname="Lev Novikov" initials="L." surname="Novikov" />
          <date year="2011" month="January" />
        </front>
        <format type="TXT" target="http://tools.ietf.org/id/draft-lanz-cicm-km-00.txt" />
      </reference>

      <reference anchor="CICM-CM">
        <front>
          <title>Common Interface to Cryptographic Modules (CICM) Channel Management
          [RFC Editor: Please update the RFC reference and date prior to publication.]</title>
          <author fullname="Daniel J. Lanz" initials="D." surname="Lanz" />
          <author fullname="Lev Novikov" initials="L." surname="Novikov" />
          <date year="2011" month="January" />
        </front>
        <format type="TXT" target="http://tools.ietf.org/id/draft-lanz-cicm-cm-00.txt" />
      </reference>

      <reference anchor="IDL">
        <front>
          <title>Information technology  Open Distributed Processing  Interface Definition Language</title>
          <author>
            <organization>International Standards Organization</organization>
          </author>
          <date year="1999" month="March" day="15" />
        </front>
        <seriesInfo name="ISO/IEC" value="14750:1999(E)" />
      </reference>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.3552" ?>

      <reference anchor="CICM-LM">
        <front>
          <title>Common Interface to Cryptographic Modules (CICM) Logical Model
          [RFC Editor: Please update the RFC reference and date prior to publication.]</title>
          <author fullname="Daniel J. Lanz" initials="D." surname="Lanz" />
          <author fullname="Lev Novikov" initials="L." surname="Novikov" />
          <date year="2011" month="January" />
        </front>
        <format type="TXT" target="http://tools.ietf.org/id/draft-lanz-cicm-lm-00.txt" />
      </reference>

      <reference anchor="CORBA"><front>
        <title>Common Object Request Broker Architecture (CORBA) Specification, Version 3.1</title>
        <author>
          <organization>Object Management Group</organization>
        </author>
        <date year="2008" month="January" />
      </front></reference>
    </references>
    <section anchor="status-codes" title="Status Codes">
		<t>Each method defined in CICM returns a status
		value to inform the caller as to the outcome of the call. The
		documentation for each individual method lists the status codes
		that may be returned in the event a call to the method results in
		failure.</t>
		<t>The status value CICM::S_OK is returned if a method completes
		successfully. The output parameters of any methods that return a
		status other than CICM::S_OK are invalid and MUST NOT be
		referenced or used.</t>
		<t>CICM methods can fail for a variety of reasons, including:
		<list style="symbols">
		  <t>Invalid, illegal, out-of-range, or poorly formed
		  parameters</t>
		  <t>Resources insufficient or unavailable</t>
		  <t>Unsupported capabilities</t>
		  <t>Policy violation</t>
		  <t>Hardware failure.</t>
		</list></t>
		<t>For additional information concerning extending status codes,
		see <xref target="extend" format="title" />.</t>
		<t>CICM status codes are defined below.</t>

		<t>S_OK = 0x00000000<list><t>No error.</t></list></t>
		<t>S_GENERAL_ERROR = 0x00000003<list><t>Unrecoverable error occurred, potentially leaving module in an inconsistent state.</t></list></t>
		<t>S_NON_FUNCTIONAL = 0x00000005<list><t>Tamper event or other condition has rendered module non-functional.</t></list></t>
		<t>S_OPERATION_FAILED = 0x00000006<list><t>Method encountered a general failure, but detailed information about the failure is not available.</t></list></t>
		<t>S_POLICY_VIOLATION = 0x00000009<list><t>Module policy does not permit the requested action.</t></list></t>
		<t>S_MODULE_RESOURCES = 0x0000000A<list><t>Module resources necessary to perform the requested operation are not available.</t></list></t>
		<t>S_HOST_RESOURCES = 0x0000000C<list><t>Host resources necessary to perform the requested operation are not available.</t></list></t>
		<t>S_INVALID_STATE = 0x0000000F<list><t>Module is in a state that does not allow this operation to be performed.</t></list></t>
		<t>S_ALARM_STATE = 0x00000011<list><t>Module has entered an alarm state.</t></list></t>
		<t>S_MODULE_NOT_AVAILABLE = 0x00000012<list><t>Module has been powered down, disconnected, or is otherwise unavailable..</t></list></t>
		<t>S_TIMEOUT = 0x00000014<list><t>Time to receive response from call exceeded threshold.</t></list></t>
		<t>S_NOT_AUTHENTICATED = 0x00000017<list><t>User has not authenticated to module.</t></list></t>
		<t>S_NOT_AUTHORIZED = 0x00000018<list><t>User is not authorized to call method.</t></list></t>
		<t>S_MODULE_DOES_NOT_EXIST = 0x0000001B<list><t>No module with the specified unique identifier exists.</t></list></t>
		<t>S_MODULE_IN_USE = 0x0000001D<list><t>Module test initiated when channels or other module resources are in use.</t></list></t>
		<t>S_NOT_AVAILABLE = 0x0000001E<list><t>Information is not available or cannot be found.</t></list></t>
		<t>S_INVALID_VECTOR = 0x00000021<list><t>Invalid vector provided; this may be because the length or format of the vector is inappropriate for the algorithm or system with which the vector is being used.</t></list></t>
		<t>S_INVALID_DATA_BUFFER = 0x00000022<list><t>Data in user-specified buffer parameter is invalid.</t></list></t>
		<t>S_KEY_USED_INVALID = 0x00000024<list><t>Key specified as parameter to method is invalid; this could denote that the key has been zeroized, a failed parity check, or other conditions that prevent the use of the key.</t></list></t>
		<t>S_KEY_USED_EXPIRED = 0x00000027<list><t>Key specified as parameter to method has expired and may not be used.</t></list></t>
		<t>S_KEY_USED_CLASSIFICATION = 0x00000028<list><t>Key specified as parameter to method at wrong classification level.</t></list></t>
		<t>S_KEY_USED_WRAPPED = 0x0000002B<list><t>Key specified as parameter to method may not be used in the context until it has been unwrapped.</t></list></t>
		<t>S_KEY_USED_CONTEXT = 0x0000002D<list><t>Attempt to use key in an illegal context as defined by the module; e.g., a key is specified for use on a channel but, due to module architecture, the key is unavailable to that channel.</t></list></t>
		<t>S_KEY_USED_COMPONENT_NOT_AVAIL = 0x0000002E<list><t>Asymmetric key specified as parameter to method contains only a public key (possibly in a certificate) or only a private key, when the other component is needed by the called method.</t></list></t>
		<t>S_KEY_INVALID = 0x00000030<list><t>Key is invalid; this could denote that the key has been zeroized, a failed parity check, or other conditions that prevent the use of the key.</t></list></t>
		<t>S_KEY_EXPIRED = 0x00000033<list><t>Key has expired and may not be used.</t></list></t>
		<t>S_KEY_INCOMPATIBLE = 0x00000035<list><t>Key type (e.g., TEK, KEK) incompatible with intended usage.</t></list></t>
		<t>S_KEY_CLASSIFICATION = 0x00000036<list><t>Key at wrong classification level.</t></list></t>
		<t>S_KEY_WRAPPED = 0x00000039<list><t>Key may not be used in this context until it has been unwrapped.</t></list></t>
		<t>S_KEY_NOT_WRAPPED = 0x0000003A<list><t>Key is not wrapped.</t></list></t>
		<t>S_KEY_NOT_WRAPPABLE = 0x0000003C<list><t>Module is not able to wrap key.</t></list></t>
		<t>S_KEY_NOT_EXPORTABLE = 0x0000003F<list><t>Key is not exportable, potentially because it has not been wrapped or other policy disallows it.</t></list></t>
		<t>S_KEY_WRAPPED_EXISTS = 0x00000041<list><t>Wrapped key already exists.</t></list></t>
		<t>S_KEY_UNWRAPPED_EXISTS = 0x00000042<list><t>Unwrapped key already exists.</t></list></t>
		<t>S_KEY_UPDATE_MAX = 0x00000044<list><t>Maximum number of updates for this key has been exceeded.</t></list></t>
		<t>S_KEY_INVALID_ID = 0x00000047<list><t>Invalid key identifier specified.</t></list></t>
		<t>S_KEY_PHYSICAL_LOC = 0x00000048<list><t>Invalid key physical location specified.</t></list></t>
		<t>S_KEY_ILLEGAL_CONVERSION = 0x0000004B<list><t>Target algorithm is incompatible with algorithm associated with specified key.</t></list></t>
		<t>S_KEY_MALFORMED = 0x0000004D<list><t>Key material supplied is malformed.</t></list></t>
		<t>S_KEY_METADATA_MALFORMED = 0x0000004E<list><t>Key metadata supplied is malformed.</t></list></t>
		<t>S_KEY_NO_NEXT = 0x00000050<list><t>No next key available for rollover.</t></list></t>
		<t>S_KEY_WRONG_TYPE = 0x00000053<list><t>Illegal attempt to process a symmetric key with an asymmetric method or an asymmetric key with a symmetric method.</t></list></t>
		<t>S_KEY_FILL_DEVICE_NOT_CONNECTED = 0x00000055<list><t>Key fill device not connected.</t></list></t>
		<t>S_KEY_FILL_NOT_INITIATED = 0x00000056<list><t>Manual key fill device interaction not initiated within system-defined time limit.</t></list></t>
		<t>S_KEY_TRUST_ANCHOR = 0x00000059<list><t>Trust anchor required but is unavailable.</t></list></t>
		<t>S_LOCAL_PORT_INVALID = 0x0000005A<list><t>Local port specified is invalid.</t></list></t>
		<t>S_LOCAL_PORT_INCOMPATIBLE = 0x0000005C<list><t>Local port specified cannot be used in intended manner.</t></list></t>
		<t>S_LOCAL_PORT_IN_USE = 0x0000005F<list><t>Local port specified is currently in use.</t></list></t>
		<t>S_REMOTE_PORT_INVALID = 0x00000060<list><t>Remote port specified is invalid.</t></list></t>
		<t>S_REMOTE_PORT_IN_USE = 0x00000063<list><t>Remote port specified is currently in use.</t></list></t>
		<t>S_ALGO_INVALID = 0x00000065<list><t>Malformed string or unsupported/invalid algorithm specified.</t></list></t>
		<t>S_ALGO_INCOMPATIBLE = 0x00000066<list><t>Algorithm incompatible with intended usage (e.g., encryption, signature, hashing).</t></list></t>
		<t>S_TOKEN_NOT_PRESENT = 0x00000069<list><t>Token must be inserted to perform the requested operation and no token is available to the module.</t></list></t>
		<t>S_TOKEN_ADMIN_NOT_PRESENT = 0x0000006A<list><t>Administrator token must be inserted to perform the requested operation and either no token is present or the inserted token is not an administrator token.</t></list></t>
		<t>S_TOKEN_ACCESS = 0x0000006C<list><t>Token I/O error.</t></list></t>
		<t>S_TOKEN_RESOURCES = 0x0000006F<list><t>Token resources necessary to perform the requested operation are not available.</t></list></t>
		<t>S_TOKEN_ASSOC_EXISTS = 0x00000071<list><t>Association between module and token already exists.</t></list></t>
		<t>S_TOKEN_ASSOC_AT_MODULE = 0x00000072<list><t>Association failed because module will allow no new associations.</t></list></t>
		<t>S_TOKEN_ASSOC_AT_TOKEN = 0x00000074<list><t>Association failed because token will allow no new associations.</t></list></t>
		<t>S_TOKEN_ASSOC_NOT_EXIST = 0x00000077<list><t>Association between module and token does not exist at the module, at the token, or both.</t></list></t>
		<t>S_TOKEN_ASSOC_GENERAL = 0x00000078<list><t>Unspecified token association error occurred.</t></list></t>
		<t>S_TOKEN_DISASSOC_GENERAL = 0x0000007B<list><t>Unspecified token disassociation error occurred.</t></list></t>
		<t>S_TOKEN_REC_NOT_FOUND = 0x0000007D<list><t>Specified record not found.</t></list></t>
		<t>S_TOKEN_TIMEOUT = 0x0000007E<list><t>Timeout for insertion of token has been exceeded.</t></list></t>
		<t>S_TOKEN_LAST_ASSOCIATED = 0x00000081<list><t>Cannot disassociate the last associated token from this module.</t></list></t>
		<t>S_PACKAGE_NOT_ACTIVATABLE = 0x00000082<list><t>Specified package is not executable.</t></list></t>
		<t>S_PACKAGE_ACTIVATED = 0x00000084<list><t>Specified package is currently running.</t></list></t>
		<t>S_PACKAGE_NOT_ACTIVE = 0x00000087<list><t>Specified package is not currently running.</t></list></t>
		<t>S_PACKAGE_INVALID = 0x00000088<list><t>Specified package is invalid.</t></list></t>
		<t>S_PACKAGE_TYPE_INVALID = 0x0000008B<list><t>Specified package type is invalid.</t></list></t>
		<t>S_PACKAGE_KEY_NOT_AVAILABLE = 0x0000008D<list><t>Package is encrypted and the key specified for use to decrypt package is not available on the module.</t></list></t>
		<t>S_PACKAGE_KEY_NOT_SPECIFIED = 0x0000008E<list><t>Package is encrypted but no key is specified to decrypt it.</t></list></t>
		<t>S_LOG_ENTRY_INVALID = 0x00000090<list><t>Log entry is invalid.</t></list></t>
		<t>S_EVENT_REGISTERED = 0x00000093<list><t>An event has already been registered by this process for this event type.</t></list></t>
		<t>S_EVENT_NOT_REGISTERED = 0x00000095<list><t>An event has not been registered by this process for this event type.</t></list></t>
		<t>S_EVENT_NOT_SUPPORTED = 0x00000096<list><t>Event is not supported in this implementation.</t></list></t>
		<t>S_TRUSTED_DISPLAY = 0x00000099<list><t>Peer information is available at trusted display.</t></list></t>
		<t>S_NEGOTIATION_ABORTED = 0x0000009A<list><t>Negotiation was aborted.</t></list></t>
		<t>S_NEGOTIATION_FAILURE = 0x0000009C<list><t>Negotiation failed.</t></list></t>
		<t>S_NEGOTIATION_IN_PROGRESS = 0x0000009F<list><t>Negotiation is already in progress.</t></list></t>
		<t>S_NEGOTIATION_NOT_IN_PROGRESS = 0x000000A0<list><t>No negotiation has been initiated.</t></list></t>
		<t>S_NEGOTIATION_TIMEOUT = 0x000000A3<list><t>Negotiation timed out.</t></list></t>
		<t>S_CERT_LOCAL_INVALID = 0x000000A5<list><t>Local certificate used in a key negotiation is invalid; the certificate may be corrupted or does not verify.</t></list></t>
		<t>S_CERT_LOCAL_EXPIRED = 0x000000A6<list><t>Local certificate used in a key negotiation has expired.</t></list></t>
		<t>S_CERT_REMOTE_INVALID = 0x000000A9<list><t>Remote certificate used in a key negotiation is invalid; the certificate may be corrupted or does not verify.</t></list></t>
		<t>S_CERT_REMOTE_EXPIRED = 0x000000AA<list><t>Remote certificate used in a key negotiation has expired.</t></list></t>
		<t>S_CERT_REMOTE_PATH = 0x000000AC<list><t>Certificates to enable verification of remote certificate's certification path are not available.</t></list></t>
		<t>S_PROTO_INVALID = 0x000000AF<list><t>Malformed string or unsupported/invalid protocol specified.</t></list></t>
		<t>S_PROTO_INCOMPATIBLE = 0x000000B1<list><t>Protocol specified is incompatible with intended usage.</t></list></t>
		<t>S_PROTO_UNDETERMINED = 0x000000B2<list><t>An "implicit" protocol has been specified, but the protocol message does not indicate the protocol.</t></list></t>
		<t>S_CHANNEL_ERROR = 0x000000B4<list><t>Generic conduit/controller error encountered.</t></list></t>
		<t>S_CHANNEL_PEER_RESET = 0x000000B7<list><t>Peer crypto reset conduit/controller or conduit/controller ceased operation.</t></list></t>
		<t>S_CHANNEL_MAX = 0x000000B8<list><t>Limit on total number of conduits/controllers has been reached.</t></list></t>
		<t>S_CHANNEL_NOT_FOUND = 0x000000BB<list><t>Conduit/controller not found.</t></list></t>
		<t>S_CHANNEL_IO_ERROR = 0x000000BD<list><t>Conduit/controller I/O error.</t></list></t>
		<t>S_CHANNEL_DATA_INVALID = 0x000000BE<list><t>Input data to cryptographic operation is invalid (e.g., plaintext for encryption or ciphertext for decryption).</t></list></t>
		<t>S_CHANNEL_DATA_INVALID_LEN = 0x000000C0<list><t>Plaintext (for encryption) or ciphertext (for decryption) input data to cryptographic operation has an inappropriate length; this could denote that the data is too short, too long, or is not a multiple of some particular block size.</t></list></t>
		<t>S_CHANNEL_BUFFER_LEN = 0x000000C3<list><t>Output of function is too large for supplied buffer.</t></list></t>
		<t>S_CHANNEL_IN_GROUP = 0x000000C5<list><t>Conduit/controller already exists as part of group.</t></list></t>
		<t>S_CHANNEL_CLASSIFICATION = 0x000000C6<list><t>Conduits/controllers are not of the same classification.</t></list></t>
		<t>S_BYPASS_DATARATE_EXCEEDED = 0x000000C9<list><t>Bypass data rate exceeded.</t></list></t>
		<t>S_BYPASS_DATALIMIT_EXCEEDED = 0x000000CA<list><t>Bypass data limit exceeded.</t></list></t>
		<t>S_INTEGRITY = 0x000000CC<list><t>In those cases where an encryption algorithm supplies both confidentiality and integrity (an integrity value is transmitted with the ciphertext), the final decrypt may fail with this integrity error if the integrity check fails.</t></list></t>
		<t>S_AUTHENTICATION_FAILED = 0x000000CF<list><t>Authentication to the module failed; this could denote that a password is incorrect or that additional authentication data supplied is invalid.</t></list></t>
		<t>S_USER_AUTHENTICATED = 0x000000D1<list><t>Specified user has already authenticated to module.</t></list></t>
		<t>S_USERNAME_INVALID = 0x000000D2<list><t>Username is invalid.</t></list></t>
		<t>S_USER_EXISTS = 0x000000D4<list><t>User already exists.</t></list></t>
		<t>S_USER_INVALID = 0x000000D7<list><t>User does not exist.</t></list></t>
		<t>S_ROLE_INVALID = 0x000000D8<list><t>Role does not exist.</t></list></t>
		<t>S_ROLE_ASSOCIATED = 0x000000DB<list><t>User already associated with this role.</t></list></t>
		<t>S_ROLE_NOT_ASSOCIATED = 0x000000DD<list><t>User not associated with this role.</t></list></t>
		<t>S_ROLE_MAX = 0x000000DE<list><t>Maximum number of roles already associated with this user.</t></list></t>
		<t>S_PASSWORD_INVALID = 0x000000E1<list><t>Specified password does not meet module policy.</t></list></t>
		<t>S_PASSWORD_INVALID_CHAR = 0x000000E2<list><t>Specified password has invalid characters in it.</t></list></t>
		<t>S_PASSWORD_INVALID_LEN = 0x000000E4<list><t>Length of specified password is either too long or too short.</t></list></t>
		<t>S_SALT_INVALID = 0x000000E7<list><t>Invalid salt specified.</t></list></t>
		<t>S_ITERATION_COUNT_INVALID = 0x000000E8<list><t>Invalid iteration count specified.</t></list></t>
		<t>S_INSUFFICIENT_ENTROPY = 0x000000EB<list><t>Insufficient entropy available. </t></list></t>
    </section>
    <section anchor="idl-code" title="IDL Definitions"><figure><artwork><![CDATA[module CICM {
  typedef unsigned long UInt32;
  typedef string CharString;
  typedef sequence<octet> Buffer;

  typedef CICM::UInt32 LocalPort;
  typedef CICM::UInt32 RemotePort;

  const CICM::LocalPort FILL_INTERFACE_PORT = 0xFFFFFFEE;
  const CICM::LocalPort IMPLICIT_LOCAL_PORT = 0xFFFFFFBB;
  const CICM::RemotePort IMPLICIT_REMOTE_PORT = 0xFFFFFF99;

  typedef CICM::UInt32 Classification;
  const CICM::Classification C_LEVEL_CONFIDENTIAL = 0x00006029;
  const CICM::Classification C_LEVEL_SECRET = 0x0000602A;
  const CICM::Classification C_LEVEL_TOP_SECRET = 0x0000602C;
  const CICM::Classification C_LEVEL_UNCLASSIFIED = 0x0000602F;

  typedef CICM::UInt32 Status;
  const CICM::Status S_OK = 0x00000000;
  const CICM::Status S_GENERAL_ERROR = 0x00000003;
  const CICM::Status S_NON_FUNCTIONAL = 0x00000005;
  const CICM::Status S_OPERATION_FAILED = 0x00000006;
  const CICM::Status S_POLICY_VIOLATION = 0x00000009;
  const CICM::Status S_MODULE_RESOURCES = 0x0000000A;
  const CICM::Status S_HOST_RESOURCES = 0x0000000C;
  const CICM::Status S_INVALID_STATE = 0x0000000F;
  const CICM::Status S_ALARM_STATE = 0x00000011;
  const CICM::Status S_MODULE_NOT_AVAILABLE = 0x00000012;
  const CICM::Status S_TIMEOUT = 0x00000014;
  const CICM::Status S_NOT_AUTHENTICATED = 0x00000017;
  const CICM::Status S_NOT_AUTHORIZED = 0x00000018;
  const CICM::Status S_MODULE_DOES_NOT_EXIST = 0x0000001B;
  const CICM::Status S_MODULE_IN_USE = 0x0000001D;
  const CICM::Status S_NOT_AVAILABLE = 0x0000001E;
  const CICM::Status S_INVALID_VECTOR = 0x00000021;
  const CICM::Status S_INVALID_DATA_BUFFER = 0x00000022;
  const CICM::Status S_KEY_USED_INVALID = 0x00000024;
  const CICM::Status S_KEY_USED_EXPIRED = 0x00000027;
  const CICM::Status S_KEY_USED_CLASSIFICATION = 0x00000028;
  const CICM::Status S_KEY_USED_WRAPPED = 0x0000002B;
  const CICM::Status S_KEY_USED_CONTEXT = 0x0000002D;
  const CICM::Status S_KEY_USED_COMPONENT_NOT_AVAIL = 0x0000002E;
  const CICM::Status S_KEY_INVALID = 0x00000030;
  const CICM::Status S_KEY_EXPIRED = 0x00000033;
  const CICM::Status S_KEY_INCOMPATIBLE = 0x00000035;
  const CICM::Status S_KEY_CLASSIFICATION = 0x00000036;
  const CICM::Status S_KEY_WRAPPED = 0x00000039;
  const CICM::Status S_KEY_NOT_WRAPPED = 0x0000003A;
  const CICM::Status S_KEY_NOT_WRAPPABLE = 0x0000003C;
  const CICM::Status S_KEY_NOT_EXPORTABLE = 0x0000003F;
  const CICM::Status S_KEY_WRAPPED_EXISTS = 0x00000041;
  const CICM::Status S_KEY_UNWRAPPED_EXISTS = 0x00000042;
  const CICM::Status S_KEY_UPDATE_MAX = 0x00000044;
  const CICM::Status S_KEY_INVALID_ID = 0x00000047;
  const CICM::Status S_KEY_PHYSICAL_LOC = 0x00000048;
  const CICM::Status S_KEY_ILLEGAL_CONVERSION = 0x0000004B;
  const CICM::Status S_KEY_MALFORMED = 0x0000004D;
  const CICM::Status S_KEY_METADATA_MALFORMED = 0x0000004E;
  const CICM::Status S_KEY_NO_NEXT = 0x00000050;
  const CICM::Status S_KEY_WRONG_TYPE = 0x00000053;
  const CICM::Status S_KEY_FILL_DEVICE_NOT_CONNECTED = 0x00000055;
  const CICM::Status S_KEY_FILL_NOT_INITIATED = 0x00000056;
  const CICM::Status S_KEY_TRUST_ANCHOR = 0x00000059;
  const CICM::Status S_LOCAL_PORT_INVALID = 0x0000005A;
  const CICM::Status S_LOCAL_PORT_INCOMPATIBLE = 0x0000005C;
  const CICM::Status S_LOCAL_PORT_IN_USE = 0x0000005F;
  const CICM::Status S_REMOTE_PORT_INVALID = 0x00000060;
  const CICM::Status S_REMOTE_PORT_IN_USE = 0x00000063;
  const CICM::Status S_ALGO_INVALID = 0x00000065;
  const CICM::Status S_ALGO_INCOMPATIBLE = 0x00000066;
  const CICM::Status S_TOKEN_NOT_PRESENT = 0x00000069;
  const CICM::Status S_TOKEN_ADMIN_NOT_PRESENT = 0x0000006A;
  const CICM::Status S_TOKEN_ACCESS = 0x0000006C;
  const CICM::Status S_TOKEN_RESOURCES = 0x0000006F;
  const CICM::Status S_TOKEN_ASSOC_EXISTS = 0x00000071;
  const CICM::Status S_TOKEN_ASSOC_AT_MODULE = 0x00000072;
  const CICM::Status S_TOKEN_ASSOC_AT_TOKEN = 0x00000074;
  const CICM::Status S_TOKEN_ASSOC_NOT_EXIST = 0x00000077;
  const CICM::Status S_TOKEN_ASSOC_GENERAL = 0x00000078;
  const CICM::Status S_TOKEN_DISASSOC_GENERAL = 0x0000007B;
  const CICM::Status S_TOKEN_REC_NOT_FOUND = 0x0000007D;
  const CICM::Status S_TOKEN_TIMEOUT = 0x0000007E;
  const CICM::Status S_TOKEN_LAST_ASSOCIATED = 0x00000081;
  const CICM::Status S_PACKAGE_NOT_ACTIVATABLE = 0x00000082;
  const CICM::Status S_PACKAGE_ACTIVATED = 0x00000084;
  const CICM::Status S_PACKAGE_NOT_ACTIVE = 0x00000087;
  const CICM::Status S_PACKAGE_INVALID = 0x00000088;
  const CICM::Status S_PACKAGE_TYPE_INVALID = 0x0000008B;
  const CICM::Status S_PACKAGE_KEY_NOT_AVAILABLE = 0x0000008D;
  const CICM::Status S_PACKAGE_KEY_NOT_SPECIFIED = 0x0000008E;
  const CICM::Status S_LOG_ENTRY_INVALID = 0x00000090;
  const CICM::Status S_EVENT_REGISTERED = 0x00000093;
  const CICM::Status S_EVENT_NOT_REGISTERED = 0x00000095;
  const CICM::Status S_EVENT_NOT_SUPPORTED = 0x00000096;
  const CICM::Status S_TRUSTED_DISPLAY = 0x00000099;
  const CICM::Status S_NEGOTIATION_ABORTED = 0x0000009A;
  const CICM::Status S_NEGOTIATION_FAILURE = 0x0000009C;
  const CICM::Status S_NEGOTIATION_IN_PROGRESS = 0x0000009F;
  const CICM::Status S_NEGOTIATION_NOT_IN_PROGRESS = 0x000000A0;
  const CICM::Status S_NEGOTIATION_TIMEOUT = 0x000000A3;
  const CICM::Status S_CERT_LOCAL_INVALID = 0x000000A5;
  const CICM::Status S_CERT_LOCAL_EXPIRED = 0x000000A6;
  const CICM::Status S_CERT_REMOTE_INVALID = 0x000000A9;
  const CICM::Status S_CERT_REMOTE_EXPIRED = 0x000000AA;
  const CICM::Status S_CERT_REMOTE_PATH = 0x000000AC;
  const CICM::Status S_PROTO_INVALID = 0x000000AF;
  const CICM::Status S_PROTO_INCOMPATIBLE = 0x000000B1;
  const CICM::Status S_PROTO_UNDETERMINED = 0x000000B2;
  const CICM::Status S_CHANNEL_ERROR = 0x000000B4;
  const CICM::Status S_CHANNEL_PEER_RESET = 0x000000B7;
  const CICM::Status S_CHANNEL_MAX = 0x000000B8;
  const CICM::Status S_CHANNEL_NOT_FOUND = 0x000000BB;
  const CICM::Status S_CHANNEL_IO_ERROR = 0x000000BD;
  const CICM::Status S_CHANNEL_DATA_INVALID = 0x000000BE;
  const CICM::Status S_CHANNEL_DATA_INVALID_LEN = 0x000000C0;
  const CICM::Status S_CHANNEL_BUFFER_LEN = 0x000000C3;
  const CICM::Status S_CHANNEL_IN_GROUP = 0x000000C5;
  const CICM::Status S_CHANNEL_CLASSIFICATION = 0x000000C6;
  const CICM::Status S_BYPASS_DATARATE_EXCEEDED = 0x000000C9;
  const CICM::Status S_BYPASS_DATALIMIT_EXCEEDED = 0x000000CA;
  const CICM::Status S_INTEGRITY = 0x000000CC;
  const CICM::Status S_AUTHENTICATION_FAILED = 0x000000CF;
  const CICM::Status S_USER_AUTHENTICATED = 0x000000D1;
  const CICM::Status S_USERNAME_INVALID = 0x000000D2;
  const CICM::Status S_USER_EXISTS = 0x000000D4;
  const CICM::Status S_USER_INVALID = 0x000000D7;
  const CICM::Status S_ROLE_INVALID = 0x000000D8;
  const CICM::Status S_ROLE_ASSOCIATED = 0x000000DB;
  const CICM::Status S_ROLE_NOT_ASSOCIATED = 0x000000DD;
  const CICM::Status S_ROLE_MAX = 0x000000DE;
  const CICM::Status S_PASSWORD_INVALID = 0x000000E1;
  const CICM::Status S_PASSWORD_INVALID_CHAR = 0x000000E2;
  const CICM::Status S_PASSWORD_INVALID_LEN = 0x000000E4;
  const CICM::Status S_SALT_INVALID = 0x000000E7;
  const CICM::Status S_ITERATION_COUNT_INVALID = 0x000000E8;
  const CICM::Status S_INSUFFICIENT_ENTROPY = 0x000000EB;

  interface Iterator {
    typedef CICM::UInt32 Status;
    const CICM::Iterator::Status C_ITERATOR_HAS_NEXT = 0x00006031;
    const CICM::Iterator::Status C_ITERATOR_NO_MORE = 0x00006032;

    CICM::Status has_next(
      out CICM::Iterator::Status has_next );
  };

  typedef CICM::CharString ModuleId;

  interface CryptoModule {
    readonly attribute CICM::ModuleId module_id;
    readonly attribute CICM::CharString manufacturer;
    readonly attribute CICM::CharString model;
    readonly attribute CICM::CharString serial_number;
    readonly attribute CICM::CharString module_version;
    readonly attribute CICM::CharString software_version;
    readonly attribute CICM::CharString driver_version;
    readonly attribute CICM::CharString library_version;
    readonly attribute CICM::RoleId role;
    attribute CICM::CharString date_time;
    readonly attribute CICM::SymKeyManager sym_key_manager;
    readonly attribute CICM::AsymKeyManager asym_key_manager;
    readonly attribute CICM::KeyDatabase key_database;
    readonly attribute CICM::ChannelManager channel_manager;
    readonly attribute CICM::ModuleEventManager event_manager;
    readonly attribute CICM::PackageManager package_manager;
    readonly attribute CICM::TokenManager token_manager;
    readonly attribute CICM::UserManager user_manager;
    readonly attribute CICM::LoginManager login_manager;
    readonly attribute CICM::TestManager test_manager;
    readonly attribute CICM::LogManager log_manager;

    CICM::Status configure_fill_interface(
      in  CICM::Buffer interface_parameters,
      in  CICM::LocalPort fill_port );

    CICM::Status reset();
  };

  interface CICMRoot {
    CICM::Status get_module_by_id(
      in  CICM::ModuleId id,
      out CICM::CryptoModule crypto_module_ref );
  };
};]]></artwork></figure>
	</section>
  </back>
</rfc>