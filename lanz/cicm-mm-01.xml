<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!-- General -->
<?rfc strict="yes" ?>   <!-- Enforce Internet-Drafts nits & DTD validity? -->
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<!-- References -->
<?rfc symrefs="yes"?>   <!-- Show symbolic links (yes) or numbers (no). -->
<?rfc sortrefs="yes" ?> <!-- Sort references? -->
<!-- Comments -->
<?rfc comments="yes" ?> <!-- Display <cref> elements? -->
<?rfc inline="yes" ?>   <!-- Place comments inline (yes) or in comments section (no). -->
<?rfc editing="no" ?>   <!-- Insert editing marks? -->
<!-- Table of Contents -->
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc tocompact="yes"?>
<!-- End of directives; start of RFC. -->
<rfc category="info" ipr="trust200902" docName="draft-lanz-cicm-mm-01">
  <front>
    <title abbrev="CICM Module Management">
      Common Interface to Cryptographic Modules (CICM) Module Management
    </title>
    <author fullname="Daniel J. Lanz" initials="D." surname="Lanz">
      <organization abbrev="MITRE">The MITRE Corporation</organization>
      <address>
        <email>dlanz@mitre.org</email>
      </address>
    </author>
    <author fullname="Lev Novikov" initials="L." surname="Novikov">
      <organization abbrev="MITRE">The MITRE Corporation</organization>
      <address>
        <email>lnovikov@mitre.org</email>
      </address>
    </author>
    <date year="2011" month="July" />
    <area>Security</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <abstract>
      <t>[RFC Editor: Please update the RFC references prior to publication.]</t>
      <t>This memo defines a programming interface for high-level management of
      cryptographic modules as outlined in draft-lanz-cicm-model-00
      and required by draft-lanz-cicm-02 including managing the module authentication,
      software, logs, built-in tests, and responding to module events.</t>
      <t>Comments are solicited and should be addressed to the mailing list at cicm@ietf.org.</t>
    </abstract>
  </front>
  <middle><!-- Content. -->
    <section title="Introduction">
      <t>This document defines the module management functions for the Common Interface to
      Cryptographic Modules (CICM) as defined in <xref target="CICM" />. The underlying logical
      model and terminology are defined in <xref target="CICM-LM" />.</t>
      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
        "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
        and "OPTIONAL" in this document are to be interpreted as
        described in <xref target="RFC2119" />.</t>
      </section>
      <section title="Definition Language">
        <t>This document uses the Interface Definition Language (IDL) <xref target="IDL" /> to
        specify language-neutral interfaces and is not intended to prescribe or preclude a particular
        communications protocol such as General Inter-ORB Protocol (GIOP) <xref target="CORBA" />
        between programs in different address spaces or on different devices. See Definition Language 
        in <xref target="CICM" /> for more information.</t>
      </section>
      <section title="Conformance and Extension Language">
        <t>This document contains definitions for several opaque data parameters whose
        format is not defined by CICM. Instead, implementers are required to create an
        Implementation Conformance Statement which MUST reference a standard format or
        define a module developer-specific format implemented by the module for these
        datatypes. See Conformance and Extensions in <xref target="CICM" /> for more details.</t>
      </section>
    </section>
    <section title="CICM Dependencies">
      <t>This document depends on type definitions and interfaces that
      are defined in other CICM documents.</t>

      <section title="Namespaces">
        <t>The CICM namespace is defined in <xref target="CICM" />.</t>
      </section>
      <section title="Types">
        <t>The following type definitions are defined in <xref target="CICM" />:
          <list>
            <t>CICM::UInt32</t>
            <t>CICM::CharString</t>
            <t>CICM::Buffer</t>
            <t>CICM::Status (including all return values)</t>
          </list>
        </t>
      </section>
      <section title="Interfaces">
        <t>The interface CICM::Iterator is defined in <xref target="CICM" />; the CICM::SymKey
        interface is defined in <xref target="CICM-KM" />.</t>
      </section>
    </section>
    <section title="Hardware Access Tokens">
      <t>Cryptographic modules may rely upon hardware
      access tokens for two primary functions: to allow subjects (e.g.,
      administrators or users in possession of a token) to be identified
      and authenticated so that privileges can be enforced and audit log
      entries can identify the subject; and to unlock all or some subset
      of cryptographic services. A hardware access token may be
      associated with a number of specific modules, and a module may
      likewise be associated with a number of specific tokens. The token
      management functions below enable tokens and modules to be
      associated with and disassociated from one another, and allow
      existing associations to be listed.</t>
      <t>The removal of an association between a token and a module is
      straightforward if both the token and the module are available.
      However, if either the token or module are unavailable, or if a
      different module than the one originally associated with the token
      is used to remove an association from a token, the disassociation
      is less straightforward.</t>
      <t>If a module requires that an administrative token be inserted
      prior to the token to which the association/disassociation will
      apply, the methods below may return an CICM::S_TOKEN_NOT_PRESENT or
      CICM::S_TOKEN_ADMIN_NOT_PRESENT status.</t>
      <t>Modules that do not support hardware tokens may instead provide
      similar support via CICM::LoginManager. Modules may use
      CICM::LoginManager in tandem with tokens to support multi-factor
      authentication. See Managing Module Authentication
      in <xref target="CICM-LM" /> for additional information.</t>

        <section title="Token Management Identifiers">
          <figure>
            <preamble>Type CICM::TokenRecord</preamble>
            <artwork><![CDATA[typedef CICM::CharString TokenRecord;]]></artwork>
            <postamble>Unique token association record.</postamble>
          </figure>
          <figure>
            <preamble>Type CICM::ModuleRecord</preamble>
            <artwork><![CDATA[typedef CICM::CharString ModuleRecord;]]></artwork>
          <postamble>Unique module association record.</postamble></figure>
        </section>
				<section title="Interface CICM::TokenManager">
					<figure>
					  <preamble>Interface CICM::TokenManager</preamble>
					  <artwork><![CDATA[interface TokenManager {]]></artwork>
					  <postamble>CICM::TokenManager supports associating and disassociating
					  modules and tokens. It is accessed from CICM::CryptoModule via the
					  CICM::CryptoModule::token_manager attribute. CICM::TokenManager
					  constructs the CICM::ModuleAssnIterator and CICM::TokenAssnIterator
					  interfaces.</postamble>
					</figure>
          <!-- figure>
            <artwork></artwork>
            <postamble>Figure 12. Interface Relationship Diagram for TokenManager</postamble>
          </figure -->
					<figure>
						<preamble>Example (C++):</preamble>
<artwork><![CDATA[// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;

CICM::Status sCode;
CICM::tokenManager tokenManager;

// Retrieve reference to the token manager.
tokenManager = device._get_token_manager();

// Associate the current token with the module.
sCode = tokenManager.associate();

// Assume that some time later the token is lost or destroyed.

// Disassociate the token from the module.
CICM::TokenUniqueId tokenId = new CICM::TokenUniqueId("TOKEN1426864");
sCode = tokenManager.disassociate_missing_token(tokenId);
]]></artwork>
					</figure>
					<section title="CICM::TokenManager Attributes">
						<figure>
						  <preamble>Attribute CICM::TokenManager::module_association_iterator</preamble>
<artwork><![CDATA[readonly attribute CICM::ModuleAssnIterator
	module_association_iterator;]]></artwork>
						  <postamble>Returns an iterator to enable each module identifier
						  associated with the current token to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The returned iterator is set to the beginning of the iterated sequence.</t>
							</list>
						</t>
						<figure>
						  <preamble>Attribute CICM::TokenManager::token_association_iterator</preamble>
<artwork><![CDATA[readonly attribute CICM::TokenAssnIterator
	token_association_iterator;]]></artwork>
						  <postamble>Returns an iterator to enable each token identifier
						  associated with the current module to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
							  <t>The returned iterator is set to the beginning of the iterated
							  sequence.</t>
							</list>
						</t>
					</section>
					<section title="CICM::TokenManager Methods">
						<figure>
						  <preamble>Method CICM::TokenManager::associate()</preamble>
<artwork><![CDATA[CICM::Status associate(
	out CICM::ModuleRecord module_rec,
	out CICM::TokenRecord token_rec
);]]></artwork>
						   <postamble>Associate the module and currently-inserted hardware access
						   token.</postamble>
						 </figure>
						<t>Remarks:
							<list>
								<t>The module and token record identifiers should be recorded
								for use in the disassociation process in the event that either
								the module or the token are no longer available or usable.</t>
								<t>The formats of the module and token records are not defined
								by CICM. The Implementation Conformance Statement (see Conformance
                and Extensions in <xref target="CICM" />)
                MUST reference a standard format or define a module developer-specific
                format implemented by the module for these datatypes.</t>
							</list>
						</t><t>Parameters:
							<list>
							  <t>[in] module_rec Module record identifier of the newly associated module.</t>
							  <t>[in] token_rec Token record identifier of the newly associated token.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ACCESS, S_TOKEN_RESOURCES,
								  S_TOKEN_ASSOC_EXISTS, S_TOKEN_ASSOC_AT_MODULE,
								  S_TOKEN_ASSOC_AT_TOKEN, S_TOKEN_ASSOC_GENERAL,
								  S_TOKEN_TIMEOUT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::TokenManager::disassociate()</preamble>
						  <artwork><![CDATA[CICM::Status disassociate();]]></artwork>
						  <postamble>Disassociate the module and currently-inserted hardware
							access token when the associated module and token are both present
							and both recognize the association.</postamble>
						</figure>
						<t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ACCESS,
								  S_TOKEN_ASSOC_NOT_EXIST, S_TOKEN_DISASSOC_GENERAL,
								  S_TOKEN_TIMEOUT, S_TOKEN_LAST_ASSOCIATED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::TokenManager::disassociate_missing_module()</preamble>
<artwork><![CDATA[CICM::Status disassociate_missing_module(
	in  CICM::ModuleRecord module_rec
);]]></artwork>
						  <postamble>Remove association information from the currently-inserted
							hardware access token when the associated module is not
							present.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The module on which this method is being executed is used
								as a surrogate to perform the disassociation (it is not the
								module that performed the initial association). The specific
								module to disassociate from the token is identified by a unique
								module identifier (e.g., a module serial number). Use
								CICM::ModuleAssnIterator to retrieve module record identifiers
								corresponding to modules associated with the inserted token.</t>
								<t>The format of the module record is not defined by CICM. The
								Implementation Conformance Statement (see Conformance and Extensions
                in <xref target="CICM" />) MUST reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] module_rec Identifies the module for which module identification
								  information should be removed from the currently-inserted
								  hardware access token.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ACCESS,
								  S_TOKEN_DISASSOC_GENERAL, S_TOKEN_REC_NOT_FOUND,
								  S_TOKEN_TIMEOUT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::TokenManager::disassociate_missing_token()</preamble>
<artwork><![CDATA[CICM::Status disassociate_missing_token(
	in  CICM::TokenRecord token_rec
);]]></artwork>
						  <postamble>Remove association information from the module on which this
							method is being executed when the associated token is not
							present.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The specific token to disassociate from the module is
								identified by a unique token identifier (e.g., a token serial
								number). Use CICM::TokenAssnIterator to retrieve token record
								identifiers corresponding to associated tokens from the module.</t>

								<t>The format of the token record is not defined by CICM. The
								Implementation Conformance Statement (see Conformance and Extensions
                in <xref target="CICM" />) MUST reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] token_rec Identifies the hardware access token for which token
								  identification information should be removed from the
								  module.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ASSOC_NOT_EXIST,
								  S_TOKEN_DISASSOC_GENERAL, S_TOKEN_REC_NOT_FOUND,
								  S_TOKEN_TIMEOUT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::TokenAssnIterator">
					<figure>
					  <preamble>Interface CICM::TokenAssnIterator</preamble>
					  <artwork><![CDATA[interface TokenAssnIterator : CICM::Iterator {]]></artwork>
					  <postamble>CICM::TokenAssnIterator supports retrieving each token record
						from the token association list in the module.</postamble>
					</figure>

					<section title="CICM::TokenAssnIterator Inheritance">
					<t>CICM::TokenAssnIterator inherits from: CICM::Iterator.</t>
					</section>
					<section title="CICM::TokenAssnIterator Methods">
						<figure>
						  <preamble>Method CICM::TokenAssnIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::TokenRecord token_rec_ref
);]]></artwork>
						  <postamble>Returns a reference to the next token.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Use CICM::Iterator::has_next to determine if additional
								elements exist.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[out] token_rec_ref Reference to next token.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
								<section title="Interface CICM::ModuleAssnIterator">
					<figure>
					  <preamble>Interface CICM::ModuleAssnIterator</preamble>
					  <artwork><![CDATA[interface ModuleAssnIterator : CICM::Iterator {]]></artwork>
					  <postamble>CICM::ModuleAssnIterator supports retrieving each module
						record from the module association list in the token.</postamble>
					</figure>

					<section title="CICM::ModuleAssnIterator Inheritance">
					<t>CICM::ModuleAssnIterator inherits from: CICM::Iterator.</t>
					</section>

					<section title="CICM::ModuleAssnIterator Methods">
						<figure>
						  <preamble>Method CICM::ModuleAssnIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::ModuleRecord module_rec_ref
);]]></artwork>
						  <postamble>Returns a reference to the next module record from the module
							association list in the token.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Use CICM::Iterator::has_next to determine if additional
								elements exist.</t>
							</list>
						</t><t>Parameters:
						  <list>
							  <t>[out] module_rec_ref  Reference to next module record.</t>
						  </list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Users">
				<t>These interfaces enable the management of
				users in support of password-based login. See the Managing Module
				Authentication in <xref target="CICM-LM" /> for additional
				information.</t>

        <section title="User Management Identifiers">
          <figure>
            <preamble>Type CICM::UserId</preamble>
            <artwork><![CDATA[typedef CICM::CharString UserId;]]></artwork>
            <postamble>Unique user identifier.</postamble>
          </figure>
          <figure>
            <preamble>Type CICM::RoleId</preamble>
            <artwork><![CDATA[typedef CICM::CharString RoleId;]]></artwork>
            <postamble>Unique role identifier.</postamble>
          </figure>
        </section>
				<section title="Interface CICM::UserManager">
					<figure>
					  <preamble>Interface CICM::UserManager</preamble>
					  <artwork><![CDATA[interface UserManager {]]></artwork>
					  <postamble>CICM::UserManager supports adding a user/password, modifying
						a user's password, and removing users; and associating and
						disassociating users from a role. It is accessed from
						CICM::CryptoModule via the CICM::CryptoModule::user_manager
						attribute. CICM::UserManager constructs the CICM::UserIdIterator
						and CICM::RoleIdIterator interfaces.</postamble>
					</figure>
					<!-- t>{FIGURE REMOVED}</t>
					<t>Figure 13. Interface Relationship Diagram for UserManager</t -->
					<figure>
					  <preamble>Example (C++):</preamble>
<artwork><![CDATA[// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;

CICM::Status sCode;
CICM::UserManager userManager;

// Retrieve reference to the user manager.
userManager = device._get_user_manager();

// Create the user.
CICM::UserUniqueId userId = "bob_smith";
CICM::CharString password = "p@$$w0rd";
sCode = userManager.add(userId, password);

// Associate the user with a pre-defined module role.
CICM::RoleUniqueId roleId = "administrator";
sCode = userManager.associate(userId, roleId);

// Destroy the user.
sCode = userManager.remove(userId);]]></artwork>
					</figure>

					<section title="CICM::UserManager Attributes">
						<figure>
						  <preamble>Attribute CICM::UserManager::user_iterator</preamble>
						  <artwork><![CDATA[readonly attribute CICM::UserIdIterator user_iterator;]]></artwork>
						  <postamble>Returns an iterator to enable an identifier for each user in
							the module user database to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The returned iterator is set to the beginning of the
								iterated sequence.</t>
						  </list>
						</t>
						<figure>
						  <preamble>Attribute CICM::UserManager::role_iterator</preamble>
						  <artwork><![CDATA[readonly attribute CICM::RoleIdIterator role_iterator;]]></artwork>
						  <postamble>Returns an iterator to enable an identifier for each role
							supported by the module to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
							  <t>The returned iterator is set to the beginning of the iterated
							  sequence.</t>
							</list>
						</t>
					</section>
					<section title="CICM::UserManager Methods">
						<figure>
						  <preamble>Method CICM::UserManager::add()</preamble>
<artwork><![CDATA[CICM::Status add(
	in  CICM::UserId user,
	in  CICM::CharString password
);]]></artwork>
						  <postamble>Add a user to the module user database.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] user New user to add.</t>
								<t>[in] password New user's password.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_USERNAME_INVALID, S_USER_EXISTS,
								  S_PASSWORD_INVALID, S_PASSWORD_INVALID_CHAR,
								  S_PASSWORD_INVALID_LEN</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::UserManager::modify()</preamble>
<artwork><![CDATA[CICM::Status modify(
	in  CICM::UserId user,
	in  CICM::CharString password
);]]></artwork>
						  <postamble>Change the password of a user in the module user
							database.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] user User to modify.</t>
								<t>[in] password User's new password.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID,
								  S_PASSWORD_INVALID, S_PASSWORD_INVALID_CHAR,
								  S_PASSWORD_INVALID_LEN</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::UserManager::remove()</preamble>
<artwork><![CDATA[CICM::Status remove(
	in  CICM::UserId user
);]]></artwork>
						  <postamble>Remove a user from the module user database.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] user User to remove.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::UserManager::associate()</preamble>
<artwork><![CDATA[CICM::Status associate(
	in  CICM::UserId user,
	in  CICM::RoleId role
);]]></artwork>
						  <postamble>Associate a role with the specified user.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] user User to associate.</t>
								<t>[in] role Role to associate with the user.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID, S_ROLE_INVALID,
								  S_ROLE_ASSOCIATED, S_ROLE_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::UserManager::disassociate()</preamble>
<artwork><![CDATA[CICM::Status disassociate(
	in  CICM::UserId user,
	in  CICM::RoleId role
);]]></artwork>
						  <postamble>Disassociate a role from the specified user.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] user User to disassociate.</t>
								<t>[in] role Role to disassociate from the user.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID, S_ROLE_INVALID,
								  S_ROLE_NOT_ASSOCIATED</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::UserIdIterator">
					<figure>
					  <preamble>Interface CICM::UserIdIterator</preamble>
					  <artwork><![CDATA[interface UserIdIterator : CICM::Iterator {]]></artwork>
					  <postamble>CICM::UserIdIterator supports retrieving each user configured on a module.</postamble>
					</figure>

					<section title="CICM::UserIdIterator Inheritance">
						<t>CICM::UserIdIterator inherits from: CICM::Iterator.</t>
					</section>
					<section title="CICM::UserIdIterator Methods">
						<figure>
						  <preamble>Method CICM::UserIdIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::UserId user_id
);]]></artwork>
						  <postamble>Returns the next user identifier.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Use CICM::Iterator::has_next to determine if additional
								elements exist.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[out] user_id Next user identifier.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::RoleIdIterator">
					<figure>
					  <preamble>Interface CICM::RoleIdIterator</preamble>
					  <artwork><![CDATA[interface RoleIdIterator : CICM::Iterator {]]></artwork>
					  <postamble>CICM::RoleIdIterator supports retrieving each role available on a module.</postamble>
					</figure>

					<section title="CICM::RoleIdIterator Inheritance">
						<t>CICM::RoleIdIterator inherits from: CICM::Iterator.</t>
					</section>
					<section title="CICM::RoleIdIterator Methods">
						<figure>
						  <preamble>Method CICM::RoleIdIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::RoleId role_id
);]]></artwork>
						  <postamble>Returns the next role identifier.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Use CICM::Iterator::has_next to determine if additional
								elements exist.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[out] role_id Reference to next role identifier.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Login">
				<t>These interfaces support a user configured on
				a module to login to a module using a password and, optionally,
				additional authentication data. See the Managing Module
				Authentication in <xref target="CICM-LM" /> for additional information.</t>
				<t>Modules that support hardware tokens may use the login manager
				in tandem with the CICM::TokenManager to support multi-factor
				authentication.</t>

				<section title="Interface CICM::LoginManager">
					<figure>
					  <preamble>Interface CICM::LoginManager</preamble>
					  <artwork><![CDATA[interface LoginManager {]]></artwork>
					  <postamble>CICM::LoginManager supports user login to a module. It is
						accessed from CICM::CryptoModule via the
						CICM::CryptoModule::login_manager attribute. CICM::LoginManager
						constructs the CICM::Login interface. The LoginManager relies upon
						the CICM::UserManager to manage the users that are specified to the
						login methods.</postamble>
					</figure>
					<!--t>{FIGURE REMOVED}</t>
					<t>Figure 14. Interface Relationship Diagram for LoginManager</t-->
					<figure>
						<preamble>Example (C++):</preamble>
<artwork><![CDATA[// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;
CICM::Status sCode;
CICM::LoginManager loginManager;
CICM::Login loginRef;
// Retrieve reference to the login manager.
loginManager = device._get_login_manager();
// Login to the module.
CICM::UserUniqueId userId = "bob_smith";
CICM::CharString password = "p@$$w0rd";
sCode = loginManager.add(userId, password, &loginRef);
// Logout from the module.
sCode = loginRef.logout();]]></artwork>
					</figure>

					<section title="CICM::LoginManager Methods">
						<figure>
						  <preamble>Method CICM::LoginManager::login()</preamble>
<artwork><![CDATA[ CICM::Status login(
	in  CICM::UserId user,
	in  CICM::CharString password,
	out CICM::Login login_ref
);]]></artwork>
						  <postamble>Login to the module with username/password.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] user User attempting to login.</t>
								<t>[in] password User's password.</t>
								<t>[out] login_ref Reference to state resulting from successful
									user login enabling the user to later logout.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_AUTHENTICATION_FAILED,
								  S_USER_AUTHENTICATED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::LoginManager::login_auth_data()</preamble>
<artwork><![CDATA[CICM::Status login_auth_data(
	in  CICM::UserId user,
	in  CICM::CharString password,
	in  CICM::Buffer auth_data,
	out CICM::Login login_ref
);]]></artwork>
						  <postamble>Login to the module with username/password, but provide
							additional (potentially host-stored) authentication data to the
							module for use in the authentication process.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This may be used in cases where the host supports a virtual token.</t>
								<t>The format of the authentication data is not defined by
								CICM. The Implementation Conformance Statement (see Conformance and Extensions
                in <xref target="CICM" />) MUST reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] user User attempting to login.</t>
								<t>[in] password User's password.</t>
								<t>[in] auth_data Additional host-stored authentication data.</t>
								<t>[out] login_ref Reference to state resulting from successful user
									  login enabling the user to later logout.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_DATA_BUFFER,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
								  S_AUTHENTICATION_FAILED, S_USER_AUTHENTICATED</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Login">
					<figure>
					  <preamble>Interface CICM::Login</preamble>
					  <artwork><![CDATA[interface Login {]]></artwork>
					  <postamble>CICM::Login results from a successful user login to a
						module and enables the user to log out from the module.</postamble>
					</figure>

					<section title="CICM::Login Methods">
						<figure>
						  <preamble>Method CICM::Login::logout()</preamble>
						  <artwork><![CDATA[CICM::Status logout();]]></artwork>
						  <postamble>Logout of the module.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This may be equivalent to disconnecting a hardware access
								token from a module in certain systems.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Software Packages">
				<t>These interfaces support software, FPGA
				images, policy databases, configuration parameters, or other types
				of executable or interpretable code to be imported into and removed
				from a module.</t>

        <section title="Package Management Identifier">
          <figure>
            <preamble>Type CICM::PackageId</preamble>
            <artwork><![CDATA[typedef CICM::CharString PackageId;]]></artwork>
            <postamble>Unique package identifier.</postamble>
          </figure>
        </section>
				<section title="Interface CICM::PackageManager">
					<figure>
					  <preamble>Interface CICM::PackageManager</preamble>
					  <artwork><![CDATA[interface PackageManager {]]></artwork>
					  <postamble>CICM::PackageManager supports the management of module
						software packages. It is accessed from CICM::CryptoModule via the
						CICM::CryptoModule::package_manager attribute. CICM::PackageManager
						constructs the CICM::PackageImporter, CICM::PackageIterator, and
						CICM::Package interfaces.</postamble>
					</figure>
					<!-- t>{FIGURE REMOVED}</t>
					<t>Figure 15. Interface Relationship Diagram for PackageManager</t-->
					<figure>
					  <preamble>Example (C++):</preamble>
<artwork><![CDATA[// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;
CICM::Status sCode;
CICM::PackageManager packageManager;
CICM::PackageImporter packageImporter;
// Retrieve reference to the package manager.
packageManager = device._get_package_manager();

// Initialize the import process.
sCode = packageManager.import_package(
	CICM::Package::C_PACKAGE_FPGA_IMAGE, &packageImporter);

// Assume FPGA image data in [fpgaData].
CICM::Buffer fpgaData;
sCode = packageImporter.import_segment(fpgaData);

// Assume all segments are imported.
// Complete the import process.

CICM::Package fpgaPackage;
sCode = packageImporter.complete(&fpgaPackage);
// If successful, [fpgaPackage] is a reference to the imported package.
// Activate the package.
sCode = fpgaPackage.activate();]]></artwork>
					</figure>

					<section title="CICM::PackageManager Attributes">
						<figure>
						  <preamble>Attribute CICM::PackageManager::package_iterator</preamble>
						  <artwork><![CDATA[readonly attribute CICM::PackageIterator package_iterator;]]></artwork>
						  <postamble>Returns an iterator to enable a reference to each
							package loaded on the module to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
							  <t>The returned iterator is set to the beginning of the iterated
							  sequence.</t>
							</list>
						</t>
					</section>
					<section title="CICM::PackageManager Methods">
						<figure>
						  <preamble>Method CICM::PackageManager::import_package()</preamble>
<artwork><![CDATA[CICM::Status import_package(
	in  CICM::Package::PackageType package_type,
	out CICM::PackageImporter importer_ref
);]]></artwork>
						  <postamble>Initiate the process of importing a package into the module.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The CICM::PackageImporter that results from this call is
								used to import package segments into the module. It is the
								responsibility of the caller to break a package into segments,
								import each individual segment, and then call
								CICM::PackageImporter::complete to receive a reference to the
								resulting package. Note that the key required to decrypt any
								encrypted package segments MUST be referenced within the
								package and MUST be available to the module; the key MAY be
								explicitly specified by using the
								CICM::PackageManager::import_package_with_key version of the
								call.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] package_type Type of the package being imported.</t>
							<t>[out] importer_ref Reference to package importer interface which enables
								  a package to be imported segment by segment.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_TYPE_INVALID,
								  S_PACKAGE_KEY_NOT_AVAILABLE,
								  S_PACKAGE_KEY_NOT_SPECIFIED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::PackageManager::import_package_with_key()</preamble>
<artwork><![CDATA[CICM::Status import_package_with_key(
	in  CICM::Package::PackageType package_type,
	in  CICM::SymKey key_ref,
	out CICM::PackageImporter importer_ref
);]]></artwork>
						  <postamble>Initiate the process of importing a package into the module,
							specifying a reference to the key that will be used by
							CICM::PackageImporter to decrypt each package segment.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The CICM::PackageImporter that results from this call is
								used to import package segments into the module. It is the
								responsibility of the caller to break a package into segments,
								import each individual segment, and then call
								CICM::PackageImporter::complete to receive a reference to the
								resulting package.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] package_type Type of the package being imported.</t>
							<t>[in] key_ref Reference to key to decrypt package segments.</t>
							<t>[out] importer_ref Reference to package importer interface which enables
								  a package to be imported segment by segment.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_TYPE_INVALID</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::PackageManager::get_package_by_id()</preamble>
<artwork><![CDATA[CICM::Status get_package_by_id(
	in  CICM::PackageId package_id,
	out CICM::Package package_ref
);]]></artwork>
						  <postamble>Retrieve a reference to a package based upon a unique
							identifier associated with that package.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] package_id Package identifier.</t>
								<t>[out] package_ref Reference to package corresponding to the specified identifier.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::PackageManager::reencrypt_software()</preamble>
						  <artwork><![CDATA[CICM::Status reencrypt_software();]]></artwork>
						  <postamble>Re-encrypt module software with a key managed by the module.</postamble>
						</figure>
						<t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::PackageImporter">
					<figure>
					  <preamble>Interface CICM::PackageImporter</preamble>
					  <artwork><![CDATA[interface PackageImporter {]]></artwork>
					  <postamble>CICM::PackageImporter supports importing software packages,
						segment by segment. CICM::PackageImporter is constructed by the
						CICM::PackageManager::import_package and
						CICM::PackageManager::import_package_with_key methods and cannot
						be instantiated independently. CICM::PackageImporter constructs the
						CICM::Package interface.</postamble>
					</figure>
					<section title="CICM::PackageImporter Methods">
						<figure>
						  <preamble>Method CICM::PackageImporter::import_segment()</preamble>
<artwork><![CDATA[CICM::Status import_segment(
	in  CICM::Buffer package_data
);]]></artwork>
						  <postamble>Import one segment of a package.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>It is the responsibility of the caller to break a package
								into segments, import each individual segment, and then call
								CICM::PackageImporter::complete to receive a reference to the
								resulting package.</t>
								<t>CICM does not specify the structure of the binary data that
								constitutes the package being imported. The Implementation
								Conformance Statement (see Conformance and Extensions in
                <xref target="CICM" />) MUST reference a standard format or define a module
								developer-specific format implemented by the module for this
								datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] package_data Contents of the package.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_INVALID</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::PackageImporter::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Package package_ref
);]]></artwork>
						  <postamble>Declare the package import complete and retrieve
							a reference to the resulting package object.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>If this method is called before the package is fully
								loaded, the CICM::S_PACKAGE_INVALID status results.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] package_ref Reference to resulting imported package.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_MODULE_RESOURCES,
								  S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE,
								  S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED,
								  S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_INVALID</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::PackageImporter::abort()</preamble>
						  <artwork><![CDATA[CICM::Status abort();]]></artwork>
						  <postamble>Abort a package import, resetting this CICM::PackageImporter
							instance, allowing a new package import session to begin.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Segments already imported are discarded.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Package">
					<figure>
					  <preamble>Interface CICM::Package</preamble>
					  <artwork><![CDATA[interface Package {]]></artwork>
					  <postamble>CICM::Package serves as a reference to a package previously
						loaded into a module, and supports activating, deactivating, and
						deleting the package. CICM::Package is constructed by the
						CICM::PackageManager::get_package_by_id and
						CICM::PackageImporter::complete methods and cannot be instantiated
						independently.</postamble>
					</figure>

					<section title="CICM::Package Types and Constants">
						<figure>
						  <preamble>Type CICM::Package::PackageType</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 PackageType;]]></artwork>
						  <postamble>Supported package types.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Package::C_PACKAGE_ALGORITHM</preamble>
<artwork><![CDATA[const CICM::Package::PackageType
	C_PACKAGE_ALGORITHM = 0x00006054;]]></artwork>
							<postamble>Algorithm package type.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Package::C_PACKAGE_CONFIG_PARAMS</preamble>
<artwork><![CDATA[const CICM::Package::PackageType
	C_PACKAGE_CONFIG_PARAMS = 0x00006057;]]></artwork>
							<postamble>Configuration parameter package type.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Package::C_PACKAGE_FPGA_IMAGE</preamble>
<artwork><![CDATA[const CICM::Package::PackageType
	C_PACKAGE_FPGA_IMAGE = 0x00006058;]]></artwork>
							<postamble>FPGA image package type.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Package::C_PACKAGE_POLICY_DB</preamble>
<artwork><![CDATA[const CICM::Package::PackageType
	C_PACKAGE_POLICY_DB = 0x0000605B;]]></artwork>
							<postamble>Policy database package type.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Package::C_PACKAGE_SOFTWARE</preamble>
<artwork><![CDATA[const CICM::Package::PackageType
	C_PACKAGE_SOFTWARE = 0x0000605D;]]></artwork>
							<postamble>Software package type.</postamble>
						</figure>
					</section>
					<section title="CICM::Package Attributes">
						<figure>
						  <preamble>Attribute CICM::Package::id</preamble>
						  <artwork><![CDATA[readonly attribute CICM::PackageId id;]]></artwork>
						  <postamble>Unique package identifier of this package.</postamble>
						</figure>
					</section>
					<section title="CICM::Package Methods">
						<figure>
						  <preamble>Method CICM::Package::activate()</preamble>
						  <artwork><![CDATA[CICM::Status activate();]]></artwork>
						  <postamble>Activate a specific package on the module.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>It may be necessary to reset the module before the
								specified package is activated in place of the currently
								activated package.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_NOT_ACTIVATABLE,
								  S_PACKAGE_ACTIVATED, S_PACKAGE_INVALID</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Package::deactivate()</preamble>
						  <artwork><![CDATA[CICM::Status deactivate();]]></artwork>
						  <postamble>Deactivate a specific package on the module.</postamble>
						</figure>
						<t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_NOT_ACTIVE,
								  S_PACKAGE_INVALID</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Package::delete()</preamble>
						  <artwork><![CDATA[CICM::Status delete();]]></artwork>
						  <postamble>Delete a package from the module.</postamble>
						</figure>
						<t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_ACTIVATED,
								  S_PACKAGE_INVALID</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::PackageIterator">
					<figure>
					  <preamble>Interface CICM::PackageIterator</preamble>
					  <artwork><![CDATA[interface PackageIterator : CICM::Iterator {]]></artwork>
					  <postamble>CICM::PackageIterator supports retrieving a reference to each
						software package available on a module. CICM::PackageIterator
						constructs the CICM::Package interface.</postamble>
					</figure>

					<section title="CICM::PackageIterator Inheritance">
						<t>CICM::PackageIterator inherits from: CICM::Iterator.</t>
					</section>
					<section title="CICM::PackageIterator Methods">
						<figure>
						  <preamble>Method CICM::PackageIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::Package package_ref
);]]></artwork>
						  <postamble>Returns a reference to the next software package.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Use CICM::Iterator::has_next to determine if additional
								elements exist.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] package_ref Reference to next software package.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Logs">
				<t>These interfaces support the retrieval and removal of log entries.</t>
				<section title="Interface CICM::LogManager">
					<figure>
					  <preamble>Interface CICM::LogManager</preamble>
					  <artwork><![CDATA[interface LogManager {]]></artwork>
					  <postamble>CICM::LogManager supports retrieving or destroying an entire
						module log, or retrieving or deleting individual log entries. It is
						accessed from CICM::CryptoModule via the
						CICM::CryptoModule::log_manager attribute. CICM::LogManager
						constructs the CICM::LogEntryIterator interface.</postamble>
					</figure>
					<!-- t>{FIGURE REMOVED}</t>
					<t>Figure 16. Interface Relationship Diagram for LogManager</t -->
					<figure>
					  <preamble>Example (C++):</preamble>
<artwork><![CDATA[// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;
CICM::Status sCode;
CICM::LogManager logManager;

// Retrieve reference to the log manager.
logManager = device._get_log_manager();

// Retrieve reference to a log entry iterator.
CICM::LogEntryIterator iter;
iter = logManager._get_log_entry_iterator();
CICM::Iterator::Status status;
CICM::LogEntry entry;

// Confirm that there are log entries.
sCode = iter.hasNext(&status);

// Iterate over the log entries.
while( CICM::Iterator::C_ITERATOR_HAS_NEXT == status ) {
        sCode = iter.get_next(&entry);
		// Perform an operation on [entry].
        sCode = iter.hasNext(&status);
}
// Delete all of the log entries.
sCode = logManager.destroy();]]></artwork>
					</figure>

					<section title="CICM::LogManager Attributes">
						<figure>
						  <preamble>Attribute CICM::LogManager::log_entry_iterator</preamble>
						  <artwork><![CDATA[readonly attribute CICM::LogEntryIterator log_entry_iterator;]]></artwork>
						  <postamble>Returns an iterator to enable a reference to each module
							CICM::LogEntry to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
							  <t>The returned iterator is set to the beginning of the iterated
							  sequence.</t>
							</list>
						</t>
					</section>
					<section title="CICM::LogManager Methods">
						<figure>
							<preamble>Method CICM::LogManager::retrieve()</preamble>
<artwork><![CDATA[ CICM::Status retrieve(
	out CICM::Buffer log_ref
);]]></artwork>
							<postamble>Retrieve a reference to the entire module log.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[out] log_ref Reference to entire module log.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::LogManager::destroy()</preamble>
						  <artwork><![CDATA[CICM::Status destroy();]]></artwork>
						  <postamble>Destroy all entries in the module log.</postamble>
						</figure>
						<t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::LogEntry">
					<figure>
					  <preamble>Interface CICM::LogEntry</preamble>
					  <artwork><![CDATA[interface LogEntry {]]></artwork>
					  <postamble>CICM::LogEntry serves as a reference to an individual log
						entry in the module log, and supports retrieving information about
						an individual log entry and deleting an individual log entry.</postamble>
					</figure>

					<section title="CICM::LogEntry Attributes">
						<figure>
						  <preamble>Attribute CICM::LogEntry::user_id</preamble>
						  <artwork><![CDATA[readonly attribute CICM::UserId user_id;]]></artwork>
						  <postamble>User initiating the module action resulting in this log entry.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::LogEntry::role_id</preamble>
						  <artwork><![CDATA[readonly attribute CICM::RoleId role_id;]]></artwork>
						  <postamble>Role under which the module action resulting in this log
							entry was initiated.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::LogEntry::message</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString message;]]></artwork>
						  <postamble>Log message associated with this log entry.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::LogEntry::date_time</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString date_time;]]></artwork>
						  <postamble>Date/time of creation of this log entry.</postamble>
						</figure>
					</section>
					<section title="CICM::LogEntry Methods">
						<figure>
						  <preamble>Method CICM::LogEntry::delete()</preamble>
						  <artwork><![CDATA[CICM::Status delete();]]></artwork>
						  <postamble>Remove the current entry from the module log.</postamble>
						</figure>
						<t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_LOG_ENTRY_INVALID</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::LogEntryIterator">
					<figure>
					  <preamble>Interface CICM::LogEntryIterator</preamble>
					  <artwork><![CDATA[interface LogEntryIterator : CICM::Iterator {]]></artwork>
					  <postamble>CICM::LogEntryIterator supports retrieving a reference to
						each log entry in the module log. CICM::LogEntryIterator constructs
						the CICM::LogEntry interface.</postamble>
					</figure>

					<section title="CICM::LogEntryIterator Inheritance">
						<t>CICM::LogEntryIterator inherits from: CICM::Iterator.</t>
					</section>
					<section title="CICM::LogEntryIterator Methods">
						<figure>
						  <preamble>Method CICM::LogEntryIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::LogEntry log_entry_ref
);]]></artwork>
						  <postamble>Returns a reference to the next log entry.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Use CICM::Iterator::has_next to determine if additional elements exist.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[out] log_entry_ref Reference to next log entry.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Tests">
				<t>These interfaces support the initiation of module internal tests by client programs.</t>

				<section title="Interface CICM::TestManager">
					<figure>
					  <preamble>Interface CICM::TestManager</preamble>
					  <artwork><![CDATA[interface TestManager {]]></artwork>
					  <postamble>CICM::TestManager supports initiating client program-invoked
						module built-in tests. It is accessed from CICM::CryptoModule via
						the CICM::CryptoModule::test_manager attribute.</postamble>
					</figure>
					<!-- t>{FIGURE REMOVED}</t>
					<t>Figure 17. Interface Relationship Diagram for TestManager</t -->

					<section title="CICM::TestManager Types and Constants">
						<figure>
						  <preamble>Type CICM::TestManager::Status</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 Status;]]></artwork>
						  <postamble>Test state at completion.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::TestManager::C_TEST_SUCCESS</preamble>
<artwork><![CDATA[const CICM::TestManager::Status
	C_TEST_SUCCESS = 0x00006062;]]></artwork>
							<postamble>The test completed successfully.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::TestManager::C_TEST_FAILURE</preamble>
<artwork><![CDATA[const CICM::TestManager::Status
	C_TEST_FAILURE = 0x00006064;]]></artwork>
							<postamble>The test failed.</postamble>
						</figure>
					 </section>
					 <section title="CICM::TestManager Methods">
						<figure>
							<preamble>Method CICM::TestManager::run_test()</preamble>
<artwork><![CDATA[CICM::Status run_test(
	in  CICM::Buffer test_parameters,
	out CICM::TestManager::Status status
);]]></artwork>
							<postamble>Run module built-in tests specifying module-specific test parameters.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This method can only initiate tests that a client program
								can explicitly request (e.g., this method does not apply to a
								series of tests automatically initiated during a module's
								start-up sequence). Running built-in tests on some modules may
								result in an alarm if an error is encountered during the test
								run.</t>
								<t>The format of the test parameters value is not defined by
								CICM. The Implementation Conformance Statement (see Conformance and Extensions
                in <xref target="CICM" />) MUST reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] test_parameters Module-specific test parameters.</t>
								<t>[out] status Status of test at completion.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_MODULE_IN_USE,
								  S_INVALID_DATA_BUFFER, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
								<t>CICM::TestManager::run_test_get_results for the version of
								this method that returns test results.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::TestManager::run_test_get_results()</preamble>
<artwork><![CDATA[CICM::Status run_test_get_results(
	in  CICM::Buffer test_parameters,
	out CICM::Buffer test_results
);]]></artwork>
						  <postamble>Run module built-in tests specifying module-specific test
							parameters and receiving module-specific results or data for later
							evaluation from the test run.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This method can only initiate tests that a client program
								can explicitly request (e.g., this method does not apply to a
								series of tests automatically initiated during a module's
								start-up sequence). Running built-in tests on some modules may
								result in an alarm if an error is encountered during the test
								run.</t>
								<t>The formats of the test parameters and test results values
								are not defined by CICM. The Implementation Conformance
								Statement (see Conformance and Extensions in <xref target="CICM" />) MUST
								reference a standard format or define a module
								developer-specific format implemented by the module for these
								datatypes.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] test_parameters Module-specific test parameters.</t>
								<t>[out] test_results Results of the test.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_MODULE_IN_USE,
								  S_INVALID_DATA_BUFFER, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
								<t>CICM::TestManager::run_test for the version of this Method
								that returns a simple test status value.</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Module Events">
				<t>In certain cases it may be necessary for a
				module to asynchronously notify a client program of an event.
				Client programs can register to receive module notifications using
				CICM::ModuleEventManager. This manager enables a client program to
				register a listener (callback) method designed to handle a specific
				condition. The event method prototype provided by the client
				program is defined in CICM::ModuleEventListener.
				CICM::ModuleEventListener also defines the conditions that may
				result in a notification, including: hardware requires attention,
				alarm, key expired, and health test failure.</t>
				<t>In certain cases, a single event on a module may result in the
				generation of multiple notification messages. For example,
				CICM::ModuleEventListener::C_MODULE_ALARM may be followed by a
				CICM::ModuleEventListener::C_MODULE_NOT_READY_FOR_TRAFFIC.</t>

				<section title="Interface CICM::ModuleEventManager">
					<figure>
					  <preamble>Interface CICM::ModuleEventManager</preamble>
					  <artwork><![CDATA[interface ModuleEventManager {]]></artwork>
					  <postamble>CICM::ModuleEventManager supports registering and
						unregistering user-defined module event listeners
						(CICM::ModuleEventListener) for specific module events. It is
						accessed from CICM::CryptoModule via the
						CICM::CryptoModule::event_manager attribute.</postamble>
					</figure>
					<!-- t>{FIGURE REMOVED}</t>
					<t>Figure 18. Interface Relationship Diagram for ModuleEventManagers</t -->

					<section title="CICM::ModuleEventManager Methods">
						<figure>
						  <preamble>Method CICM::ModuleEventManager::register()</preamble>
<artwork><![CDATA[CICM::Status register(
	in  CICM::ModuleEventListener::ModuleEvent event,
	in  CICM::ModuleEventListener listener
);]]></artwork>
						  <postamble>Registers the listener for a specific module event.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The provided listener applies only to the client program
								from which the registration is initiated.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] event Event for which this listener is being registered.</t>
								<t>[in] listener Listener that will receive a notification about the
									  specified event.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_MODULE_RESOURCES,
								  S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE,
								  S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED,
								  S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_EVENT_REGISTERED,
								  S_EVENT_NOT_SUPPORTED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::ModuleEventManager::unregister()</preamble>
<artwork><![CDATA[CICM::Status unregister(
	in  CICM::ModuleEventListener::ModuleEvent event
);]]></artwork>
						  <postamble>Unregisters the listener associated with the specified event.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The listener associated with the specified event is only
								unregistered from the client program from which this method is
								called.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] event Event that will no longer have a listener associated with it.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_MODULE_RESOURCES,
								  S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE,
								  S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED,
								  S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_EVENT_NOT_REGISTERED</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::ModuleEventListener">
					<figure>
					  <preamble>Interface CICM::ModuleEventListener</preamble>
					  <artwork><![CDATA[interface ModuleEventListener {]]></artwork>
					  <postamble>CICM::ModuleEventListener is unlike other CICM interfaces in
						that the interface is implemented by the developer of the client
						program to service a specific module event and is then registered
						via the CICM::ModuleEventManager.</postamble>
					</figure>

					<section title="CICM::ModuleEventListener Types and Constants">
						<figure>
						  <preamble>Type CICM::ModuleEventListener::ModuleEvent</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 ModuleEvent;]]></artwork>
						  <postamble>Events for which a ModuleEventListener can be notified.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_ACCESS_TOKEN_INSERTED</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ACCESS_TOKEN_INSERTED = 0x00002001;]]></artwork>
							<postamble>Access token has been inserted.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_ACCESS_TOKEN_REMOVED</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ACCESS_TOKEN_REMOVED = 0x00002002;]]></artwork>
							<postamble>Access token has been removed.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_ALARM</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ALARM = 0x00002004;]]></artwork>
							<postamble>Module has entered an alarm state.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_FAILURE</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_FAILURE = 0x00002007;]]></artwork>
							<postamble>Non-critical module failure detected.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_INSUFFICIENT_ENTROPY</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_INSUFFICIENT_ENTROPY = 0x00002008;]]></artwork>
						    <postamble>Insufficient entropy available to a cryptographic operation
								that requires it.</postamble>
						 </figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_KEY_EXPIRED_HARD</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_EXPIRED_HARD =	0x0000200B;]]></artwork>
							<postamble>Specific key has expired; the module can optionally include
							  identifying information about the specific key that expired in
							  the event_data buffer that is provided with the event
							  itself.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_KEY_EXPIRED_SOFT</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_EXPIRED_SOFT = 0x0000200D;]]></artwork>
							<postamble>Specific key is within some system-defined delta of hard
							  expiration; the module can optionally include identifying
							  information about the specific key that is about to expire in the
							  event_data buffer that is provided with the event itself.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_KEY_FILL_COMPLETE</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_FILL_COMPLETE = 0x0000200E;]]></artwork>
							<postamble>Key fill is complete.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_KEY_FILL_CONNECTED</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_FILL_CONNECTED = 0x00002010;]]></artwork>
							<postamble>Key fill device has been connected.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_KEY_FILL_INITIATED</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_FILL_INITIATED = 0x00002013;]]></artwork>
							<postamble>Key fill has been initiated.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_KEY_MEMORY</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_MEMORY = 0x00002015;]]></artwork>
							<postamble>Out of internal key memory condition.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_KEY_PROTO_MESSAGE</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_PROTO_MESSAGE = 0x00002016;]]></artwork>
							<postamble>Key protocol message is available; see the Key Protocol
								Management documentation for additional information.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_LOG_FULL</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_LOG_FULL = 0x00002019;]]></artwork>
							<postamble>Module log is full.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_LOG_NEAR_FULL</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_LOG_NEAR_FULL = 0x0000201A;]]></artwork>
							<postamble>Module log is nearly full.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_LOGIN_FAILURE</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_LOGIN_FAILURE = 0x0000201C;]]></artwork>
							<postamble>Attempted login failed.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_NOT_READY_FOR_TRAFFIC</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_NOT_READY_FOR_TRAFFIC = 0x0000201F;]]></artwork>
							<postamble>Module is not able to process traffic.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_POWER_MGMT_ENTER</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
C_MODULE_POWER_MGMT_ENTER = 0x00002020;]]></artwork>
							<postamble>Module has entered power management state.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_POWER_MGMT_EXIT</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_MGMT_EXIT = 0x00002023;]]></artwork>
							<postamble>Module has exited power management state.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_POWER_OFF</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_OFF = 0x00002025;]]></artwork>
							<postamble>Change in module power state to OFF detected.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_POWER_OFF_FAILURE</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_OFF_FAILURE = 0x00002026;]]></artwork>
							<postamble>Disorderly change in module power state to OFF detected.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_POWER_ON</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_ON = 0x00002029;]]></artwork>
							<postamble>Change in module power state to ON detected.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_READY_FOR_TRAFFIC</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_READY_FOR_TRAFFIC = 0x0000202A;]]></artwork>
							<postamble>Module is ready to process traffic.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_REKEY_REQUEST</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_REKEY_REQUEST = 0x0000202C;]]></artwork>
							<postamble>Rekey of a specific key is required; the module can
							  optionally include identifying information about the specific key
							  to be rekeyed in the event_data buffer that is provided with the
							  event itself.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_TEST_FAILURE</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_TEST_FAILURE = 0x0000202F;]]></artwork>
							<postamble>Module internal test has failed; the module can optionally
							  include identifying information about the specific test that
							  failed in the event_data buffer that is provided with the event
							  itself.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_ZEROIZED</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ZEROIZED = 0x00002031;]]></artwork>
							<postamble>Module has been zeroized.</postamble>
						</figure>
					</section>
					<section title="CICM::ModuleEventListener Methods">
						<figure>
							<preamble>Method CICM::ModuleEventListener::event_occurred()</preamble>
<artwork><![CDATA[void event_occurred(
	in  CICM::ModuleEventListener::ModuleEvent event,
	in  CICM::Buffer event_data
);]]></artwork>
							<postamble>Method implemented by client program that is called by the
								host runtime system to notify that a specific module event has
								occurred.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>An opaque data field with additional information about the
								event in a module-specific format MAY optionally be provided
								with the event itself. This field MAY be of length zero.</t>
								<t>The format of the event data value is not defined in this
								specification. The Implementation Conformance Statement (see
								Conformance and Extensions in <xref target="CICM" />) MUST reference a
								standard format or define a module-specific format for this
								datatype.</t>
							</list>
						</t><t>Note:
							<list>
							    <t>Because this method is called by the runtime system and not
                    a client program, it does not return a status value.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] event Event that occurred.</t>
								<t>[in] event_data Opaque data associated with the event (e.g., specific
									  test that failed, key that will expire).</t>
							</list>
						</t>
					</section>
				</section>
			</section>
      <section title="IANA Considerations">
        <t>[RFC Editor: Please remove this section prior to publication.]</t>
        <t>This document has no IANA actions.</t>
      </section>
      <section title="Security Considerations">
        <section title="Unauthorized Usage">
          <t>A cryptographic module is typically a controlled resource which requires
          appropriate authorization to use. Specific implementations may use a combination
          of hardware access tokens, usernames and passwords, access control lists,
          or other means.</t>
          <t>CICM defines the TokenManager, UserManager, and LoginManager interfaces
          to facilitate with the management of authorized users and to provide authentication
          capabilities.</t>
        </section>
        <section title="Inappropriate Usage">
          <t>Although CICM does not define audit logs as a separate concept,
          the LogManager interface can conceivably provide enough information
          to act as a means for tracking inappropriate usage which is especially
          important for the operations that manage the module itself:
          managing users, updating the module software, and running the built-in
          tests. Additionally, manipulation of the module logs may undermine
          the value of the auditing countermeasure.</t>
        </section>
        <section title="Denial of Service">
          <t>As suggested by <xref target="RFC3552" />, implementers are advised to
          include mechanisms that mitigate against denial of service attacks.
          This is primarily an issue for modules that authenticate using a
          user name and password, although this may also be an issue for hardware
          access tokens.</t>
        </section>
      </section>
  </middle>
  <back><!-- Back material. -->
    <references title="Normative References">
      <?rfc include="reference.RFC.2119" ?>

      <reference anchor="CICM">
        <front>
          <title>Common Interface to Cryptographic Modules (CICM)
          [RFC Editor: Please update the RFC reference and date prior to publication.]</title>
          <author fullname="Daniel J. Lanz" initials="D." surname="Lanz" />
          <author fullname="Lev Novikov" initials="L." surname="Novikov" />
          <date year="2011" month="January" />
        </front>
        <format type="TXT" target="http://tools.ietf.org/id/draft-lanz-cicm-02.txt" />
      </reference>

      <reference anchor="CICM-KM">
        <front>
          <title>Common Interface to Cryptographic Modules (CICM) Key Management
          [RFC Editor: Please update the RFC reference and date prior to publication.]</title>
          <author fullname="Daniel J. Lanz" initials="D." surname="Lanz" />
          <author fullname="Lev Novikov" initials="L." surname="Novikov" />
          <date year="2011" month="January" />
        </front>
        <format type="TXT" target="http://tools.ietf.org/id/draft-lanz-cicm-km-00.txt" />
      </reference>

      <reference anchor="IDL">
        <front>
          <title>Information technology  Open Distributed Processing  Interface Definition Language</title>
          <author>
            <organization>International Standards Organization</organization>
          </author>
          <date year="1999" month="March" day="15" />
        </front>
        <seriesInfo name="ISO/IEC" value="14750:1999(E)" />
      </reference>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.3552" ?>

      <reference anchor="CICM-LM">
        <front>
          <title>Common Interface to Cryptographic Modules (CICM) Logical Model
          [RFC Editor: Please update the RFC reference and date prior to publication.]</title>
          <author fullname="Daniel J. Lanz" initials="D." surname="Lanz" />
          <author fullname="Lev Novikov" initials="L." surname="Novikov" />
          <date year="2011" month="January" />
        </front>
        <format type="TXT" target="http://tools.ietf.org/id/draft-lanz-cicm-model-00.txt" />
      </reference>

      <reference anchor="CORBA"><front>
        <title>Common Object Request Broker Architecture (CORBA) Specification, Version 3.1</title>
        <author>
          <organization>Object Management Group</organization>
        </author>
        <date year="2008" month="January" />
      </front></reference>
    </references>
    <section anchor="idl-code" title="IDL Definitions"><figure><artwork><![CDATA[module CICM {
  typedef CICM::CharString TokenRecord;
  typedef CICM::CharString ModuleRecord;

  interface TokenAssnIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::TokenRecord token_rec_ref );
  };

  interface ModuleAssnIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::ModuleRecord module_rec_ref );
  };

  interface TokenManager {
    readonly attribute CICM::ModuleAssnIterator
      module_association_iterator;

    readonly attribute CICM::TokenAssnIterator
      token_association_iterator;

    CICM::Status associate(
      out CICM::ModuleRecord module_rec,
      out CICM::TokenRecord token_rec );

    CICM::Status disassociate();

    CICM::Status disassociate_missing_module(
      in  CICM::ModuleRecord module_rec );

    CICM::Status disassociate_missing_token(
      in  CICM::TokenRecord token_rec );
  };

  typedef CICM::CharString UserId;
  typedef CICM::CharString RoleId;

  interface UserIdIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::UserId user_id );
  };

  interface RoleIdIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::RoleId role_id );
  };

  interface UserManager {
    readonly attribute CICM::UserIdIterator user_iterator;
    readonly attribute CICM::RoleIdIterator role_iterator;

    CICM::Status add(
      in  CICM::UserId user,
      in  CICM::CharString password );

    CICM::Status modify(
      in  CICM::UserId user,
      in  CICM::CharString password );

    CICM::Status remove(
      in  CICM::UserId user );

    CICM::Status associate(
      in  CICM::UserId user,
      in  CICM::RoleId role );

    CICM::Status disassociate(
      in  CICM::UserId user,
      in  CICM::RoleId role );
  };

  interface Login {
    CICM::Status logout();
  };

  interface LoginManager {
     CICM::Status login(
      in  CICM::UserId user,
      in  CICM::CharString password,
      out CICM::Login login_ref );

    CICM::Status login_auth_data(
      in  CICM::UserId user,
      in  CICM::CharString password,
      in  CICM::Buffer auth_data,
      out CICM::Login login_ref );
  };

  typedef CICM::CharString PackageId;

  interface Package {
    typedef CICM::UInt32 PackageType;
    const CICM::Package::PackageType
      C_PACKAGE_ALGORITHM = 0x00006054;

    const CICM::Package::PackageType
      C_PACKAGE_CONFIG_PARAMS = 0x00006057;

    const CICM::Package::PackageType
      C_PACKAGE_FPGA_IMAGE = 0x00006058;

    const CICM::Package::PackageType
      C_PACKAGE_POLICY_DB = 0x0000605B;

    const CICM::Package::PackageType
      C_PACKAGE_SOFTWARE = 0x0000605D;

    readonly attribute CICM::PackageId id;

    CICM::Status activate();
    CICM::Status deactivate();
    CICM::Status delete();
  };

  interface PackageIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::Package package_ref );
  };

  interface PackageImporter {
    CICM::Status import_segment(
      in  CICM::Buffer package_data );

    CICM::Status complete(
      out CICM::Package package_ref );

    CICM::Status abort();
  };

  interface PackageManager {
    readonly attribute CICM::PackageIterator package_iterator;

    CICM::Status import_package(
      in  CICM::Package::PackageType package_type,
      out CICM::PackageImporter importer_ref );

    CICM::Status import_package_with_key(
      in  CICM::Package::PackageType package_type,
      in  CICM::SymKey key_ref,
      out CICM::PackageImporter importer_ref );

    CICM::Status get_package_by_id(
      in  CICM::PackageId package_id,
      out CICM::Package package_ref );

    CICM::Status reencrypt_software();
  };

  interface LogEntry {
    readonly attribute CICM::UserId user_id;
    readonly attribute CICM::RoleId role_id;
    readonly attribute CICM::CharString message;
    readonly attribute CICM::CharString date_time;

    CICM::Status delete();
  };

  interface LogEntryIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::LogEntry log_entry_ref );
  };

  interface LogManager {
    readonly attribute CICM::LogEntryIterator log_entry_iterator;

    CICM::Status retrieve(
      out CICM::Buffer log_ref );

    CICM::Status destroy();
  };

  interface TestManager {
    typedef CICM::UInt32 Status;
    const CICM::TestManager::Status C_TEST_SUCCESS = 0x00006062;
    const CICM::TestManager::Status C_TEST_FAILURE = 0x00006064;

    CICM::Status run_test(
      in  CICM::Buffer test_parameters,
      out CICM::TestManager::Status status );

    CICM::Status run_test_get_results(
      in  CICM::Buffer test_parameters,
      out CICM::Buffer test_results );
  };

  interface ModuleEventListener {
    typedef CICM::UInt32 ModuleEvent;
    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_ACCESS_TOKEN_INSERTED = 0x00002001;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_ACCESS_TOKEN_REMOVED = 0x00002002;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_ALARM = 0x00002004;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_FAILURE = 0x00002007;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_INSUFFICIENT_ENTROPY = 0x00002008;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_EXPIRED_HARD = 0x0000200B;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_EXPIRED_SOFT = 0x0000200D;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_FILL_COMPLETE = 0x0000200E;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_FILL_CONNECTED = 0x00002010;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_FILL_INITIATED = 0x00002013;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_MEMORY = 0x00002015;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_PROTO_MESSAGE = 0x00002016;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_LOG_FULL = 0x00002019;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_LOG_NEAR_FULL = 0x0000201A;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_LOGIN_FAILURE = 0x0000201C;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_NOT_READY_FOR_TRAFFIC = 0x0000201F;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_POWER_MGMT_ENTER = 0x00002020;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_POWER_MGMT_EXIT = 0x00002023;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_POWER_OFF = 0x00002025;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_POWER_OFF_FAILURE = 0x00002026;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_POWER_ON = 0x00002029;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_READY_FOR_TRAFFIC = 0x0000202A;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_REKEY_REQUEST = 0x0000202C;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_TEST_FAILURE = 0x0000202F;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_ZEROIZED = 0x00002031;

    void event_occurred(
      in  CICM::ModuleEventListener::ModuleEvent event,
      in  CICM::Buffer event_data );
  };

  interface ModuleEventManager {
    CICM::Status register(
      in  CICM::ModuleEventListener::ModuleEvent event,
      in  CICM::ModuleEventListener listener );

    CICM::Status unregister(
      in  CICM::ModuleEventListener::ModuleEvent event );
  };
};]]></artwork></figure>
    </section>
  </back>
</rfc>