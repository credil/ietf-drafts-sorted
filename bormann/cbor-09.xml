<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<rfc ipr="trust200902" docName="draft-bormann-cbor-09" category="std">

<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

  <front>
    <title abbrev="CBOR">Concise Binary Object Representation (CBOR)</title>

    <author initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization>Universität Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>D-28359 Bremen</city>
          
          
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        
        <email>cabo@tzi.org</email>
        
      </address>
    </author>
    <author initials="P." surname="Hoffman" fullname="Paul Hoffman">
      <organization>VPN Consortium</organization>
      <address>
        
        
        <email>paul.hoffman@vpnc.org</email>
        
      </address>
    </author>

    <date year="2013" month="September" day="12"/>

    <area>Internet</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>The Concise Binary Object Representation (CBOR) is a data format whose design goals include the
possibility of extremely small code size, fairly small message size, and extensibility without the
need for version negotiation. These design goals make it different from earlier binary
serializations such as ASN.1 and MessagePack.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>There are hundreds of standardized formats for binary representation
of structured data (also known as binary serialization formats).  Of those,
some are for specific domains of information, while others are generalized for arbitrary data.  In
the IETF, probably the best-known formats in the latter category are ASN.1’s BER and DER <xref target="ASN.1"/>.</t>

<t>The format defined here follows some specific design goals that are not well met by current formats.
The underlying data model is an extended version of the JSON data model <xref target="RFC4627"/>.  It is important to
note that this is not a proposal that the grammar in RFC 4627 be extended in general, since doing so
would cause a significant backwards incompatibility with already-deployed JSON documents. Instead,
this document simply defines its own data model which starts from JSON.</t>

<t><xref target="comparison-app"/> lists some existing binary formats and discusses how well they do or do not fit the
design objectives of CBOR.</t>

<section anchor="objectives" title="Objectives">

<t>The objectives of the Concise Binary Object Representation (CBOR),
roughly in decreasing order of importance, are:</t>

<t><list style='numbers'>
  <t>The representation must be able to unambiguously encode most common
data formats used in Internet standards.  <list style='symbols'>
      <t>Representing a reasonable set of basic data types and structures
 using binary encoding.  “Reasonable” here is largely influenced by
 the capabilities of JSON, with the major addition of binary byte
 strings.  The structures supported are limited to arrays and trees; loops and
 lattice-style graphs are not supported.</t>
      <t>There is no requirement that all data formats be uniquely
 encoded; that is, it is acceptable that the number “7” might be
 encoded in multiple different ways.</t>
    </list></t>
  <t>The code for an encoder or decoder must be able to be compact in
order to support systems with very limited memory and processor
power and instruction sets.  <list style='symbols'>
      <t>An encoder and a decoder need to be implementable in a very small amount of code
 (for example, in class 1 constrained nodes as defined
 in <xref target="I-D.ietf-lwig-terminology"/>).</t>
      <t>The format should use contemporary machine
 representations of data (for example, not requiring binary-to-decimal
 conversion).</t>
    </list></t>
  <t>Data must be able to be decoded without a schema description.  <list style='symbols'>
      <t>Similar to JSON, encoded data should be self-describing so
that a generic decoder can be written.</t>
    </list></t>
  <t>The serialization must be reasonably compact, but data compactness is
secondary to code compactness for the encoder and decoder.  <list style='symbols'>
      <t>“Reasonable” here is bounded by JSON
 as an upper bound in size, and by implementation complexity
 maintaining a lower bound.  Using either general compression
 schemes or extensive bit-fiddling violates the
 complexity goals.</t>
    </list></t>
  <t>The format must be applicable to both constrained nodes and high-volume applications.  <list style='symbols'>
      <t>This means it must be reasonably frugal in CPU usage for both encoding and decoding.
 This is relevant both for constrained nodes and for potential usage
 in applications with a very high volume of data.</t>
    </list></t>
  <t>The format must support all JSON data types for conversion to and from JSON.  <list style='symbols'>
      <t>It must support a reasonable level of conversion as long
 as the data represented are within the capabilities of JSON.
 It must be possible to define a unidirectional mapping towards JSON for all types of
 data.</t>
    </list></t>
  <t>The format must be extensible, with the extended data being able to be decoded by
earlier decoders.  <list style='symbols'>
      <t>The format is designed for decades of use.</t>
      <t>The format must support a form of extensibility that allows
 fallback so that a decoder that does not understand an extension
 can still decode the message.</t>
      <t>The format must be able to be extended in the future by later
 IETF standards.</t>
    </list></t>
</list></t>

</section>
<section anchor="terminology" title="Terminology">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this
document are to be interpreted as described in RFC 2119, BCP 14
<xref target="RFC2119"/> and indicate requirement levels for compliant CBOR
implementations.</t>

<t>The term “byte” is used in its now-customary sense as a synonym for
“octet”. All multi-byte values are encoded in network byte order
(that is, most significant byte first, also known as “big-endian”).</t>

<t>This specification makes use of the following terminology:</t>

<t><list style='hanging'>
  <t hangText='Data item:'>
  A single piece of CBOR data.  The structure of a data item may contain
zero, one or more nested data items.  The term is used both for the
data item in representation format and for the abstract idea that can
be derived from that by a decoder.</t>
  <t hangText='Decoder:'>
  A process that decodes a CBOR data item and makes it available to an
application.  Formally speaking, a decoder contains a parser to break
up the input using the syntax rules of CBOR, as well as a semantic
processor to prepare the data in a form suitable to the application.</t>
  <t hangText='Encoder:'>
  A process that generates the representation format of a CBOR data
item from application information.</t>
  <t hangText='Data Stream:'>
  A sequence of zero or more data items, not further assembled into a
larger containing data item.  The independent data items that make up
a data stream are sometimes also referred to as “top-level data items”.</t>
  <t hangText='Well-formed:'>
  A data item that follows the syntactic structure of CBOR.
A well-formed data item uses the initial bytes and the byte strings
and/or data items that are implied by their values as defined in CBOR
and is not followed by extraneous data.</t>
  <t hangText='Valid:'>
  A data item that is well-formed and also follows the semantic
restrictions that apply to CBOR data items.</t>
  <t hangText='Stream decoder:'>
  A process that decodes a data stream and makes each of the data
items in the sequence available to an application as they are received.</t>
</list></t>

<t>Where bit arithmetic or data types are explained, this document uses
the notation familiar from the programming language C, except that
** denotes exponentiation.  Similar to the
“0x” notation for hexadecimal numbers, numbers in binary notation are
prefixed with “0b”.  Underscores can be added to such a number solely
for readability, so 0b00100001 (0x21) might be written 0b001_00001 to
emphasize the desired interpretation of the bits in the byte, in this case
split into three bits and five bits.</t>

</section>
</section>
<section anchor="specification-of-the-cbor-encoding" title="Specification of the CBOR Encoding">

<t>A CBOR encoded data item is structured and encoded as described in
this section.  The encoding is summarized in
<xref target="jumptable"/>.</t>

<t>The initial byte of each data item contains both information about the
major type (the high-order 3 bits, described in <xref target="majortypes"/>) and additional information (the
low-order 5 bits).
When the value of the additional information is less than 24, it is directly used as a
small unsigned integer.
When it is 24 to 27, the additional bytes for a variable-length integer immediately follow;
the values 24 to 27 of the additional information specify that its length is a 1-, 2-, 4-
or 8-byte unsigned integer, respectively.
Additional information value 31 is used for indefinite length items, described
in <xref target="indefinite"/>.
Additional information values 28 to 30 are reserved for future expansion.</t>

<t>In all additional information values, the resulting integer is interpreted depending on
the major type.
It may represent the actual data: for example, in integer types the
resulting integer is used for the value itself.
It may instead supply length information: for example, in byte strings it gives
the length of the byte string data that follows.</t>

<t>A CBOR decoder implementation can be based on a jump table with all
256 defined values for the initial byte (<xref target="jumptable"/>).  A decoder in
a constrained implementation can instead use the structure of the
initial byte and following bytes for more compact code (see
<xref target="pseudocode"/> for a rough impression of how this could look like).</t>

<section anchor="majortypes" title="Major Types">

<t>The following lists the major types and the additional
information and other bytes associated with the type.</t>

<t><list style='hanging'>
  <t hangText='Major type 0:'>
  an unsigned integer. The 5-bit additional information is either the
integer itself (for additional information values 0 through
23), or the length of additional data.  Additional information
24 means the value is represented in an additional uint8_t,
25 means a uint16_t, 26 means a uint32_t, and 27
means a uint64_t.  For example, the integer 10 is denoted as the one
byte 0b000_01010 (major type 0, additional information 10).
The integer 500 would be 0b000_11001 (major type 0, additional
information 25) followed by the
two bytes 0x01f4, which is 500 in decimal.</t>
  <t hangText='Major type 1:'>
  a negative integer. The encoding follows the rules for unsigned
integers (major type 0), except that the value is then -1 minus
the encoded unsigned integer.
For example, the integer -500 would be 0b001_11001 (major type 1, additional
information 25) followed by the
two bytes 0x01f3, which is 499 in decimal.</t>
  <t hangText='Major type 2:'>
  a byte string. The string’s length in bytes is represented
following the rules for positive integers (major type 0).  For
example, a byte string whose length is 5 would have an initial byte of
0b010_00101 (major type 2, additional information 5 for the length),
followed by 5 bytes of binary content. A byte string whose
length is 500 would have 3 initial bytes of 0b010_11001 (major type 2,
additional information 25 to indicate a two-byte length) followed by the
two bytes 0x01f4 for a length of 500, followed by 500 bytes of binary content.</t>
  <t hangText='Major type 3:'>
  a text string, specifically a string of Unicode characters that is encoded as UTF-8 <xref target="RFC3629"/>.  The format
of this type is identical to that of byte strings (major type 2), that is,
as with major type 2, the length gives the number of bytes.
This type is provided for systems that need to interpret or display
human-readable text, and allows the differentiation between unstructured bytes
and text that has a specified repertoire and encoding.
In contrast to formats such as JSON,
the Unicode characters in this type are never escaped. Thus,
a newline character (U+000A) is always represented in a string as the byte 0x0a,
and never as the bytes 0x5c6e (the characters “\” and “n”) or as 0x5c7530303061
(the characters “\”, “u”, “0”, “0”, “0”, and “a”).</t>
  <t hangText='Major type 4:'>
  an array of data items.  Arrays are also called lists, sequences, or tuples.
The array’s length follows the rules for
byte strings (major type 2), except that the length denotes the
number of data items, not the length in bytes that the array takes
up.  Items in an array do not need to all be of the same type.
For example, an array that contains 10 items of any type would
have an initial byte of 0b100_01010 (major type of 4, additional information
of 10 for the length) followed by the 10 remaining items.</t>
  <t hangText='Major type 5:'>
  a map of pairs of data items. Maps are also called tables,
dictionaries, hashes, or objects (in JSON).
A map is comprised of pairs of data items, each pair consisting of a key which is immediately followed by a value.
The map’s length follows the rules for
byte strings (major type 2), except that the length denotes the
number of pairs, not the length in bytes that the map takes up.
For example, a map that contains 9 pairs would
have an initial byte of 0b101_01001 (major type of 5, additional information
of 9 for the number of pairs) followed by the 18 remaining items. The first
item is the first key, the second item is the first value, the third item
is the second key, and so on.
A map that has duplicate keys may be well-formed but it is not valid,
and thus it causes indeterminate decoding; see also <xref target="map-keys"/>.</t>
  <t hangText='Major type 6:'>
  optional semantic tagging of other major types. See <xref target="tags"/>. </t>
  <t hangText='Major type 7:'>
  floating point numbers and simple data types that need no content,
as well as the “break” stop code. See <xref target="fpnocont"/>.</t>
</list></t>

<t>These eight major types lead to a simple table showing which of the 256 possible values
for the initial byte of a data item are used (<xref target="jumptable"/>).</t>

<t>In major types 6 and 7, many of the possible values are reserved for
future specification. See <xref target="ianacons"/> for more information on these
values.</t>

</section>
<section anchor="indefinite" title="Indefinite Lengths for Some Major Types">

<t>Four CBOR items (arrays, maps, byte strings, and text strings) can be encoded with an indefinite
length using additional information value 31.
This is useful if the encoding of the item needs to begin before the
number of items inside the array or map, or the total
length of the string, is known.
(The application of this is often referred to as “streaming” within a
data item.)</t>

<t>Indefinite length arrays and maps are dealt with differently than
  indefinite length byte strings and text strings.</t>

<section anchor="indefinite-length-arrays-and-maps" title="Indefinite Length Arrays and Maps">

<t>Indefinite length
  arrays and maps are simply opened without indicating the number of
  data items that will be included in the array or map, using the
  additional information value of 31. The initial major type and
  additional information byte is followed by the elements of the array
  or map, just as they would be in other arrays or maps. The end of the
  array or map is indicated by encoding a “break” stop code in a place
  where the next data item would normally have been included.  “Break”
  is encoded with major type 7 and additional information value 31
  (0b111_11111), but is not itself a data item: it is just a syntactic
  feature to close the array or map.  That is, the “break” stop code
  comes after the last item in the array or map, and cannot occur
  anywhere else in place of a data item. In this way, indefinite length
  arrays and maps look identical to other arrays and maps except for
  beginning with the additional information value 31 and ending with
  the “break” stop code.</t>

<t>Arrays and maps with indefinite lengths allow any number of items (for arrays) and key/value pairs
(for maps) to be given before the “break” stop code.
There is no restriction against nesting indefinite length array or map items. A “break” only terminates
a single item, so nested indefinite length items need exactly as many “break”
stop codes as there are type bytes
starting an indefinite length item.</t>

<t>For example, assume an encoder wants to represent the abstract array
[1, [2, 3], [4, 5]].
The definite-length encoding would be 0x8301820203820405:</t>

<figure><artwork><![CDATA[
83        -- Array of length 3
   01     -- 1
   82     -- Array of length 2
      02  -- 2
      03  -- 3
   82     -- Array of length 2
      04  -- 4
      05  -- 5
]]></artwork></figure>

<t>Indefinite length encoding could be applied independently to each of the three arrays
encoded in this data item, as required, leading to representations
such as:</t>

<figure><artwork><![CDATA[
0x9f018202039f0405ffff
9F        -- Start indefinite length array
   01     -- 1
   82     -- Array of length 2
      02  -- 2
      03  -- 3
   9F     -- Start indefinite length array
      04  -- 4
      05  -- 5
      FF  -- "break" (inner array)
   FF     -- "break" (outer array)
]]></artwork></figure>
<figure><artwork><![CDATA[
0x9f01820203820405ff
9F        -- Start indefinite length array
   01     -- 1
   82     -- Array of length 2
      02  -- 2
      03  -- 3
   82     -- Array of length 2
      04  -- 4
      05  -- 5
   FF     -- "break"
]]></artwork></figure>
<figure><artwork><![CDATA[
0x83018202039f0405ff
83        -- Array of length 3
   01     -- 1
   82     -- Array of length 2
      02  -- 2
      03  -- 3
   9F     -- Start indefinite length array
      04  -- 4
      05  -- 5
      FF  -- "break"
]]></artwork></figure>
<figure><artwork><![CDATA[
0x83019f0203ff820405
83        -- Array of length 3
   01     -- 1
   9F     -- Start indefinite length array
      02  -- 2
      03  -- 3
      FF  -- "break"
   82     -- Array of length 2
      04  -- 4
      05  -- 5
]]></artwork></figure>

<t>An example of an indefinite length map (that happens to have two key/value pairs) might be:</t>

<figure><artwork><![CDATA[
0xbf6346756ef563416d7421ff
BF           -- Start indefinite length map
   63        -- First key, UTF-8 string length 3
      46756e --   "Fun"
   F5        -- First value, true
   63        -- Second key, UTF-8 string length 3
      416d74 --   "Amt"
   21        -- -2
   FF        -- "break"
]]></artwork></figure>

</section>
<section anchor="indefinite-length-byte-strings-and-text-strings" title="Indefinite Length Byte Strings and Text Strings">

<t>Indefinite length byte strings and text strings
  are actually a concatenation of zero or more definite length byte or text strings (“chunks”)
  that are together treated as one contiguous string. Indefinite length strings
  are opened with the major type and additional information value
  of 31, but what follows are a series of byte or text strings that
  have definite lengths (the chunks). The end of the series of chunks is indicated
  by encoding the “break” stop code (0b111_11111) in a place where the
  next chunk in the series would occur. The contents of the chunks
  are concatenated together, and the overall length of the indefinite
  length string will be the sum of the lengths of all of the chunks.
  In summary, an indefinite length string is encoded similarly to how
  an indefinite length array of its chunks would be encoded, except
  that the major type of the indefinite length string is that of a
  (text or byte) string and matches the major types of its chunks.</t>

<t>For indefinite length byte strings,
every data item (chunk) between
the indefinite length indicator and the “break” MUST be a definite length byte string
item; if the parser sees any item type other than a byte string before it sees the “break”, it is an error.</t>

<t>For example, assume the sequence:</t>

<t>0b010_11111 0b010_00100 0xaabbccdd 0b010_00011 0xeeff99 0b111_11111</t>

<figure><artwork><![CDATA[
5F              -- Start indefinite length byte string
   44           -- Byte string of length 4
      aabbccdd  -- Bytes content
   43           -- Byte string of length 3
      eeff99    -- Bytes content
   FF           -- "break"
]]></artwork></figure>

<t>After decoding, this results in a single byte string with seven bytes: 0xaabbccddeeff99.</t>

<t>Text strings with indefinite lengths act the same as byte strings with indefinite lengths, except
that all their chunks MUST be definite length text strings.
Note that this implies that the bytes of a single UTF-8 character cannot be
spread between chunks: a new chunk can only be started at a
character boundary.</t>

<t><vspace blankLines='999' /></t>

</section>
</section>
<section anchor="fpnocont" title="Floating Point Numbers and Values with No Content">

<t>Major type 7 is for two types of data: floating point numbers and
“simple values” that do not need any content.
Each value of the 5-bit
additional information in the initial byte has its own separate meaning, as defined
in <xref target="fpnoconttbl"/>.  Like the major types for integers, items of this major type do not carry
content data; all the information is in the initial bytes.</t>

<texttable title="Values for Additional Information in Major Type 7" anchor="fpnoconttbl">
      <ttcol align='left'>5-bit value</ttcol>
      <ttcol align='left'>semantics</ttcol>
      <c>0..23</c>
      <c>Simple value (value 0..23)</c>
      <c>24</c>
      <c>Simple value (value 32..255 in following byte)</c>
      <c>25</c>
      <c>IEEE 754 Half-Precision Float (16 bits follow)</c>
      <c>26</c>
      <c>IEEE 754 Single-Precision Float (32 bits follow)</c>
      <c>27</c>
      <c>IEEE 754 Double-Precision Float (64 bits follow)</c>
      <c>28-30</c>
      <c>(Unassigned)</c>
      <c>31</c>
      <c>“break” stop code for indefinite length items</c>
</texttable>

<t>As with all other major types, the 5-bit value 24 signifies a
single-byte extension: it is followed
by an additional byte to represent the simple value (to
minimize confusion, only the values 32 to 255 are used).
This maintains the structure of the initial bytes: as for the other
major types, the length of these always depends on the additional
information in the first byte.
<xref target="fpnoconttbl2"/> lists the values assigned and available for simple types.</t>

<texttable title="Simple Values" anchor="fpnoconttbl2">
      <ttcol align='left'>value</ttcol>
      <ttcol align='left'>semantics</ttcol>
      <c>0..19</c>
      <c>(Unassigned)</c>
      <c>20</c>
      <c>False</c>
      <c>21</c>
      <c>True</c>
      <c>22</c>
      <c>Null</c>
      <c>23</c>
      <c>Undefined value</c>
      <c>24..31</c>
      <c>(reserved)</c>
      <c>32..255</c>
      <c>(Unassigned)</c>
</texttable>

<t>The 5-bit values of 25, 26, and 27 are for 16-bit,
32-bit, and 64-bit IEEE 754 binary floating point values.  These
floating point values are encoded in the additional bytes of the
appropriate size.
(See <xref target="half-precision"/> for some information about 16-bit floating
point.)</t>

</section>
<section anchor="tags" title="Optional Tagging of Items">

<t>In CBOR, a data item can optionally be preceded by a tag to give it
additional semantics while retaining its structure. The tag is
major type 6, and represents an
integer number as indicated by the tag’s integer value; the (sole)
data item is carried as content data.  If a tag requires structured
data, this structure is encoded into the nested data item.
The definition of a tag usually restricts what kinds of nested data
item or items can be carried by a tag.</t>

<t>The initial bytes of the tag follow the rules for positive
integers (major type 0). The tag is followed by a single data item
of any type.
For example, assume that a byte string of length 12 is marked with a tag
to indicate it is a positive bignum. This
would be marked as 0b110_00010 (major type 6, additional information
2 for the tag) followed by 0b010_01100 (major type 2, additional information of
12 for the length) followed by the 12 bytes of the bignum.</t>

<t>Decoders do not need to understand tags, and thus tags may be of little value in
applications where the implementation creating a particular CBOR data item
and the implementation decoding that stream know the semantic meaning of each
item in the data flow. Their primary purpose in this specification is to define
common data types such as dates. A secondary purpose is to allow optional
tagging when the decoder is a generic CBOR decoder that might be able to benefit
from hints about the content of items.
Understanding the semantic tags is optional for a decoder; it can just
jump over the initial bytes of the tag and interpret the tagged data
item itself.</t>

<t>A tag always applies to the item that is directly followed by it. Thus, if tag A is
followed by tag B which is followed by data item C, tag A applies to the result
of applying tag B on data item C.
That is, a tagged item is a data item consisting of a tag and a value.
The content of the tagged item is the data item (the value) that is being tagged.</t>

<t>IANA maintains a registry of tag values as described in <xref target="ianatags"/>.
<xref target="tagvalues"/> provides a list of initial values, with definitions in the
rest of this section.</t>

<texttable title="Values for tags" anchor="tagvalues">
      <ttcol align='left'>tag</ttcol>
      <ttcol align='left'>data item</ttcol>
      <ttcol align='left'>semantics</ttcol>
      <c>0</c>
      <c>UTF-8 string</c>
      <c>Standard date/time string; see <xref target="datetimesect"/></c>
      <c>1</c>
      <c>multiple</c>
      <c>Epoch-based date/time; see <xref target="datetimesect"/></c>
      <c>2</c>
      <c>byte string</c>
      <c>Positive bignum; see <xref target="bignums"/></c>
      <c>3</c>
      <c>byte string</c>
      <c>Negative bignum; see <xref target="bignums"/></c>
      <c>4</c>
      <c>array</c>
      <c>Decimal fraction; see <xref target="fractions"/></c>
      <c>5</c>
      <c>array</c>
      <c>Bigfloat; see <xref target="fractions"/></c>
      <c>6..20</c>
      <c>(Unassigned)</c>
      <c>(Unassigned)</c>
      <c>21</c>
      <c>multiple</c>
      <c>Expected conversion to base64url encoding; see <xref target="convexpect"/></c>
      <c>22</c>
      <c>multiple</c>
      <c>Expected conversion to base64 encoding; see <xref target="convexpect"/></c>
      <c>23</c>
      <c>multiple</c>
      <c>Expected conversion to base16 encoding; see <xref target="convexpect"/></c>
      <c>24</c>
      <c>byte string</c>
      <c>Encoded CBOR data item; see <xref target="embedded-di"/></c>
      <c>25..31</c>
      <c>(Unassigned)</c>
      <c>(Unassigned)</c>
      <c>32</c>
      <c>UTF-8 string</c>
      <c>URI; see <xref target="encodedtext"/></c>
      <c>33</c>
      <c>UTF-8 string</c>
      <c>Base64url; see <xref target="encodedtext"/></c>
      <c>34</c>
      <c>UTF-8 string</c>
      <c>Base64; see <xref target="encodedtext"/></c>
      <c>35</c>
      <c>UTF-8 string</c>
      <c>Regular expression; see <xref target="encodedtext"/></c>
      <c>36</c>
      <c>UTF-8 string</c>
      <c>MIME message; see <xref target="encodedtext"/></c>
      <c>37..55798</c>
      <c>(Unassigned)</c>
      <c>(Unassigned)</c>
      <c>55799</c>
      <c>multiple</c>
      <c>Self-describe CBOR; see <xref target="self-describe"/></c>
      <c>55800+</c>
      <c>(Unassigned)</c>
      <c>(Unassigned)</c>
</texttable>

<section anchor="datetimesect" title="Date and Time">

<t>Tag value 0 is for date/time strings that follow the standard format
described in <xref target="RFC3339"/>, as refined by Section 3.3 of <xref target="RFC4287"/>.</t>

<t>Tag value 1 is for numerical representation of seconds relative to 1970-01-01T00:00Z in UTC
time.
(For the non-negative values that POSIX defines, the number of seconds
is counted in the same way as for POSIX “seconds since the epoch”
[TIME_T].)
The tagged item can be a positive or negative integer (major types 0 and 1), or a floating
point number (major type 7 with additional information 25, 26 or 27). Note that the number can be
negative (time before 1970-01-01T00:00Z) and, if a floating point number, indicate fractional
seconds.</t>

</section>
<section anchor="bignums" title="Bignums">

<t>Bignums are integers that do not fit into the basic integer
representations provided by major types 0 and 1.
They are encoded as a byte string data item, which is interpreted as an unsigned
integer n in network byte order.
For tag value 2, the value of the bignum is n.
For tag value 3, the value of the bignum is -1 - n.
Decoders that understand these tags MUST be able to decode bignums
that have leading zeroes.</t>

<t>For example, the number 18446744073709551616 (2**64) is represented
as 0b110_00010 (major type 6, tag 2), followed by 0b010_01001 (major
type 2, length 9), followed by 0x010000000000000000 (one byte 0x01 and
eight bytes 0x00). In hexadecimal:</t>

<figure><artwork><![CDATA[
C2                        -- Tag 2
   29                     -- Byte string of length 9
      010000000000000000  -- Bytes content
]]></artwork></figure>

</section>
<section anchor="fractions" title="Decimal Fractions and Bigfloats">

<t>Decimal fractions combine an integer mantissa with a base-10 scaling factor.
They are most useful if an application needs the exact representation
of a decimal fraction such as 1.1 because there is no exact representation
for many decimal fractions in binary floating point.</t>

<t>Bigfloats combine an integer mantissa with a base-2 scaling factor.
They are binary floating point values that can exceed the range
or the precision of the three IEEE 754 formats supported by CBOR
(<xref target="fpnocont"/>).
Bigfloats may also be used by constrained applications that need some
basic binary floating point capability without the need for supporting
IEEE 754.</t>

<t>A decimal fraction or a bigfloat is represented as a tagged array that
contains exactly two integer numbers: an exponent e and a mantissa m.
Decimal fractions (tag 4) use base-10 exponents,
the value of a decimal fraction data item is m*(10**e).
Bigfloats (tag 5) use base-2 exponents,
the value of a bigfloat data item is m*(2**e).
The exponent e MUST be represented in an integer of major type 0 or 1,
while the mantissa also can be a bignum (<xref target="bignums"/>).</t>

<t>An example of a decimal fraction is that
the number 273.15 could be represented as 0b110_00100 (major type of 6 for the
tag, additional information of 4 for the type of tag), followed by 0b100_00010 (major type of 4 for
the array, additional information of 2 for the length of the array), followed by 0b001_00001 (major type of 1 for the first
integer, additional information of 1 for the value of -2), followed by 0b000_11001 (major
type of 0 for the second integer, additional information of 25 for a two-byte value), followed by
0b0110101010110011 (27315 in two bytes).
In hexadecimal:</t>

<figure><artwork><![CDATA[
C4             -- Tag 4
   82          -- Array of length 2
      21       -- -2
      19 6ab3  -- 27315
]]></artwork></figure>

<t>An example of a bigfloat is that
the number 1.5 could be represented as 0b110_00101
(major type of 6 for the tag, additional information of 5 for the type
of tag), followed by 0b100_00010 (major type of 4 for the array,
additional information of 2 for the length of the array), followed by
0b001_00000 (major type of 1 for the first integer, additional
information of 0 for the value of -1), followed by 0b000_00011 (major
type of 0 for the second integer, additional information of 3 for the
value of 3).
In hexadecimal:</t>

<figure><artwork><![CDATA[
C5             -- Tag 5
   82          -- Array of length 2
      20       -- -1
      03       -- 3
]]></artwork></figure>

<t>Decimal fractions and bigfloats provide no representation of Infinity, -Infinity, or NaN; if
these are needed in place of a decimal fraction or bigfloat, the IEEE 754 half precision
representations from <xref target="fpnocont"/> can be used.
For constrained applications, where there is a choice between
representing a specific number as an integer and as a decimal fraction or bigfloat (such as
when the exponent is small and non-negative), there is a quality of
implementation expectation that the integer representation is used
directly.</t>

</section>
<section anchor="content-hints" title="Content Hints">

<t>The tags in this section are for content hints that might be used by generic
CBOR processors.</t>

<section anchor="embedded-di" title="Encoded CBOR data item">

<t>Sometimes it is beneficial to carry an embedded CBOR data item that is
not meant to be decoded immediately at the time the enclosing data item
is being parsed.  Tag 24 (CBOR data item) can be used to tag the
embedded byte string as a data item encoded in CBOR format.</t>

</section>
<section anchor="convexpect" title="Expected Later Encoding for CBOR to JSON Converters">

<t>Tags 21 to 23 indicate that a byte string might require a specific
encoding when interoperating with a text-based representation.
These tags are useful when an encoder knows that the byte string data it is writing is likely to be
later converted to a particular JSON-based usage. That usage specifies that some strings are encoded
as Base64, Base64url, and so on. The encoder uses byte strings instead of doing the encoding itself
to reduce the message size, to reduce the code size of the encoder, or both. The encoder does not
know whether or not the converter will be generic, and therefore wants to say what it believes is
the proper way to convert binary strings to JSON.</t>

<t>The data item tagged can be a byte string, or any other data item.  In
the latter case, the tag applies to all of the byte string data items
contained in the data item, except for those contained in a nested
expected conversion tagged item.</t>

<t>These three tag types suggest conversions to three of the base data
encodings defined in <xref target="RFC4648"/>.  For base64url encoding, padding is
not used (see section 3.2 of RFC 4648), that is all trailing equals
signs (“=”) are removed from the base64url encoded string.  Later tags
might be defined for other data encodings of RFC 4648, or of other
ways to encode binary data in strings.</t>

</section>
<section anchor="encodedtext" title="Encoded Text">

<t>Some text strings hold data that have formats widely-used on the Internet, and sometimes those
formats can be validated and presented to the application in
appropriate form by the decoder. There are tags for some of these formats.</t>

<t><list style='symbols'>
  <t>Tag 32 is for URIs, as defined in <xref target="RFC3986"/>;</t>
  <t>Tags 33 and 34 are for base64url and base64 encoded text strings, as defined in <xref target="RFC4648"/>;</t>
  <t>Tag 35 is for regular expressions in PCRE/JavaScript syntax <xref target="ECMA262"/>.</t>
  <t>Tag 36 is for MIME messages (including all headers), as defined in <xref target="RFC2045"/>;</t>
</list></t>

<t>Note that tag 33 and 34 differ from 21 and 22 in that the data is
transported in base-encoded form for the former and in raw byte
string form in the latter case.</t>

</section>
</section>
<section anchor="self-describe" title="Self-describe CBOR">

<t>In many applications, it will be clear from the context that CBOR is
being employed for encoding a data item.  For instance, a specific
protocol might specify the use of CBOR, or a media type is indicated
that specifies its use.  However, there may be applications where such
context information is not available, such as when CBOR data is
stored in a file and disambiguating metadata is not in use.  Here, it
may help to have some distinguishing characteristics for the data
itself.</t>

<t>Tag 55799 is defined for this purpose.  It does not impart any special
semantics on the data item that follows, that is, the semantics of a data
item tagged with tag 55799 is exactly identical to the semantics of
the data item itself.</t>

<t>The serialization of this tag is 0xd9d9f7, which appears not to be in
use as a distinguishing mark for frequently used file types.  In
particular, it is not a valid start of a Unicode text in any Unicode
encoding if followed by a valid CBOR data item.</t>

<t>For instance, a decoder might be able to parse both CBOR and JSON. Such
a decoder would need to mechanically distinguish the two formats. An
easy way for an encoder to help the decoder would be to tag the entire
CBOR item with Tag 55799, the serialization of which will never be
found at the beginning of a JSON text.</t>

</section>
</section>
</section>
<section anchor="creating-cbor-based-protocols" title="Creating CBOR-Based Protocols">

<t>Data formats such as CBOR are often used in environments where there is no format negotiation. A
specific design goal of CBOR is to not need any included or assumed schema: a decoder can take a CBOR
item and decode it with no other knowledge.</t>

<t>Of course, in real-world implementations, the encoder and the decoder will have a shared view of what
should be in a CBOR data item. For example, an agreed-to format might be “the item is an array
whose first value is a UTF-8 string, the second value is an integer, followed by zero or more
floating point numbers” or “a map whose keys are byte strings that has to contain at least one
pair whose key is 0xab01”.</t>

<t>This specification puts no restrictions on CBOR-based protocols. An encoder can be capable of encoding as
many or as few types of values as is required by the protocol in which it is used; a decoder can be
capable of understanding as many or as few types of values as is required by the protocols in which
it is used. This lack of restrictions allows CBOR to be used in extremely constrained environments.</t>

<t>This section discusses some considerations in creating CBOR-based protocols.
It is advisory only, and explicitly excludes any language from
RFC 2119 other than words that could be interpreted as “MAY” in the
RFC 2119 sense.</t>

<section anchor="cbor-in-streaming-applications" title="CBOR in Streaming Applications">

<t>In a streaming application, a data stream may be composed of a
sequence of CBOR data items concatenated back-to-back. In such an
environment, the decoder immediately begins decoding a new data item if
data is found after the end of a previous data item.</t>

<t>Not all of the bytes making up a data item may be immediately
available to the decoder; some decoders will buffer additional data
until a complete data item can be presented to the application.
Other decoders can present partial information about a top-level data
item to an application, such as the nested data items that could
already be decoded, or even parts of a byte string that hasn’t
completely arrived yet.</t>

<t>Note that some applications and protocols will not want to use indefinite length encoding.
Using indefinite length encoding allows an encoder to not need to marshall all the data
for counting, but it requires a decoder to allocate increasing amounts of memory while
waiting for the end of the item. This might be fine for some applications but not others.</t>

</section>
<section anchor="generic" title="Generic Encoders and Decoders">

<t>A generic CBOR decoder can decode all well-formed CBOR data and present
them to an application.
CBOR data are well-formed if the structure of the initial bytes and
the byte strings/data items implied by their values is followed and no
extraneous data follows (<xref target="pseudocode"/>).</t>

<t>Even though CBOR attempts to minimize these cases, not all well-formed
CBOR data are valid:
for example, the format excludes simple values below 32 that are encoded with
an extension byte.
Also, specific tags may make semantic constraints that may be
violated, such as by including a tag in a bignum tag or by following a byte
string within a date tag.
Finally, the data may be invalid, such as invalid UTF-8 strings or
date strings that do not conform to <xref target="RFC3339"/>.
There is no requirement that generic encoders and decoders make
unnatural choices for their application interface to enable the
processing of invalid data.
Generic encoders and decoders are expected to forward simple values and
tags even if their specific code points had not been registered at the
time the encoder/decoder has been written (<xref target="unknown-tags"/>).</t>

<t>Generic decoders provide ways to present well-formed CBOR values, both
valid and invalid, to an application.  The diagnostic notation
(<xref target="diagnostic-notation"/>) may be used to present well-formed CBOR
values to humans.</t>

<t>Generic encoders provide an application interface that allows the
application to specify any well-formed value, including simple values
and tags unknown to the encoder.</t>

</section>
<section anchor="syntax-errors" title="Syntax Errors">

<t>A decoder encountering a CBOR data item that is not well-formed
generally can choose to completely fail the decoding (issue an error
and/or stop processing altogether), substitute the problematic data
and data items using an decoder-specific convention that clearly
indicates there has been a problem, or it might take some other
action.</t>

<section anchor="incomplete-cbor-data-items" title="Incomplete CBOR data items">

<t>The representation of a CBOR data item has a specific length,
determined by its initial bytes and by the structure of any data items
enclosed in the data items.  If less data is available, this can be
treated as a syntax error.
A decoder may also implement incremental parsing, that is, decode the data
item as far as it is available and present the data found so far,
(such as in an event-based interface) with the option of continuing the
decoding once further data are available.</t>

<t>Examples of incomplete data items include:</t>

<t><list style='symbols'>
  <t>a decoder expecting a certain number of array or map entries instead
encounters the end of the data</t>
  <t>a decoder processing what it expects to be the last pair in a map
comes to the end of the data</t>
  <t>a decoder has just seen a tag and then encounters the end of the
data</t>
  <t>a decoder has seen the beginning of an indefinite length item but
encounters the end of the data before it sees the “break” stop code</t>
</list></t>

</section>
<section anchor="malformed-indefinite-length-items" title="Malformed Indefinite Length Items">

<t>Examples of malformed indefinite length data items include:</t>

<t><list style='symbols'>
  <t>Within an indefinite length byte string or text, a decoder finds
an item that is not of the appropriate major type before it finds the
“break” stop code</t>
  <t>Within an indefinite length map, a decoder encounters the “break”
stop code immediately after reading a key (the value is missing)</t>
</list></t>

<t>Another error is a “break” stop code that is found when there is no
immediately enclosing indefinite length item needing to be closed.</t>

</section>
<section anchor="unknown-additional-information-values" title="Unknown Additional Information Values">

<t>At the time this document is written, some additional information values
are unassigned and reserved for future versions of this document (see
<xref target="curating"/>).  Since the overall syntax for these additional
information values is not yet defined,
a decoder that sees an additional information value that
it does not understand cannot continue parsing.</t>

</section>
</section>
<section anchor="semantic-errors" title="Other Decoding Errors">

<t>A CBOR data item may be syntactically well-formed, but present a
problem with interpreting the data encoded in it in the CBOR data
model.  Generally speaking, a decoder that finds a data item with such
a problem might issue a warning, might stop processing altogether,
might handle the error and make the problematic value available
to the application as such, or take some other type of action.</t>

<t>Such problems might include:</t>

<t><list style='hanging'>
  <t hangText='Duplicate keys in a map:'>
  Generic decoders (<xref target="generic"/>) make data available to applications
using the native CBOR data model. That data model
includes maps (key-value mappings with unique keys), not multimaps
(key-value mappings where multiple entries can have the same key).
Thus, a generic decoder that gets a CBOR map item that has duplicate
keys will decode to a map
with only one instance of that key, or it might stop processing
altogether.
On the other hand, a “streaming decoder” may not even be able to
notice (<xref target="map-keys"/>).</t>
  <t hangText='Inadmissible type on the value following a tag:'>
  Tags (<xref target="tags"/>) specify what type of data item is supposed to follow
the tag; for example, the tags for positive or negative bignums are
supposed to be put on byte strings. A decoder that decodes the tagged
data item into a native representation (a native big integer in this
example) is expected to check the type of the data item being tagged.
Even decoders that don’t have such native representations available in
their environment may perform the check on those tags known to them
and react appropriately.</t>
  <t hangText='Invalid UTF-8 string:'>
  A decoder might or might not want to verify that the sequence of
bytes in an UTF-8 string (major type 3) is actually valid UTF-8 and
react appropriately.</t>
</list></t>

</section>
<section anchor="unknown-tags" title="Handling Unknown Simple Values and Tags">

<t>A decoder that comes across a simple value (<xref target="fpnocont"/>) that it does
not recognize, such as a value that was added to the IANA registry
after the decoder was deployed or a value that the decoder chose not to
implement, might issue a warning, might stop processing altogether,
might handle the error by making the unknown value available to the
application as such (as is expected of generic decoders), or take some other type of action.</t>

<t>A decoder that comes across a tag (<xref target="tags"/>) that it does not recognize,
such as a tag that was added to the IANA registry after the decoder was
deployed or a tag that the decoder chose not to implement, might issue
a warning, might stop processing altogether, might handle the error
and present the unknown tag value together with the contained data
item to the application (as is expected of generic decoders), might ignore the tag and simply present the
contained data item only to the application, or take some other type
of action.</t>

</section>
<section anchor="numbers" title="Numbers">

<t>For the purposes of this specification, all number representations for
the same numeric value are
equivalent.  This means that an encoder can encode a floating point
value of 0.0 as the integer 0.  It, however, also means that an
application that expects to find integer values only might find
floating point values if the encoder decides these are desirable,
such as when the floating point value is more compact than a 64-bit
integer.</t>

<t>An application or protocol that uses CBOR might restrict the representations of numbers.
For instance, a protocol that only deals with integers might say that floating point
numbers may not be used and that decoders of that protocol do not need to be able to
handle floating point numbers. Similarly, a protocol or application that uses CBOR
might say that decoders need to be able to handle either type of number.</t>

<t>CBOR-based protocols should take into account that different language
environments pose different restrictions on the range and precision of
numbers that are representable.  For example, the JavaScript number
system treats all numbers as floating-point, which may result in
silent loss of precision in decoding integers with more than 53
significant bits.  A protocol that uses numbers should define its
expectations on the handling of non-trivial numbers in decoders and
receiving applications.</t>

<t>A CBOR-based protocol that includes floating point numbers can restrict which of
the three formats (half-precision, single-precision, and
double-precision) are to be supported.  For an integer-only
application, a protocol may want to completely exclude the use of
floating point values.</t>

<t>A CBOR-based protocol designed for compactness may want to exclude specific integer
encodings that are longer than necessary for the application, such as
to save the need to implement 64-bit integers.  There is an
expectation that encoders will use the most compact integer
representation that can represent a given value.  However, a compact
application should accept values that use a longer-than needed
encoding (such as encoding “0” as 0b000_11101 followed by two bytes
of 0x00) as long as the application can decode an integer of the given
size.</t>

</section>
<section anchor="map-keys" title="Specifying Keys for Maps">

<t>The encoding and decoding applications need to agree on what types of
keys are going to be used in maps.
In applications that need to interwork with JSON-based applications, keys probably should be
limited to UTF-8 strings only; otherwise, there has to be a specified mapping from
the other CBOR types to Unicode characters, and this often leads to implementation errors.
In applications where keys are numeric in nature and numeric ordering
of keys is important to the application, directly using the numbers
for the keys is useful.</t>

<t>If multiple types of keys are to used, consideration should be given to
how these types would be represented in the specific programming
environments that are to be used.
For example, in JavaScript objects, a key of integer 1 cannot be
distinguished from a key of string “1”.
This means that, if integer keys are used, the simultaneous use of
string keys that look like numbers needs to be avoided. Again, this leads to the
conclusion that keys should be of a single CBOR type.</t>

<t>Decoders that deliver data items nested within a CBOR data item
immediately on decoding them (“streaming decoders”) often do not keep
the state that is necessary to ascertain uniqueness of a key in a map.
Similarly, an encoder that can start encoding data items before the
enclosing data item is completely available (“streaming encoder”) may
want to reduce its overhead significantly by relying on its data
source to maintain uniqueness.</t>

<t>A CBOR-based protocol should make an intentional decision about what
to do when a receiving application does see multiple identical keys in
a map.  The resulting rule in the protocol should respect the CBOR data model: it
cannot prescribe a specific handling of the entries with the identical
keys, except that it might have a rule that having identical keys in a
map indicates a malformed map and that the decoder has to stop with an
error. Duplicate keys are also prohibited by CBOR decoders that are using <xref target="strict-mode"/>.</t>

<t>The CBOR data model for maps does not allow ascribing semantics to the
order of the key/value pairs in the map representation.<vspace />
Thus, it would be a very bad practice to define a CBOR-based
protocol in such a way that changing the key/value
pair order in a map would change the semantics, apart from trivial
aspects (cache usage etc.).  (A CBOR-based protocol can prescribe a
specific order of serialization, such as for canonicalization.)</t>

<t>Applications for constrained devices that have maps with 24 or fewer
frequently used keys should consider using small integers (and those
with up to 48 frequently used keys should consider also using small
negative integers) because the keys can then be encoded in a single
byte.</t>

</section>
<section anchor="undefined-values" title="Undefined Values">

<t>In some CBOR-based protocols, the simple value (<xref target="fpnocont"/>) of Undefined might be used by an encoder as a
substitute for a data item with an encoding problem, in order to allow
the rest of the enclosing data items to be encoded without harm.</t>

</section>
<section anchor="c14n" title="Canonical CBOR">

<t>Some protocols may want encoders to only emit CBOR in a particular canonical format; those protocols
might also have the decoders check that their input is canonical. Those protocols are free to define
what they mean by a canonical format and what encoders and decoders are expected to do. This section
lists some suggestions for such protocols.</t>

<t>If a protocol considers “canonical” to mean that two encoder implementations starting with the same
input data will produce the same CBOR output, the following four rules would suffice:</t>

<t><list style='symbols'>
  <t>Integers must be as small as possible.
  <list style='symbols'>
      <t>0 to 23 and -1 to -24 must be expressed in the same byte as the major type;</t>
      <t>24 to 255 and -25 to -256 must be expressed only with an additional uint8_t;</t>
      <t>256 to 65535 and -257 to -65536 must be expressed only with an additional uint16_t;</t>
      <t>65536 to 4294967295 and -65537 to -4294967296 must be expressed only with an additional uint32_t.</t>
    </list></t>
  <t>The expression of lengths in major types 2 through 5 must be as short as possible. The rules for
these lengths follow the above rule for integers.</t>
  <t>The keys in every map must be sorted lowest value to highest. Sorting is performed on the bytes of
the representation of the key data items without paying attention to
the 3/5 bit splitting for major types.
(Note that this rule
allows maps that have keys of different types, even though that is probably a bad practice that
could lead to errors in some canonicalization implementations.) The sorting rules are:
  <list style='symbols'>
      <t>If two keys have different lengths, the shorter one sorts earlier;</t>
      <t>If two keys have the same length, the one with the lower value in
(byte-wise) lexical order sorts earlier.</t>
    </list></t>
  <t>Indefinite length items must be made into definite length items.</t>
</list></t>

<t>If a protocol allows for IEEE floats, then additional canonicalization rules might need to be added.
One example rule might be to have all floats start as a 64-bit float, then do a test conversion to a
32-bit float; if the result is the same numeric value, use the shorter value and repeat the process with a
test conversion to a 16-bit float. (This rule selects 16-bit float
for positive and negative infinity as well.)
Also, there are many representations for NaN. If NaN is an
allowed value, it must always be represented as 0xf97e00.</t>

<t>CBOR tags present additional considerations for the canonicalization. The absence or presence of tags in a canonical
format is determined by the optionality of the tags in the protocol. In a CBOR-based protocol that
allows optional tagging anywhere, the canonical format must not allow them. In a protocol that
requires tags in certain places, the tag needs to appear in the canonical format. A CBOR-based
protocol that uses canonicalization might instead say that all tags that appear in a message must
be retained regardless of whether they are optional.</t>

</section>
<section anchor="strict-mode" title="Strict Mode">

<t>Some areas of application of CBOR do not require canonicalization
(<xref target="c14n"/>), but may require that different decoders reach the same
(semantically equivalent) results, even in the presence of potentially
malicious data.  This can be required if one application (such as a
firewall or other protecting entity) makes a
decision based on the data that another application, which
independently decodes the data, relies on.</t>

<t>Normally, it is the responsibility of the sender to avoid
ambiguously decodable data.  However, the sender might be an
attacker specially making up CBOR data such that it will be
interpreted differently by different decoders in an attempt to exploit
that as a vulnerability.  Generic decoders used in applications where
this might be a problem need to support a strict mode in which it
is also the responsibility of the receiver to reject ambiguously
decodable data. It is expected that firewalls and other security systems
that decode CBOR will only decode in strict mode.</t>

<t>A decoder in strict mode will reliably reject any data that could be
interpreted by other decoders in different ways.  It will reliably
reject data items with syntax errors (<xref target="syntax-errors"/>).  It will
also expend the effort to reliably detect other decoding errors
<xref target="semantic-errors"/>. In particular, a strict decoder needs to have
an API that reports an error (and does not return data) for
a CBOR data item that contains any of the following:</t>

<t><list style='symbols'>
  <t>A map (major type 5) that has more than one entry with the same key</t>
  <t>A tag that is used on a data item of the
  incorrect type</t>
  <t>A data item that is incorrectly formatted for the type given to it, such as
  invalid UTF-8 or data that cannot be interpreted with the specific
  tag that it has been tagged with</t>
</list></t>

<t>A decoder in strict mode can do one of two things when it encounters a tag or simple value
that it does not recognize:</t>

<t><list style='symbols'>
  <t>It can report an error (and not return data).</t>
  <t>It can emit the unknown item (type, value, and, for tags, the
decoded tagged data item) to the application calling the decoder with
an indication that the decoder did not recognize that tag or simple
value.</t>
</list></t>

<t>The latter approach, which is also appropriate for non-strict
decoders, supports forward compatibility with newly registered tags
and simple values without the requirement to update the encoder at the
same time as the calling application.  (For this, the API for the
decoder needs to have a way to mark unknown items so that the calling
application can handle them in a manner appropriate for the program.)</t>

<t>Since some of this processing may have an appreciable cost (in
particular with duplicate detection for maps), support of strict mode
is not a requirement placed on all CBOR decoders.</t>

<t>Some encoders will rely on their applications to provide input data in
such a way that unambiguously decodable CBOR results.  A generic
encoder also may want to provide a strict mode where it reliably
limits its output to unambiguously decodable CBOR, independent of
whether its application is providing API-conformant data or not.</t>

</section>
</section>
<section anchor="converting-data-between-cbor-and-json" title="Converting Data Between CBOR and JSON">

<t>This section gives non-normative advice about converting between CBOR and JSON. Implementations
of converters are free to use whichever advice here they want.</t>

<t>It is worth noting that a JSON text is a sequence of characters, not an encoded sequence of bytes,
while a CBOR data item consist of bytes, not characters.</t>

<t><vspace blankLines='999' /></t>

<section anchor="converting-from-cbor-to-json" title="Converting From CBOR to JSON">

<t>Most of the types in CBOR have direct analogs in JSON. However, some
do not, and someone implementing a CBOR-to-JSON converter has to
consider what to do in those cases. The following non-normative
suggestion deals with these by converting them to a single substitute value,
such as a JSON null.</t>

<t><list style='symbols'>
  <t>An Integer (major type 0 or 1) becomes a JSON number.</t>
  <t>A byte string (major type 2) that is not embedded in a tag that
specifies a proposed encoding is encoded in Base64url without
padding and becomes a JSON string.</t>
  <t>A UTF-8 string (major type 3) becomes a JSON string.  Note that JSON
requires escaping certain characters (RFC 4627, section 2.5):
quotation mark (U+0022), reverse solidus (U+005C), and the “C0 control characters” (U+0000
through U+001F).  All other
characters are copied unchanged into the JSON UTF-8 string.</t>
  <t>An array (major type 4) becomes a JSON array.</t>
  <t>A map (major type 5) becomes a JSON object.  This is possible
directly only if all keys are UTF-8 strings.  A converter might also
convert other keys into UTF-8 strings (such as by converting integers
into strings containing their decimal representation); however,
doing so introduces a danger of key collision.</t>
  <t>False (major type 7, additional information 20) becomes a JSON false.</t>
  <t>True (major type 7, additional information 21) becomes a JSON true.</t>
  <t>Null (major type 7, additional information 22) becomes a JSON null.</t>
  <t>A floating point value (major type 7, additional information 25
through 27) becomes a JSON number if it is finite (that is, it can be
represented in a JSON number); if the value is non-finite (NaN, or
positive or negative Infinity), it is represented by the substitute value.</t>
  <t>Any other simple value (Major type 7, any additional information
value not yet discussed) is represented by the substitute value.</t>
  <t>A bignum (major type 6, tag value 2 or 3) is represented by encoding
its byte string in Base64url without padding and becomes a JSON
string.  For tag value 3 (negative bignum), a “~” (ASCII tilde) is
inserted before the base-encoded value. (The conversion to a binary
blob instead of a number is to prevent a likely numeric overflow for
the JSON decoder.)</t>
  <t>A byte string with an encoding hint (major type 6, tag value 21
through 23) is encoded as described and becomes a JSON string.</t>
  <t>For all other tags (major type 6, any other tag value), the embedded
CBOR item is represented as a JSON value; the tag value is ignored.</t>
  <t>Indefinite length items are made definite before conversion.</t>
</list></t>

</section>
<section anchor="converting-from-json-to-cbor" title="Converting From JSON to CBOR">

<t>All JSON values, once decoded, directly map into one or more CBOR values.
As with any kind of CBOR generation, decisions have to be made with
respect to number representation.  In a suggested conversion:</t>

<t><list style='symbols'>
  <t>JSON numbers without fractional parts (integer numbers) are
represented as integers (major types 0 and 1, possibly major type 6
tag value 2 and 3), choosing the shortest form; integers longer than
an implementation-defined threshold (which is usually either 32 or 64 bits) may
instead be represented as floating point values.  (If the JSON was
generated from a JavaScript implementation, its precision is already
limited to 53 bits maximum.)</t>
  <t>Numbers with fractional parts are represented as floating point
values.  Preferably, the shortest exact floating point representation is used;
for instance, 1.5 is represented in a 16-bit floating point value
(not all implementations will be efficiently capable of finding the
minimum form, though).  There
may be an implementation-defined limit to the precision
that will affect the precision of the represented values. Decimal
representation should only be used if that is specified in a protocol.</t>
</list></t>

<t>CBOR has been designed to generally provide a more compact encoding
than JSON.  One implementation strategy that might come to mind is to
perform a JSON to CBOR encoding in place in a single buffer.  This
strategy would need to carefully consider a number of pathological
case, such as that some
strings represented with no or very few escapes and longer (or much
longer) than 255 may expand when encoded as UTF-8 strings in CBOR.
Similarly, a few of the binary floating point representations might
cause expansion from some short decimal representations (1.1, 1e9) in
JSON.
This may be hard to get right and any ensuing vulnerabilities may be
exploited by an attacker.</t>

</section>
</section>
<section anchor="future-evolution-of-cbor" title="Future Evolution of CBOR">

<t>Successful protocols evolve over time.  New ideas appear,
implementation platforms improve, related protocols
are developed and evolve, and new requirements from
applications and protocols are added.  Facilitating protocol evolution
is therefore an important design consideration for any protocol
development.</t>

<t>For protocols that will use CBOR, CBOR provides
some useful mechanisms to facilitate their evolution.  Best
practices for this are well known, particularly from JSON format
development of JSON-based protocols.  Therefore, such
best practices are outside the scope of this specification.</t>

<t>However, facilitating the evolution of CBOR itself is very well within its
scope.  CBOR is designed to both provide a stable basis for
development of CBOR-based protocols and to be able to evolve.
Since a successful protocol may live for decades, CBOR needs to be designed
for decades of use and evolution.  This section provides some
guidance for the evolution of CBOR.  It is
necessarily more subjective than other parts of this document.
It is also necessarily incomplete, lest it turn into a textbook on
protocol development.</t>

<section anchor="extension-points" title="Extension Points">

<t>In a protocol design, opportunities for evolution are often included in
the form of extension points.  For example, there may be a code point space
that is not fully allocated from the outset, and the protocol is
designed to tolerate and embrace implementations that start using more
code points than initially allocated.</t>

<t>Sizing the code point space may be difficult because the range required
may be hard to predict.  An attempt should be made to make
the codepoint space large enough so that it can slowly be filled over
the intended lifetime of the protocol.</t>

<t>CBOR has three major extension points:</t>

<t><list style='symbols'>
  <t>the “simple” space (values in major type 7).  Of the 24 efficient (and
224 slightly less efficient) values, only a small number have been
allocated.  Implementations receiving an unknown simple data item
may be able to process it as such, given that the structure of the
value is indeed simple. An IANA registry is appropriate here.</t>
  <t>the “tag” space (values in major type 6).  Again, only a small part of
the code point space has been allocated, and the space is abundant
(although the early numbers are more efficient than the later ones).
Implementations receiving an unknown tag can choose to simply ignore
it, or to process it as an unknown tag wrapping the following data
item. An IANA registry is appropriate here.</t>
  <t>the “additional information” space.  An implementation receiving an
unknown additional information has no way to continue parsing, so allocating
codepoints to this space is a major step.  There are also very
few codepoints left.</t>
</list></t>

</section>
<section anchor="curating" title="Curating the Additional Information Space">

<t>The human mind is sometimes drawn to filling in little perceived gaps
to make something neat.
We expect the remaining gaps in the code point space for the additional information values
to be an attractor for new ideas, just because they are there.</t>

<t>The present specification does not manage the additional information code point space
by an IANA registry.  Instead, allocations out of this space can only
be done by updating this specification.</t>

<t>For an additional information value of n ≥ 24, the size of the additional data typically is
2**(n-24) bytes.  Therefore, additional information values 28 and 29 should be viewed as
candidates for 128-bit and 256-bit quantities, in case a need arises to
add them to the protocol.  Additional information value 30 is then the only additional information value available
for general allocation, and there should be a very good reason for
allocating it before assigning it through an update of this protocol.</t>

</section>
</section>
<section anchor="diagnostic-notation" title="Diagnostic Notation">

<t>CBOR is a binary interchange format.  To facilitate documentation and
debugging, and in particular to facilitate communication between
entities cooperating in debugging, this section defines a simple
human-readable diagnostic notation.  All actual interchange always happens
in the binary format.</t>

<t>Note that this truly is a diagnostic format; it is not meant to be parsed.
Therefore, no formal definition (as in ABNF) is given in this document.
(Implementers looking for a text-based format for representing CBOR
data items in configuration files may also want to consider YAML <xref target="YAML"/>.)</t>

<t>The diagnostic notation is loosely based on JSON as it is defined in
RFC 4627, extending it where needed.</t>

<t>The notation borrows the JSON syntax for numbers
(integer and floating point), True (&gt;true&lt;), False (&gt;false&lt;), Null
(&gt;null&lt;), UTF-8 strings, arrays
and maps (maps are called objects in JSON; the diagnostic notation
extends JSON here by allowing any data item in the key position).
Undefined is written &gt;undefined&lt; as in JavaScript.
The non-finite floating point numbers Infinity, -Infinity, and NaN
are written exactly as in this sentence (this is also a way they can
be written in JavaScript, although JSON does not allow them).
A tagged item is
written as an integer number for the tag followed by the item in
parentheses; for instance, an RFC 3339 (ISO 8601) date could be notated as:</t>

<t><list style='empty'>
  <t>0(“2013-03-21T20:04:00Z”)</t>
</list></t>

<t>or the equivalent relative time as</t>

<t><list style='empty'>
  <t>1(1363896240)</t>
</list></t>

<t>Byte strings are notated in one of the base encodings, without padding, enclosed in
single quotes, prefixed by &gt;h&lt; for base16, &gt;b32&lt; for base32, &gt;h32&lt;
for base32hex, &gt;b64&lt; for base64 or base64url (the actual encodings do
not overlap, so the string remains unambiguous).  For example, the byte string 0x12345678 could be
written h’12345678’, b32’CI2FM6A’, or b64’EjRWeA’.</t>

<t>Unassigned simple values are given as “simple()” with the appropriate integer in
the parentheses. For example, “simple(42)” indicates major type 7, value 42.</t>

<section anchor="encoding-indicators" title="Encoding indicators">

<t>Sometimes it is useful to indicate in the diagnostic notation which of
several alternative representations were actually used; for example, a data item
written &gt;1.5&lt; by a diagnostic decoder might have been encoded as a
half-, single-, or double-precision float.</t>

<t>The convention for encoding indicators is that anything starting with an
underscore and all following characters that are alphanumeric
or underscore, is an encoding indicator, and can be ignored by anyone not
interested in this information.  Encoding indicators are always optional.</t>

<t>A single underscore can be written after the opening brace of a map or
the opening bracket of an array to indicate that the data item was
represented in indefinite length format.  For example, [_ 1, 2]
contains a indicator that an indefinite length representation was used to represent
the data item [1, 2].</t>

<t>An underscore followed by a decimal digit n indicates that the
preceding item (or, for arrays and maps, the item starting with the
preceding bracket or brace) was encoded with an additional information
value of 24+n.  For example, 1.5_1 is a half precision floating point
number, while 1.5_3 is encoded as double precision.  (This encoding
indicator is not shown in <xref target="examples"/>.)  (Note that the encoding indicator “_”
is thus an abbreviation of the full form “_7”, which is not used.)</t>

<t>As a special case, byte and text strings of indefinite length can be
notated in the form (_ h’0123’, h’4567’) and (_ “foo”, “bar”).</t>

</section>
</section>
<section anchor="ianacons" title="IANA Considerations">

<t>IANA will create two registries for new CBOR values. The registries will
be separate, not under an umbrella registry. The registries will follow the
rules in <xref target="RFC5226"/>. IANA will also assign a new MIME media type and
an associated CoAP Content-Format entry.</t>

<section anchor="simple-values-registry" title="Simple Values Registry">

<t>A registry called “CBOR Simple Values” will be created. The initial values are
shown in <xref target="fpnoconttbl2"/>.</t>

<t>New entries in the range 0 to 19 will be assigned by Standards Action. It is suggested that these
Standards Actions allocate values starting with the number 16 in order to reserve the lower numbers
for any contiguous block.</t>

<t>New entries in the range 32 to 255 will be assigned by Specification Required.</t>

</section>
<section anchor="ianatags" title="Tags Registry">

<t>A registry called “CBOR Tags” will be created. The initial values are
shown in <xref target="tagvalues"/>.</t>

<t>New entries in the range 0 to 23 will be assigned by Standards Action.
New entries in the range 24 to 255 will be assigned by Specification Required.
New entries in the range 256 to 18446744073709551615 will be assigned by
First Come First Served. The template for First Come First Served will include
point of contact and an optional field for URL to a description of the
semantics of the tag;
the latter can be something like an Internet-Draft or a web page.</t>

</section>
<section anchor="media-type-mime-type" title="Media Type (“MIME Type”)">

<t>The Internet media type <xref target="RFC6838"/> for CBOR data is application/cbor.</t>

<t>Type name: application</t>

<t>Subtype name: cbor</t>

<t>Required parameters: n/a</t>

<t>Optional parameters: n/a</t>

<t><list style='hanging'>
  <t hangText='Encoding considerations:'>
  binary</t>
  <t hangText='Security considerations:'>
  See <xref target="securitycons"/> of this document</t>
</list></t>

<t>Interoperability considerations: n/a</t>

<t>Published specification: This document</t>

<t><list style='hanging'>
  <t hangText='Applications that use this media type:'>
  None yet, but it is expected that this format will be deployed
in protocols and applications.</t>
</list></t>

<figure><artwork><![CDATA[
Additional information:
  Magic number(s): n/a
  File extension(s): .cbor
  Macintosh file type code(s): n/a

Person & email address to contact for further information:
  Carsten Bormann
  cabo@tzi.org

Intended usage: COMMON

Restrictions on usage: none

Author:
  Carsten Bormann <cabo@tzi.org>

Change controller:
  The IESG <iesg@ietf.org>
]]></artwork></figure>

</section>
<section anchor="coap-content-format" title="CoAP Content-Format">

<t>Media Type: application/cbor</t>

<t>Encoding: -</t>

<t>Id: 60</t>

<t>Reference: [RFC-THIS-SPEC]</t>

</section>
<section anchor="the-cbor-structured-syntax-suffix-registration" title="The +cbor Structured Syntax Suffix Registration">

<t>Name:  Concise Binary Object Representation (CBOR)</t>

<t>+suffix: +cbor</t>

<t>References: [RFC-THIS-SPEC]</t>

<t>Encoding considerations: CBOR is a binary format.</t>

<figure><artwork><![CDATA[
Fragment identifier considerations:
  The syntax and semantics of fragment identifiers specified for
  +cbor SHOULD be as specified for "application/cbor".  (At
  publication of this document, there is no fragment identification
  syntax defined for "application/cbor".)

  The syntax and semantics for fragment identifiers for a specific
  "xxx/yyy+cbor" SHOULD be processed as follows:

  For cases defined in +cbor, where the fragment identifier resolves
  per the +cbor rules, then process as specified in +cbor.

  For cases defined in +cbor, where the fragment identifier does
  not resolve per the +cbor rules, then process as specified in
  "xxx/yyy+cbor".

  For cases not defined in +cbor, then process as specified in
  "xxx/yyy+cbor".
]]></artwork></figure>

<t>Interoperability considerations: n/a</t>

<t><list style='hanging'>
  <t hangText='Security considerations:'>
  See <xref target="securitycons"/> of this document</t>
</list></t>

<figure><artwork><![CDATA[
Contact:
  Apps Area Working Group (apps-discuss at ietf.org)

Author/Change controller:
  The Apps Area Working Group.
  The IESG has change control over this registration.
]]></artwork></figure>

</section>
</section>
<section anchor="securitycons" title="Security Considerations">

<t>A network-facing application can exhibit vulnerabilities in its
processing logic for incoming data. Complex parsers are well known
as a likely source of such vulnerabilities, such as the ability to
remotely crash a node, or even remotely execute arbitrary code on it.
CBOR attempts to narrow the opportunities for introducing such
vulnerabilities by reducing parser complexity, by giving the entire
range of encodable values a meaning where possible.</t>

<t>Resource exhaustion attacks might attempt to lure a decoder into
allocating very big data items (strings, arrays, maps) or exhaust the
stack depth by setting up deeply nested items.  Decoders need to have
appropriate resource management to mitigate these attacks.  (Items for
which very large sizes are given can also attempt to exploit integer
overflow vulnerabilities.)</t>

<t>Applications where CBOR data items are examined by a gatekeeper
function and later used by a different application may exhibit
vulnerabilities when multiple interpretations of the data item are
possible. For example, an attacker could make use of duplicate keys in maps
and precision issues in numbers to make the gatekeeper base its
decisions on a different interpretation than the one that will be used
by the second application.  Protocols that are used in a security context should be
defined in such a way that these multiple interpretations are reliably
reduced to a single one.  To facilitate this, encoder and decoder
implementations used in such contexts should provide at least one
strict mode of operation (<xref target="strict-mode"/>).</t>

</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>CBOR was inspired by MessagePack.  MessagePack was developed and
promoted by Sadayuki Furuhashi (“frsyuki”).  This reference to
MessagePack is solely for attribution; CBOR is not intended as a
version of or replacement for MessagePack, as it has different design
goals and requirements.</t>

<t>The need for functionality beyond the original MessagePack
Specification became obvious to many people at about the same time
around the year 2012.  BinaryPack is a minor derivation of MessagePack
that was developed by Eric Zhang for the binaryjs project.  A similar,
but different extension was made by Tim Caswell for his msgpack-js
and msgpack-js-browser projects.  Many people have contributed to
the recent discussion about extending MessagePack to separate text
string representation from byte string representation.</t>

<t>The encoding of the additional information in CBOR was inspired by the
encoding of length information designed by Klaus Hartke for CoAP.</t>

<t>This document also incorporates suggestions made by many people, notably
Dan Frost, James Manger, Joe Hildebrand, Keith Moore, Matthew Lepinski,
Nico Williams, Phillip Hallam-Baker, Ray Polk, Tim Bray, Tony Finch,
Tony Hansen, and Yaron Sheffer.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

<reference anchor="ECMA262" target="http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf">
  <front>
    <title>ECMAScript Language Specification 5.1 Edition</title>
    <author >
      <organization>European Computer Manufacturers Association</organization>
    </author>
    <date year="2011" month="June"/>
  </front>
  <seriesInfo name="ECMA" value="Standard ECMA-262"/>
</reference>
<reference anchor="TIME_T" target="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15">
  <front>
    <title>Base Definitions, section 4.15 'Seconds Since the Epoch'</title>
    <author >
      <organization>The Open Group Base Specifications Issue 7, Volume 1</organization>
    </author>
    <date year="2013"/>
  </front>
  <seriesInfo name="IEEE Std" value="1003.1, 2013 Edition"/>
</reference>




<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='http://www.rfc-editor.org/rfc/rfc2119.txt' />
<format type='HTML' octets='17970' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>



<reference anchor='RFC3629'>

<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'>
<organization /></author>
<date year='2003' month='November' />
<abstract>
<t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract></front>

<seriesInfo name='STD' value='63' />
<seriesInfo name='RFC' value='3629' />
<format type='TXT' octets='33856' target='http://www.rfc-editor.org/rfc/rfc3629.txt' />
</reference>



<reference anchor='RFC3339'>

<front>
<title>Date and Time on the Internet: Timestamps</title>
<author initials='G.' surname='Klyne' fullname='Graham Klyne' role='editor'>
<organization>Clearswift Corporation</organization>
<address>
<postal>
<street>1310 Waterside</street>
<street>Arlington Business Park</street>
<city>Theale</city>
<region>Reading</region>
<code>RG7 4SA</code>
<country>UK</country></postal>
<phone>+44 11 8903 8903</phone>
<facsimile>+44 11 8903 9000</facsimile>
<email>GK@ACM.ORG</email></address></author>
<author initials='C.' surname='Newman' fullname='Chris Newman'>
<organization>Sun Microsystems</organization>
<address>
<postal>
<street>1050 Lakes Drive, Suite 250</street>
<city>West Covina</city>
<region>CA</region>
<code>91790</code>
<country>USA</country></postal>
<email>chris.newman@sun.com</email></address></author>
<date year='2002' month='July' />
<abstract>
<t>
   This document defines a date and time format for use in Internet
   protocols that is a profile of the ISO 8601 standard for
   representation of dates and times using the Gregorian calendar.
     </t></abstract></front>

<seriesInfo name='RFC' value='3339' />
<format type='TXT' octets='35064' target='http://www.rfc-editor.org/rfc/rfc3339.txt' />
<format type='HTML' octets='65570' target='http://xml.resource.org/public/rfc/html/rfc3339.html' />
<format type='XML' octets='37259' target='http://xml.resource.org/public/rfc/xml/rfc3339.xml' />
</reference>



<reference anchor='RFC4287'>

<front>
<title abbrev='Atom Format'>The Atom Syndication Format</title>
<author initials='M.' surname='Nottingham' fullname='Mark Nottingham' role='editor'>
<organization />
<address>
<email>mnot@pobox.com</email>
<uri>http://www.mnot.net/</uri></address></author>
<author initials='R.' surname='Sayre' fullname='Robert Sayre' role='editor'>
<organization />
<address>
<email>rfsayre@boswijck.com</email>
<uri>http://boswijck.com</uri></address></author>
<date year='2005' month='December' />
<abstract>
<t>This document specifies Atom, an XML-based Web content and metadata syndication format.</t></abstract></front>

<seriesInfo name='RFC' value='4287' />
<format type='TXT' octets='81922' target='http://www.rfc-editor.org/rfc/rfc4287.txt' />
<format type='HTML' octets='164395' target='http://xml.resource.org/public/rfc/html/rfc4287.html' />
<format type='XML' octets='108706' target='http://xml.resource.org/public/rfc/xml/rfc4287.xml' />
</reference>



<reference anchor='RFC4648'>

<front>
<title>The Base16, Base32, and Base64 Data Encodings</title>
<author initials='S.' surname='Josefsson' fullname='S. Josefsson'>
<organization /></author>
<date year='2006' month='October' />
<abstract>
<t>This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4648' />
<format type='TXT' octets='35491' target='http://www.rfc-editor.org/rfc/rfc4648.txt' />
</reference>



<reference anchor='RFC3986'>

<front>
<title abbrev='URI Generic Syntax'>Uniform Resource Identifier (URI): Generic Syntax</title>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization abbrev='W3C/MIT'>World Wide Web Consortium</organization>
<address>
<postal>
<street>Massachusetts Institute of Technology</street>
<street>77 Massachusetts Avenue</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>USA</country></postal>
<phone>+1-617-253-5702</phone>
<facsimile>+1-617-258-5999</facsimile>
<email>timbl@w3.org</email>
<uri>http://www.w3.org/People/Berners-Lee/</uri></address></author>
<author initials='R.' surname='Fielding' fullname='Roy T. Fielding'>
<organization abbrev='Day Software'>Day Software</organization>
<address>
<postal>
<street>5251 California Ave., Suite 110</street>
<city>Irvine</city>
<region>CA</region>
<code>92617</code>
<country>USA</country></postal>
<phone>+1-949-679-2960</phone>
<facsimile>+1-949-679-2972</facsimile>
<email>fielding@gbiv.com</email>
<uri>http://roy.gbiv.com/</uri></address></author>
<author initials='L.' surname='Masinter' fullname='Larry Masinter'>
<organization abbrev='Adobe Systems'>Adobe Systems Incorporated</organization>
<address>
<postal>
<street>345 Park Ave</street>
<city>San Jose</city>
<region>CA</region>
<code>95110</code>
<country>USA</country></postal>
<phone>+1-408-536-3024</phone>
<email>LMM@acm.org</email>
<uri>http://larry.masinter.net/</uri></address></author>
<date year='2005' month='January' />
<area>Applications</area>
<keyword>uniform resource identifier</keyword>
<keyword>URI</keyword>
<keyword>URL</keyword>
<keyword>URN</keyword>
<keyword>WWW</keyword>
<keyword>resource</keyword>
<abstract>
<t>
A Uniform Resource Identifier (URI) is a compact sequence of characters
that identifies an abstract or physical resource.  This specification
defines the generic URI syntax and a process for resolving URI references
that might be in relative form, along with guidelines and security
considerations for the use of URIs on the Internet.
The URI syntax defines a grammar that is a superset of all valid URIs,
allowing an implementation to parse the common components of a URI
reference without knowing the scheme-specific requirements of every
possible identifier.  This specification does not define a generative
grammar for URIs; that task is performed by the individual
specifications of each URI scheme.
</t></abstract></front>

<seriesInfo name='STD' value='66' />
<seriesInfo name='RFC' value='3986' />
<format type='TXT' octets='141811' target='http://www.rfc-editor.org/rfc/rfc3986.txt' />
<format type='HTML' octets='214067' target='http://xml.resource.org/public/rfc/html/rfc3986.html' />
<format type='XML' octets='163534' target='http://xml.resource.org/public/rfc/xml/rfc3986.xml' />
</reference>



<reference anchor='RFC2045'>

<front>
<title abbrev='Internet Message Bodies'>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</title>
<author initials='N.' surname='Freed' fullname='Ned Freed'>
<organization>Innosoft International, Inc.</organization>
<address>
<postal>
<street>1050 East Garvey Avenue South</street>
<city>West Covina</city>
<region>CA</region>
<code>91790</code>
<country>US</country></postal>
<phone>+1 818 919 3600</phone>
<facsimile>+1 818 919 3614</facsimile>
<email>ned@innosoft.com</email></address></author>
<author initials='N.S.' surname='Borenstein' fullname='Nathaniel S. Borenstein'>
<organization>First Virtual Holdings</organization>
<address>
<postal>
<street>25 Washington Avenue</street>
<city>Morristown</city>
<region>NJ</region>
<code>07960</code>
<country>US</country></postal>
<phone>+1 201 540 8967</phone>
<facsimile>+1 201 993 3032</facsimile>
<email>nsb@nsb.fv.com</email></address></author>
<date year='1996' month='November' />
<abstract>
<t>STD 11, RFC 822, defines a message representation protocol specifying considerable detail about US-ASCII message headers, and leaves the message content, or message body, as flat US-ASCII text.  This set of documents, collectively called the Multipurpose Internet Mail Extensions, or MIME, redefines the format of messages to allow for</t>
<t>(1)   textual message bodies in character sets other than US-ASCII,</t>
<t>(2)   an extensible set of different formats for non-textual message bodies,</t>
<t>(3)   multi-part message bodies, and</t>
<t>(4)   textual header information in character sets other than US-ASCII.</t>
<t>These documents are based on earlier work documented in RFC 934, STD 11, and RFC 1049, but extends and revises them.  Because RFC 822 said so little about message bodies, these documents are largely orthogonal to (rather than a revision of) RFC 822.</t>
<t>This initial document specifies the various headers used to describe the structure of MIME messages. The second document, RFC 2046, defines the general structure of the MIME media typing system and defines an initial set of media types. The third document, RFC 2047, describes extensions to RFC 822 to allow non-US-ASCII text data in Internet mail header fields. The fourth document, RFC 2048, specifies various IANA registration procedures for MIME-related facilities. The fifth and final document, RFC 2049, describes MIME conformance
  criteria as well as providing some illustrative examples of MIME message formats, acknowledgements, and the bibliography.</t>
<t>These documents are revisions of RFCs 1521, 1522, and 1590, which themselves were revisions of RFCs 1341 and 1342.  An appendix in RFC 2049 describes differences and changes from previous versions.</t></abstract></front>

<seriesInfo name='RFC' value='2045' />
<format type='TXT' octets='72932' target='http://www.rfc-editor.org/rfc/rfc2045.txt' />
</reference>



<reference anchor='RFC5226'>

<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='T. Narten'>
<organization /></author>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
<organization /></author>
<date year='2008' month='May' />
<abstract>
<t>Many protocols make use of identifiers consisting of constants and other well-known values. Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec). To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority. For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).&lt;/t>&lt;t> In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made. If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role. This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA.&lt;/t>&lt;t> This document obsoletes RFC 2434. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='26' />
<seriesInfo name='RFC' value='5226' />
<format type='TXT' octets='66160' target='http://www.rfc-editor.org/rfc/rfc5226.txt' />
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="ASN.1" >
  <front>
    <title>Information Technology -- ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</title>
    <author >
      <organization>International Telecommunications Union</organization>
    </author>
    <date year="1994"/>
  </front>
  <seriesInfo name="ITU-T" value="Recommendation X.690"/>
</reference>
<reference anchor="BSON" target="http://bsonspec.org/">
  <front>
    <title>BSON</title>
    <author >
      <organization>Various</organization>
    </author>
    <date year="2013"/>
  </front>
</reference>
<reference anchor="MessagePack" target="http://msgpack.org/">
  <front>
    <title>MessagePack</title>
    <author >
      <organization>FURUHASHI Sadayuki</organization>
    </author>
    <date year="2013"/>
  </front>
</reference>
<reference anchor="UBJSON" target="http://ubjson.org/">
  <front>
    <title>Universal Binary JSON Specification</title>
    <author >
      <organization>The Buzz Media</organization>
    </author>
    <date year="2013"/>
  </front>
</reference>
<reference anchor="YAML" target="http://www.yaml.org/spec/1.2/spec.html">
  <front>
    <title>YAML Ain’t Markup Language (YAML™) Version 1.2, 3rd Edition</title>
    <author initials="O." surname="Ben-Kiki" fullname="Oren Ben-Kiki">
      <organization></organization>
    </author>
    <author initials="C." surname="Evans" fullname="Clark Evans">
      <organization></organization>
    </author>
    <author initials="I.d." surname="Net" fullname="Ingy döt Net">
      <organization></organization>
    </author>
    <date year="2009" month="October" day="01"/>
  </front>
</reference>




<reference anchor='RFC4627'>

<front>
<title>The application/json Media Type for JavaScript Object Notation (JSON)</title>
<author initials='D.' surname='Crockford' fullname='D. Crockford'>
<organization /></author>
<date year='2006' month='July' />
<abstract>
<t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.  This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='4627' />
<format type='TXT' octets='16319' target='http://www.rfc-editor.org/rfc/rfc4627.txt' />
</reference>



<reference anchor='I-D.ietf-lwig-terminology'>
<front>
<title>Terminology for Constrained Node Networks</title>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<author initials='M' surname='Ersue' fullname='Mehmet Ersue'>
    <organization />
</author>

<author initials='A' surname='Keranen' fullname='Ari Keranen'>
    <organization />
</author>

<date month='July' day='9' year='2013' />

<abstract><t>The Internet Protocol Suite is increasingly used on small devices with severe constraints, creating constrained node networks.  This document provides a number of basic terms that have turned out to be useful in the standardization work for constrained environments.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-lwig-terminology-05' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-lwig-terminology-05.txt' />
</reference>



<reference anchor='RFC6838'>

<front>
<title>Media Type Specifications and Registration Procedures</title>
<author initials='N.' surname='Freed' fullname='N. Freed'>
<organization /></author>
<author initials='J.' surname='Klensin' fullname='J. Klensin'>
<organization /></author>
<author initials='T.' surname='Hansen' fullname='T. Hansen'>
<organization /></author>
<date year='2013' month='January' />
<abstract>
<t>This document defines procedures for the specification and registration of media types for use in HTTP, MIME, and other Internet protocols.  This memo documents an Internet Best Current Practice.</t></abstract></front>

<seriesInfo name='BCP' value='13' />
<seriesInfo name='RFC' value='6838' />
<format type='TXT' octets='72942' target='http://www.rfc-editor.org/rfc/rfc6838.txt' />
</reference>



<reference anchor='RFC0713'>

<front>
<title>MSDTP-Message Services Data Transmission Protocol</title>
<author initials='J.' surname='Haverty' fullname='Jack Haverty'>
<organization>Massachusetts Institute of Technology (MIT)</organization>
<address>
<email>JFH@MIT-DMS</email></address></author>
<date year='1976' day='6' month='April' />
<abstract>
<t>A mechanism is defined for use by message servers in transferring data between hosts.  The mechanism, called the MSDTP, is defined in terms of a model of the process as a translation between two sets of items, the abstract entities such as 'strings' and 'integers', and the formats used to represent such data as a byte stream.</t>
<t>A proposed organization of a general data transfer mechanism is described, and the manner in which the MSDTP would be used in that environment is presented.</t></abstract></front>

<seriesInfo name='RFC' value='713' />
<format type='TXT' octets='41175' target='http://www.rfc-editor.org/rfc/rfc713.txt' />
</reference>




    </references>


<section anchor="examples" title="Examples">

<t>The following table provides some CBOR encoded values in hexadecimal
(right column), together with diagnostic notation for these values
(left column).  Note that the string “\u00fc” is one form of
diagnostic notation for a UTF-8 string containing the single Unicode
character U+00FC, LATIN SMALL LETTER U WITH DIAERESIS (u umlaut).
Similarly, “\u6c34” is a UTF-8 string in diagnostic notation with a
single character U+6C34 (CJK UNIFIED IDEOGRAPH-6C34, often
representing “water”), and “\ud800\udd51” is a UTF-8 string in
diagnostic notation with a single character U+10151 (GREEK ACROPHONIC
ATTIC FIFTY STATERS).  (Note that all these single-character strings
could also be represented in native UTF-8 in diagnostic notation, just
not in an ASCII-only specification like the present one.)
In the diagnostic notation provided for bignums, their intended
numeric value is shown as a decimal number (such as
18446744073709551616) instead of showing a tagged byte string (such as
2(h’010000000000000000’)).</t>

<texttable>
      <ttcol align='left'>Diagnostic</ttcol>
      <ttcol align='left'>Encoded</ttcol>
      <c>0</c>
      <c>0x00</c>
      <c>1</c>
      <c>0x01</c>
      <c>10</c>
      <c>0x0a</c>
      <c>23</c>
      <c>0x17</c>
      <c>24</c>
      <c>0x1818</c>
      <c>25</c>
      <c>0x1819</c>
      <c>100</c>
      <c>0x1864</c>
      <c>1000</c>
      <c>0x1903e8</c>
      <c>1000000</c>
      <c>0x1a000f4240</c>
      <c>1000000000000</c>
      <c>0x1b000000e8d4a51000</c>
      <c>18446744073709551615</c>
      <c>0x1bffffffffffffffff</c>
      <c>18446744073709551616</c>
      <c>0xc249010000000000000000</c>
      <c>-18446744073709551616</c>
      <c>0x3bffffffffffffffff</c>
      <c>-18446744073709551617</c>
      <c>0xc349010000000000000000</c>
      <c>-1</c>
      <c>0x20</c>
      <c>-10</c>
      <c>0x29</c>
      <c>-100</c>
      <c>0x3863</c>
      <c>-1000</c>
      <c>0x3903e7</c>
      <c>0.0</c>
      <c>0xf90000</c>
      <c>-0.0</c>
      <c>0xf98000</c>
      <c>1.0</c>
      <c>0xf93c00</c>
      <c>1.1</c>
      <c>0xfb3ff199999999999a</c>
      <c>1.5</c>
      <c>0xf93e00</c>
      <c>65504.0</c>
      <c>0xf97bff</c>
      <c>100000.0</c>
      <c>0xfa47c35000</c>
      <c>3.4028234663852886e+38</c>
      <c>0xfa7f7fffff</c>
      <c>1.0e+300</c>
      <c>0xfb7e37e43c8800759c</c>
      <c>5.960464477539063e-8</c>
      <c>0xf90001</c>
      <c>0.00006103515625</c>
      <c>0xf90400</c>
      <c>-4.0</c>
      <c>0xf9c400</c>
      <c>-4.1</c>
      <c>0xfbc010666666666666</c>
      <c>Infinity</c>
      <c>0xf97c00</c>
      <c>NaN</c>
      <c>0xf97e00</c>
      <c>-Infinity</c>
      <c>0xf9fc00</c>
      <c>Infinity</c>
      <c>0xfa7f800000</c>
      <c>NaN</c>
      <c>0xfa7fc00000</c>
      <c>-Infinity</c>
      <c>0xfaff800000</c>
      <c>Infinity</c>
      <c>0xfb7ff0000000000000</c>
      <c>NaN</c>
      <c>0xfb7ff8000000000000</c>
      <c>-Infinity</c>
      <c>0xfbfff0000000000000</c>
      <c>false</c>
      <c>0xf4</c>
      <c>true</c>
      <c>0xf5</c>
      <c>null</c>
      <c>0xf6</c>
      <c>undefined</c>
      <c>0xf7</c>
      <c>simple(16)</c>
      <c>0xf0</c>
      <c>simple(24)</c>
      <c>0xf818</c>
      <c>simple(255)</c>
      <c>0xf8ff</c>
      <c>0(“2013-03-21T20:04:00Z”)</c>
      <c>0xc074323031332d30332d32315432303a30343a30305a</c>
      <c>1(1363896240)</c>
      <c>0xc11a514b67b0</c>
      <c>1(1363896240.5)</c>
      <c>0xc1fb41d452d9ec200000</c>
      <c>23(h’01020304’)</c>
      <c>0xd74401020304</c>
      <c>24(h’6449455446’)</c>
      <c>0xd818456449455446</c>
      <c>32(“http://www.example.com”)</c>
      <c>0xd82076687474703a2f2f7777772e6578616d706c652e636f6d</c>
      <c>h’’</c>
      <c>0x40</c>
      <c>h’01020304’</c>
      <c>0x4401020304</c>
      <c>””</c>
      <c>0x60</c>
      <c>“a”</c>
      <c>0x6161</c>
      <c>“IETF”</c>
      <c>0x6449455446</c>
      <c>”\”\\”</c>
      <c>0x62225c</c>
      <c>”\u00fc”</c>
      <c>0x62c3bc</c>
      <c>”\u6c34”</c>
      <c>0x63e6b0b4</c>
      <c>”\ud800\udd51”</c>
      <c>0x64f0908591</c>
      <c>[]</c>
      <c>0x80</c>
      <c>[1, 2, 3]</c>
      <c>0x83010203</c>
      <c>[1, [2, 3], [4, 5]]</c>
      <c>0x8301820203820405</c>
      <c>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]</c>
      <c>0x98190102030405060708090a0b0c0d0e0f101112131415161718181819</c>
      <c>{}</c>
      <c>0xa0</c>
      <c>{1: 2, 3: 4}</c>
      <c>0xa201020304</c>
      <c>{“a”: 1, “b”: [2, 3]}</c>
      <c>0xa26161016162820203</c>
      <c>[“a”, {“b”: “c”}]</c>
      <c>0x826161a161626163</c>
      <c>{“a”: “A”, “b”: “B”, “c”: “C”, “d”: “D”, “e”: “E”}</c>
      <c>0xa56161614161626142616361436164614461656145</c>
      <c>(_ h’0102’, h’030405’)</c>
      <c>0x5f42010243030405ff</c>
      <c>(_ “strea”, “ming”)</c>
      <c>0x7f657374726561646d696e67ff</c>
      <c>[_ ]</c>
      <c>0x9fff</c>
      <c>[_ 1, [2, 3], [_ 4, 5]]</c>
      <c>0x9f018202039f0405ffff</c>
      <c>[_ 1, [2, 3], [4, 5]]</c>
      <c>0x9f01820203820405ff</c>
      <c>[1, [2, 3], [_ 4, 5]]</c>
      <c>0x83018202039f0405ff</c>
      <c>[1, [_ 2, 3], [4, 5]]</c>
      <c>0x83019f0203ff820405</c>
      <c>[_ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]</c>
      <c>0x9f0102030405060708090a0b0c0d0e0f101112131415161718181819ff</c>
      <c>{_ “a”: 1, “b”: [_ 2, 3]}</c>
      <c>0xbf61610161629f0203ffff</c>
      <c>[“a”, {_ “b”: “c”}]</c>
      <c>0x826161bf61626163ff</c>
      <c>{_ “Fun”: true, “Amt”: -2}</c>
      <c>0xbf6346756ef563416d7421ff</c>
</texttable>

</section>
<section anchor="jump-table" title="Jump Table">

<t>For brevity, this jump table does not show initial bytes that are
reserved for future extension. It also only shows a selection of the
initial bytes that can be used for optional features.  (All
unsigned integers are in network byte order.)</t>

<texttable title="Jump Table for Initial Byte" anchor="jumptable">
      <ttcol align='left'>Byte</ttcol>
      <ttcol align='left'>Structure/Semantics</ttcol>
      <c>0x00..0x17</c>
      <c>Integer 0x00..0x17 (0..23)</c>
      <c>0x18</c>
      <c>Unsigned integer (one-byte uint8_t follows)</c>
      <c>0x19</c>
      <c>Unsigned integer (two-byte uint16_t follows)</c>
      <c>0x1a</c>
      <c>Unsigned integer (four-byte uint32_t follows)</c>
      <c>0x1b</c>
      <c>Unsigned integer (eight-byte uint64_t follows)</c>
      <c>0x20..0x37</c>
      <c>Negative Integer -1-0x00..-1-0x17 (-1..-24)</c>
      <c>0x38</c>
      <c>Negative Integer -1-n (one-byte uint8_t for n follows)</c>
      <c>0x39</c>
      <c>Negative integer -1-n (two-byte uint16_t for n follows)</c>
      <c>0x3a</c>
      <c>Negative integer -1-n (four-byte uint32_t for n follows)</c>
      <c>0x3b</c>
      <c>Negative integer -1-n (eight-byte uint64_t for n follows)</c>
      <c>0x40..0x57</c>
      <c>byte string (0x00..0x17 bytes follow)</c>
      <c>0x58</c>
      <c>byte string (one-byte uint8_t for n, and then n bytes follow)</c>
      <c>0x59</c>
      <c>byte string (two-byte uint16_t for n, and then n bytes follow)</c>
      <c>0x5a</c>
      <c>byte string (four-byte uint32_t for n, and then n bytes follow)</c>
      <c>0x5b</c>
      <c>byte string (eight-byte uint64_t for n, and then n bytes follow)</c>
      <c>0x5f</c>
      <c>byte string, byte strings follow, terminated by “break”</c>
      <c>0x60..0x77</c>
      <c>UTF-8 string (0x00..0x17 bytes follow)</c>
      <c>0x78</c>
      <c>UTF-8 string (one-byte uint8_t for n, and then n bytes follow)</c>
      <c>0x79</c>
      <c>UTF-8 string (two-byte uint16_t for n, and then n bytes follow)</c>
      <c>0x7a</c>
      <c>UTF-8 string (four-byte uint32_t for n, and then n bytes follow)</c>
      <c>0x7b</c>
      <c>UTF-8 string (eight-byte uint64_t for n, and then n bytes follow)</c>
      <c>0x7f</c>
      <c>UTF-8 string, UTF-8 strings follow, terminated by “break”</c>
      <c>0x80..0x97</c>
      <c>array (0x00..0x17 data items follow)</c>
      <c>0x98</c>
      <c>array (one-byte uint8_t for n, and then n data items follow)</c>
      <c>0x99</c>
      <c>array (two-byte uint16_t for n, and then n data items follow)</c>
      <c>0x9a</c>
      <c>array (four-byte uint32_t for n, and then n data items follow)</c>
      <c>0x9b</c>
      <c>array (eight-byte uint64_t for n, and then n data items follow)</c>
      <c>0x9f</c>
      <c>array, data items follow, terminated by “break”</c>
      <c>0xa0..0xb7</c>
      <c>map (0x00..0x17 pairs of data items follow)</c>
      <c>0xb8</c>
      <c>map (one-byte uint8_t for n, and then n pairs of data items follow)</c>
      <c>0xb9</c>
      <c>map (two-byte uint16_t for n, and then n pairs of data items follow)</c>
      <c>0xba</c>
      <c>map (four-byte uint32_t for n, and then n pairs of data items follow)</c>
      <c>0xbb</c>
      <c>map (eight-byte uint64_t for n, and then n pairs of data items follow)</c>
      <c>0xbf</c>
      <c>map, pairs of data items follow, terminated by “break”</c>
      <c>0xc0</c>
      <c>Text-based date/time (data item follows, see <xref target="datetimesect"/>)</c>
      <c>0xc1</c>
      <c>Epoch-based date/time (data item follows, see <xref target="datetimesect"/>)</c>
      <c>0xc2</c>
      <c>Positive bignum (data item “byte string” follows)</c>
      <c>0xc3</c>
      <c>Negative bignum (data item “byte string” follows)</c>
      <c>0xc4</c>
      <c>Decimal Fraction (data item “array” follows, see <xref target="fractions"/>)</c>
      <c>0xc5</c>
      <c>Bigfloat (data item “array” follows, see <xref target="fractions"/>)</c>
      <c>0xc6..0xd4</c>
      <c>(tagged item, tag to be assigned by IANA)</c>
      <c>0xd5..0xd7</c>
      <c>Expected Conversion (data item follows, see <xref target="convexpect"/>)</c>
      <c>0xd8..0xdb</c>
      <c>(more tagged items, 1/2/4/8 bytes and then a data item follow)</c>
      <c>0xe0..0xf3</c>
      <c>(simple value to be assigned by IANA)</c>
      <c>0xf4</c>
      <c>False</c>
      <c>0xf5</c>
      <c>True</c>
      <c>0xf6</c>
      <c>Null</c>
      <c>0xf7</c>
      <c>Undefined</c>
      <c>0xf8</c>
      <c>(simple value to be assigned by IANA, one byte follows)</c>
      <c>0xf9</c>
      <c>Half-Precision Float (two-byte IEEE 754)</c>
      <c>0xfa</c>
      <c>Single-Precision Float (four-byte IEEE 754)</c>
      <c>0xfb</c>
      <c>Double-Precision Float (eight-byte IEEE 754)</c>
      <c>0xff</c>
      <c>“break” stop code</c>
</texttable>

</section>
<section anchor="pseudocode" title="Pseudocode">

<t>The well-formedness of a CBOR item can be checked by the
pseudo-code in <xref target="pseudo"/>.  The data is well-formed if and only if:</t>

<t><list style='symbols'>
  <t>the pseudo-code does not “fail”;</t>
  <t>after execution of the pseudo-code, no bytes are left in the input
(except in streaming applications)</t>
</list></t>

<t>The pseudo-code has the following prerequisites:</t>

<t><list style='symbols'>
  <t>take(n) reads n bytes from the input data and returns them as a
byte string.  If n bytes are no longer available, take(n) fails.</t>
  <t>uint() converts a byte string into an unsigned integer by interpreting
the byte string in network byte order.</t>
  <t>Arithmetic works as in C.</t>
  <t>All variables are unsigned integers of sufficient range.</t>
</list></t>

<figure title="Pseudo-Code for well-formedness check" anchor="pseudo"><artwork><![CDATA[
well_formed (breakable = false) {
  // process initial bytes
  ib = uint(take(1));
  mt = ib >> 5;
  val = ai = ib & 0x1f;
  switch (ai) {
    case 24: val = uint(take(1)); break;
    case 25: val = uint(take(2)); break;
    case 26: val = uint(take(4)); break;
    case 27: val = uint(take(8)); break;
    case 28: case 29: case 30: fail();
    case 31:
      return well_formed_indefinite(mt, breakable);
  }
  // process content
  switch (mt) {
    // case 0, 1, 7 do not have content; just use val
    case 2: case 3: take(val); break; // bytes/UTF-8
    case 4: for (i = 0; i < val; i++) well_formed(); break;
    case 5: for (i = 0; i < val*2; i++) well_formed(); break;
    case 6: well_formed(); break;     // 1 embedded data item
  }
  return mt;                    // finite data item
}

well_formed_indefinite(mt, breakable) {
  switch (mt) {
    case 2: case 3:
      while ((it = well_formed(true)) != -1)
        if (it != mt)           // need finite embedded
          fail();               //    of same type
      break;
    case 4: while (well_formed(true) != -1); break;
    case 5: while (well_formed(true) != -1) well_formed(); break;
    case 7:
      if (breakable)
        return -1;              // signal break out
      else fail();              // no enclosing indefinite
    default: fail();            // wrong mt
  }
  return 0;                     // no break out
}
]]></artwork></figure>

<t>Note that the remaining complexity of a complete CBOR decoder is about
presenting data that has been parsed to the application in an appropriate form.</t>

<t>Major types 0 and 1 are designed in such a way that they can be
encoded in C from a signed integer without actually doing an if-then-else
for positive/negative (<xref target="branchless"/>).  This uses the fact that
(-1-n), the transformation for major type 1, is the same as ~n
(bitwise complement) in C unsigned arithmetic, ~n can then be
expressed as (-1)^n for the negative case, while 0^n leaves n
unchanged for non-negative.  The sign of a number can be converted to
-1 for negative and 0 for non-negative (0 or positive) by
arithmetic-shifting the number by one bit less than the bit length of
the number (for example, by 63 for 64-bit numbers).</t>

<figure title="Pseudo-code for encoding a signed integer" anchor="branchless"><artwork><![CDATA[
void encode_sint(int64_t n) {
  uint64t ui = n >> 63;    // extend sign to whole length
  mt = ui & 0x20;          // extract major type
  ui ^= n;                 // complement negatives
  if (ui < 24)
    *p++ = mt + ui;
  else if (ui < 256) {
    *p++ = mt + 24;
    *p++ = ui;
  } else
       ...
]]></artwork></figure>

</section>
<section anchor="half-precision" title="Half-precision">

<t>As half-precision floating point numbers were only added to IEEE 754
in 2008, today’s programming platforms often still only have limited support for
them.  It is very easy to include at least decoding support for them
even without such support.  An example of a small decoder for half-precision
floating point numbers in the C language is shown in
<xref target="decode-half-c"/>.
A similar program for Python is in <xref target="decode-half-py"/>; this code
assumes that the 2-byte value has already been decoded as an (unsigned
short) integer in network byte order (as would be done by the
pseudocode in <xref target="pseudocode"/>).</t>

<figure title="C code for a half-precision decoder" anchor="decode-half-c"><artwork><![CDATA[
#include <math.h>

double decode_half(unsigned char *halfp) {
  int half = (halfp[0] << 8) + halfp[1];
  int exp = (half >> 10) & 0x1f;
  int mant = half & 0x3ff;
  double val;
  if (exp == 0) val = ldexp(mant, -24);
  else if (exp != 31) val = ldexp(mant + 1024, exp - 25);
  else val = mant == 0 ? INFINITY : NAN;
  return half & 0x8000 ? -val : val;
}
]]></artwork></figure>

<figure title="Python code for a half-precision decoder" anchor="decode-half-py"><artwork><![CDATA[
import struct
from math import ldexp

def decode_single(single):
    return struct.unpack("!f", struct.pack("!I", single))[0]

def decode_half(half):
    valu = (half & 0x7fff) << 13 | (half & 0x8000) << 16
    if ((half & 0x7c00) != 0x7c00):
        return ldexp(decode_single(valu), 112)
    return decode_single(valu | 0x7f800000)
]]></artwork></figure>

</section>
<section anchor="comparison-app" title="Comparison of Other Binary Formats to CBOR’s Design Objectives">

<t>The proposal for CBOR follows a history of binary formats that is as long as the history of
computers themselves. Different formats have had different objectives. In most cases, the objectives
of the format were never stated, although they can sometimes be implied by the context where the
format was first used. Some formats were meant to be universally-usable, although history has proven
that no binary format meets the needs of all protocols and applications.</t>

<t>CBOR differs from many of these formats due to it starting with a set of objectives and attempting
to meet just those. This section compares a few of the dozens of formats with CBOR’s objectives in
order to help the reader decide if they want to use CBOR or a different format for a particular
protocol or application.</t>

<t>Note that the discussion here is not meant to be a criticism of any format: to the best of our
knowledge, no format before CBOR was meant to cover CBOR’s objectives in the priority we have
assigned them. A brief recap of the objectives from <xref target="objectives"/> is:</t>

<t><list style='numbers'>
  <t>unambiguously encode common data formats from Internet standards</t>
  <t>code compactness for encoder or decoder</t>
  <t>no schema description needed</t>
  <t>reasonably compact serialization</t>
  <t>applicable to constrained and unconstrained applications</t>
  <t>good JSON conversion</t>
  <t>extensibility</t>
</list></t>

<section anchor="asn1-der-ber-and-per" title="ASN.1 DER, BER, and PER">

<t><xref target="ASN.1"/> has many serializations. In the IETF, DER and BER are the most common. The serialized
output is not particularly compact for many items, and the code needed to decode numeric items can be
complex on a constrained device.</t>

<t>Few (if any) IETF protocols have adopted one of the several variants
of PER.  There could be many reasons for this, but one that is
commonly stated is that PER requires making use of the schema for even
parsing the surface structure of the data stream, requiring
significant tool support.  There are different versions of
the ASN.1 schema language in use, which has also hampered adoption.</t>

</section>
<section anchor="messagepack" title="MessagePack">

<t><xref target="MessagePack"/> is a concise, widely-implemented counted binary
serialization format, similar in many properties to CBOR, although somewhat less
regular.  While the data model can be used to represent JSON data,
MessagePack has also been used in many RPC applications and
for long-term storage of data.</t>

<t>MessagePack has been essentially stable since it was first published
around 2011; it has not yet had a transition.  The evolution of
MessagePack is impeded by an imperative to maintain complete backwards
compatibility with existing stored data, while only few bytecodes are
still available for extension.  Repeated requests over the years from the MessagePack user community
to separate out binary and text strings in the encoding
recently have led to an extension proposal that would
leave MessagePack’s “raw” data ambiguous between its usages for binary
and text data. The extension mechanism for MessagePack remains unclear.</t>

</section>
<section anchor="bson" title="BSON">

<t><xref target="BSON"/> is a data format that was developed for the storage of
JSON-like maps (JSON objects) in the MongoDB database.  Its major
distinguishing feature is the capability for in-place update,
foregoing a compact representation.  BSON uses a counted
representation except for map keys, which are null-byte terminated.
While BSON can be used for the representation of JSON-like objects on
the wire, its specification is dominated by the requirements of the
database application and has become somewhat baroque. The status of
how BSON extensions will be implemented remains unclear.</t>

</section>
<section anchor="ubjson" title="UBJSON">

<t><xref target="UBJSON"/> has a design goal to make JSON faster and somewhat smaller,
using a binary format that is limited to exactly the data model JSON
uses.  Thus, there is expressly no intention to support, for example,
binary data; however, there is a “high-precision number”, expressed as
a character string in JSON syntax.  UBJSON is not optimized for code
compactness, and its type byte coding is optimized for human
recognition and not for compact representation of native types such as
small integers.  Although UBJSON is mostly counted, it provides a
reserved “unknown-length” value to support streaming of arrays and
maps (JSON objects).  Within these containers, UBJSON also has a
“Noop” type for padding.</t>

</section>
<section anchor="msdtp-rfc-713" title="MSDTP: RFC 713">

<t>A very early example of a compact message format is described in <xref target="RFC0713"/>, defined in 1976. It
is included here for its historical value, not because it was ever widely used.</t>

</section>
<section anchor="conciseness-on-the-wire" title="Conciseness On The Wire">

<t>While CBOR’s design objective of code compactness for encoders and decoders is higher
than its objective of conciseness on the wire, many people focus on the wire size.
<xref target="concise"/> shows some encoding examples for the simple nested array
[1, [2, 3]]; where some form of indefinite length encoding is supported by the encoding,
[_ 1, [2, 3]] (indefinite length on the outer array) is also shown.</t>

<t>(Entries marked with an asterisk have not been checked against an
implementation and might be applying some liberty in translating the
CBOR data model to that format. Corrections are appreciated.)</t>

<texttable title="Examples for different levels of conciseness" anchor="concise">
      <ttcol align='left'>Format</ttcol>
      <ttcol width='40' align='left'>[1, [2, 3]]</ttcol>
      <ttcol width='40' align='left'>[_ 1, [2, 3]]</ttcol>
      <c>RFC 713*</c>
      <c>c2 05 81 c2 02 82 83</c>
      <c>&#160;</c>
      <c>ASN.1 BER*</c>
      <c>30 0b 02 01 01 30 06 02 01 02 02 01 03</c>
      <c>30 80 02 01 01 30 06 02 01 02 02 01 03 00 00</c>
      <c>MessagePack</c>
      <c>92 01 92 02 03</c>
      <c>&#160;</c>
      <c>BSON</c>
      <c>22 00 00 00 10 30 00 01 00 00 00 04 31 00 13 00 00 00 10 30 00 02 00 00 00 10 31 00 03 00 00 00 00 00</c>
      <c>&#160;</c>
      <c>UBJSON</c>
      <c>61 02 42 01 61 02 42 02 42 03</c>
      <c>61 ff 42 01 61 02 42 02 42 03 45*</c>
      <c>CBOR</c>
      <c>82 01 82 02 03</c>
      <c>9f 01 82 02 03 ff</c>
</texttable>

<!--  LocalWords:  CBOR JSON IETF Evolvability BCP multi UTF IEEE UTC
 -->
<!--  LocalWords:  bignum IANA interworking PCRE  bignums POSIX YAML
 -->
<!--  LocalWords:  NTP encodings roundtripping parsers encodable ASN
 -->
<!--  LocalWords:  Acknowledgements acknowledgements extensibility
 -->
<!--  LocalWords:  MessagePack BER DER interoperating URIs tuples NaN
 -->
<!--  LocalWords:  interwork Interoperability uint codepoint metadata
 -->
<!--  LocalWords:  canonicalization optionality codepoints ABNF BSON
 -->
<!--  LocalWords:  bytecodes UBJSON bigfloat bigfloats attractor CoAP
 -->
<!--  LocalWords:  representable disambiguating multimaps IESG
 -->
<!--  LocalWords:  Implementers decodable
 -->

</section>
</section>


  </back>
</rfc>

