


Network Working Group                                    F. Templin, Ed.
Internet-Draft                              Boeing Research & Technology
Intended status: Standards Track                        October 28, 2011
Expires: April 30, 2012


        The Subnetwork Encapsulation and Adaptation Layer (SEAL)
                   draft-templin-intarea-seal-35.txt

Abstract

   For the purpose of this document, a subnetwork is defined as a
   virtual topology configured over a connected IP network routing
   region and bounded by encapsulating border nodes.  These virtual
   topologies are manifested by tunnels that may span multiple IP and/or
   sub-IP layer forwarding hops, and can introduce failure modes due to
   packet duplication and/or links with diverse Maximum Transmission
   Units (MTUs).  This document specifies a Subnetwork Encapsulation and
   Adaptation Layer (SEAL) that accommodates such virtual topologies
   over diverse underlying link technologies.

Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on April 30, 2012.

Copyright Notice

   Copyright (c) 2011 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect



Templin                  Expires April 30, 2012                 [Page 1]

Internet-Draft                    SEAL                      October 2011


   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.1.  Motivation . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.2.  Approach . . . . . . . . . . . . . . . . . . . . . . . . .  6
   2.  Terminology and Requirements . . . . . . . . . . . . . . . . .  6
   3.  Applicability Statement  . . . . . . . . . . . . . . . . . . .  8
   4.  SEAL Specification . . . . . . . . . . . . . . . . . . . . . .  9
     4.1.  VET Interface Model  . . . . . . . . . . . . . . . . . . . 10
     4.2.  SEAL Model of Operation  . . . . . . . . . . . . . . . . . 10
     4.3.  SEAL Header Format . . . . . . . . . . . . . . . . . . . . 11
     4.4.  SEAL Trailer Format  . . . . . . . . . . . . . . . . . . . 13
     4.5.  ITE Specification  . . . . . . . . . . . . . . . . . . . . 13
       4.5.1.  Tunnel Interface Soft State  . . . . . . . . . . . . . 13
       4.5.2.  Tunnel Interface MTU . . . . . . . . . . . . . . . . . 14
       4.5.3.  Submitting Packets for Encapsulation . . . . . . . . . 15
       4.5.4.  SEAL Encapsulation . . . . . . . . . . . . . . . . . . 16
       4.5.5.  Outer Encapsulation  . . . . . . . . . . . . . . . . . 17
       4.5.6.  Probing Strategy . . . . . . . . . . . . . . . . . . . 18
       4.5.7.  Processing ICMP Messages . . . . . . . . . . . . . . . 19
     4.6.  ETE Specification  . . . . . . . . . . . . . . . . . . . . 20
       4.6.1.  Tunnel Interface Soft State  . . . . . . . . . . . . . 20
       4.6.2.  Reassembly Buffer Requirements . . . . . . . . . . . . 20
       4.6.3.  IP-Layer Reassembly  . . . . . . . . . . . . . . . . . 20
       4.6.4.  Decapsulation and Re-Encapsulation . . . . . . . . . . 21
     4.7.  The SEAL Control Message Protocol (SCMP) . . . . . . . . . 22
       4.7.1.  Generating SCMP Error Messages . . . . . . . . . . . . 22
       4.7.2.  Processing SCMP Error Messages . . . . . . . . . . . . 24
   5.  Link Requirements  . . . . . . . . . . . . . . . . . . . . . . 26
   6.  End System Requirements  . . . . . . . . . . . . . . . . . . . 26
   7.  Router Requirements  . . . . . . . . . . . . . . . . . . . . . 26
   8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 26
   9.  Security Considerations  . . . . . . . . . . . . . . . . . . . 27
   10. Related Work . . . . . . . . . . . . . . . . . . . . . . . . . 27
   11. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 28
   12. References . . . . . . . . . . . . . . . . . . . . . . . . . . 29
     12.1. Normative References . . . . . . . . . . . . . . . . . . . 29
     12.2. Informative References . . . . . . . . . . . . . . . . . . 29
   Appendix A.  Reliability . . . . . . . . . . . . . . . . . . . . . 32
   Appendix B.  Integrity . . . . . . . . . . . . . . . . . . . . . . 32
   Appendix C.  Transport Mode  . . . . . . . . . . . . . . . . . . . 33
   Appendix D.  Historic Evolution of PMTUD . . . . . . . . . . . . . 33



Templin                  Expires April 30, 2012                 [Page 2]

Internet-Draft                    SEAL                      October 2011


   Author's Address . . . . . . . . . . . . . . . . . . . . . . . . . 35


















































Templin                  Expires April 30, 2012                 [Page 3]

Internet-Draft                    SEAL                      October 2011


1.  Introduction

   As Internet technology and communication has grown and matured, many
   techniques have developed that use virtual topologies (including
   tunnels of one form or another) over an actual network that supports
   the Internet Protocol (IP) [RFC0791][RFC2460].  Those virtual
   topologies have elements that appear as one hop in the virtual
   topology, but are actually multiple IP or sub-IP layer hops.  These
   multiple hops often have quite diverse properties that are often not
   even visible to the endpoints of the virtual hop.  This introduces
   failure modes that are not dealt with well in current approaches.

   The use of IP encapsulation (also known as "tunneling") has long been
   considered as the means for creating such virtual topologies.
   However, the insertion of an outer IP header reduces the effective
   path MTU visible to the inner network layer.  When IPv4 is used, this
   reduced MTU can be accommodated through the use of IPv4
   fragmentation, but unmitigated in-the-network fragmentation has been
   found to be harmful through operational experience and studies
   conducted over the course of many years [FRAG][FOLK][RFC4963].
   Additionally, classical path MTU discovery [RFC1191] has known
   operational issues that are exacerbated by in-the-network tunnels
   [RFC2923][RFC4459].  The following subsections present further
   details on the motivation and approach for addressing these issues.

1.1.  Motivation

   Before discussing the approach, it is necessary to first understand
   the problems.  In both the Internet and private-use networks today,
   IPv4 is ubiquitously deployed as the Layer 3 protocol.  The two
   primary functions of IPv4 are to provide for 1) addressing, and 2) a
   fragmentation and reassembly capability used to accommodate links
   with diverse MTUs.  While it is well known that the IPv4 address
   space is rapidly becoming depleted, there is a lesser-known but
   growing consensus that other IPv4 protocol limitations have already
   or may soon become problematic.

   First, the IPv4 header Identification field is only 16 bits in
   length, meaning that at most 2^16 unique packets with the same
   (source, destination, protocol)-tuple may be active in the Internet
   at a given time [I-D.ietf-intarea-ipv4-id-update].  Due to the
   escalating deployment of high-speed links, however, this number may
   soon become too small by several orders of magnitude for high data
   rate packet sources such as tunnel endpoints [RFC4963].  Furthermore,
   there are many well-known limitations pertaining to IPv4
   fragmentation and reassembly - even to the point that it has been
   deemed "harmful" in both classic and modern-day studies (see above).
   In particular, IPv4 fragmentation raises issues ranging from minor



Templin                  Expires April 30, 2012                 [Page 4]

Internet-Draft                    SEAL                      October 2011


   annoyances (e.g., in-the-network router fragmentation [RFC1981]) to
   the potential for major integrity issues (e.g., mis-association of
   the fragments of multiple IP packets during reassembly [RFC4963]).

   As a result of these perceived limitations, a fragmentation-avoiding
   technique for discovering the MTU of the forward path from a source
   to a destination node was devised through the deliberations of the
   Path MTU Discovery Working Group (PMTUDWG) during the late 1980's
   through early 1990's (see Appendix D).  In this method, the source
   node provides explicit instructions to routers in the path to discard
   the packet and return an ICMP error message if an MTU restriction is
   encountered.  However, this approach has several serious shortcomings
   that lead to an overall "brittleness" [RFC2923].

   In particular, site border routers in the Internet are being
   configured more and more to discard ICMP error messages coming from
   the outside world.  This is due in large part to the fact that
   malicious spoofing of error messages in the Internet is trivial since
   there is no way to authenticate the source of the messages [RFC5927].
   Furthermore, when a source node that requires ICMP error message
   feedback when a packet is dropped due to an MTU restriction does not
   receive the messages, a path MTU-related black hole occurs.  This
   means that the source will continue to send packets that are too
   large and never receive an indication from the network that they are
   being discarded.  This behavior has been confirmed through documented
   studies showing clear evidence of path MTU discovery failures in the
   Internet today [TBIT][WAND][SIGCOMM].

   The issues with both IPv4 fragmentation and this "classical" method
   of path MTU discovery are exacerbated further when IP tunneling is
   used [RFC4459].  For example, an ingress tunnel endpoint (ITE) may be
   required to forward encapsulated packets into the subnetwork on
   behalf of hundreds, thousands, or even more original sources within
   the end site that it serves.  If the ITE allows IPv4 fragmentation on
   the encapsulated packets, persistent fragmentation could lead to
   undetected data corruption due to Identification field wrapping.  If
   the ITE instead uses classical IPv4 path MTU discovery, it may be
   inconvenienced by excessive ICMP error messages coming from the
   subnetwork that may be either suspect or contain insufficient
   information for translation into error messages to be returned to the
   original sources.

   Although recent works have led to the development of a robust end-to-
   end MTU determination scheme [RFC4821], they do not excuse tunnels
   from delivering path MTU discovery feedback when packets are lost due
   to size restrictions.  Moreover, in current practice existing
   tunneling protocols mask the MTU issues by selecting a "lowest common
   denominator" MTU that may be much smaller than necessary for most



Templin                  Expires April 30, 2012                 [Page 5]

Internet-Draft                    SEAL                      October 2011


   paths and difficult to change at a later date.  Therefore, a new
   approach to accommodate tunnels over links with diverse MTUs is
   necessary.

1.2.  Approach

   For the purpose of this document, a subnetwork is defined as a
   virtual topology configured over a connected network routing region
   and bounded by encapsulating border nodes.  Example connected network
   routing regions include Mobile Ad hoc Networks (MANETs), enterprise
   networks and the global public Internet itself.  Subnetwork border
   nodes forward unicast and multicast packets over the virtual topology
   across multiple IP and/or sub-IP layer forwarding hops that may
   introduce packet duplication and/or traverse links with diverse
   Maximum Transmission Units (MTUs).

   This document introduces a Subnetwork Encapsulation and Adaptation
   Layer (SEAL) for tunneling network layer protocols (e.g., IP, OSI,
   etc.) over IP subnetworks that connect Ingress and Egress Tunnel
   Endpoints (ITEs/ETEs) of border nodes.  It provides a modular
   specification designed to be tailored to specific associated
   tunneling protocols.  A transport-mode of operation is also possible,
   and described in Appendix C.

   SEAL provides a minimal mid-layer encapsulation that accommodates
   links with diverse MTUs and allows routers in the subnetwork to
   perform efficient duplicate packet detection.  The encapsulation
   further ensures packet header integrity, data origin authentication
   and anti-replay [I-D.ietf-savi-framework][RFC4302].

   SEAL treats tunnels that traverse the subnetwork as ordinary links
   that must support network layer services.  Moreover, SEAL provides
   dynamic mechanisms to ensure a maximal per-destination path MTU over
   the tunnel.  This is in contrast to static approaches which avoid MTU
   issues by selecting a lowest common denominator MTU value that may be
   overly conservative for the vast majority of tunnel paths and
   difficult to change even when larger MTUs become available.

   The following sections provide the SEAL normative specifications,
   while the appendices present non-normative additional considerations.


2.  Terminology and Requirements

   The following terms are defined within the scope of this document:






Templin                  Expires April 30, 2012                 [Page 6]

Internet-Draft                    SEAL                      October 2011


   subnetwork
      a virtual topology configured over a connected network routing
      region and bounded by encapsulating border nodes.

   Ingress Tunnel Endpoint
      a virtual interface over which an encapsulating border node (host
      or router) sends encapsulated packets into the subnetwork.

   Egress Tunnel Endpoint
      a virtual interface over which an encapsulating border node (host
      or router) receives encapsulated packets from the subnetwork.

   inner packet
      an unencapsulated network layer protocol packet (e.g., IPv6
      [RFC2460], IPv4 [RFC0791], OSI/CLNP [RFC1070], etc.) before any
      outer encapsulations are added.  Internet protocol numbers that
      identify inner packets are found in the IANA Internet Protocol
      registry [RFC3232].

   outer IP packet
      a packet resulting from adding an outer IP header (and possibly
      other outer headers) to a SEAL-encapsulated inner packet.

   packet-in-error
      the leading portion of an invoking data packet encapsulated in the
      body of an error control message (e.g., an ICMPv4 [RFC0792] error
      message, an ICMPv6 [RFC4443] error message, etc.).

   Packet Too Big (PTB)
      a control plane message indicating an MTU restriction (e.g., an
      ICMPv6 "Packet Too Big" message [RFC4443], an ICMPv4
      "Fragmentation Needed" message [RFC0792], etc.).

   IP
      used to generically refer to either IP protocol version, i.e.,
      IPv4 or IPv6.

   The following abbreviations correspond to terms used within this
   document and/or elsewhere in common Internetworking nomenclature:

      DF - the IPv4 header "Don't Fragment" flag [RFC0791]

      ETE - Egress Tunnel Endpoint

      HLEN - the length of the SEAL header plus outer headers

      ICV - Integrity Check Vector




Templin                  Expires April 30, 2012                 [Page 7]

Internet-Draft                    SEAL                      October 2011


      ITE - Ingress Tunnel Endpoint

      MTU - Maximum Transmission Unit

      SCMP - the SEAL Control Message Protocol

      SDU - SCMP Destination Unreachable message

      SNA - SCMP Neighbor Advertisement message

      SNS - SCMP Neighbor Solicitation message

      SPP - SCMP Parameter Problem message

      SPTB - SCMP Packet Too Big message

      SEAL - Subnetwork Encapsulation and Adaptation Layer

      SEAL_PORT - a transport-layer service port number used for SEAL

      SEAL_PROTO - an IPv4 protocol number used for SEAL

      TE - Tunnel Endpoint (i.e., either ingress or egress)

      VET - Virtual Enterprise Traversal

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].  When used
   in lower case (e.g., must, must not, etc.), these words MUST NOT be
   interpreted as described in [RFC2119], but are rather interpreted as
   they would be in common English.


3.  Applicability Statement

   SEAL was originally motivated by the specific case of subnetwork
   abstraction for Mobile Ad hoc Networks (MANETs), however the domain
   of applicability also extends to subnetwork abstractions over
   enterprise networks, ISP networks, SOHO networks, the global public
   Internet itself, and any other connected network routing region.
   SEAL along with the Virtual Enterprise Traversal (VET)
   [I-D.templin-intarea-vet] tunnel virtual interface abstraction are
   the functional building blocks for the Internet Routing Overlay
   Network (IRON) [I-D.templin-ironbis] and Routing and Addressing in
   Networks with Global Enterprise Recursion (RANGER) [RFC5720][RFC6139]
   architectures.




Templin                  Expires April 30, 2012                 [Page 8]

Internet-Draft                    SEAL                      October 2011


   SEAL provides a network sublayer for encapsulation of an inner
   network layer packet within outer encapsulating headers.  SEAL can
   also be used as a sublayer within a transport layer protocol data
   payload, where transport layer encapsulation is typically used for
   Network Address Translator (NAT) traversal as well as operation over
   subnetworks that give preferential treatment to certain "core"
   Internet protocols (e.g., TCP, UDP, etc.).  The SEAL header is
   processed the same as for IPv6 extension headers, i.e., it is not
   part of the outer IP header but rather allows for the creation of an
   arbitrarily extensible chain of headers in the same way that IPv6
   does.

   To accommodate MTU diversity, the Egress Tunnel Endpoint (ETE) acts
   as a passive observer that simply informs the Ingress Tunnel Endpoint
   (ITE) of any packet size limitations.  This allows the ITE to return
   appropriate path MTU discovery feedback even if the network path
   between the ITE and ETE filters ICMP messages.

   SEAL further ensures data origin authentication
   [I-D.ietf-savi-framework], packet header integrity, and anti-replay.
   The SEAL framework resembles a lightweight version of the IP Security
   (IPsec) [RFC4301] Authentication Header (AH) [RFC4302], however its
   purpose is to provide minimal hop-by-hop authenticating services
   along a path while leaving full data integrity, authentication and
   confidentiality services as an end-to-end consideration.

   SEAL supports both "nested" tunneling and "re-encapsulating"
   tunneling.  Nested tunneling occurs when a first tunnel is
   encapsulated within a second tunnel, which may then further be
   encapsulated within a third tunnel, etc.  Nested tunneling can be
   useful, and stands in contrast to "recursive" tunneling which is an
   anomalous condition incurred due to misconfiguration or a routing
   loop.  Considerations for nested tunneling are discussed in Section 4
   of [RFC2473].

   Re-encapsulating tunneling occurs when a packet emerges from a first
   ETE, which then acts as an ITE to re-encapsulate and forward the
   packet to a second ETE connected to the same subnetwork.  In that
   case each ITE/ETE transition represents a segment of a bridged path
   between the ITE nearest the source and the ETE nearest the
   destination.  Combinations of nested and re-encapsulating tunneling
   are also naturally supported by SEAL.


4.  SEAL Specification

   The following sections specify the operation of SEAL:




Templin                  Expires April 30, 2012                 [Page 9]

Internet-Draft                    SEAL                      October 2011


4.1.  VET Interface Model

   SEAL is an encapsulation sublayer used within VET non-broadcast,
   multiple access (NBMA) tunnel virtual interfaces.  Each VET interface
   connects an ITE to one or more ETE "neighbors" via tunneling across
   an underlying subnetwork.  The tunnel neighbor relationship between
   the ITE and each ETE may be either unidirectional or bidirectional.

   A unidirectional tunnel neighbor relationship allows the near end ITE
   to send data packets forward to the far end ETE, while the ETE only
   returns control messages when necessary.  A bidirectional tunnel
   neighbor relationship is one over which both TEs can exchange both
   data and control messages.

   Implications of the VET unidirectional and bidirectional models are
   discussed in [I-D.templin-intarea-vet].

4.2.  SEAL Model of Operation

   SEAL-enabled ITEs encapsulate each inner packet in a SEAL header, any
   outer header encapsulations, and in some instances a SEAL trailer as
   shown in Figure 1:

                                +--------------------+
                                ~   outer IP header  ~
                                +--------------------+
                                ~  other outer hdrs  ~
                                +--------------------+
                                ~    SEAL Header     ~
   +--------------------+       +--------------------+
   |                    |  -->  |                    |
   ~        Inner       ~  -->  ~        Inner       ~
   ~       Packet       ~  -->  ~       Packet       ~
   |                    |  -->  |                    |
   +--------------------+       +--------------------+
                                |    SEAL Trailer    |
                                +--------------------+

                       Figure 1: SEAL Encapsulation

   The ITE inserts the SEAL header according to the specific tunneling
   protocol.  For simple encapsulation of an inner network layer packet
   within an outer IP header (e.g.,
   [RFC1070][RFC2003][RFC2473][RFC4213], etc.), the ITE inserts the SEAL
   header between the inner packet and outer IP headers as: IP/SEAL/
   {inner packet}.

   For encapsulations over transports such as UDP (e.g., in the same



Templin                  Expires April 30, 2012                [Page 10]

Internet-Draft                    SEAL                      October 2011


   manner as for [RFC4380]), the ITE inserts the SEAL header between the
   outer transport layer header and the inner packet, e.g., as IP/UDP/
   SEAL/{inner packet}.  (Here, the UDP header is seen as an "other
   outer header" as depicted in Figure 1.)

   Finally, in some instances the ITE appends a SEAL trailer at the end
   of the SEAL packet.  In that case, the trailer is added after the
   final byte of the encapsulated packet, and need not be aligned on an
   even byte boundary.

   The following sections specify the SEAL header format and SEAL-
   related operations of the ITE and ETE.

4.3.  SEAL Header Format

   The SEAL header is formatted as follows:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |VER|C|A|R|F|P|X|     NEXTHDR   |    PREFLEN    | LINK_ID |LEVEL|
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             PKT_ID                            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                              ICV1                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ~                      PREFIX (when present)                    ~
      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

                       Figure 2: SEAL Header Format

   where the header fields are defined as:

   VER (2)
      a 2-bit version field.  This document specifies Version 0 of the
      SEAL protocol, i.e., the VER field encodes the value 0.

   C (1)
      the "Control/Data" bit.  Set to 1 by the ITE in SEAL Control
      Message Protocol (SCMP) control messages, and set to 0 in ordinary
      data packets.

   A (1)
      the "Acknowledgement Requested" bit.  Set to 1 by the ITE in SEAL
      data packets for which it wishes to receive an explicit
      acknowledgement from the ETE.





Templin                  Expires April 30, 2012                [Page 11]

Internet-Draft                    SEAL                      October 2011


   R (1)
      the "Redirects Permitted" bit.  For data packets, set to 1 by the
      ITE to inform the ETE that the source is accepting Redirects (see:
      [I-D.templin-intarea-vet]).

   F (1)
      the "Fragmentation Needed" bit.  Set to 1 if the ITE was obliged
      to perform outer fragmentation before sending the packet.

   P (1)
      the "Prefix Included" bit.  Set to 1 if the header includes a
      Prefix Field.  Used for SCMP messages that do not include a
      packet-in-error (see: [I-D.templin-intarea-vet]), and for NULL
      SEAL data packets used as probes (see: Section 4.4.6).

   X (1)
      the "Reserved" bit.  Must be set to 0 for this version of the SEAL
      specification.

   NEXTHDR (8)  an 8-bit field that encodes the next header Internet
      Protocol number the same as for the IPv4 protocol and IPv6 next
      header fields.

   PREFLEN (8)  an 8-bit field that encodes the length of the prefix to
      be applied to the source address of inner packets.

   LINK_ID (5)
      an 5-bit link identification value, set to a unique value by the
      ITE for each underlying link over which it will send encapsulated
      packets to ETEs.  Up to 32 underlying links are therefore
      supported.

   LEVEL (3)
      an 3-bit nesting level; use to limit the number of nestings of
      tunnels-within-tunnels.  Set to an integer value up to 7 in the
      initial SEAL encapsulation, and decremented by 1 for each
      successive additional SEAL encapsulation nesting level.  Up to 8
      levels of nesting are therefore supported.

   PKT_ID (32)
      a 32-bit per-packet identification field.  Set to a monotonically-
      incrementing 32-bit value for each SEAL packet transmitted to this
      ETE, beginning with 0.

   ICV1 (32)
      a 32-bit header integrity check value that covers the leading 128
      bytes of the packet beginning with the SEAL header.  The value 128
      is chosen so that at least the SEAL header as well as the inner



Templin                  Expires April 30, 2012                [Page 12]

Internet-Draft                    SEAL                      October 2011


      packet network and transport layer headers are covered by the
      integrity check.

   PREFIX (variable)
      a variable-length string of bytes; present only when P=1.  The
      length is found by determining the equation Len=(Ceiling(PREFLEN /
      32) * 4).  For example, if PREFLEN=63, the Prefix field is 8 bytes
      in length.  The Prefix field encodes an inner network layer prefix
      beginning with the most significant bit, and with zero-padding in
      the least significant bits when PREFLEN is not properly divisible
      by 32.

4.4.  SEAL Trailer Format

   The SEAL trailer is formatted as follows:

        0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                              ICV2                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                       Figure 3: SEAL Trailer Format

   When present, the trailer includes a single 32-bit field formatted as
   follows:

   ICV22 (32)
      a 32-bit packet body integrity check value.  Present only when
      F=1, and covers the remaining length of the encapsulated packet
      beyond the leading 128 bytes (i.e., the remaining portion that was
      not covered by ICV1).  Added as a trailing 32 bit field following
      the final byte of the encapsulated SEAL packet.  Need not be
      aligned on an even byte boundary.

4.5.  ITE Specification

4.5.1.  Tunnel Interface Soft State

   The ITE maintains a per-ETE integrity check vector (ICV) calculation
   algorithm and a symmetric secret key to verify the ICV(s) in received
   packets.  The ITE also maintains a window of PKT_ID values for the
   packets it has recently sent to this ETE.  Finally, for each
   underlying link of each ETE, the ITE maintains a boolean variable
   "USE_MIN_MTU" initialized to "FALSE".  (The ITE may maintain
   USE_MIN_MTU as a per-ETE instead of a per-link value, but in that
   case a lowest-common-denominator MTU value may be chosen.)




Templin                  Expires April 30, 2012                [Page 13]

Internet-Draft                    SEAL                      October 2011


4.5.2.  Tunnel Interface MTU

   The tunnel interface must present a constant MTU value to the inner
   network layer as the size for admission of inner packets into the
   interface.  Since VET NBMA tunnel virtual interfaces may support a
   large set of ETEs that accept widely varying maximum packet sizes,
   however, a number of factors should be taken into consideration when
   selecting a tunnel interface MTU.

   Due to the ubiquitous deployment of standard Ethernet and similar
   networking gear, the nominal Internet cell size has become 1500
   bytes; this is the de facto size that end systems have come to expect
   will either be delivered by the network without loss due to an MTU
   restriction on the path or a suitable ICMP Packet Too Big (PTB)
   message returned.  When large packets sent by end systems incur
   additional encapsulation at an ITE, however, they may be dropped
   silently within the tunnel since the network may not always deliver
   the necessary PTBs [RFC2923].

   The ITE should therefore set a tunnel interface MTU of at least 1500
   bytes plus extra room to accommodate any additional encapsulations
   that may occur on the path from the original source.  The ITE can
   also set smaller MTU values; however, care must be taken not to set
   so small a value that original sources would experience an MTU
   underflow.  In particular, IPv6 sources must see a minimum path MTU
   of 1280 bytes, and IPv4 sources should see a minimum path MTU of 576
   bytes.

   The ITE can alternatively set an indefinite MTU on the tunnel
   interface such that all inner packets are admitted into the interface
   without regard to size.  For ITEs that host applications that use the
   tunnel interface directly, this option must be carefully coordinated
   with protocol stack upper layers since some upper layer protocols
   (e.g., TCP) derive their packet sizing parameters from the MTU of the
   outgoing interface and as such may select too large an initial size.
   This is not a problem for upper layers that use conservative initial
   maximum segment size estimates and/or when the tunnel interface can
   reduce the upper layer's maximum segment size, e.g., by reducing the
   size advertised in the MSS option of outgoing TCP messages (sometimes
   known as "MSS clamping").

   The inner network layer protocol consults the tunnel interface MTU
   when admitting a packet into the interface.  For non-SEAL inner IPv4
   packets with the IPv4 Don't Fragment (DF) bit set to 0, if the packet
   is larger than the tunnel interface MTU the inner IPv4 layer uses
   IPv4 fragmentation to break the packet into fragments no larger than
   the tunnel interface MTU.  The ITE then admits each fragment into the
   interface as an independent packet.



Templin                  Expires April 30, 2012                [Page 14]

Internet-Draft                    SEAL                      October 2011


   For all other inner packets, the inner network layer admits the
   packet if it is no larger than the tunnel interface MTU; otherwise,
   it drops the packet and sends a PTB error message to the source with
   the MTU value set to the tunnel interface MTU.  The message contains
   as much of the invoking packet as possible without the entire message
   exceeding the network layer minimum MTU (e.g., 576 bytes for IPv4,
   1280 bytes for IPv6, etc.).

   In light of the above considerations, the ITE SHOULD configure an
   indefinite MTU on tunnel *router* interfaces.  The ITE MAY instead
   set a finite MTU on tunnel *host* interfaces.

4.5.3.  Submitting Packets for Encapsulation

   For each inner packet, if the packet is itself a SEAL packet (i.e.,
   one with either SEAL_PROTO in the IP protocol/next-header field, or
   with SEAL_PORT in the transport layer destination port field) and the
   LEVEL field of the SEAL header contains the value 0, the ITE discards
   the inner packet and treats it as an auditable indication of
   excessive nesting.

   Otherwise, the ITE calculates HLEN as the sum of the lengths of the
   SEAL header plus outer transport and network layer headers that will
   be used for encapsulation of the inner packet.  The ITE must include
   the length of the uncompressed outer headers when calculating HLEN
   even if the tunnel is using header compression.  The ITE next sets
   the variable "EMTU" to the MTU of the underlying link minus HLEN.  If
   EMTU is less than 1280, the ITE also sets the boolean variable
   USE_MIN_MTU for this ETE link path to TRUE.  The ITE then prepares
   the inner packet for encapsulation according to its length.

   For IPv4 inner packets with DF=0 in the IPv4 header, if the packet is
   not the first fragment of a SEAL data packet (i.e., not a SEAL packet
   with Offset=0 in the IPv4 header and with C=0 in the SEAL header) the
   ITE fragments the packet into inner fragments no larger than the
   minimum of EMTU and 512 bytes.  The ITE then submits each inner
   fragment for SEAL encapsulation as specified in Section 4.5.4.

   For all other inner packets, if the packet is no larger than EMTU the
   ITE submits it for SEAL encapsulation; otherwise the ITE processes it
   further according to its size.  If the packet is no larger than 1280
   bytes, the ITE submits it for SEAL encapsulation.  Otherwise, the ITE
   sends a PTB message toward the source address of the inner packet.

   To send the PTB message, the ITE first checks its forwarding tables
   to discover the previous hop toward the source address of the inner
   packet.  If the previous hop is reached via the same tunnel
   interface, the ITE sends an SCMP PTB (SPTB) message to the previous



Templin                  Expires April 30, 2012                [Page 15]

Internet-Draft                    SEAL                      October 2011


   hop with the MTU field set to EMTU (see: Section 4.7.1).  Otherwise,
   the ITE prepares an ordinary PTB message appropriate to the inner
   protocol version.

   When preparing the PTB message, the ITE sets the MTU field to EMTU
   the same as for an SPTB message.  When the inner packet is an IPv4
   packet that includes the first fragment of a SEAL data packet, the
   ITE first sets DF=1 in the inner header then re-calculates the inner
   header checksum before generating the PTB.

   After sending the (S)PTB message, the ITE discards the inner packet.

4.5.4.  SEAL Encapsulation

   The ITE next encapsulates the inner packet in a SEAL header formatted
   as specified in Section 4.3.  The ITE sets NEXTHDR to the Internet
   Protocol number corresponding to the encapsulated inner packet.  For
   example, the ITE sets NEXTHDR to the value '4' for encapsulated IPv4
   packets [RFC2003], the value '41' for encapsulated IPv6 packets
   [RFC2473][RFC4213], the value '80' for encapsulated OSI/CLNP packets
   [RFC1070], etc.

   The ITE then sets R=1 if redirects are permitted (see:
   [I-D.templin-intarea-vet]) and sets PREFLEN to the length of the
   prefix to be applied to the inner source address.  The ITE's claimed
   PREFLEN is subject to verification by the ETE; hence, the ITE MUST
   set PREFLEN to the exact prefix length that it is authorized to use.
   (Note that if this process is entered via re-encapsulation (see:
   Section 4.6.4), PREFLEN and R are instead copied from the SEAL header
   of the re-encapsulated packet.  This implies that the PREFLEN and R
   values are propagated across a re-encapsulating chain of ITE/ETEs
   that must all be authorized to represent the prefix.)

   The ITE next sets C=0, P=0 and sets A=1 if an explicit
   acknowledgement is required from the ETE (see: Section 4.5.6).  The
   ITE then sets LINK_ID to the value assigned to the underlying link
   and sets PKT_ID to a monotonically-increasing integer value,
   beginning with the value 0 in the first packet transmitted to this
   ETE.

   Next, if the inner packet is not itself a SEAL packet the ITE sets
   LEVEL to an integer value between 0 and 7 as a specification of the
   number of additional layers of nested SEAL encapsulations permitted.
   Otherwise, the ITE sets LEVEL to the value that appears in the inner
   packet's SEAL header minus 1.  If the inner packet is no larger than
   1280 and the variable USE_MIN_MTU for this ETE link path is TRUE, the
   ITE then sets F=1; otherwise, it sets F=0.




Templin                  Expires April 30, 2012                [Page 16]

Internet-Draft                    SEAL                      October 2011


   The ITE finally sets ICV1 and ICV2 (when F=1) to 0 and calculates the
   ICVs over the packet beginning with the SEAL header and leading
   portion of the inner packet.  The ICVs are calculated using an
   algorithm agreed on by the ITE and ETE.  The algorithm uses a
   symmetric secret key so that the ETE can verify that the ICVs were
   generated by the ITE.

   The ITE first calculates the ICV value over the leading 128 bytes of
   the packet beginning with the SEAL header (or up to the end of the
   packet if there are fewer than 128 bytes) then places result in the
   ICV1 field in the header.  If F=1, and if the packet includes more
   than 128 bytes beginning with the SEAL header, the ITE next
   calculates the ICV over the remainder of the packet beyond the
   leading 128 bytes and places the result in the ICV2 field in the SEAL
   trailer.  The ITE then submits the packet for outer encapsulation.

4.5.5.  Outer Encapsulation

   Following SEAL encapsulation, the ITE next encapsulates the packet in
   the requisite outer headers according to the specific encapsulation
   format (e.g., [RFC1070], [RFC2003], [RFC2473], [RFC4213], etc.),
   except that it writes 'SEAL_PROTO' in the protocol field of the outer
   IP header (when simple IP encapsulation is used) or writes
   'SEAL_PORT' in the outer destination transport service port field
   (e.g., when IP/UDP encapsulation is used).

   When UDP encapsulation is used, the ITE sets the UDP header fields as
   specified in Section 5.5.4 of [I-D.templin-intarea-vet].  The ITE
   then performs outer IP header encapsulation as specified in Section
   5.5.5 of [I-D.templin-intarea-vet].  If this process is entered via
   re-encapsulation (see: Section 4.6.4), the ITE instead follows the
   outer IP/UDP re-encapsulation procedures specified in Section 5.5.6
   of [I-D.templin-intarea-vet].

   When IPv4 is used as the outer encapsulation layer, the ITE sets DF=0
   in the IPv4 header if the ETE correctly implements IP fragmentation
   (see: Section 4.5.6); otherwise, it sets DF=1.

   When IPv6 is used as the outer encapsulation layer, the "DF" flag is
   absent but implicitly set to 1.  The packet therefore will not be
   fragmented within the subnetwork, since IPv6 deprecates in-the-
   network fragmentation.

   Next, if the SEAL header has F=1 the ITE uses IP fragmentation if
   necessary to fragment it into outer IP fragments that are no larger
   than (EMTU + HLEN).  During fragmentation, the ITE should fragment
   the packet into fragments of approximately equal length, i.e.,
   instead of causing the first fragment to be approximately MTU-sized.



Templin                  Expires April 30, 2012                [Page 17]

Internet-Draft                    SEAL                      October 2011


   The ITE then sends each outer packet via the underlying link
   corresponding to LINK_ID.

4.5.6.  Probing Strategy

   The ITE can perform a qualification exchange over an underlying link
   to ensure that the subnetwork path to the ETE correctly delivers IP
   fragments.  This procedure could be employed, e.g., to determine
   whether there are middleboxes on the path that violate the [RFC1812],
   Section 5.2.6 requirement that: "A router MUST NOT reassemble any
   datagram before forwarding it".

   To perform this qualification, the ITE constructs a NULL SEAL data
   packet to be used as a probe.  The ITE sets (C=0; A=1; R=0; F=0; P=1)
   in the SEAL header, writes the length of the ITE's claimed prefix in
   the PREFLEN field, and writes the ITE's claimed prefix in the PREFIX
   field.  The ITE then sets NEXTHDR to the value '4' for an IPv4
   prefix, the value '41' for an IPv6 prefix , the value '80' for an
   OSI/CLNP prefix, etc.  The ITE can further add padding following the
   SEAL header to a length that would not cause the size of the packet
   to exceed 512 bytes before outer encapsulation.  The ITE then sets
   PKT_ID to an appropriate value for this ETE, calculates the ICV over
   the first 128 bytes of the packet beginning with the SEAL header, and
   writes the value in the ICV1 field.

   Next, the ITE encapsulates the packet in the appropriate outer
   headers, splits it into two outer IP fragments, then sends both
   fragments to the ETE over the same underlying link.  If the ETE
   returns an SCMP PTB message with a non-zero MTU (see Section
   4.7.1.1), then the subnetwork path correctly delivers IP fragments.
   If the ETE returns an SCMP PTB message with MTU=0, however, then a
   middlebox in the subnetwork is reassembling the fragments before they
   are delivered to the ETE [RFC1812].

   In addition to any control plane probing, all SEAL data packets sent
   from the ITE to the ETE are considered implicit probes.  SEAL data
   packets will elicit SPTB messages from the ETE if any outer IP
   fragmentation occurs in the path.  SEAL data packets that are too
   large may also be dropped by a router on the path, which will return
   an ICMP PTB message.

   The ITE should also send explicit probes, periodically, to verify
   that the ETE is still reachable.  The ITE sets A=1 in the SEAL header
   of a data packet to be used as an explicit probe.  The probe will
   elicit an SPTB message with MTU=0 from the ETE as an acknowledgement
   (see Section 4.7.1.1).  The ITE can also send an SCMP Neighbor
   Solicitation (SNS) message to elicit an SCMP Neighbor Advertisement
   (SNA) response from the ETE when there are no convenient data packets



Templin                  Expires April 30, 2012                [Page 18]

Internet-Draft                    SEAL                      October 2011


   to use as explicit probes (see: [I-D.templin-intarea-vet].

   The ITE processes ICMP PTB messages as specified in Section 4.5.7.
   The ITE processes SCMP messages as specified in Section 4.7.2.

4.5.7.  Processing ICMP Messages

   When the ITE sends SEAL packets, it may receive raw ICMP error
   messages[RFC0792][RFC4443] from either the ETE or from a router
   within the subnetwork.  Each ICMP message includes an outer IP
   header, followed by an ICMP header, followed by a portion of the SEAL
   data packet that generated the error (also known as the "packet-in-
   error") beginning with the outer IP header.

   The ITE should process raw ICMPv4 Protocol Unreachable messages and
   ICMPv6 Parameter Problem messages with Code "Unrecognized Next Header
   type encountered" as a hint that the ETE does not implement the SEAL
   protocol.  The ITE can also process other raw ICMP messages that do
   not include sufficient information in the packet-in-error as a hint
   that the path to the ETE may be failing.  Specific actions that the
   ITE may take in these cases are out of scope.

   For other ICMP messages, the ITE examines the packet-in-error
   beginning with the SEAL header.  If the value in the SEAL header ICV1
   field is incorrect and/or the value in the PKT_ID field is not within
   the window of packets the ITE has recently sent to this ETE, the ITE
   discards the message.

   Next, the ITE processes the ICMP message if there is operational
   assurance that it has not been crafted by a malicious middlebox
   (e.g., if the source of the ICMP message is within the same
   administrative domain as the ITE).  If the received ICMP message is a
   PTB, and the MTU field encodes a non-zero value, the ITE deducts the
   length of the outer IP headers and SEAL header of the packet-in-error
   from the MTU value.  If the resulting MTU value is less than 1280,
   the ITE marks the ETE link path as USE_MIN_MTU and discards the ICMP
   message.

   Otherwise, the ITE transcribes the ICMP message into a message to
   return to the previous hop.  If the previous hop toward the inner
   source address is reached via the same tunnel interface the SEAL data
   packet was sent on, the ITE transcribes the ICMP message into an SCMP
   message (see: Section 4.7.1) and forwards it to the previous hop.
   Otherwise, the ITE transcribes the ICMP message into a message
   appropriate for the inner protocol version and forwards it to the
   inner source address.

   To transcribe the message, the ITE extracts the inner packet from



Templin                  Expires April 30, 2012                [Page 19]

Internet-Draft                    SEAL                      October 2011


   within the ICMP message packet-in-error field and generates a new
   SCMP/ICMP message corresponding to the type of the received ICMP
   message.

4.6.  ETE Specification

4.6.1.  Tunnel Interface Soft State

   The ETE maintains a per-ITE ICV calculation algorithm and a symmetric
   secret key to verify the ICVs in the SEAL header and trailer.  The
   ETE also maintains a window of PKT_ID values for the packets it has
   recently received from this ITE.

4.6.2.  Reassembly Buffer Requirements

   The ETE must maintain a minimum IP reassembly buffer size of 1500
   bytes for both IPv4 [RFC0791] and IPv6 [RFC2460].  The ETE must also
   be capable of partially reassembling and delivering at least the
   leading 1280 byte portion of the inner packet even if the completely
   reassembled packet would exceed that size.

   The ETE should maintain conservative IP-layer reassembly cache high-
   and low-water marks.  When the size of the reassembly cache exceeds
   this high-water mark, the ETE should actively discard stale
   incomplete reassemblies (e.g., using an Active Queue Management (AQM)
   strategy) until the size falls below the low-water mark.  The ETE
   should also actively discard any pending reassemblies that clearly
   have no opportunity for completion, e.g., when a considerable number
   of new fragments have arrived before a fragment that completes a
   pending reassembly arrives.

4.6.3.  IP-Layer Reassembly

   The ETE processes non-SEAL IP packets as specified in the normative
   references, i.e., it performs any necessary IP reassembly then
   delivers the (reassembled) packet to the appropriate upper layer
   protocol.

   For each SEAL packet received, if the packet did not undergo outer IP
   fragmentation the ETE submits it for decapsulation as specified in
   Section 4.6.4.  Otherwise, the ETE gathers the outer IP fragments of
   the SEAL packet until it has received at least the first 1280 bytes
   beyond the SEAL header or up to the end of the packet.

   The ETE then examines the SEAL header within this (partially)
   reassembled SEAL packet.  If the PKT_ID value is not acceptable for
   this ITE, or if the value in the ICV1 field is incorrect, the ETE
   silently discards the packet.  Otherwise, the ETE processes the



Templin                  Expires April 30, 2012                [Page 20]

Internet-Draft                    SEAL                      October 2011


   packet further according to the F bit.

   If the SEAL header has F=0, the ETE sends an SPTB message back to the
   ITE (see Section 4.7.1.1) with MTU set to the size of the IP first
   fragment.

   Next, if the inner packet is larger than 1280 bytes the ETE silently
   discards the packet regardless of the F bit setting.

   Finally, if the SEAL header has F=1 and the packet contains more than
   128 beginning with the SEAL header, the ETE verifies the ICV2 value
   over the remainder of the packet and silently discards the packet if
   the value is incorrect.

   If the reassembled SEAL packet has not been discarded, the ETE
   finally submits it for decapsulation.

4.6.4.  Decapsulation and Re-Encapsulation

   For each SEAL packet submitted for decapsulation, if the packet did
   not undergo the integrity checks specified in Section 4.6.4 the ETE
   examines the PKT_ID and ICV fields.  If the PKT_ID is not within the
   window of acceptable values from this ITE, or if an ICV field
   includes an incorrect value, the ETE silently discards the packet.

   Next, if the SEAL header has C=1 the ETE processes the packet as an
   SCMP packet as specified in Section 4.7.2.  Otherwise the ETE process
   the packet as a SEAL data packet as follows.

   If there is an incorrect value in a SEAL header field, the returns an
   SCMP "Parameter Problem" (SPP) message (see Section 4.7.1.2) then
   discards the packet.  Otherwise, if the SEAL header has A=1 the ETE
   next sends an SPTB message with MTU=0 back to the ITE (see Section
   4.7.1.1) but does not discard the packet.

   Thee ETE next discards the outer headers and processes the inner
   packet according to the header type indicated in the SEAL NEXTHDR
   field.  If the next hop toward the inner destination address is via a
   different interface than the SEAL packet arrived on, the ETE discards
   the SEAL header and delivers the inner packet either to the local
   host or to the next hop interface if the packet is not destined to
   the local host.

   If the next hop is on the same interface the SEAL packet arrived on,
   however, the ETE submits the packet for SEAL re-encapsulation
   beginning with the specification in Section 4.5.3 above.





Templin                  Expires April 30, 2012                [Page 21]

Internet-Draft                    SEAL                      October 2011


4.7.  The SEAL Control Message Protocol (SCMP)

   SEAL provides a companion SEAL Control Message Protocol (SCMP) that
   uses the same message types and formats as for the Internet Control
   Message Protocol for IPv6 (ICMPv6) [RFC4443].  When the TE prepares
   an SCMP message, it sets the Type and Code fields to the same values
   that would appear in the corresponding ICMPv6 message, but it does
   not calculate the SCMP message checksum.  The TE then formats the
   Message Body the same as for the corresponding ICMPv6 message.  The
   TE then encapsulates the SCMP message in the SEAL header and trailer
   as well as the outer headers as shown in Figure 4:

                                       +--------------------+
                                       ~   outer IP header  ~
                                       +--------------------+
                                       ~  other outer hdrs  ~
                                       +--------------------+
                                       ~    SEAL Header     ~
          +--------------------+       +--------------------+
          ~ SCMP message header~  -->  ~ SCMP message header~
          +--------------------+  -->  +--------------------+
          ~  SCMP message body ~  -->  ~  SCMP message body ~
          +--------------------+  -->  +--------------------+
                                       |    SEAL Trailer    |
                                       +--------------------+

               SCMP Message                  SCMP Packet
           before encapsulation          after encapsulation

                   Figure 4: SCMP Message Encapsulation

   The following sections specify the generation, processing and
   relaying of SCMP messages.

4.7.1.  Generating SCMP Error Messages

   ETEs generate SCMP error messages in response to receiving certain
   SEAL data packets using the format shown in Figure 5:













Templin                  Expires April 30, 2012                [Page 22]

Internet-Draft                    SEAL                      October 2011


       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Type      |     Code      |           Reserved            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                      Type-Specific Data                       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           As much of invoking SEAL data packet as             |
      ~    possible (beginning immediately after the SEAL header)     ~
      |        without the SCMP packet exceeding 576 bytes (*)        |

      (*) also known as the "packet-in-error"

                    Figure 5: SCMP Error Message Format

   The error message includes the 4 byte SCMP message header, followed
   by a 4 byte Type-Specific Data field, followed by the leading portion
   of the invoking SEAL data packet (beginning immediately after the
   SEAL header) as the "packet-in-error".  The packet-in-error includes
   as much of the leading portion of the invoking SEAL data packet as
   possible extending to a length that would not cause the entire SCMP
   packet following outer encapsulation to exceed 576 bytes.

   When the ETE processes a SEAL data packet for which the ICVs are
   correct but an error must be returned, it prepares an SCMP error
   message as shown in Figure 5.  The ETE sets the Type and Code fields
   in the SCMP header according to the appropriate error message type,
   sets the Reserved field to 0, fills out the Type-Specific Data field
   and includes the packet-in-error.

   The ETE next encapsulates the SCMP message in the requisite SEAL
   header, outer headers and SEAL trailer as shown in Figure 4.  During
   encapsulation, the ETE sets the outer destination address/port
   numbers of the SCMP packet to the outer source address/port numbers
   of the original SEAL data packet and sets the outer source address/
   port numbers to its own outer address/port numbers.

   The ETE then sets (C=1; A=0; R=0; F=1; P=0; NEXTHDR=0) in the SEAL
   header, then sets PREFLEN and LEVEL to the same values that appeared
   in the SEAL data packet header.  The ETE then writes the value 0 in
   the LINK_ID field and writes a value from within the current window
   for this ITE in the PKT_ID .

   The ETE then calculates and sets the ICV1 and ICV2 fields the same as
   specified for SEAL data packet encapsulation in Section 4.5.4 (the
   ETE instead omits the SEAL trailer if the SCMP message includes fewer
   than 128 bytes beyond the SEAL header).  Next, the ETE encapsulates
   the SCMP message in the requisite outer encapsulations the same as



Templin                  Expires April 30, 2012                [Page 23]

Internet-Draft                    SEAL                      October 2011


   specified for SEAL data packets in Section 4.5.5 (while performing
   outer fragmentation on the packet if necessary) then sends the
   resulting SCMP packet to the ITE.

   The following sections describe additional considerations for various
   SCMP error messages:

4.7.1.1.  Generating SCMP Packet Too Big (SPTB) Messages

   An ETE generates an SCMP "Packet Too Big" (SPTB) message when it
   receives a SEAL data packet that arrived as multiple outer IP
   fragments but for which F=0 in the SEAL header.  The ETE prepares the
   SPTB message the same as for the corresponding ICMPv6 PTB message,
   and writes the length of the outer IP first fragment (i.e., the
   fragment with MF=1 and Offset=0) in the MTU field of the message.

   The ETE also generates an SPTB message when it accepts a SEAL
   protocol data packet with A=1 in the SEAL header.  The ETE prepares
   the SPTB message the same as above, except that it writes the value 0
   in the MTU field.  The message is therefore a control plane
   acknowledgement of a data plane probe, and does not signify a packet
   size restriction.

4.7.1.2.  Generating Other SCMP Error Messages

   An ETE generates an SCMP "Destination Unreachable" (SDU) message
   under the same circumstances that an IPv6 system would generate an
   ICMPv6 Destination Unreachable message.

   An ETE generates an SCMP "Parameter Problem" (SPP) message when it
   receives a SEAL packet with an incorrect value in the SEAL header.
   IN THIS CASE ALONE, the ETE prepares the packet-in-error beginning
   with the SEAL header instead of beginning immediately after the SEAL
   header.

   TEs generate other SCMP message types using methods and procedures
   specified in other documents.  For example, SCMP message types used
   for tunnel neighbor coordinations are specified in VET
   [I-D.templin-intarea-vet].

4.7.2.  Processing SCMP Error Messages

   For each SCMP error message it receives, the ITE first verifies that
   the outer addresses of the SCMP packet are correct and that the
   PKT_ID is within its window of values for this ETE.  The ITE then
   verifies the ICV1 and ICV2 values.  If the identifying information
   and/or ICVs are incorrect, the ITE discards the message; otherwise,
   it processes the message as follows:



Templin                  Expires April 30, 2012                [Page 24]

Internet-Draft                    SEAL                      October 2011


4.7.2.1.  Processing SCMP PTB Messages

   After an ITE sends a SEAL data packet to an ETE, it may receive an
   SPTB message with a packet-in-error containing the leading portion of
   the inner packet (see: Section 4.7.1.1).  If the SPTB message has
   MTU=0, the ITE processes the message as confirmation that the ETE has
   accepted the packet indicated by the packet-in-error; the ITE then
   discards the SPTB message.  If the SPTB message is the response to a
   fragmented SNS message used for path qualification (see Section
   4.5.6), the ITE processes the message as a confirmation that the path
   supports IP fragmentation.  Otherwise, the ITE processes the message
   as an indication of a packet size limitation.

   If the MTU value in the SPTB message is less than 1280+HLEN, and the
   length of the inner packet within the packet-in-error is no larger
   than 1280, the ITE sets the boolean variable USE_MIN_MTU for this ETE
   link path to TRUE.  The ITE then discards the SPTB message.

   If the MTU value in the SPTB message is not substantially less that
   1500, the value is likely to represent the true MTU of the
   restricting link on the path to the ETE; otherwise, a router on the
   path may be generating runt first fragments.  In that case, the ITE
   can consult a plateau table (e.g., as described in [RFC1191]) to
   rewrite the MTU value to a reduced size.  For example, if the ITE
   receives an SPTB message with MTU=256 and inner header length 1500,
   it can rewrite the MTU to 1400.  If the ITE subsequently receives an
   SPTB message with MTU=256 and inner header length 1400, it can
   rewrite the MTU to 1300, etc.

   The ITE then checks its forwarding tables to determine the previous
   hop on the reverse path toward the source address of the inner packet
   in the packet-in-error.  If the previous hop is reached over a
   different interface than the SPTB message arrived on, the ITE
   transcribes the message into a format appropriate for the inner
   packet (i.e., the same as described for transcribing ICMP messages in
   Section 4.5.7) and sends the resulting transcribed message to the
   original source.

   If the previous hop is reached over the same tunnel interface that
   the SPTB message arrived on, the ITE instead relays the message to
   the previous hop.  In order to relay the message, the ITE rewrites
   the SEAL header fields with values corresponding to the previous hop.
   Next, the ITE replaces the SPTB's outer headers with headers of the
   appropriate protocol version and fills in the header fields as
   specified in Sections 5.5.4-5.5.6 of [I-D.templin-intarea-vet], where
   the destination address/port correspond to the previous hop and the
   source address/port correspond to the ITE.  The ITE then sends the
   message to the previous hop the same as if it were issuing a new SPTB



Templin                  Expires April 30, 2012                [Page 25]

Internet-Draft                    SEAL                      October 2011


   message.

4.7.2.2.  Processing Other SCMP Error Messages

   An ITE may receive an SDU message with an appropriate code under the
   same circumstances that an IPv6 node would receive an ICMPv6
   Destination Unreachable message.  The ITE either transcribes or
   relays the message toward the source address of the inner packet
   within the packet-in-error the same as specified for SPTB messages in
   Section 4.7.2.1.

   An ITE may receive an SPP message when the ETE receives a SEAL packet
   with an incorrect value in the SEAL header.  The ITE should examine
   the SEAL header within the packet-in-error to determine whether a
   different setting should be used in subsequent packets, but does not
   relay the message further.

   TEs process other SCMP message types using methods and procedures
   specified in other documents.  For example, SCMP message types used
   for tunnel neighbor coordinations are specified in VET
   [I-D.templin-intarea-vet].


5.  Link Requirements

   Subnetwork designers are expected to follow the recommendations in
   Section 2 of [RFC3819] when configuring link MTUs.


6.  End System Requirements

   End systems are encouraged to implement end-to-end MTU assurance
   (e.g., using Packetization Layer Path MTU Discovery per [RFC4821])
   even if the subnetwork is using SEAL.


7.  Router Requirements

   Routers within the subnetwork are expected to observe the router
   requirements found in the normative references, including the
   implementation of IP fragmentation and reassembly [RFC1812][RFC2460]
   as well as the generation of ICMP messages [RFC0792][RFC4443].


8.  IANA Considerations

   The IANA is instructed to allocate an IP protocol number for
   'SEAL_PROTO' in the 'protocol-numbers' registry.



Templin                  Expires April 30, 2012                [Page 26]

Internet-Draft                    SEAL                      October 2011


   The IANA is instructed to allocate a Well-Known Port number for
   'SEAL_PORT' in the 'port-numbers' registry.

   The IANA is instructed to establish a "SEAL Protocol" registry to
   record SEAL Version values.  This registry should be initialized to
   include the initial SEAL Version number, i.e., Version 0.


9.  Security Considerations

   SEAL provides a segment-by-segment data origin authentication and
   anti-replay service across the (potentially) multiple segments of a
   re-encapsulating tunnel.  It further provides a segment-by-segment
   integrity check of the headers of encapsulated packets, but does not
   verify the integrity of the rest of the packet beyond the headers
   unless fragmentation is unavoidable.  SEAL therefore considers full
   message integrity checking, authentication and confidentiality as
   end-to-end considerations in a manner that is compatible with
   securing mechanisms such as TLS/SSL [RFC5246].

   An amplification/reflection attack is possible when an attacker sends
   IP first fragments with spoofed source addresses to an ETE in an
   attempt to generate a stream of SCMP messages returned to a victim
   ITE.  The SCMP message ICVs, PKT_ID, as well as the inner headers of
   the packet-in-error, provide mitigation for the ETE to detect and
   discard SEAL segments with spoofed source addresses.

   The SEAL header is sent in-the-clear the same as for the outer IP and
   other outer headers.  In this respect, the threat model is no
   different than for IPv6 extension headers.  Unlike IPv6 extension
   headers, however, the SEAL header is protected by an integrity check
   that also covers the inner packet headers.

   Security issues that apply to tunneling in general are discussed in
   [RFC6169].


10.  Related Work

   Section 3.1.7 of [RFC2764] provides a high-level sketch for
   supporting large tunnel MTUs via a tunnel-level segmentation and
   reassembly capability to avoid IP level fragmentation.  This
   capability was implemented in the first edition of SEAL, but is now
   deprecated.

   Section 3 of [RFC4459] describes inner and outer fragmentation at the
   tunnel endpoints as alternatives for accommodating the tunnel MTU.




Templin                  Expires April 30, 2012                [Page 27]

Internet-Draft                    SEAL                      October 2011


   Section 4 of [RFC2460] specifies a method for inserting and
   processing extension headers between the base IPv6 header and
   transport layer protocol data.  The SEAL header is inserted and
   processed in exactly the same manner.

   IPsec/AH is [RFC4301][RFC4301] is used for full message integrity
   verification between tunnel endpoints, whereas SEAL only ensures
   integrity for the inner packet headers.  The AYIYA proposal
   [I-D.massar-v6ops-ayiya] uses similar means for providing full
   message authentication and integrity.

   The concepts of path MTU determination through the report of
   fragmentation and extending the IP Identification field were first
   proposed in deliberations of the TCP-IP mailing list and the Path MTU
   Discovery Working Group (MTUDWG) during the late 1980's and early
   1990's.  An historical analysis of the evolution of these concepts,
   as well as the development of the eventual path MTU discovery
   mechanism for IP, appears in Appendix D of this document.


11.  Acknowledgments

   The following individuals are acknowledged for helpful comments and
   suggestions: Jari Arkko, Fred Baker, Iljitsch van Beijnum, Oliver
   Bonaventure, Teco Boot, Bob Braden, Brian Carpenter, Steve Casner,
   Ian Chakeres, Noel Chiappa, Remi Denis-Courmont, Remi Despres, Ralph
   Droms, Aurnaud Ebalard, Gorry Fairhurst, Washam Fan, Dino Farinacci,
   Joel Halpern, Sam Hartman, John Heffner, Thomas Henderson, Bob
   Hinden, Christian Huitema, Eliot Lear, Darrel Lewis, Joe Macker, Matt
   Mathis, Erik Nordmark, Dan Romascanu, Dave Thaler, Joe Touch, Mark
   Townsley, Ole Troan, Margaret Wasserman, Magnus Westerlund, Robin
   Whittle, James Woodyatt, and members of the Boeing Research &
   Technology NST DC&NT group.

   Discussions with colleagues following the publication of RFC5320 have
   provided useful insights that have resulted in significant
   improvements to this, the Second Edition of SEAL.

   Path MTU determination through the report of fragmentation was first
   proposed by Charles Lynn on the TCP-IP mailing list in 1987.
   Extending the IP identification field was first proposed by Steve
   Deering on the MTUDWG mailing list in 1989.


12.  References






Templin                  Expires April 30, 2012                [Page 28]

Internet-Draft                    SEAL                      October 2011


12.1.  Normative References

   [RFC0791]  Postel, J., "Internet Protocol", STD 5, RFC 791,
              September 1981.

   [RFC0792]  Postel, J., "Internet Control Message Protocol", STD 5,
              RFC 792, September 1981.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2460]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", RFC 2460, December 1998.

   [RFC3971]  Arkko, J., Kempf, J., Zill, B., and P. Nikander, "SEcure
              Neighbor Discovery (SEND)", RFC 3971, March 2005.

   [RFC4443]  Conta, A., Deering, S., and M. Gupta, "Internet Control
              Message Protocol (ICMPv6) for the Internet Protocol
              Version 6 (IPv6) Specification", RFC 4443, March 2006.

   [RFC4861]  Narten, T., Nordmark, E., Simpson, W., and H. Soliman,
              "Neighbor Discovery for IP version 6 (IPv6)", RFC 4861,
              September 2007.

12.2.  Informative References

   [FOLK]     Shannon, C., Moore, D., and k. claffy, "Beyond Folklore:
              Observations on Fragmented Traffic", December 2002.

   [FRAG]     Kent, C. and J. Mogul, "Fragmentation Considered Harmful",
              October 1987.

   [I-D.ietf-intarea-ipv4-id-update]
              Touch, J., "Updated Specification of the IPv4 ID Field",
              draft-ietf-intarea-ipv4-id-update-04 (work in progress),
              September 2011.

   [I-D.ietf-savi-framework]
              Wu, J., Bi, J., Bagnulo, M., Baker, F., and C. Vogt,
              "Source Address Validation Improvement Framework",
              draft-ietf-savi-framework-05 (work in progress),
              July 2011.

   [I-D.massar-v6ops-ayiya]
              Massar, J., "AYIYA: Anything In Anything",
              draft-massar-v6ops-ayiya-02 (work in progress), July 2004.




Templin                  Expires April 30, 2012                [Page 29]

Internet-Draft                    SEAL                      October 2011


   [I-D.templin-aero]
              Templin, F., "Asymmetric Extended Route Optimization
              (AERO)", draft-templin-aero-04 (work in progress),
              October 2011.

   [I-D.templin-intarea-vet]
              Templin, F., "Virtual Enterprise Traversal (VET)",
              draft-templin-intarea-vet-27 (work in progress),
              October 2011.

   [I-D.templin-ironbis]
              Templin, F., "The Internet Routing Overlay Network
              (IRON)", draft-templin-ironbis-06 (work in progress),
              October 2011.

   [MTUDWG]   "IETF MTU Discovery Working Group mailing list,
              gatekeeper.dec.com/pub/DEC/WRL/mogul/mtudwg-log, November
              1989 - February 1995.".

   [RFC1063]  Mogul, J., Kent, C., Partridge, C., and K. McCloghrie, "IP
              MTU discovery options", RFC 1063, July 1988.

   [RFC1070]  Hagens, R., Hall, N., and M. Rose, "Use of the Internet as
              a subnetwork for experimentation with the OSI network
              layer", RFC 1070, February 1989.

   [RFC1191]  Mogul, J. and S. Deering, "Path MTU discovery", RFC 1191,
              November 1990.

   [RFC1812]  Baker, F., "Requirements for IP Version 4 Routers",
              RFC 1812, June 1995.

   [RFC1981]  McCann, J., Deering, S., and J. Mogul, "Path MTU Discovery
              for IP version 6", RFC 1981, August 1996.

   [RFC2003]  Perkins, C., "IP Encapsulation within IP", RFC 2003,
              October 1996.

   [RFC2473]  Conta, A. and S. Deering, "Generic Packet Tunneling in
              IPv6 Specification", RFC 2473, December 1998.

   [RFC2675]  Borman, D., Deering, S., and R. Hinden, "IPv6 Jumbograms",
              RFC 2675, August 1999.

   [RFC2764]  Gleeson, B., Heinanen, J., Lin, A., Armitage, G., and A.
              Malis, "A Framework for IP Based Virtual Private
              Networks", RFC 2764, February 2000.




Templin                  Expires April 30, 2012                [Page 30]

Internet-Draft                    SEAL                      October 2011


   [RFC2923]  Lahey, K., "TCP Problems with Path MTU Discovery",
              RFC 2923, September 2000.

   [RFC3232]  Reynolds, J., "Assigned Numbers: RFC 1700 is Replaced by
              an On-line Database", RFC 3232, January 2002.

   [RFC3366]  Fairhurst, G. and L. Wood, "Advice to link designers on
              link Automatic Repeat reQuest (ARQ)", BCP 62, RFC 3366,
              August 2002.

   [RFC3819]  Karn, P., Bormann, C., Fairhurst, G., Grossman, D.,
              Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L.
              Wood, "Advice for Internet Subnetwork Designers", BCP 89,
              RFC 3819, July 2004.

   [RFC4191]  Draves, R. and D. Thaler, "Default Router Preferences and
              More-Specific Routes", RFC 4191, November 2005.

   [RFC4213]  Nordmark, E. and R. Gilligan, "Basic Transition Mechanisms
              for IPv6 Hosts and Routers", RFC 4213, October 2005.

   [RFC4301]  Kent, S. and K. Seo, "Security Architecture for the
              Internet Protocol", RFC 4301, December 2005.

   [RFC4302]  Kent, S., "IP Authentication Header", RFC 4302,
              December 2005.

   [RFC4380]  Huitema, C., "Teredo: Tunneling IPv6 over UDP through
              Network Address Translations (NATs)", RFC 4380,
              February 2006.

   [RFC4459]  Savola, P., "MTU and Fragmentation Issues with In-the-
              Network Tunneling", RFC 4459, April 2006.

   [RFC4821]  Mathis, M. and J. Heffner, "Packetization Layer Path MTU
              Discovery", RFC 4821, March 2007.

   [RFC4963]  Heffner, J., Mathis, M., and B. Chandler, "IPv4 Reassembly
              Errors at High Data Rates", RFC 4963, July 2007.

   [RFC4987]  Eddy, W., "TCP SYN Flooding Attacks and Common
              Mitigations", RFC 4987, August 2007.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [RFC5445]  Watson, M., "Basic Forward Error Correction (FEC)
              Schemes", RFC 5445, March 2009.



Templin                  Expires April 30, 2012                [Page 31]

Internet-Draft                    SEAL                      October 2011


   [RFC5720]  Templin, F., "Routing and Addressing in Networks with
              Global Enterprise Recursion (RANGER)", RFC 5720,
              February 2010.

   [RFC5927]  Gont, F., "ICMP Attacks against TCP", RFC 5927, July 2010.

   [RFC6139]  Russert, S., Fleischman, E., and F. Templin, "Routing and
              Addressing in Networks with Global Enterprise Recursion
              (RANGER) Scenarios", RFC 6139, February 2011.

   [RFC6169]  Krishnan, S., Thaler, D., and J. Hoagland, "Security
              Concerns with IP Tunneling", RFC 6169, April 2011.

   [SIGCOMM]  Luckie, M. and B. Stasiewicz, "Measuring Path MTU
              Discovery Behavior", November 2010.

   [TBIT]     Medina, A., Allman, M., and S. Floyd, "Measuring
              Interactions Between Transport Protocols and Middleboxes",
              October 2004.

   [TCP-IP]   "Archive/Hypermail of Early TCP-IP Mail List,
              http://www-mice.cs.ucl.ac.uk/multimedia/misc/tcp_ip/, May
              1987 - May 1990.".

   [WAND]     Luckie, M., Cho, K., and B. Owens, "Inferring and
              Debugging Path MTU Discovery Failures", October 2005.


Appendix A.  Reliability

   Although a SEAL tunnel may span an arbitrarily-large subnetwork
   expanse, the IP layer sees the tunnel as a simple link that supports
   the IP service model.  Links with high bit error rates (BERs) (e.g.,
   IEEE 802.11) use Automatic Repeat-ReQuest (ARQ) mechanisms [RFC3366]
   to increase packet delivery ratios, while links with much lower BERs
   typically omit such mechanisms.  Since SEAL tunnels may traverse
   arbitrarily-long paths over links of various types that are already
   either performing or omitting ARQ as appropriate, it would therefore
   often be inefficient to also require the tunnel endpoints to also
   perform ARQ.


Appendix B.  Integrity

   The SEAL header includes an ICV field that covers the SEAL header and
   at least the inner packet headers.  This provides for header
   integrity verification on a segment-by-segment basis for a segmented
   re-encapsulating tunnel path.  When fragmentation is needed, the SEAL



Templin                  Expires April 30, 2012                [Page 32]

Internet-Draft                    SEAL                      October 2011


   packet also contains a trailer with a secondary ICV that covers the
   remainder of the packet.

   Fragmentation and reassembly schemes must consider packet-splicing
   errors, e.g., when two fragments from the same packet are
   concatenated incorrectly, when a fragment from packet X is
   reassembled with fragments from packet Y, etc.  The primary sources
   of such errors include implementation bugs and wrapping IP ID fields.

   In terms of wrapping ID fields, when IPv4 is used as the outer IP
   protocol, the 16-bit IP ID field can wrap with only 64K packets with
   the same (src, dst, protocol)-tuple alive in the system at a given
   time [RFC4963] increasing the likelihood of reassembly mis-
   associations

   SEAL avoids reassembly mis-associations through the use of extended
   ICVs, and also discards any reassembled packets larger than 1280
   bytes.


Appendix C.  Transport Mode

   SEAL can also be used in "transport-mode", e.g., when the inner layer
   comprises upper-layer protocol data rather than an encapsulated IP
   packet.  For instance, TCP peers can negotiate the use of SEAL (e.g.,
   by inserting a 'SEAL_OPTION' TCP option during connection
   establishment) for the carriage of protocol data encapsulated as
   IPv4/SEAL/TCP.  In this sense, the "subnetwork" becomes the entire
   end-to-end path between the TCP peers and may potentially span the
   entire Internet.

   If both TCPs agree on the use of SEAL, their protocol messages will
   be carried as IPv4/SEAL/TCP and the connection will be serviced by
   the SEAL protocol using TCP (instead of an encapsulating tunnel
   endpoint) as the transport layer protocol.  The SEAL protocol for
   transport mode otherwise observes the same specifications as for
   Section 4.


Appendix D.  Historic Evolution of PMTUD

   The topic of Path MTU discovery (PMTUD) saw a flurry of discussion
   and numerous proposals in the late 1980's through early 1990.  The
   initial problem was posed by Art Berggreen on May 22, 1987 in a
   message to the TCP-IP discussion group [TCP-IP].  The discussion that
   followed provided significant reference material for [FRAG].  An IETF
   Path MTU Discovery Working Group [MTUDWG] was formed in late 1989
   with charter to produce an RFC.  Several variations on a very few



Templin                  Expires April 30, 2012                [Page 33]

Internet-Draft                    SEAL                      October 2011


   basic proposals were entertained, including:

   1.  Routers record the PMTUD estimate in ICMP-like path probe
       messages (proposed in [FRAG] and later [RFC1063])

   2.  The destination reports any fragmentation that occurs for packets
       received with the "RF" (Report Fragmentation) bit set (Steve
       Deering's 1989 adaptation of Charles Lynn's Nov. 1987 proposal)

   3.  A hybrid combination of 1) and Charles Lynn's Nov. 1987 (straw
       RFC draft by McCloughrie, Fox and Mogul on Jan 12, 1990)

   4.  Combination of the Lynn proposal with TCP (Fred Bohle, Jan 30,
       1990)

   5.  Fragmentation avoidance by setting "IP_DF" flag on all packets
       and retransmitting if ICMPv4 "fragmentation needed" messages
       occur (Geof Cooper's 1987 proposal; later adapted into [RFC1191]
       by Mogul and Deering).

   Option 1) seemed attractive to the group at the time, since it was
   believed that routers would migrate more quickly than hosts.  Option
   2) was a strong contender, but repeated attempts to secure an "RF"
   bit in the IPv4 header from the IESG failed and the proponents became
   discouraged. 3) was abandoned because it was perceived as too
   complicated, and 4) never received any apparent serious
   consideration.  Proposal 5) was a late entry into the discussion from
   Steve Deering on Feb. 24th, 1990.  The discussion group soon
   thereafter seemingly lost track of all other proposals and adopted
   5), which eventually evolved into [RFC1191] and later [RFC1981].

   In retrospect, the "RF" bit postulated in 2) is not needed if a
   "contract" is first established between the peers, as in proposal 4)
   and a message to the MTUDWG mailing list from jrd@PTT.LCS.MIT.EDU on
   Feb 19. 1990.  These proposals saw little discussion or rebuttal, and
   were dismissed based on the following the assertions:

   o  routers upgrade their software faster than hosts

   o  PCs could not reassemble fragmented packets

   o  Proteon and Wellfleet routers did not reproduce the "RF" bit
      properly in fragmented packets

   o  Ethernet-FDDI bridges would need to perform fragmentation (i.e.,
      "translucent" not "transparent" bridging)





Templin                  Expires April 30, 2012                [Page 34]

Internet-Draft                    SEAL                      October 2011


   o  the 16-bit IP_ID field could wrap around and disrupt reassembly at
      high packet arrival rates

   The first four assertions, although perhaps valid at the time, have
   been overcome by historical events.  The final assertion is addressed
   by the mechanisms specified in SEAL.


Author's Address

   Fred L. Templin (editor)
   Boeing Research & Technology
   P.O. Box 3707
   Seattle, WA  98124
   USA

   Email: fltemplin@acm.org


































Templin                  Expires April 30, 2012                [Page 35]

